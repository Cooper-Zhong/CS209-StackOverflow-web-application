[{"owner":{"profile_image":"https://www.gravatar.com/avatar/6b2c535fac79e482b71f15de561f55ca?s=256&d=identicon&r=PG","account_id":60171,"user_type":"registered","user_id":179850,"link":"https://stackoverflow.com/users/179850/gray","reputation":115485,"display_name":"Gray","accept_rate":100},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1676413077,"creation_date":1676413077,"body":"<blockquote>\n<p>while I was doing an exercise on the synchronization method I couldn't able to get a proper output but when I'm trying the same exercise by implementing Runnable it's working fine</p>\n</blockquote>\n<p>So your &quot;proper output&quot; is when the output is synchronized that each teacher enters, teaches, and exits before other teacher output is displayed.</p>\n<pre><code>Physics teacher enters class room\nPhysics teacher teaching students\nPhysics teacher exits class room\nEnglish teacher enters class room\nEnglish teacher teaching students\nEnglish teacher exits class room\nCS teacher enters class room\n...\n</code></pre>\n<p>When you have the <code>synchronize</code> keyword on a non-static method, the lock that gets enabled when the method is called is applied on the <em>instance</em> of the object that contains the method.  In the case of the <code>ClassRoom</code> <code>Runnable</code>, each of the threads is sharing <code>class_room</code>:</p>\n<pre><code>ClassRoom class_room = new ClassRoom();\nThread t1 = new Thread(class_room);\nThread t2 = new Thread(class_room);\nThread t3 = new Thread(class_room);\n</code></pre>\n<p>In this case the same <code>ClassRoom</code> object instance is being locked by all 3 threads and the synchronization ensures that only one thread executes the <code>run()</code> method at a time.  Excellent.</p>\n<p>Now let's look at the <code>Thread</code> case:</p>\n<pre><code>ClassRoom physics_class = new ClassRoom();\nClassRoom cs_class = new ClassRoom();\nClassRoom english_class = new ClassRoom();\n</code></pre>\n<p>In this case, there are 3 separate instances of <code>ClassRoom</code> so the <code>synchronized</code> keyword is locking on 3 different objects so each thread works independently.</p>\n<pre><code>Thread t1 = new Thread(new ClassRoom()); // &lt;- distinct instance\n</code></pre>\n<p>Aside from the locking issue, you don't want to do this if <code>ClassRoom</code> extends <code>Thread</code> because you are creating 2 <code>Thread</code> objects – the <code>ClassRoom</code> and the <code>new Thread(...)</code> that wraps the <code>ClassRoom</code> but only starting one of them.  This is very confusing and unnecessary.  <code>ClassRoom</code> should implement <code>Runnable</code> instead.</p>\n","answer_id":75453771,"question_id":75433400},{"owner":{"profile_image":"https://lh3.googleusercontent.com/a/AEdFTp7DA9dycOPxmVqchXxiKqTDCkZOCxgPtCijdF0B=k-s256","account_id":27771970,"user_type":"registered","user_id":21202100,"link":"https://stackoverflow.com/users/21202100/pt7092","reputation":11,"display_name":"pt7092 "},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1676292635,"creation_date":1676292557,"body":"<p>Yield(): When a running thread is stopped to give its space to another thread with a high priority, this is called Yield.Here the running thread changes to runnable thread.</p>\n<p>Wait(): A thread is waiting to get resources from a thread to continue its execution.</p>\n","answer_id":75436114,"question_id":26798073,"last_edit_date":1676292635},{"owner":{"profile_image":"https://lh3.googleusercontent.com/a/AEdFTp61CUpQI3VbC_PLq34lGLauPTVC9VC23rZkIOSpZw=k-s256","account_id":27772393,"user_type":"registered","user_id":21202467,"link":"https://stackoverflow.com/users/21202467/nasir-mushtaq","reputation":1,"display_name":"Nasir Mushtaq"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1676279114,"creation_date":1676279114,"body":"<p>Was facing the same issue,  Paul Samsotha's answer helped. Creating Client loads jersey jars and JARFile in java overrides finalize method putting lot of overhead on finalizer thread.</p>\n","answer_id":75433827,"question_id":38570732},{"owner":{"profile_image":"https://i.stack.imgur.com/zHTaT.png?s=256&g=1","account_id":39208,"user_type":"registered","user_id":112968,"link":"https://stackoverflow.com/users/112968/knittl","reputation":251260,"display_name":"knittl","accept_rate":68},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1676278578,"creation_date":1676278578,"body":"<p>With the <code>Runnable</code> implementation, you are sharing a single instance across all threads. In the former, you are having 3 separate instances.</p>\n<p>To match the behavior of separate threads with a runnable, you have to use separate runnables too:</p>\n<pre><code>public class ClassRoomApp  {\n\n    public static void main(String[] args) throws InterruptedException {\n        \n        Thread t1 = new Thread(new ClassRoom()); // &lt;- distinct instance\n        Thread t2 = new Thread(new ClassRoom()); // &lt;- distinct instance\n        Thread t3 = new Thread(new ClassRoom()); // &lt;- distinct instance\n            \n        t1.setName(&quot;Physics teacher&quot;);\n        t2.setName(&quot;CS teacher&quot;);\n        t3.setName(&quot;English teacher&quot;);\n    \n        t1.start();\n        t2.start();\n        t3.start();\n        \n    }\n\n}\n</code></pre>\n","answer_id":75433733,"question_id":75433400},{"owner":{"profile_image":"https://www.gravatar.com/avatar/97cbc5a26a5cfcdbb3fb718c3e066d87?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":21083132,"user_type":"registered","user_id":15496965,"link":"https://stackoverflow.com/users/15496965/henning","reputation":3240,"display_name":"Henning"},"content_license":"CC BY-SA 4.0","score":-1,"is_accepted":false,"last_activity_date":1676135847,"creation_date":1675979780,"body":"<p>Skipped lines are not counted when considering whether <code>maxItemCount</code> lines have been read.</p>\n<p>Instead of calculating the variable <code>toId</code> and passing it to <code>maxItemCount</code>, you need to pass the fixed value <code>range</code> to <code>maxItemCount</code>.</p>\n<p>edit: As the answer has been down-voted, I've pushed the <code>RangePartitioner</code> from the question and a <code>FixedRangePartitioner</code> to github. The latter sets <code>maxItemCount</code> to <code>range</code> and works as expected: <a href=\"https://github.com/hpoettker/so-partitioning\" rel=\"nofollow noreferrer\">https://github.com/hpoettker/so-partitioning</a></p>\n","answer_id":75404837,"question_id":55227133,"last_edit_date":1676135847},{"owner":{"profile_image":"https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG","account_id":47283,"user_type":"registered","user_id":139985,"link":"https://stackoverflow.com/users/139985/stephen-c","reputation":703927,"display_name":"Stephen C","accept_rate":69},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1676124875,"creation_date":1301873225,"body":"<blockquote>\n<p>What are the caveats for using thread.setName() apart from those mentioned in the javadoc? How does it affect performance? The peak frequency of calling thread.setName() would be about 200 per second and average about 0.3 per second.</p>\n</blockquote>\n<p>Performance should not be a significant issue.  <code>Thread.setName()</code> does a security check and then copies / sets an attribute.  The security check should be cheap unless your code is privileged code running in a security sandbox that forbids unprivileged calls to the <code>Thread.setName()</code> method.</p>\n<p><sup>In Java 9 and later, <code>setName</code> is going to tell the OS to change the native thread's name.  For Linux, Solaris, AIX and BSD (e.g. MacOS) this is done via a call to <code>pthread_setname_np</code> which makes a syscall under the hood.  With Windows, it does some weird thing with the Windows debugger ... and only works if there is a debugger already attached.  In Java 8, no attempt is made to change the native thread name.</sup></p>\n<p>The only other caveat I can think of is that thread names changing all of the time could be confusing if you are trying to debug threading behavior; e.g. looking at thread dumps, etc.o</p>\n","answer_id":5533219,"question_id":5532864,"last_edit_date":1676124875},{"owner":{"profile_image":"https://lh3.googleusercontent.com/-CNNlW_hAMJI/AAAAAAAAAAI/AAAAAAAAPFk/OfGtXwoVyTM/photo.jpg?sz=256","account_id":6183990,"user_type":"registered","user_id":4818628,"link":"https://stackoverflow.com/users/4818628/sergey-kosarev","reputation":71,"display_name":"Sergey Kosarev"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1676025693,"creation_date":1676025693,"body":"<p>There is <code>happens-before</code> between <code>Holder.read</code> and <code>Holder.write</code> methods obviously. But no any guaranties between <code>State.getAge</code> and <code>Holder.write</code>.\nif you want to read age you actually need to execute two operations:</p>\n<pre><code>(1) State state = holder.read(key);\n\n(2) int age = state.getAge();\n</code></pre>\n<p>So, if <code>Holder.write</code> in another thread happens after (1) but before (2), you may see old age value in (2).</p>\n","answer_id":75409974,"question_id":67825678},{"owner":{"profile_image":"https://i.stack.imgur.com/SEQOn.jpg?s=256&g=1","account_id":10611364,"user_type":"registered","user_id":7815223,"link":"https://stackoverflow.com/users/7815223/shagun-verma","reputation":163,"display_name":"Shagun Verma"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1675909718,"creation_date":1675909368,"body":"<p>To accomplish this, you have to use <code>Executors</code> in Java. The below code will be done the job for you-</p>\n<pre><code>btnPausePlay.setOnClickListener(view -&gt; {\n    btnPausePlay.setVisibility(View.GONE);\n    progressPausePlay.setVisibility(View.VISIBLE);\n    ExecutorService executorService =  Executors.newSingleThreadExecutor();\n        executorService.execute(() -&gt; {\n            // Implement your file download code here i.e.\n            // httpRequest_noBackgroundThread( urlStr, urlParams, fileStr, itf );\n        handler.post(() -&gt; {\n            btnPausePlay.setVisibility(View.VISIBLE);\n            progressPausePlay.setVisibility(View.GONE);\n        });\n    });\n});\n</code></pre>\n<p>When you press the btnPausePlay button, then it will become invisible and the progress bar becomes visible. After that, once the download is completed reverse will happen.</p>\n","answer_id":75393592,"question_id":75389536,"last_edit_date":1675909718},{"owner":{"profile_image":"https://www.gravatar.com/avatar/67f2ccd17aa6fd622152ad88fc2ae784?s=256&d=identicon&r=PG","account_id":422870,"user_type":"registered","user_id":801894,"link":"https://stackoverflow.com/users/801894/solomon-slow","reputation":25925,"display_name":"Solomon Slow"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1665068370,"creation_date":1665068370,"body":"<p>Not sure I understand what you're really trying to do, but changing your <code>run()</code> function so that it spends most of its time &quot;sleeping&quot; might improve the performance of your program:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public void run() {\n    System.out.println(&quot;it is running&quot;);\n    while(true) {\n        long timeUntilDelete = lastEdit - System.currentTimeMillis();\n        if (timeUntilDelete &gt; 0) {\n            try {\n                Thread.sleep(timeUntilDelete);\n            }\n            catch(InterruptedException ex) {\n                ...What you do here is up to you...\n            }\n            continue;\n        }\n        System.out.println(&quot;DELETE&quot;);\n        timerStart(12000);\n    }\n}\n</code></pre>\n","answer_id":73975979,"question_id":73968499},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG","account_id":401843,"user_type":"registered","user_id":768644,"link":"https://stackoverflow.com/users/768644/rzwitserloot","reputation":89863,"display_name":"rzwitserloot"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1665067435,"creation_date":1665067435,"body":"<p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/LockSupport.html#park()\" rel=\"nofollow noreferrer\">Reading docs</a> is fundamental.</p>\n<p>As the docs indicate, <code>LockSupport.park()</code> is allowed to spuriously return. In other words, the docs literally spell out:</p>\n<ul>\n<li>Q: &quot;Why did the park() call return so quickly?&quot;</li>\n<li>A: Because the JVM felt like it.</li>\n</ul>\n<p>LockSupport's locks are thread-global. There is exactly one semaphore (which LockSupport calls a 'permit') for each thread, you can't make more and you can't make less. Basically meaning, exactly one system within your JVM can use it, because if two use it, they confuse each other.</p>\n<p>As the docs also say:</p>\n<blockquote>\n<p>Basic thread blocking primitives for creating locks and other synchronization classes.</p>\n</blockquote>\n<p>Which in essence means: Why are you doing this? If you want locking behaviour, use e.g. <code>ReentrantLock</code> from the <code>java.util.concurrent</code> package; this isn't meant for you, and hence it has all sorts of bizarre weirdness in it, such as <code>park()</code>'s rule that it is allowed spurious returns.</p>\n<p>Most likely the <code>log.debug</code> code either [A] ends up calling <code>LockSupport.unpark(ownThread)</code> for some reason, which means the next <code>park()</code> call returns immediately, or [B] it's a timing matter. <code>log.debug</code> is not 'free', many log frameworks run 'in-place', meaning, the <code>log.debug</code> call actually goes out on disk and fsyncs, meaning, it takes a very long time indeed compared to your average non-disk-interacting java instruction (hundreds of instructions worth of time). That time is enough for the scheduler to fly by it, especially considering 'write to disk' or 'fsync' is a natural stopping point (threads in java are pre-emptive, but if you give the scheduler an excuse to pause your thread, it will usually take it).</p>\n<p>In the end, the docs are clear: You don't get an answer to your 'why' question. The specs give the JVM free reign not to have to explain to you why <code>park()</code> spuriously returns. Therefore there isn't much point chasing down the why for this case - even if you have an answer, tomorrow there can be a different reason. If your code can't handle spurious returns on <code>LockSupport.park()</code>, your code is by definition broken. Even if you can make it work on your machine, today, with this phase of the moon, then that's no guarantee it would work fine tomorrow.</p>\n<p>Once your code can handle spurious returns, figuring out why it spuriously returns here isn't interesting anymore. Thus, solution: Deal with spurious returns properly. Or, more likely, don't use this for locks, use something more friendly to end users.</p>\n","answer_id":73975752,"question_id":73975470},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e648659dd573c1161a370efa0f5e10d6?s=256&d=identicon&r=PG","account_id":238127,"user_type":"registered","user_id":506796,"link":"https://stackoverflow.com/users/506796/tenfour04","reputation":86162,"display_name":"Tenfour04","accept_rate":83},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1665061342,"creation_date":1665061342,"body":"<p>If you truly want to fire and forget, such that the coroutine will not be cancelled under any circumstance, GlobalScope is the right way to do it. The need to truly fire and forget is rare enough in practice that Kotlin gives you a warning about a &quot;fragile API&quot; if you use it, I think because so many newbies were using it for everything. This was especially a problem on Android (where Kotlin is primarily used), where long running tasks that should run even off-screen should be handled in services instead of coroutines.</p>\n<p>But, referring to your example, if <code>inventory</code> is something that could become obsolete and you want to free it to the GC at some point, you should use your own created CoroutineScope that you store in a property, so you can cancel it to clear any running coroutines and prevent them from hanging onto references that should be freed for the GC. If the scope might be used for more than one coroutine, then you should give it a <code>SupervisorJob()</code>.</p>\n<pre><code>private val coroutineScope = CoroutineScope(SupervisorJob())\n\nfun onEndOfLifecycle() { // some function called when cleaning up memory \n    coroutineScope.cancel()\n}\n</code></pre>\n","answer_id":73974282,"question_id":73973632},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e34d0dd755c1ca59cd89d4a4e566439a?s=256&d=identicon&r=PG","account_id":2226374,"user_type":"registered","user_id":1965042,"link":"https://stackoverflow.com/users/1965042/vcg","reputation":106,"display_name":"vcg"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1665028662,"creation_date":1665028662,"body":"<p>Hi so you could be using <code>ScheduledExecutorService</code>, take a look to oracle docs, you will find an example, I believe solves your problem</p>\n","answer_id":73968534,"question_id":73968499},{"owner":{"profile_image":"https://www.gravatar.com/avatar/6b2c535fac79e482b71f15de561f55ca?s=256&d=identicon&r=PG","account_id":60171,"user_type":"registered","user_id":179850,"link":"https://stackoverflow.com/users/179850/gray","reputation":115485,"display_name":"Gray","accept_rate":100},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1664922241,"creation_date":1664903717,"body":"<blockquote>\n<p>What can be the reasons for the above assumptions or the observations?</p>\n</blockquote>\n<p>One of the issues that you need to realize is that you will not get more than the core number of threads allocated in your thread-pool until the queue fills up.  I kid you not.  In your case, it's only when the 5 threads are busy and 10000 jobs are queued that the 6th thread will be started.</p>\n<p>I would set the <code>corePoolSize</code> and the <code>maxPoolSize</code> both to be 100 and then set the <code>keepAliveSeconds</code> to 30 or something if you want the core threads to drop down during periods of inactivity.  See this question for more details: <a href=\"https://stackoverflow.com/q/19528304/179850\">How to get the ThreadPoolExecutor to increase threads to max before queueing?</a></p>\n<p>Couple other comments:</p>\n<blockquote>\n<pre><code>int i = Thread.activeCount();\nlogger.info(&quot;Point 1: Active thread count : [{}]&quot;, i);\naskExecutor.execute(new Runnable() { ... });\nlogger.info(&quot;Point 2: Active thread count : [{}]&quot;, i);\n</code></pre>\n</blockquote>\n<p>The active-count won't change at point 2 since you aren't making another call to <code>Thread.activeCount()</code>.  Also, you are scheduling a job to be run by the thread-pool but that doesn't necessarily mean that a thread will be created.</p>\n<p>If you are using a <code>ThreadPoolExecutor</code> directly (as opposed to the Spring wrapper) then you could call <code>pool.getActiveCount()</code> and other methods to get a more accurate picture of the threads running in your thread pool.  The 114 threads running in your application may be associated with the tomcat handlers and other JVM threads instead of your pool specifically.  You can also use jconsole, jstack, or a <code>SIGQUIT</code> to dump the thread stacks and see how many threads are associated with your pool.  The thread names should be something like xxx-pool-1 or something unless you are using a thread-factory.</p>\n<p>Lastly a general comment.  Maybe this is obvious but you really should be trying to optimize your throughput as opposed to worrying about the number of threads.  100 may be too many threads if you are pounding the server too hard or if the job is computational or 100 may be too few if your HTTP connections take a while to be satisfied because of latency.</p>\n","answer_id":73951424,"question_id":73920478,"last_edit_date":1664922241},{"owner":{"profile_image":"https://i.stack.imgur.com/wOpca.jpg?s=256&g=1","account_id":1901420,"user_type":"registered","user_id":1717210,"link":"https://stackoverflow.com/users/1717210/tachedechoco","reputation":3763,"display_name":"TacheDeChoco"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1664813945,"creation_date":1664811858,"body":"<blockquote>\n<p>We have no control over their timeout time</p>\n</blockquote>\n<p>Do not care about the server timeouts. As an HTTP client, you can define your own timeouts, on two distinct levels:</p>\n<ul>\n<li>a <strong>connection</strong> timeout : how long max to reach the target server</li>\n<li>a <strong>read</strong> timeout : allowing you to give up after a certain amount of time (and potentially earlier than the server will abort) in case the HTTP response does not come</li>\n</ul>\n<p>See Spring doc on how to configure these two timeouts.</p>\n","answer_id":73937781,"question_id":73937447,"last_edit_date":1664813945},{"owner":{"profile_image":"https://www.gravatar.com/avatar/dc91a8e29fedbd6a6d7e03a8394009ab?s=256&d=identicon&r=PG","account_id":75804,"user_type":"registered","user_id":217324,"link":"https://stackoverflow.com/users/217324/nathan-hughes","reputation":94840,"display_name":"Nathan Hughes","accept_rate":96},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1664737739,"creation_date":1664717306,"body":"<p>Exceptions don't propagate across threads, for instance you need an UncaughtExceptionHandler to retrieve the exception thrown by another thread, see <a href=\"https://stackoverflow.com/q/6546193/217324\">How to catch an Exception from a thread</a>.</p>\n<p>So putting InterruptedException in the throws clause creates a false expectation, the exception still can't be thrown in one thread and caught in another. That's the only reason I can think of for not doing this, they are trying to communicate to the developer that the toplevel run method for a thread needs to handle everything. Putting InterruptedException in the throws clause dilutes this message, as the developer isn't forced to deal with it.</p>\n<p>But yes, they could have added InterruptedException to the throws clause of Runnable, that would make this case much simpler. But there are design goals in conflict. The designars want developers to be very aware of the exception behavior, including making  InterruptedException checked, but it's not having it in the throws clause that forces people to deal with it. The goal of letting simple things be easy and having a thread call sleep without a catch is at odds with that so it wasn't implemented.</p>\n","answer_id":73926210,"question_id":73926124,"last_edit_date":1664737739},{"owner":{"profile_image":"https://i.stack.imgur.com/MEVJT.jpg?s=256&g=1","account_id":6589671,"user_type":"registered","user_id":5091346,"link":"https://stackoverflow.com/users/5091346/andrii-abramov","reputation":10127,"display_name":"Andrii Abramov","accept_rate":72},"content_license":"CC BY-SA 4.0","score":8,"is_accepted":false,"last_activity_date":1664737068,"creation_date":1522142645,"body":"<p>Since Java 8 release, there is more declarative way to initialize <code>ThreadLocal</code>:</p>\n<pre><code>ThreadLocal&lt;String&gt; local = ThreadLocal.withInitial(() -&gt; &quot;init value&quot;);\n</code></pre>\n<p>Until Java 8 release you had to do the following:</p>\n<pre><code>ThreadLocal&lt;String&gt; local = new ThreadLocal&lt;String&gt;(){\n    @Override\n    protected String initialValue() {\n        return &quot;init value&quot;;\n    }\n};\n</code></pre>\n<p>Moreover, if instantiation method (constructor, factory method) of class that is used for <code>ThreadLocal</code> does not take any parameters, you can simply use method references (introduced in Java 8):</p>\n<pre><code>class NotThreadSafe {\n    // no parameters\n    public NotThreadSafe(){}\n}\n    \nThreadLocal&lt;NotThreadSafe&gt; container = ThreadLocal.withInitial(NotThreadSafe::new);\n</code></pre>\n<p><strong>Note:</strong>\nEvaluation is lazy since you are passing <code>java.util.function.Supplier</code> lambda that is evaluated only when <code>ThreadLocal#get</code> is called but value was not previously evaluated.</p>\n","answer_id":49509030,"question_id":817856,"last_edit_date":1664737068},{"owner":{"profile_image":"https://i.stack.imgur.com/WAhD8.png?s=256&g=1","account_id":1129864,"user_type":"registered","user_id":1116216,"link":"https://stackoverflow.com/users/1116216/michele-la-ferla","reputation":6795,"display_name":"Michele La Ferla","accept_rate":100},"content_license":"CC BY-SA 4.0","score":7,"is_accepted":false,"last_activity_date":1662061119,"creation_date":1464877239,"body":"<p>Within the lifecycle callback methods, you can declare how your activity behaves when the user leaves and re-enters the activity. Remember that the way Android is designed, there is a lifecycle for each and every app. If you put too much load to the <code>onCreate()</code> method (which is the method used to load the layout files and initalise any controls you have in it), then the white screen will become more visible, as the layout file will take longer to load.</p>\n<p>I suggest using several different methods when starting an activity. Such are the <code>onStart()</code> (being called as the first thing once the app is loaded), <code>onActivityCreated()</code> (being called after the layout is displayed and useful if you are making any data processing upon starting the activity).</p>\n<p>To make it easier for you, below is the official activity lifecycle diagram (from <a href=\"http://web.archive.org/web/20140218132043/http://developer.android.com/training/basics/activity-lifecycle/starting.html\" rel=\"nofollow noreferrer\">http://web.archive.org/web/20140218132043/http://developer.android.com/training/basics/activity-lifecycle/starting.html</a>):</p>\n<p><a href=\"https://i.stack.imgur.com/KozRu.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/KozRu.png\" alt=\"enter image description here\" /></a></p>\n","answer_id":37594546,"question_id":37437037,"last_edit_date":1662061119},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e442a53d36f9351aee11b5ecb8369691?s=256&d=identicon&r=PG","account_id":6520,"user_type":"registered","user_id":11002,"link":"https://stackoverflow.com/users/11002/tgdavies","reputation":10523,"display_name":"tgdavies","accept_rate":75},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1659525121,"creation_date":1659525121,"body":"<p>Why not simply:</p>\n<pre><code>ExecutorService executorService = Executors.newSingleThreadExecutor();\n        executorService.submit((Runnable) () -&gt; {\n            while (true) {\n                try {\n                    ...\n                } catch (Exception e) {\n                    // log\n                }\n            }\n        });\n</code></pre>\n<p>There doesn't seem to be any need for a <code>Callable</code> or a <code>Future</code>.</p>\n","answer_id":73220736,"question_id":73220654},{"owner":{"profile_image":"https://i.stack.imgur.com/b5Dq4.jpg?s=256&g=1","account_id":476019,"user_type":"registered","user_id":886697,"link":"https://stackoverflow.com/users/886697/stanislav-bashkyrtsev","reputation":14699,"display_name":"Stanislav Bashkyrtsev","accept_rate":92},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1654931009,"creation_date":1654928561,"body":"<p>I don't think you're measuring what you think you're measuring. You have 100 tasks and you measure how much time each task takes to finish. Suppose each takes 2sec. So if we execute them one after another it'll be 2sec * 100.</p>\n<p>Now suppose you run them in 8 threads and 8 cores. This doesn't (ideally) change the amount of time each task takes, so you still have 2sec for each task. And you again have 2sec * 100 of <em>summed</em> time. But the overall execution time changes - it's <code>(2sec * 100) / 8</code> because this <em>summed</em> time is now spread across 8 cores instead of 1.</p>\n<p>So what you need to measure is the total time it takes for the program to run. Just measure it in <code>runBenchmark()</code> method:</p>\n<pre><code>private void runBenchmark() throws Exception {\n  try {\n      long started = System.nanoTime();\n      for (int i = 0; i &lt; numThreads; i++)\n          benchMarkResultsFuture.add(executorService.submit(new BenchmarkThread(numOperationsPerThread)));\n      for (Future&lt;BenchmarkResult&gt; resultFuture : benchMarkResultsFuture)\n          resultFuture.get();\n\n      long timeToComplete = (System.nanoTime() - started) / 1000;\n      System.out.println(&quot;=====runBenchmark() FINISHED in &quot; + timeToComplete);\n  } finally {\n      executorService.shutdown();\n  }\n}\n</code></pre>\n","answer_id":72582182,"question_id":72582076,"last_edit_date":1654931009},{"owner":{"profile_image":"https://i.stack.imgur.com/Klcqr.gif?s=256&g=1","account_id":292208,"user_type":"registered","user_id":2245707,"link":"https://stackoverflow.com/users/2245707/pveentjer","reputation":10665,"display_name":"pveentjer","accept_rate":17},"content_license":"CC BY-SA 4.0","score":4,"is_accepted":false,"last_activity_date":1654927764,"creation_date":1654927764,"body":"<p>This could be the cause of the problem:</p>\n<pre><code>  private static final Random RANDOM = new Random();\n</code></pre>\n<p>Because this is contended between all threads.</p>\n<p>Try a ThreadLocalRandom instead.</p>\n<p>Also, I would use a more reliable benchmarking approach like JMH.</p>\n","answer_id":72582123,"question_id":72582076},{"owner":{"profile_image":"https://lh3.googleusercontent.com/a/AATXAJxX9Iix5-V4Afy0vaosyCz1npCO7X3fhNOxSnIe=k-s256","account_id":25423725,"user_type":"registered","user_id":19229200,"link":"https://stackoverflow.com/users/19229200/scizora","reputation":21,"display_name":"Scizora"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1654922791,"creation_date":1654922791,"body":"<p>Hi just to update after deploying and testing my code the implementation of shutdown hooks and setting to daemon solved this issue of threads running despite closing the jar file via cmd/pressing x. I am still looking at the Executor service as an alternative way to encapsulate my code better but tbh its still quite hard to grasp its concepts. It would be fantastic if there was an example of its implementation!</p>\n","answer_id":72581802,"question_id":72429901},{"owner":{"profile_image":"https://i.stack.imgur.com/ZWEI3.jpg?s=256&g=1","account_id":322981,"user_type":"registered","user_id":642706,"link":"https://stackoverflow.com/users/642706/basil-bourque","reputation":310755,"display_name":"Basil Bourque","accept_rate":58},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1654919342,"creation_date":1654919342,"body":"<p>Currently in Java, threads are quite expensive, being mapped directly one-to-one to host OS threads. They impact both memory usage and CPU usage. So we usually limit the number of threads to a few, often roughly the number of cores or so. So increasing/decreasing the size of the thread pool is not likely to make sense nowadays.</p>\n<h1>Virtual threads in <em>Project Loom</em></h1>\n<p>Sounds like your scenario is ideal for the <a href=\"https://openjdk.java.net/jeps/425\" rel=\"nofollow noreferrer\">virtual threads</a> (<a href=\"https://en.wikipedia.org/wiki/Fiber_(computer_science)\" rel=\"nofollow noreferrer\">fibers</a>) coming from the <a href=\"https://wiki.openjdk.java.net/display/loom/Main\" rel=\"nofollow noreferrer\"><em>Project Loom</em></a> project. Many virtual threads are mapped to a single host OS thread.</p>\n<p>In today's Java threading, if the Java code blocks, the host OS thread blocks. No further work is performed on that thread. With virtual threads, when the Java code blocks the virtual thread is dismounted from its assigned host OS thread, and “parked”. When that code eventually returns, and therefore needs further execution, it is mounted onto another host OS thread. This parking and mounting of virtual threads is <em>much</em> faster than blocking/unblocking of host OS threads. Virtual threads have much less impact on memory and and CPU. So we can have thousands, or even millions, of threads running simultaneously on conventional hardware.</p>\n<p>In your scenario where your work load may go up or down, the virtual thread facility in Project Loom will automatically manage the thread pool and scheduling. You should see vastly improved throughput with no effort on your part.</p>\n<p>A few caveats:</p>\n<ul>\n<li>Cheap threads can still do expensive things. So you may need to manage or limit your particular concurrent tasks to avoid blowing out memory or overburdening other resources.</li>\n<li>Virtual threads only make sense for tasks that block. That means most common Java work. But for entirely CPU bound tasks such as video encoding/decoding with little to no logging, storage I/O, network I/O, etc. you would stick with conventional Java threads.</li>\n<li>There may be some situations where the particular content in your task may prevent the parking while blocked. You may choose to alter your code a bit to enable the virtual thread from being “pinned” to the host OS thread. This may be especially the case with the initial releases of Loom. This situation is fluid right now in pre-release Loom, so we will need to stay informed as to changes.</li>\n</ul>\n<p>Virtual threads and other Project Loom features are available as preview features in Java 19, with experimental builds available now.</p>\n<p>For more information, see the articles, presentations, and interviews by members of the Project Loom team such as Ron Pressler and Alan Bateman.</p>\n","answer_id":72581584,"question_id":72580556},{"owner":{"profile_image":"https://lh3.googleusercontent.com/a/AATXAJzJlRNdxfu9SC29izHRXdSfvH-4Ns7e7qVBN1Yq=k-s256","account_id":25335362,"user_type":"registered","user_id":19154594,"link":"https://stackoverflow.com/users/19154594/rohit-dakota","reputation":13,"display_name":"Rohit Dakota"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1654850384,"creation_date":1654850384,"body":"<p>You should associate the properties map with the user session or request</p>\n","answer_id":72571407,"question_id":45265777},{"owner":{"profile_image":"https://i.stack.imgur.com/FKKLW.jpg?s=256&g=1","account_id":404649,"user_type":"registered","user_id":773113,"link":"https://stackoverflow.com/users/773113/mike-nakis","reputation":57192,"display_name":"Mike Nakis","accept_rate":72},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1654848295,"creation_date":1654848295,"body":"<p>All the stuff about android, java, C#, xamarin, bluetooth, etc. is irrelevant. This question is essentially asking how to build a socket server application for a small number of clients, where &quot;small&quot; here means that you have the luxury of spawning one thread per client. (If you were to serve a large number of clients, then you would have to resort to a threadpool, but in your case that would be an unnecessary complication.)</p>\n<p>The way we build a socket server application for a small number of clients is as follows:</p>\n<ol>\n<li>One thread (the &quot;Accept&quot; thread) does nothing but an endless loop where it invokes <code>serverSocket.Accept()</code>.</li>\n<li>When a socket connection is established, the &quot;Accept&quot; thread creates a &quot;Session&quot; thread for the connected socket. So, we have one &quot;Session&quot; thread per client.</li>\n<li>Each &quot;Session&quot; thread receives packets from a client and sends packets back to the client. When a &quot;Session&quot; thread has something to useful to show to the user, the &quot;Session&quot; thread &quot;posts&quot; a message to the GUI thread, which means that it sends it in a thread-safe way. Different GUI systems support different means of accomplishing this; I am not sure about Xamarin, perhaps with <code>MessagingCenter.Send()</code>.</li>\n</ol>\n","answer_id":72570970,"question_id":72557561},{"owner":{"profile_image":"https://www.gravatar.com/avatar/18b9001fd20c1e089d19f4a1e994bcdc?s=256&d=identicon&r=PG","account_id":6482932,"user_type":"registered","user_id":5019386,"link":"https://stackoverflow.com/users/5019386/mahmoud-ben-hassine","reputation":29552,"display_name":"Mahmoud Ben Hassine"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1654843263,"creation_date":1654843263,"body":"<p>While it is possible to make the commit interval and thread pool size configurable and change them at startup time, it is not possible to change them at runtime (ie &quot;in-flight&quot;) once the job execution has started.</p>\n<p>Making the commit interval and thread pool size configurable (via application/system properties or passing them as job parameters) will allow you to empirically adapt the values to best utilize your resources without having to recompile/repackage your application.</p>\n<p>The <em>runtime</em> dynamism you are looking for is not available by default, but you can always implement the <code>Step</code> interface and use it as part of a Spring Batch job next to other step types provided out-of-the-box by the framework.</p>\n","answer_id":72570061,"question_id":72567117},{"owner":{"profile_image":"https://www.gravatar.com/avatar/dc91a8e29fedbd6a6d7e03a8394009ab?s=256&d=identicon&r=PG","account_id":75804,"user_type":"registered","user_id":217324,"link":"https://stackoverflow.com/users/217324/nathan-hughes","reputation":94840,"display_name":"Nathan Hughes","accept_rate":96},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1654778339,"creation_date":1654715348,"body":"<p>The notify/notifyAll methods tell the scheduler to notify one/all of the threads currently waiting on the lock that notify or notifyAll was called on. But if a thread hasn't started waiting yet then it doesn't get notified.</p>\n<p>The solution is to introduce a condition variable that keeps wait from being called if the notifying has happened already. Define it in the same scope as your lock:</p>\n<pre><code>public static volatile boolean ready = false;\n</code></pre>\n<p>Then use it to guard the wait block, like this:</p>\n<pre><code>while (!ready) {\n    object.wait();\n}\n</code></pre>\n<p>The code calling notify/notifyAll needs to set the variable (it doesn't matter what order you do it in because the notification doesn't happen until the lock is released):</p>\n<pre><code>synchronized (object) {\n    ready = true;\n    object.notifyAll();\n}\n</code></pre>\n<p>What happens:</p>\n<p>If the waiting thread gets to the waiting part before the notifying thread does its notifying, then the waiting thread finds ready is false, so it enters the wait method, releases the lock, and stays there.  Then the notifying thread changes the flag to true and wakes up the waiting thread, which can leave the wait, reacquire the lock, and then leave the loop now that the flag is set.</p>\n<p>But if the notifying thread does its notify before the other thread waits, that's ok, because the ready flag now prevents the thread from entering the wait, it can skip over it.</p>\n<p>Further reading: <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html</a></p>\n","answer_id":72551003,"question_id":72547510,"last_edit_date":1654778339},{"owner":{"profile_image":"https://i.stack.imgur.com/qHEzx.png?s=256&g=1","account_id":3192259,"user_type":"registered","user_id":2696260,"link":"https://stackoverflow.com/users/2696260/m-deinum","reputation":117619,"display_name":"M. Deinum"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":true,"last_activity_date":1654761035,"creation_date":1654760603,"body":"<p>Do something like this.</p>\n<pre><code>ExecutorService exector = Executors.newCachedThreadPool();\n\npublic List&lt;ResultDto&gt; queryAll(List&lt;String&gt; ids) throws ExecutionException, InterruptedException {\n\n    List&lt;CompletableFuture&gt; cfs = new ArrayList&lt;&gt;(ids.size());\n    for (String id : ids) {\n      CompletableFuture cf = Completableuture.supplyAsync(() -&gt; getResult(id), exector);\n      cfs.add(cf);\n    }\n    CompletableFuture allOfThem = CompletableFuture.allOf(cfs.toArray(new CompletableFuture[0]);\n \n    CompletableFuture&lt;List&lt;ResultDto&gt;&gt; allCompletableFutures = allOfThem .thenApply(future -&gt; {\n    return cfs.stream()\n            .map(completableFuture -&gt; completableFuture.join())\n            .collect(Collectors.toList());\n});\n    return allCompletableFutures.get();\n}\n\nResultDto getResult(String id) {\n    String remoteResult = &quot; httpUtils.get()&quot; + id;\n    BaseData baseData = new BaseData();\n    baseData.setBaseInfo(&quot;baseData&quot; + id);\n    baseData.setRemoteInfo(remoteResult);\n    ResultDto resultDto = new ResultDto();\n    resultDto.setBaseData(baseData);\n    return resultDto;\n}\n</code></pre>\n<p>This will give you a non-blocking solution (it will only block in the end).</p>\n<p>Or you can make it even easier and just use a <code>parallelStream</code> and use the default fork-join pool.</p>\n<pre class=\"lang-java prettyprint-override\"><code>public List&lt;ResultDto&gt; queryAll(List&lt;String&gt; ids) throws ExecutionException, InterruptedException {\n    return ids.parallelStream().map(id -&gt; getResult(id)).collect(Collectors.toList());\n}\n\nResultDto getResult(String id) {\n    String remoteResult = &quot; httpUtils.get()&quot; + id;\n    BaseData baseData = new BaseData();\n    baseData.setBaseInfo(&quot;baseData&quot; + id);\n    baseData.setRemoteInfo(remoteResult);\n    ResultDto resultDto = new ResultDto();\n    resultDto.setBaseData(baseData);\n    return resultDto;\n}\n</code></pre>\n<p>You can probably decide which is better to read...</p>\n","answer_id":72556469,"question_id":72556212,"last_edit_date":1654761035},{"owner":{"profile_image":"https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG","account_id":47283,"user_type":"registered","user_id":139985,"link":"https://stackoverflow.com/users/139985/stephen-c","reputation":703927,"display_name":"Stephen C","accept_rate":69},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1654760346,"creation_date":1654759924,"body":"<blockquote>\n<p>Some people say that: the thread pool get method is Blocking methods, so it is no different from writing without threads.</p>\n</blockquote>\n<p>They are correct.  If you call <code>get()</code> at that point, it immediately blocks until the that particular task has completed.  So the 2nd task isn't submitted until the first one completes ... and so on.</p>\n<p>What you need to do is submit all of the tasks before calling <code>get()</code>. Something like the following pseudo-code.</p>\n<pre><code>List&lt;Future&gt; futures\nfor each id in ids:\n   futures.add(executor.submit(...))\n\nfor each future in futures:\n   result = future.get()\n   results.add(process(result))\n</code></pre>\n<p>If you can arrange that each task does the processing of its result, you potentially get more parallelism.</p>\n<p>As noted, you could use <code>CompleteableFuture.allOf</code> instead of the second loop.</p>\n","answer_id":72556323,"question_id":72556212,"last_edit_date":1654760346},{"owner":{"profile_image":"https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8532578,"user_type":"registered","user_id":6395627,"link":"https://stackoverflow.com/users/6395627/slaw","reputation":39918,"display_name":"Slaw"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1654719209,"creation_date":1654719209,"body":"<p>The problem, I believe, is in your <code>SpiderUtils</code> class. More specifically, this method:</p>\n<blockquote>\n<pre class=\"lang-java prettyprint-override\"><code>public static boolean isLinkURLValid(URI url) {\n    return url.getHost().equalsIgnoreCase(baseUrl.getHost()) &amp;&amp;\n            !containsURL(linksCrawled, url) &amp;&amp;\n            !containsURL(linksInProgress, url) &amp;&amp;\n            !url.getPath().contains(&quot;.&quot;);\n}\n</code></pre>\n</blockquote>\n<p>And this method:</p>\n<blockquote>\n<pre class=\"lang-java prettyprint-override\"><code>public static boolean containsURL(ArrayList&lt;URI&gt; urls, URI left) {\n    return urls.stream().anyMatch(right -&gt; urlsMatch(left, right));\n}\n</code></pre>\n</blockquote>\n<p>Both these methods are not <code>synchronized</code>, which means multiple threads can execute them at the same time. This is likely not a problem for the <code>containsURL(...)</code> method. Given what it does, it has no reason to be <code>synchronized</code> (neither it, nor the <code>urlsMatch(...)</code> method, rely on any external state). The problem is with how the <code>isLinkURLValid(...)</code> method passes both <code>linksCrawled</code> and <code>linksInProgress</code> to the <code>containsURL(...)</code> method.</p>\n<p>These list variables are static, and thus the same instances are passed to the <code>isLinkURLValid(...)</code> method on different threads. This would be okay, if all you did was stream the elements of these lists (i.e., only <em>read</em> from the lists). However, elsewhere in your code you also <em>add elements</em> to these lists (i.e., you <em>write</em> to the lists). These writes are performed in <code>synchronized</code> methods, but that doesn't matter because you're reading the lists without synchronizing on the same object. So, your code is vulnerable to <code>ConcurrentModificationException</code>s (you cannot modify a non-concurrent collection while iterating over it).</p>\n<p><em>I believe</em> the solution would be to simply make the <code>isLinkURLValid(...)</code> method <code>synchronized</code>, but I'm not 100% positive as I haven't tested it.</p>\n","answer_id":72551685,"question_id":72525288},{"owner":{"profile_image":"https://i.stack.imgur.com/5EJGg.png?s=256&g=1","account_id":4104221,"user_type":"registered","user_id":3368818,"link":"https://stackoverflow.com/users/3368818/woodchuck","reputation":3989,"display_name":"Woodchuck","accept_rate":75},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1649619176,"creation_date":1649617272,"body":"<p>I don't exactly follow what you're looking for. But it sounds like you're looking to execute those methods in a multi-threaded way.</p>\n<p>If that's the case, you appear to be missing some things, such as the <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html\" rel=\"nofollow noreferrer\">synchronized</a> keyword and the <a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html\" rel=\"nofollow noreferrer\">Runnable</a> interface.</p>\n<p>The following is an example to perhaps get you started down the right path. It runs as it is, but I'm sure you'll need to tweak it to accomplish your goal:</p>\n<pre><code>package SatrancSaatiRunner ;\n\nimport java.util.Scanner;\n\npublic class SatrancSaatiRunner {\n    static int beyazZamani = 60;\n    static int siyahZamani = 60;\n\n    static boolean BeyazinSirasi = false;\n    static boolean SiyahinSirasi = false;// rakip baslar\n\n    static boolean zamanVarMi = true;\n\n    public static void main(String[] args) throws InterruptedException {\n\n        SatrancSaatiRunner s = new SatrancSaatiRunner();\n\n        for (int i = 0; i &lt; 999; i++) {\n\n            //Scanner scanner = new Scanner(System.in);\n            System.out.println(&quot;Beyaz hamle yaptiktan sonra 1 e basmali&quot;);\n            System.out.println(&quot;Siyah hamle yaptiktan sonra 2 e basmali&quot;);\n\n            //int kiminSirasi = scanner.nextInt();\n            //if (kiminSirasi == 1) {\n            //    saatCalistirSiyah(BeyazinSirasi, siyahZamani, zamanVarMi, beyazZamani, siyahZamani);\n\n            //} else if (kiminSirasi == 2) {\n            //      saatCalistirBeyaz(BeyazinSirasi, siyahZamani, zamanVarMi, beyazZamani, siyahZamani);\n            //}\n        //}\n      }\n\n        Thread t1 = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                try {\n                    s.saatCalistirSiyah(BeyazinSirasi, siyahZamani, zamanVarMi, beyazZamani, siyahZamani);\n                } catch (InterruptedException e) {\n                    System.out.println(e);\n                }\n            }\n        });\n\n        Thread t2 = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                try {\n                    s.saatCalistirBeyaz(BeyazinSirasi, siyahZamani, zamanVarMi, beyazZamani, siyahZamani);\n                } catch (InterruptedException e) {\n                    System.out.println(e);\n                }\n            }\n        });\n\n        t1.start();\n        t2.start();\n\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void saatCalistirBeyaz(boolean beyazinSirasi, int siyahZamani, boolean zamanVarMi, int beyazZamani,\n            int siyahZamani1) throws InterruptedException {\n        synchronized (this) {\n            System.out.println(&quot;***Hamle Beyazda***&quot;);\n            while (true) {\n                siyahZamani++;\n                beyazZamani--;\n                System.out.print(&quot;Beyaz: &quot; + beyazZamani + &quot; &quot;);\n                System.out.print(&quot;Siyah: &quot; + siyahZamani);\n                System.out.print(&quot;\\u000C&quot;);\n                Thread.sleep(1000);\n\n                if (beyazZamani &lt;= 0 || siyahZamani &lt;= 0) {\n                    break;\n                }\n            }\n        }\n    }\n\n    private void saatCalistirSiyah(boolean beyazinSirasi, int siyahZamani, boolean zamanVarMi, int beyazZamani,\n            int siyahZamani1) throws InterruptedException {\n        System.out.println(&quot;***Hamle Siyahta***&quot;);\n        while (true) {\n            beyazZamani++;\n            siyahZamani--;\n            System.out.print(&quot;Beyaz: &quot; + beyazZamani + &quot; &quot;);\n            System.out.print(&quot;Siyah: &quot; + siyahZamani);\n            System.out.print(&quot;\\u000C&quot;);\n            Thread.sleep(1000);\n\n            if (beyazZamani &lt;= 0 || siyahZamani &lt;= 0) {\n                break;\n            }\n        }\n    }\n}\n</code></pre>\n","answer_id":71819697,"question_id":71817703,"last_edit_date":1649619176},{"owner":{"profile_image":"https://www.gravatar.com/avatar/1f698e72460b5a8c716a0c1cea91b81e?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":13429972,"user_type":"registered","user_id":9690075,"link":"https://stackoverflow.com/users/9690075/zysaaa","reputation":1807,"display_name":"zysaaa"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1646282321,"creation_date":1646282321,"body":"<p>When a thread is woken up(<code>wait</code>-&gt;<code>runnable</code>), it needs to judge again whether the current <code>counter</code> is less than <code>LIMIT</code>, otherwise, it will continue to print until <code>while (counter &lt;= LIMIT)</code> does not hold.(That's why <code>11</code> and <code>12</code> are printed too).</p>\n<p>I would suggest that you determine in advance how many times each thread will loop(This will make the code simpler):</p>\n<pre><code>    // thread1\n    // prints 1, 4, 7, 10, ...\n    synchronized void printAPStartingFrom1() {\n        int count = LIMIT % 3 == 0 ? LIMIT / 3 : LIMIT / 3 + 1;\n        for (int i = 0; i &lt; count; i++) {\n            while (counter % 3 != 1) {\n                wait();\n            }\n            printAndAddCounter();\n            notifyAll();\n        }\n    }\n    // thread2\n    // prints 2, 5, 8, 11, ...\n    synchronized void printAPStartingFrom1() {\n        int count = (LIMIT - 1) % 3 == 0 ? LIMIT / 3 : LIMIT / 3 + 1;\n        for (int i = 0; i &lt; count; i++) {\n            while (counter % 3 != 2) {\n                wait();\n            }\n            printAndAddCounter();\n            notifyAll();\n        }\n    }\n    // thread3\n    // prints 3, 6, 9, 12, ...\n    synchronized void printAPStartingFrom1() {\n        int count = LIMIT / 3;\n        for (int i = 0; i &lt; count; i++) {\n            while (counter % 3 != 0) {\n                wait();\n            }\n            printAndAddCounter();\n            notifyAll();\n        }\n    }\n</code></pre>\n","answer_id":71332202,"question_id":71328425},{"owner":{"profile_image":"https://www.gravatar.com/avatar/6b2c535fac79e482b71f15de561f55ca?s=256&d=identicon&r=PG","account_id":60171,"user_type":"registered","user_id":179850,"link":"https://stackoverflow.com/users/179850/gray","reputation":115485,"display_name":"Gray","accept_rate":100},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":true,"last_activity_date":1646246685,"creation_date":1646246685,"body":"<blockquote>\n<p>java.lang.IllegalStateException: No thread-bound request found:</p>\n</blockquote>\n<p>This exception is trying to tell you that there is no current request being processed by the <code>HttpServletRequest</code> that has been auto-wired into your class.</p>\n<p>Something is calling the <code>putData()</code> method but not as through a call to the HTTP controller.  You mention that you are using the &quot;Kafka Consumer&quot; so maybe it is the consumer code which is calling <code>putData()</code>?  You can't call it because the method needs to have a web request context to work since it needs the request headers and cookie information.</p>\n<p>You should probably separate out the data persistence code so that both the controller <code>putData()</code> method and the kafka consumer can both call it.</p>\n","answer_id":71327704,"question_id":71311675},{"owner":{"profile_image":"https://www.gravatar.com/avatar/bc9274828a5770ef2f992f78fa8f3339?s=256&d=identicon&r=PG","account_id":1306332,"user_type":"registered","user_id":1255267,"link":"https://stackoverflow.com/users/1255267/tastywheat","reputation":2147,"display_name":"TastyWheat"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1646243274,"creation_date":1646243274,"body":"<p>The documentation is unfortunately not very clear about what can and can't be reused safely. When in doubt reuse nothing. However, if you're determined to minimize overhead you can safely reuse most objects depending on the methods called.</p>\n<p>Starting with your code, here's some comments about what's happening:</p>\n<pre class=\"lang-java prettyprint-override\"><code>// (1) Store an instance of Client with its own configuration\nprivate static Client client = ClientBuilder.newClient();\n// (2) Store an instance of WebTarget with its own configuration (inherited from client)\nprivate static WebTarget webTarget = client.target(&quot;someBaseUrl&quot;);\n...\npublic static String someMethod(String arg1, String arg2)\n{\n    // (3) New instance of WebTarget (copy entrTarget config) with &quot;arg1&quot; param\n    // (4) New instance of WebTarget (copy anonymous config) with &quot;arg2&quot; param\n    WebTarget target = entrTarget.queryParam(&quot;arg1&quot;, arg1).queryParam(&quot;arg2&quot;, arg2);\n    // (5) New instance of Invocation.Builder (copy target config)\n    // (6) Invoke GET request with stored configuration\n    Response response = target.request().get();\n    final String result = response.readEntity(String.class);\n    response.close();\n    return result;\n}\n</code></pre>\n<p>I commented on the code as-is but I'm guessing <code>(3)</code> should've referenced the static <code>webTarget</code> field.</p>\n<p>A lot of objects are getting created here. Every time an object is created there's a new instance with its own copy of the configuration (so it won't affect its predecessors). In this particular case there should be no race conditions, but there are definitely ways in which this could go wrong.</p>\n<p>If on or before <code>(3)</code> you had done something like this (assuming these are legitimate properties):</p>\n<pre class=\"lang-java prettyprint-override\"><code>WebTarget target = webTarget.property(&quot;foo&quot;, fooProperty).queryParam(&quot;arg1&quot;, arg1);\n</code></pre>\n<p>Then you would be altering the configuration of the static <code>webTarget</code> field and that could cause a race condition. There are many ways to alter the configuration from the static fields so you either need to guard them carefully or just not have them at all.</p>\n<p>Also, be aware that pretty much every object that spawns from the original <code>client</code> will have a reference to it for the purpose of determining if the httpEngine has been closed. So unless you're trying to gracefully shutdown your application it's likely never a good idea to close the client.</p>\n<p>And I found out all of this by digging through the source code because there's really no good reference.</p>\n","answer_id":71327053,"question_id":33097230},{"owner":{"profile_image":"https://i.stack.imgur.com/W6OMC.png?s=256&g=1","account_id":1056871,"user_type":"registered","user_id":1059372,"link":"https://stackoverflow.com/users/1059372/eugene","reputation":117749,"display_name":"Eugene","accept_rate":97},"content_license":"CC BY-SA 4.0","score":4,"is_accepted":false,"last_activity_date":1646233694,"creation_date":1645609597,"body":"<p>The <a href=\"https://stackoverflow.com/a/71212240/1059372\">accepted answer</a> is simple, yet great. <code>volatile</code> is rarely explained and used for safe publishing, yet it provides the needed guarantees.</p>\n<p>imho, to properly prove that this works with volatile, there are some things that need explaining.</p>\n<p>The first one is &quot;program order&quot;, or the perceivable order in which things happen within a thread. We can draw this to easier grasp things:</p>\n<pre><code> --------------- T1 -------------\n | write to num or this.num=num |\n --------------------------------\n                 |\n                \\|/  (PO)\n --------------- T1 -------------\n |    write Wrapper instance    |\n --------------------------------\n                 |\n                \\|/  (??)\n --------------- T2 -------------\n |    read Wrapper instance     |\n --------------------------------\n                 |\n                \\|/  (PO)\n --------------- T2 -------------\n |      read num first time     |\n --------------------------------\n                 |\n                \\|/  (PO)\n --------------- T2 -------------\n |      read num second time    |\n --------------------------------\n</code></pre>\n<p><code>T1</code> and <code>T2</code> are thread1 and thread2 and <code>PO</code> is program order. Now a rule in the <code>JLS</code> says this:</p>\n<blockquote>\n<p>If x and y are actions of the same thread and x comes before y in program order, then hb(x, y).</p>\n</blockquote>\n<p>As such we can replace <code>PO</code> in the above drawing with <code>HB</code> (happens-before).</p>\n<p>At the same time, if <code>wrapper</code> instance is <em>not</em> volatile, there is no special relation between <em>writing</em> to <code>wrapper</code> (from <code>T1</code>) and <em>reading</em> from <code>wrapper</code> in <code>T2</code>.</p>\n<p>We need to also introduce here <em>happen-before consistency</em>:</p>\n<blockquote>\n<p>a <em>read</em> sees the last <em>write</em> in happens-before order, or <em>any other</em> write.</p>\n</blockquote>\n<p>Since we do not have a full chain of happens-before here (that <code>??</code> does not establish one), we get that : &quot;...or any other read&quot;, which means we can read <em>different</em> values in those two reads of <code>num</code> (in that <code>num != num</code>).</p>\n<hr />\n<p>If you make <code>wrapper</code> instance <code>volatile</code>, <code>JLS</code> says that:</p>\n<blockquote>\n<p>A write to a volatile field (§8.3.1.4) happens-before every subsequent read of that field.</p>\n</blockquote>\n<p>As such, we have this now:</p>\n<pre><code> --------------- T1 -------------\n | write to num or this.num=num |\n --------------------------------\n                 |\n                \\|/  (HB)\n --------------- T1 -------------\n |    write Wrapper instance    |\n --------------------------------\n                 |\n                \\|/  (HB)\n --------------- T2 -------------\n |    read Wrapper instance     |\n --------------------------------\n                 |\n                \\|/  (HB)\n --------------- T2 -------------\n |      read num first time     |\n --------------------------------\n                 |\n                \\|/  (HB)\n --------------- T2 -------------\n |      read num second time    |\n --------------------------------\n</code></pre>\n<p>Now, happens-before consistency says : &quot;a <em>read</em> sees the last <em>write</em> in happens-before order...&quot;; the key part here is &quot;in happens-before order&quot;. This means that <em>both</em> reads of <code>num</code> will see the write of it (again: in happens before order).</p>\n","answer_id":71234632,"question_id":71212008,"last_edit_date":1646233694},{"owner":{"profile_image":"https://www.gravatar.com/avatar/a287ffec5b98c1e185187f04bbe8d424?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":10957698,"user_type":"registered","user_id":8051929,"link":"https://stackoverflow.com/users/8051929/echo-zeng","reputation":61,"display_name":"Echo Zeng"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1646226073,"creation_date":1646226073,"body":"<p>Like if you want a row in this table, and you do not want any cell would be changed during the period, so you can add one read-lock.</p>\n<p>Other guys can also read, it doesn't matter.</p>\n","answer_id":71323151,"question_id":33384822},{"owner":{"profile_image":"https://i.stack.imgur.com/t2hoD.jpg?s=256&g=1","account_id":3211603,"user_type":"registered","user_id":2711488,"link":"https://stackoverflow.com/users/2711488/holger","reputation":289317,"display_name":"Holger"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1646216677,"creation_date":1646216677,"body":"<p>You should not create a new <code>ScheduledThreadPoolExecutor</code> within the method. An executor is supposed to be reused. And you should call <code>shutdown()</code> on it once you really don’t need it anymore.</p>\n<p>But more important is that, since the scheduled action is performed by a different thread, <em>it must use <code>synchronized</code></em> when accessing the mutable state.</p>\n<p>This leads to the point you’re missing about <code>wait()</code>. The only way for the condition you’re waiting for to correctly become fulfilled, is by having another thread performing the necessary steps within a <code>synchronized</code> block and calling <code>notify()</code> or <code>notifyAll()</code>, both methods insisting on being called within that <code>synchronized</code> block.</p>\n<p>This can only work, when <code>wait()</code> releases the lock, so the other thread can acquire it and do the duty. And <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long,int)\" rel=\"nofollow noreferrer\">that’s precisely what <code>wait</code> does</a>:</p>\n<blockquote>\n<p>This method causes the current thread (referred to here as <em>T</em>) to place itself in the wait set for this object and then to relinquish any and all synchronization claims on this object. Note that only the locks on this object are relinquished; any other objects on which the current thread may be synchronized remain locked while the thread waits.</p>\n<p>Thread <em>T</em> then becomes disabled for thread scheduling purposes and lies dormant until one of the following occurs:</p>\n<p>…</p>\n<p>The thread <em>T</em> is then removed from the wait set for this object and re-enabled for thread scheduling. It competes in the usual manner with other threads for the right to synchronize on the object; once it has regained control of the object, all its synchronization claims on the object are restored to the status quo ante - that is, to the situation as of the time that the <code>wait</code> method was invoked. Thread <em>T</em> then returns from the invocation of the <code>wait</code> method. Thus, on return from the <code>wait</code> method, the synchronization state of the object and of thread <em>T</em> is exactly as it was when the <code>wait</code> method was invoked.</p>\n</blockquote>\n<p><sup>Note that <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait()\" rel=\"nofollow noreferrer\">the documentation of the no-arg <code>wait</code> method</a> redirects to the <code>wait(long,int)</code> documentation shown above</sup></p>\n<p>So the issue of your code is not that the initiating thread synchronizes but that the pool’s thread does not.</p>\n<pre class=\"lang-java prettyprint-override\"><code>static final ScheduledThreadPoolExecutor EXEC = new ScheduledThreadPoolExecutor(1);\n\npublic synchronized void joinClass(UUID student) throws InterruptedException {\n    this.students.add(student);\n\n    if(students.size() == 1) {\n        lecture = true;\n        EXEC.schedule(new Runnable() {\n            @Override\n            public void run() {\n                synchronized(OuterClassName.this) {\n                    students.clear();\n                    lecture = false;\n                    OuterClassName.this.notifyAll();\n                }\n            }\n        }, LECTURE_DURATION, TimeUnit.MILLISECONDS);\n    }\n    while(lecture) wait();\n}\n</code></pre>\n<p>As a side note, there is no reason to remove single elements in a loop to empty a list, <code>clear()</code> does the job. In case of an <code>ArrayList</code>, repeatedly calling <code>remove(0)</code> is the worst way to clear it.</p>\n<p>It’s also important to keep in mind that an inner class instance is a different object than the outer class instance. It’s simpler when using a lambda expression:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public synchronized void joinClass(UUID student) throws InterruptedException {\n    this.students.add(student);\n\n    if(students.size() == 1) {\n        lecture = true;\n        EXEC.schedule(() -&gt; {\n            synchronized(this) {\n                students.clear();\n                lecture = false;\n                notifyAll();\n            }\n        }, LECTURE_DURATION, TimeUnit.MILLISECONDS);\n    }\n\n    while(lecture) wait();\n}\n</code></pre>\n","answer_id":71321045,"question_id":71096361},{"owner":{"profile_image":"https://www.gravatar.com/avatar/2361856f85f6f797554dab9e867f868c?s=256&d=identicon&r=PG","account_id":24334457,"user_type":"unregistered","user_id":18272775,"link":"https://stackoverflow.com/users/18272775/user18272775","reputation":31,"display_name":"user18272775"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1645482567,"creation_date":1645482567,"body":"<p><a href=\"https://stackoverflow.com/a/71212240\">The answer above</a> is correct.</p>\n<p>Just keep in mind that  <code>effectively immutable + safe publication</code> behaves unintuitively in some cases.<br />\nFor instance:</p>\n<ol>\n<li><p>If</p>\n<ul>\n<li>at first <code>thread 1</code> safely publishes object <code>o</code> to <code>thread 2</code></li>\n<li>then <code>thread 2</code> unsafely publishes object <code>o</code> to <code>thread 3</code></li>\n</ul>\n<p>in the end <code>thread 3</code> can see object <code>o</code> in an inconsistent state<br />\nSee <a href=\"https://stackoverflow.com/questions/10254456/effectively-immutable-object/10254521#comment13189477_10254521\">[1]</a> and <a href=\"https://stackoverflow.com/q/66214096\">[2]</a></p>\n</li>\n<li><p>also <a href=\"https://shipilev.net/blog/2016/close-encounters-of-jmm-kind/#wishful-volatiles-are-finals\" rel=\"nofollow noreferrer\">this</a></p>\n</li>\n</ol>\n<p>Real immutable objects have no such problems.</p>\n","answer_id":71213773,"question_id":71212008},{"owner":{"profile_image":"https://i.stack.imgur.com/7H9TF.png?s=256&g=1","account_id":2994830,"user_type":"registered","user_id":2541560,"link":"https://stackoverflow.com/users/2541560/kayaman","reputation":1,"display_name":"Kayaman"},"content_license":"CC BY-SA 4.0","score":7,"is_accepted":true,"last_activity_date":1645473905,"creation_date":1645473019,"body":"<p>No, because <code>volatile</code> being used establishes a happens-before relationship. Without it various reorderings and other things are allowed, which make the inconsistent state possible, but with it the JVM must give you the expected outcome.</p>\n<p>In this case <code>volatile</code> is <strong>not</strong> used for the visibility effects (threads seeing up to date values), but the safe publishing provided by the happpens-before. This feature of <code>volatile</code> is often left out when its use is explained.</p>\n","answer_id":71212240,"question_id":71212008,"last_edit_date":1645473905},{"owner":{"profile_image":"https://i.stack.imgur.com/21IXR.jpg?s=256&g=1","account_id":1662506,"user_type":"registered","user_id":1530504,"link":"https://stackoverflow.com/users/1530504/asok-buzz","reputation":1874,"display_name":"asok Buzz","accept_rate":36},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1645074489,"creation_date":1645074489,"body":"<p>You should have <code>colors.xml</code> on values-night (create alongside values folder if it doesn't already exist) folder for dark theme colors.\neg.</p>\n<pre><code>&lt;resources&gt;\n    &lt;color name=&quot;status_bar&quot;&gt;#0e0e0e&lt;/color&gt;\n&lt;/resources&gt;\n</code></pre>\n<p>(<code>colors.xml</code> on regular values folder will be used for light theme)</p>\n<p>And on <code>styles.xml</code> which supplies your app theme you will have entry for background and statusbar which takes necessary values.\neg.</p>\n<pre><code>&lt;style name=&quot;Theme.&lt;AppName&gt;&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;\n        &lt;item name=&quot;colorPrimary&quot;&gt;@color/red700&lt;/item&gt;\n        &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/red900&lt;/item&gt;\n        &lt;item name=&quot;colorAccent&quot;&gt;@color/red700&lt;/item&gt;\n        &lt;item name=&quot;android:statusBarColor&quot;&gt;@color/status_bar&lt;/item&gt;\n        &lt;item name=&quot;android:background&quot;&gt;@color/status_bar&lt;/item&gt;\n    &lt;/style&gt;\n</code></pre>\n<p>This style is referenced on AndroidManifest.xml file</p>\n<pre><code>android:theme=&quot;@style/Theme.&lt;AppName&gt;&quot;&gt;\n</code></pre>\n","answer_id":71152787,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/53aa3f0985b383044bf3f33643ffde76?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":14584795,"user_type":"registered","user_id":10534012,"link":"https://stackoverflow.com/users/10534012/darkman","reputation":2961,"display_name":"Darkman"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1644908921,"creation_date":1644899177,"body":"<p>No idea if this going to solve your problem but it might give you an idea.</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class Main\n{\n    public static void main(String[] args) throws Exception\n    {\n        Classroom classroom = new Classroom();\n        Student studentA = new Student(&quot;Student A&quot;, classroom);\n        Student studentB = new Student(&quot;Student B&quot;, classroom);\n        Student studentC = new Student(&quot;Student C&quot;, classroom);\n        Student studentD = new Student(&quot;Student D&quot;, classroom);\n        \n        studentA.enterClass();\n        Thread.sleep(1000L); //1000 m/s early.\n        classroom.start();\n        Thread.sleep(1000L); //1 second late.\n        studentB.enterClass();\n        Thread.sleep(500L); //Late for 1.5 seconds.\n        studentC.enterClass();\n        classroom.join();\n        Thread.sleep(2000L); //Class has ended.\n        studentD.enterClass();\n        System.out.println(&quot;Main Thread&quot;);\n    }\n}\n\nclass Student implements Runnable\n{\n    public String name;\n    private Classroom classroom;\n    public Thread thread;\n    \n    Student(String name, Classroom classroom)\n    {\n        this.name = name;\n        this.classroom = classroom;\n        thread = new Thread(this);\n    }\n    public void enterClass()\n    {\n        thread.start();\n    }\n    public synchronized void exitClass()\n    {\n        this.notify();\n    }\n    @Override\n    public void run()\n    {\n        try {\n            System.out.println(name + &quot; entering the class.&quot;);\n            classroom.joinClass(this);\n            synchronized(this) {\n                while(!classroom.hasEnded) this.wait();\n            }\n            System.out.println(name + &quot; existing the class.&quot;);\n        } catch(Exception e) {}\n    }\n}\n\nclass Classroom implements Runnable\n{\n    private static final long LECTURE_DURATION = 3000L;\n    private Thread thread;\n    public volatile boolean hasEnded;\n    private List&lt;Student&gt; students;\n    \n    Classroom()\n    {\n        students = new ArrayList&lt;Student&gt;();\n        thread = new Thread(this);\n    }\n    public void start()\n    {\n        thread.start();\n    }\n    public void join() throws Exception\n    {\n        thread.join();\n    }\n    @Override\n    public void run()\n    {\n        System.out.println(&quot;Class starting...&quot;);\n        try {\n            Thread.sleep(LECTURE_DURATION);\n        } catch(Exception e) {}\n        hasEnded = true;\n        System.out.println(&quot;Class ended&quot;);\n        for(Student s : students) s.exitClass();\n    }\n    public void joinClass(Student student) throws Exception\n    {\n        if(!hasEnded) {\n            System.out.println(student.name + &quot; joins the class.&quot;);\n            students.add(student);\n        }\n    }\n}\n</code></pre>\n<p>Here is the output. It may vary in your system.</p>\n<pre><code>Student A entering the class.\nStudent A joins the class.\nClass starting...\nStudent B entering the class.\nStudent B joins the class.\nStudent C entering the class.\nStudent C joins the class.\nClass ended\nStudent B existing the class.\nStudent A existing the class.\nStudent C existing the class.\nMain Thread\nStudent D entering the class.\nStudent D existing the class.\n</code></pre>\n","answer_id":71121105,"question_id":71096361,"last_edit_date":1644908921},{"owner":{"profile_image":"https://i.stack.imgur.com/RDWxl.png?s=256&g=1","account_id":4342327,"user_type":"registered","user_id":3545273,"link":"https://stackoverflow.com/users/3545273/serge-ballesta","reputation":145474,"display_name":"Serge Ballesta","accept_rate":100},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1636974569,"creation_date":1636974348,"body":"<p>Let us look carefully to your test code:</p>\n<pre><code>    GameServer server = new GameServer();\n</code></pre>\n<p>Ok, this lines creates a server, and the test thread is ready to execute next line</p>\n<pre><code>    server.start(9000);\n</code></pre>\n<p>Ok, the test thread starts the server, and <strong>will be ready to execute the next line when the <code>start</code> method will return</strong>.</p>\n<p>What happens in <code>start</code>:</p>\n<pre><code>    System.out.println(&quot;Server started !!!&quot;);\n</code></pre>\n<p>Ok, you should see that message</p>\n<pre><code>    serverSocket = new ServerSocket(port);\n</code></pre>\n<p>Ok, you have created a <code>ServerSocket</code></p>\n<pre><code>    while (true) {\n        new Thread(new GameClientHandler(serverSocket.accept())).start();\n    }\n</code></pre>\n<p>ok you a waiting for a connection (at <code>serverSocket.accept()</code>), will create a new thread to handle it as soon as you will get one, and loop again.</p>\n<p>But as this point, the test thread is waiting and will never go to the following line to start the first connection. And it will remain stuck unless <em>something else</em> (maybe another thread) starts those damned connections.</p>\n","answer_id":69973382,"question_id":69973062,"last_edit_date":1636974569},{"owner":{"profile_image":"https://www.gravatar.com/avatar/0f3e2abdf89734028a734c821c4fab78?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8775035,"user_type":"registered","user_id":6560579,"link":"https://stackoverflow.com/users/6560579/ackdari","reputation":3254,"display_name":"Ackdari"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1636973254,"creation_date":1636973254,"body":"<p>The method <code>GameServer.start</code> will only return with an exception. That is because you have the while-loop.</p>\n<p>So your test execution will start the server and wait for someone to open a connection, but that never happens.</p>\n","answer_id":69973143,"question_id":69973062},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG","account_id":401843,"user_type":"registered","user_id":768644,"link":"https://stackoverflow.com/users/768644/rzwitserloot","reputation":89863,"display_name":"rzwitserloot"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1636927783,"creation_date":1636927783,"body":"<p>Sure it is. However, 'wake the thread' does not mean 'it will fly ahead and IMMEDIATELY start running this very instant in time, whilst your thread has to do the extremely slow move of.. looping a for loop'.</p>\n<p>It could (that's one of the problems of threads: Things are arbitrary, and arbitrary is bad, because it's untestable. There is no fix for this, other than not using threads that require synchronization, for example by doing all state communication via transactions and a database)... but it usually won't.</p>\n<p>Your dropBall runs to its natural end, then it releases the lock (as the dropBall method is synchronized). Only now can the other thread's takeBall move on from its wait (wait doesn't JUST wait for a notify - it also releases the lock and can't continue until it has both been notified AND it can re-acquire the lock, which initially it by definition cannot, because you can't notify without holding the lock).</p>\n<p>What actually happens is this:</p>\n<ul>\n<li>Player2's thread is watching out for the ball's lock being available; it currently is not.</li>\n<li>Player1's thread releases the lock, hops back to your for loop that loops 25 times, executes the takeBall method and re-acquires the lock.</li>\n<li>Sometime later Player2 looks up and goes: Oh, wait, WHAT? Oh nuts! I missed it!</li>\n</ul>\n<p>Locks are not guaranteed to be 'fair'. Because fair locks take time and the JVM is designed to fulfill all guarantees as fast as possible (and thus, doesn't give you unpromised freebies), JVM locks as a consequence are pretty much never fair except on <em>extremely</em> bizarro combinations of JVM impl, OS, and hardware.</p>\n<p>Shove a sleep in between the dropping and the re-taking and you'll likely see something you were expecting. Now the VM/OS/hardware either [A] actually lets player2's thread grab the lock and actually take the ball, or [B] twiddle its thumbs.</p>\n<p>Note that the <code>Thread.sleep</code> you'll be writing MUST NOT be in any place where you hold the lock. Given that the entirety of the takeBall method is synchronized, don't do it there; do it in your for loop. (And as a side note, catch an exception and do nothing? <em><strong>That is extremely bad, don't ever do that</strong></em><sup>1</sup> - I fixed that for you too):</p>\n<pre><code>try {\n  ball.takeBall();\n  sleep(1000);\n  ball.dropBall();\n  sleep(100);\n} catch (Exception e) {\n  throw new RuntimeException(&quot;Unhandled&quot;, e);\n}\n</code></pre>\n<p>[1] Unless you truly intend for code to silently ignore the error and carry on like nothing happened. There are times where that is the right move but extremely rare and not something a newbie should be meddling with. Far too easy to misunderstand something and then get utterly lost because crucial information (namely, that an error occured, where it occurred, why, and the details surrounding) got discarded.</p>\n","answer_id":69967575,"question_id":69967482},{"owner":{"profile_image":"https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG","account_id":47283,"user_type":"registered","user_id":139985,"link":"https://stackoverflow.com/users/139985/stephen-c","reputation":703927,"display_name":"Stephen C","accept_rate":69},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":true,"last_activity_date":1636864683,"creation_date":1636863799,"body":"<p>The <code>final</code> makes no difference here.  The code is not thread-safe, whether the <code>final</code> is there or not.</p>\n<p>There are two reasons that this is not thread-safe.</p>\n<ol>\n<li><p>You are publishing (and potentially mutating) the state of <code>Dummy</code> before its constructor has completed.  This is unsafe whether or not the variable is <code>final</code>.</p>\n</li>\n<li><p>You are returning a shared mutable object in the <code>getIntegers()</code> call.  So that means that the caller <em>could</em> change it, and a second caller may or may not see the results ... due to lack of synchronization.  Once again <code>final</code> makes no difference to this.</p>\n</li>\n</ol>\n<hr />\n<p>The thread-safety guarantees of <code>final</code> are limited.  Here's what the <a href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.5\" rel=\"nofollow noreferrer\">JLS</a> says:</p>\n<blockquote>\n<p><code>final</code> fields also allow programmers to implement thread-safe immutable objects without synchronization. A thread-safe immutable object is seen as immutable by all threads, even if a data race is used to pass references to the immutable object between threads. This can provide safety guarantees against misuse of an immutable class by incorrect or malicious code. <strong><code>final</code> fields must be used correctly to provide a guarantee of immutability.</strong></p>\n<p>An object is considered to be completely initialized when its constructor finishes. A thread that can only see a reference to an object after that object has been completely initialized is guaranteed to see the correctly initialized values for that object's <code>final</code> fields.</p>\n</blockquote>\n<p>The takeaways are that the <code>final</code> guarantees only apply to <strong>immutable</strong> objects, and they only apply <strong>after</strong> the return of the object's constructor.</p>\n<p>In your example does not satisfy either of these prerequisites.  Therefore, the guarantees do not apply.</p>\n","answer_id":69960265,"question_id":69960082,"last_edit_date":1636864683},{"owner":{"profile_image":"https://i.stack.imgur.com/ZWEI3.jpg?s=256&g=1","account_id":322981,"user_type":"registered","user_id":642706,"link":"https://stackoverflow.com/users/642706/basil-bourque","reputation":310755,"display_name":"Basil Bourque","accept_rate":58},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1636857098,"creation_date":1636831831,"body":"<p>To quote the <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/join.html\" rel=\"nofollow noreferrer\">Oracle tutorial</a>:</p>\n<blockquote>\n<p><code>t.join()</code> causes the current thread to pause execution until t's thread terminates</p>\n</blockquote>\n<p>So effectively you are not making any real use of threading. On every pass through your <code>for</code> loop, you launch a thread but then wait for it to complete. No point in doing that, you could forgo the threads and just sequentially do your tasks’ work within the current thread.</p>\n<hr />\n<p>In modern Java, we rarely need to address the <code>Thread</code> class directly. Instead we submit our <code>Runnable</code>/<code>Callable</code> task to an <code>ExecutorService</code>.</p>\n<p>To schedule repeated calculations every 5 seconds, use a <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/ScheduledExecutorService.html\" rel=\"nofollow noreferrer\"><code>ScheduledExecutorService</code></a>.</p>\n<pre><code>ScheduledExecutorService ses = Executors. newSingleThreadScheduledExecutor() ;\n…\nses.scheduleAtFixedRate( myStatsCalcRunnable , 1 , 5 , TimeUnit.SECONDS ) ;\n</code></pre>\n<p>Caution: Be sure to eventually shut down your executor services. Otherwise their backing thread pools may continue running indefinitely, like a zombie 🧟‍♂️.</p>\n<p>Change this:</p>\n<pre><code>public class FestivalStatisticsThread extends Thread { … } \n</code></pre>\n<p>… with a <code>run</code> method into:</p>\n<pre><code>public class FestivalStatistics { … } \n</code></pre>\n<p>… with a <code>recalculate</code> method. Call that <code>recalculate</code> method from the <code>Runnable</code> task submitted to your scheduled executor service.</p>\n<p>Or perhaps that functionality should just be a part of the <code>Gate</code> class. (I’m not sure. I’d have to think more on that.)</p>\n<hr />\n<p>85,000 simultaneous threads may be too much of a burden on common hardware. Instead, start an executor service with a limited number of threads. Then submit your 85,000 tasks as <code>Runnable</code>/<code>Callable</code> objects. The executor service takes care of feeding those tasks to be executed on those limited number of threads.</p>\n<p>In the future, if <a href=\"https://wiki.openjdk.java.net/display/loom/Main\" rel=\"nofollow noreferrer\"><em>Project Loom</em></a> succeeds, you will be able to use 85,000 (or even millions) <em>virtual</em> threads (also known as “fibers”) at a time. To learn more, see the more recent talks by Ron Pressler or other members of the Loom team. Experimental builds based on early-access Java 18 are available now. The Loom team seeks feedback.</p>\n<hr />\n<p>All of these topics have been addressed already on Stack Overflow.  Search to learn more. I myself have written multiple Answers with code examples, as have others.</p>\n<hr />\n<p>By the way, I would make <code>FestivalGate</code> more encapsulated. The other classes should not have access to, or even know about, its internal use of a synchronized <code>List</code>. Add methods to collect and report on tickets.</p>\n<hr />\n<p>Here is some quick code I wrote as a demonstration of topics discussed above.</p>\n<p>Use at your own risk; I’ve not done any serious testing nor a thoughtful code review.</p>\n<p>Perhaps I have oversimplified your domain problem. You could of course expand or rearrange as needed. But hopefully this shows clearly how to use executor service.</p>\n<p>We have a basic <code>Ticket</code> class to represent each ticket. We use a <a href=\"https://openjdk.java.net/jeps/395\" rel=\"nofollow noreferrer\">record</a> here to define that class. We nest the enum of ticket types.</p>\n<pre class=\"lang-java prettyprint-override\"><code>package work.basil.festival;\n\nimport java.util.UUID;\n\npublic record Ticket( UUID id , Type type )\n{\n    enum Type\n    { FULL_VIP, FREE_PASS, ONE_DAY, ONE_DAY_VIP }\n}\n</code></pre>\n<p>We have a <code>Gate</code> class to hold our domain logic. We nest a <code>Statistics</code> class to hold our reported summary of tickets taken so far.</p>\n<pre class=\"lang-java prettyprint-override\"><code>package work.basil.festival;\n\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.*;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.stream.Collectors;\n\npublic class Gate\n{\n    final private Set &lt; Ticket &gt; ticketsTaken;\n\n    public Gate ( )\n    {\n        this.ticketsTaken = new HashSet &lt;&gt;();\n    }\n\n    synchronized public boolean takeTicket ( final Ticket ticket )\n    {\n        // Simulate hard work by sleeping some random amount of time.\n        int millis = ThreadLocalRandom.current().nextInt( 2 );\n        try { Thread.sleep( millis ); }catch ( InterruptedException e ) { e.printStackTrace(); }\n        return this.ticketsTaken.add( ticket );\n    }\n\n    synchronized public List &lt; Ticket &gt; ticketsTaken ( )\n    {\n        return List.copyOf( this.ticketsTaken );  // Returns unmodifiable list of the `Ticket` objects contained in our private member set.\n    }\n\n    record Statistics( Instant when , int countTicketsTaken , Map &lt; Ticket.Type, Integer &gt; countOfTicketsTakenByType )\n    {\n    }\n\n    synchronized public Statistics statistics ( )\n    {\n        int count = this.countTicketsTaken();\n        Map &lt; Ticket.Type, Integer &gt; map = this.reportCountOfTicketsTakenByType();\n        if ( count != map.values().stream().mapToInt( Integer :: intValue ).sum() ) { throw new IllegalStateException( &quot;Counts do not match in Gate.Statistics. Error # 898e905f-9432-4195-a3e0-118bede2872d.&quot; ); }\n        return new Statistics( Instant.now() , count , map );\n    }\n\n    private int countTicketsTaken ( )\n    {\n        return this.ticketsTaken.size();\n    }\n\n    private Map &lt; Ticket.Type, Integer &gt; reportCountOfTicketsTakenByType ( )\n    {\n        // We use `AtomicInteger` here not for thread-safety, but for the convenience of its `incrementAndGet` method.\n        Map &lt; Ticket.Type, AtomicInteger &gt; map = new EnumMap &lt; Ticket.Type, AtomicInteger &gt;( Ticket.Type.class );\n        Arrays.stream( Ticket.Type.values() ).forEach( type -&gt; map.put( type , new AtomicInteger( 0 ) ) ); // Initialize the map, so each ticket-type has an atomic integer set to zero.\n        this.ticketsTaken.stream().forEach( ticket -&gt; map.get( ticket.type() ).incrementAndGet() );\n\n        // Convert the AtomicInteger values to simply `Integer` values.\n        Map &lt; Ticket.Type, Integer &gt; result = map.entrySet().stream().collect( Collectors.toMap( Map.Entry :: getKey , atomicInteger -&gt; atomicInteger.getValue().intValue() ) );\n        return Map.copyOf( result ); // Return an unmodifiable map, as a good practice.\n    }\n}\n</code></pre>\n<p>And we have an <code>App</code> class to drive a demonstration.</p>\n<pre class=\"lang-java prettyprint-override\"><code>package work.basil.festival;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\nimport java.util.concurrent.*;\nimport java.util.stream.IntStream;\n\n/**\n * Hello world!\n */\npublic class App\n{\n    public static void main ( String[] args )\n    {\n        System.out.println( &quot;Hello World!&quot; );\n\n        App app = new App();\n        app.demo();\n    }\n\n    private void demo ( )\n    {\n        final List &lt; Ticket &gt; ticketsToTake = this.generateTicketsForFestival();\n\n        Gate gate = new Gate();\n\n        // Report every five seconds on the progress of our gate taking tickets.\n        ScheduledExecutorService reportingExecutorService = Executors.newSingleThreadScheduledExecutor();\n        reportingExecutorService.scheduleAtFixedRate( ( ) -&gt; System.out.println( gate.statistics() ) , 0 , 5 , TimeUnit.SECONDS );\n\n        ExecutorService ticketTakingExecutorService = Executors.newFixedThreadPool( 7 );\n        for ( Ticket ticket : ticketsToTake )\n        {\n            ticketTakingExecutorService.submit( ( ) -&gt; gate.takeTicket( ticket ) );\n        }\n        ticketTakingExecutorService.shutdown();\n        try { ticketTakingExecutorService.awaitTermination( 10 , TimeUnit.MINUTES ); } catch ( InterruptedException e ) { e.printStackTrace(); }\n        reportingExecutorService.shutdown();\n        try { reportingExecutorService.awaitTermination( 10 , TimeUnit.MINUTES ); } catch ( InterruptedException e ) { e.printStackTrace(); }\n\n        System.out.println( &quot;« FIN » &quot; + gate.statistics() );\n    }\n\n    private List &lt; Ticket &gt; generateTicketsForFestival ( )\n    {\n        List &lt; Ticket &gt; tickets = new ArrayList &lt;&gt;();\n        for ( int i = 0 ; i &lt; 85_000 ; i++ )\n        {\n            tickets.add(\n                    new Ticket(\n                            UUID.randomUUID() ,  // Randomly generate a UUID, to identify uniquely each ticket.\n                            Ticket.Type.values()[ ThreadLocalRandom.current().nextInt( Ticket.Type.values().length ) ]  // Randomly pick one of the ticket types.\n                    )\n            );\n        }\n        return List.copyOf( tickets );\n    }\n}\n</code></pre>\n<p>When run on an 8-core M1 MacBook Pro.</p>\n<pre class=\"lang-none prettyprint-override\"><code>Hello World!\nStatistics[when=2021-11-14T02:28:52.746596Z, countTicketsTaken=0, countOfTicketsTakenByType={FREE_PASS=0, ONE_DAY=0, ONE_DAY_VIP=0, FULL_VIP=0}]\nStatistics[when=2021-11-14T02:28:57.800514Z, countTicketsTaken=7517, countOfTicketsTakenByType={FREE_PASS=1862, ONE_DAY=1953, ONE_DAY_VIP=1889, FULL_VIP=1813}]\nStatistics[when=2021-11-14T02:29:02.804886Z, countTicketsTaken=15128, countOfTicketsTakenByType={FREE_PASS=3791, ONE_DAY=3788, ONE_DAY_VIP=3775, FULL_VIP=3774}]\nStatistics[when=2021-11-14T02:29:07.746712Z, countTicketsTaken=22819, countOfTicketsTakenByType={FREE_PASS=5764, ONE_DAY=5653, ONE_DAY_VIP=5703, FULL_VIP=5699}]\nStatistics[when=2021-11-14T02:29:12.769943Z, countTicketsTaken=30577, countOfTicketsTakenByType={FREE_PASS=7687, ONE_DAY=7631, ONE_DAY_VIP=7641, FULL_VIP=7618}]\nStatistics[when=2021-11-14T02:29:17.803627Z, countTicketsTaken=38146, countOfTicketsTakenByType={FREE_PASS=9553, ONE_DAY=9552, ONE_DAY_VIP=9554, FULL_VIP=9487}]\nStatistics[when=2021-11-14T02:29:22.785355Z, countTicketsTaken=45896, countOfTicketsTakenByType={FREE_PASS=11455, ONE_DAY=11497, ONE_DAY_VIP=11499, FULL_VIP=11445}]\nStatistics[when=2021-11-14T02:29:27.768809Z, countTicketsTaken=53563, countOfTicketsTakenByType={FREE_PASS=13448, ONE_DAY=13393, ONE_DAY_VIP=13386, FULL_VIP=13336}]\nStatistics[when=2021-11-14T02:29:32.739398Z, countTicketsTaken=61189, countOfTicketsTakenByType={FREE_PASS=15358, ONE_DAY=15291, ONE_DAY_VIP=15310, FULL_VIP=15230}]\nStatistics[when=2021-11-14T02:29:37.751764Z, countTicketsTaken=68758, countOfTicketsTakenByType={FREE_PASS=17214, ONE_DAY=17136, ONE_DAY_VIP=17226, FULL_VIP=17182}]\nStatistics[when=2021-11-14T02:29:42.759303Z, countTicketsTaken=76446, countOfTicketsTakenByType={FREE_PASS=19136, ONE_DAY=19057, ONE_DAY_VIP=19171, FULL_VIP=19082}]\nStatistics[when=2021-11-14T02:29:47.768858Z, countTicketsTaken=84030, countOfTicketsTakenByType={FREE_PASS=21086, ONE_DAY=20930, ONE_DAY_VIP=21062, FULL_VIP=20952}]\n« FIN » Statistics[when=2021-11-14T02:29:48.406351Z, countTicketsTaken=85000, countOfTicketsTakenByType={FREE_PASS=21321, ONE_DAY=21174, ONE_DAY_VIP=21305, FULL_VIP=21200}]\n</code></pre>\n","answer_id":69957568,"question_id":69954623,"last_edit_date":1636857098},{"owner":{"profile_image":"https://i.stack.imgur.com/5ovO7.png?s=256&g=1","account_id":9713597,"user_type":"registered","user_id":7204683,"link":"https://stackoverflow.com/users/7204683/umair","reputation":615,"display_name":"Umair","accept_rate":38},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1636835220,"creation_date":1636835220,"body":"<p>It is possible to use synchronized blocks inside a Java Lambda Expression and inside anonymous classes.</p>\n<p>Note: You have forgotten to add code snippet as no code snippet is visible in your code , So I ma adding my own code snippet to make clear my point.</p>\n<pre><code>    import java.util.function.Consumer;\n\npublic class SynchronizedExample {\n\n  public static void main(String[] args) {\n\n    Consumer&lt;String&gt; func = (String param) -&gt; {\n\n      synchronized(SynchronizedExample.class) {\n\n        System.out.println(\n            Thread.currentThread().getName() +\n                    &quot; step 1: &quot; + param);\n\n        try {\n          Thread.sleep( (long) (Math.random() * 1000));\n        } catch (InterruptedException e) {\n          e.printStackTrace();\n        }\n\n        System.out.println(\n            Thread.currentThread().getName() +\n                    &quot; step 2: &quot; + param);\n      }\n\n    };\n\n\n    Thread thread1 = new Thread(() -&gt; {\n        func.accept(&quot;Parameter&quot;);\n    }, &quot;Thread 1&quot;);\n\n    Thread thread2 = new Thread(() -&gt; {\n        func.accept(&quot;Parameter&quot;);\n    }, &quot;Thread 2&quot;);\n\n    thread1.start();\n    thread2.start();\n  }\n}\n</code></pre>\n","answer_id":69957970,"question_id":69957844},{"owner":{"profile_image":"https://i.stack.imgur.com/VlLm5.jpg?s=256&g=1","account_id":11179150,"user_type":"registered","user_id":8203686,"link":"https://stackoverflow.com/users/8203686/wangsir","reputation":374,"display_name":"wangsir"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1636815741,"creation_date":1636815741,"body":"<p>I had the same problem when using HSDB on openjdk-8. Installing lib <code>sudo apt-get install openjdk-8-dbg</code> works.</p>\n","answer_id":69955469,"question_id":49516601},{"owner":{"profile_image":"https://www.gravatar.com/avatar/1f698e72460b5a8c716a0c1cea91b81e?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":13429972,"user_type":"registered","user_id":9690075,"link":"https://stackoverflow.com/users/9690075/zysaaa","reputation":1807,"display_name":"zysaaa"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1636813384,"creation_date":1636813384,"body":"<p><code>ExecutorService</code> in Java, for example, is a producer-consumer model with a series of worker threads trying to fetch tasks from a work queue. I might close the thread pool by <code>ExecutorService#shutdownNow</code>, this method will set the thread pool state to <code>STOP</code> and interrupt each worker. Take a look at <code>shutdownNow</code> method and worker's run method(I removed the irrelevant code):</p>\n<pre><code>  public List&lt;Runnable&gt; shutdownNow() {\n            advanceRunState(STOP);\n            interruptWorkers();\n  }\n</code></pre>\n<pre><code>final void runWorker(Worker w) {\n        try {\n            while (task != null || (task = getTask()) != null) {\n                // ...\n            }\n        } \n    }\n</code></pre>\n<pre><code> private Runnable getTask() {\n        boolean timedOut = false; // Did the last poll() time out?\n        for (;;) {\n            // ...\n            // Check if queue empty only if necessary.\n            if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {\n                decrementWorkerCount();\n                return null;\n            }\n            try {\n                Runnable r = timed ?\n                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                    workQueue.take();\n                if (r != null)\n                    return r;\n                timedOut = true;\n            } \n        }\n    }\n</code></pre>\n<p>I think this is an example of using Flag &amp; interrupt to stop consumers. I don't think it's inelegant.</p>\n","answer_id":69955150,"question_id":69950945},{"owner":{"profile_image":"https://i.stack.imgur.com/9G6ke.png?s=256&g=1","account_id":439045,"user_type":"registered","user_id":827704,"link":"https://stackoverflow.com/users/827704/artyom-chernetsov","reputation":1394,"display_name":"Artyom Chernetsov","accept_rate":71},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1636774485,"creation_date":1636774485,"body":"<p>My approach would be to use framework with back-pressure mechanism support, for example <a href=\"https://vertx.io/docs/vertx-reactive-streams/java/\" rel=\"nofollow noreferrer\">vert.x reactive streams</a>.</p>\n<p>Good examples of systems handling back-pressure built on vert.x can be found in the book <a href=\"https://vertx.io/docs/vertx-reactive-streams/java/\" rel=\"nofollow noreferrer\">vert.x in action</a></p>\n","answer_id":69951248,"question_id":69950945},{"owner":{"profile_image":"https://i.stack.imgur.com/Poqe8.png?s=256&g=1","account_id":10898797,"user_type":"registered","user_id":8011734,"link":"https://stackoverflow.com/users/8011734/marwa-eltayeb","reputation":1961,"display_name":"Marwa Eltayeb"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1634784057,"creation_date":1634784057,"body":"<p>According to <strong>Google's recommendation</strong> <a href=\"https://developer.android.com/topic/performance/vitals/launch-time\" rel=\"nofollow noreferrer\">Here</a>, you <em>should not</em> prevent this white screen from launching. You can use this theme attribute to turn off the initial blank screen that the system process draws when launching the app.</p>\n<pre><code>&lt;item name=&quot;android:windowDisablePreview&quot;&gt;true&lt;/item&gt;\n</code></pre>\n<p>However, <strong>This approach is not recommended</strong> because it can result in a longer startup time than apps that don’t suppress the preview window. Also, it forces the user to wait with no feedback while the activity launches, making them wonder if the app is functioning properly.</p>\n<p>They recommend to use the activity's windowBackground theme attribute to provide a simple custom drawable for the starting activity instead of disabling the preview window.</p>\n<p>Therefore, here is the recommended solution:</p>\n<p>First, create a new drawable file for example startup_screen.xml</p>\n<pre><code> &lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:opacity=&quot;opaque&quot;&gt;\n    &lt;!-- The background color, preferably the same as normal theme --&gt;\n    &lt;item android:drawable=&quot;@android:color/white&quot;/&gt;\n    &lt;!-- Product logo - 144dp color version of App icon --&gt;\n    &lt;item&gt;\n        &lt;bitmap\n            android:src=&quot;@drawable/logo&quot;\n            android:gravity=&quot;center&quot;/&gt;\n    &lt;/item&gt;\n &lt;/layer-list&gt;\n</code></pre>\n<p>Second, reference it from your style file. If you use Night mode. Add it in both themes.xml files.</p>\n<pre><code>&lt;!-- Start Up Screen --&gt;\n&lt;style name=&quot;AppThemeLauncher&quot; parent=&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;&gt;\n     &lt;item name=&quot;android:statusBarColor&quot; tools:targetApi=&quot;l&quot;&gt;@color/lightGray&lt;/item&gt;\n     &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/startup_screen&lt;/item&gt;\n&lt;/style&gt;\n</code></pre>\n<p>If you notice, I added statusBarColor attribute to change the color of status Bar according to my custom design.</p>\n<p>Then, Add <em>AppThemeLauncher</em> Theme in your current activity.</p>\n<pre><code>&lt;activity\n    android:name=&quot;.MainActivity&quot;\n    android:theme=&quot;@style/AppThemeLauncher&quot;/&gt;\n</code></pre>\n<p>If you want to transition back to your normal theme, call setTheme(R.style.AppTheme) before calling super.onCreate() and setContentView():</p>\n<pre><code>class MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        // Make sure this is before calling super.onCreate\n        setTheme(R.style.AppTheme)\n        super.onCreate(savedInstanceState)\n        // ...\n    }\n}\n</code></pre>\n","answer_id":69655199,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/3c5fa52b5efec6532a8f33a920789d6d?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6089387,"user_type":"registered","user_id":4752240,"link":"https://stackoverflow.com/users/4752240/tuda224","reputation":1,"display_name":"tuda224"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1629096564,"creation_date":1629096564,"body":"<p>In my opinion you aren't testing a multithread scenario.</p>\n<p>You have one thread that is accessing everything one after each other. From the question I assume that this is not your intention.</p>\n<p>What I also like is using a locker object of type ReentrantLock(). Then you have a single instance of the object and lock it before the synchronized code block and you can unlock it when the work is done.</p>\n<p>Like in the following example (taken and adapted from <a href=\"https://winterbe.com/posts/2015/04/30/java8-concurrency-tutorial-synchronized-locks-examples/\" rel=\"nofollow noreferrer\">https://winterbe.com/posts/2015/04/30/java8-concurrency-tutorial-synchronized-locks-examples/</a>):</p>\n<pre><code>ReentrantLock lock = new ReentrantLock();\n\nvoid transaction(Long accountIdOne, Long accountIdTwo, int value) {\n    Account accountOne = accountRepository.findById(accountIdOne).orElseThrow();\n    Account accountTwo = accountRepository.findById(accountIdTwo).orElseThrow();\n\n    lock.lock();\n    try {\n        accountOne.withdrawal(value);\n        this.update(accountOne);\n        accountTwo.send(value);\n        this.update(accountTwo);\n    } finally {\n        lock.unlock();\n    }\n}\n</code></pre>\n","answer_id":68798496,"question_id":68791080},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG","account_id":401843,"user_type":"registered","user_id":768644,"link":"https://stackoverflow.com/users/768644/rzwitserloot","reputation":89863,"display_name":"rzwitserloot"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":true,"last_activity_date":1629077177,"creation_date":1629077177,"body":"<p>Make threads. A thousand if you want.</p>\n<p>At the CPU core level, here's what's happening:</p>\n<ul>\n<li>The CPU core is chugging along, doing work for a given websocket.</li>\n<li>Pretty soon the core runs into a road block: Half of an incoming bunch of data has arrived, the rest is still making its way down the network cable, and thus the CPU can't continue until it arrives. Alternatively, the code that the CPU core is running is sending data out, but the network card's buffer is full, so now the CPU core has to wait for that network card to find its way to sending another packet down the cable before there's room.</li>\n<li>Of course, if there's work to do (say, you have 10 cores in the box, and 15 web users are simultaneously connected, that leaves at least 5 users of your web site waiting around right now) - then the CPU should <strong>not</strong> just start twiddling its thumbs. It should go do <em>something</em>.</li>\n<li>In practice, then, there's a whole boatload of memory that WAS relevant that no longer is (all that memory that contained all that state and other 'working items' that was neccessary to do the work for the websocket that we were working on, but which is currently 'blocked' by the network), and a whole bunch of memory that wasn't relevant that now becomes relevant (All the state and working memory of a websocket connection that was earlier put in the 'have yourself a bit of a timeout and wait around for the network packet to arrive' - for which the network packet has since arrived, so if a CPU core is free to do work, it can now go do work).</li>\n<li>This is called a 'context switch', and it is <strong>ridiculously expensive</strong>, 500+ cycles worth. It is also <strong>completely unavoidable</strong>. You have to make the context switch. You can't avoid it. That means a cost is paid, and about 500 cycles worth just go down the toilet. It's what it is.</li>\n</ul>\n<p>The thing is, there are 2 ways to pay that cost: You can switch to another thread, which is all sorts of context switching. Or, you have a single thread running so-called 'async' code that manages all this stuff itself and hops to another job to do, but then there's still a context switch.</p>\n<p>Specifically, CPUs can't interact with memory at all anymore these days and haven't for the past decade. They can only interact with a CPU cache page. machine code is actually not really 'run directly' anymore, instead there's a level below that where a CPU notices it's about to run an instruction that touches some memory and will then map that memory command (after all, CPUs can no longer interact with it at all, memory is <em>far</em> too slow to wait for it) to the right spot in the cache. It'll also notice if the memory you're trying to access with your machinecode isn't in a cache page associated with that core at all, in which case it'll fire a page miss interrupt which causes the memory subsystem of your CPU/memory bus to 'evict a page' (write all back out to main memory) and then load in the right page, and only then does the CPU continue.</p>\n<p>This all happens 'under the hood', you don't have to write code to switch pages, the CPU manages it automatically. But it's a heavy cost. Not quite as heavy as a thread switch but almost as heavy.</p>\n<p><strong>CONCLUSION: Threads are good, have many of them. It ensures CPUs won't twiddle their thumbs when there is work to do. Note that there are MANY blog posts that extoll the virtues of async, claiming that threads 'do not scale'. They are wrong. Threads scale fine, and async code also pays the cost of context switching, all the time.</strong></p>\n<p>In case you weren't aware, 'async code' is code that tries to never sleep (never do something that would ever wait. So, instead of writing 'getMeTheNextBlockOfBytesFromTheNetworkCard', you'd write: &quot;onceBytesAreAvailableRunThis(code goes here)`). Writing async code in java is possible but incredibly difficult compared to using threads.</p>\n<p>Even in the extremely rare cases where async code would be a significant win, Project Loom is close to completion which will grant java the ability to have thread-like things that you can manually manage (so-called fibers). That is the route the OpenJDK has chosen for this. In that sense, even if you think async is the answer, no it's not. Wait for Project Loom to complete, instead. If you want to read more, read <a href=\"https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/\" rel=\"nofollow noreferrer\">What color is your function?</a>, and <a href=\"http://callbackhell.com\" rel=\"nofollow noreferrer\">callback hell</a>. Neither post is java-specific but covers some of the more serious problems inherent in async.</p>\n","answer_id":68796545,"question_id":68796254},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e442a53d36f9351aee11b5ecb8369691?s=256&d=identicon&r=PG","account_id":6520,"user_type":"registered","user_id":11002,"link":"https://stackoverflow.com/users/11002/tgdavies","reputation":10523,"display_name":"tgdavies","accept_rate":75},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1629062177,"creation_date":1629062177,"body":"<p>If we run the following code:</p>\n<pre><code>Account accountOneA = accountRepository.findById(1L).orElseThrow();\nAccount accountOneB = accountRepository.findById(1L).orElseThrow();\n</code></pre>\n<p>We expect that <code>accountOneA.equals(accountOneB)</code> will be true, assuming that <code>Account</code> has a sensible <code>equals()</code> implementation.</p>\n<p>We <em>don't</em> expect that <code>accountOneA == accountOneB</code> will be true, because <code>AccountRepository</code> will be creating a new object for the result of each query. We want this behaviour for thread safety, as two transactions might modify the data in different ways, to be reconciled when they try to save it.</p>\n<p>The <code>synchronized</code> keyword locks a <em>particular Object</em>, so for it to work, each thread must be synchronising using the same instance.</p>\n<p>That's why your synchronisation doesn't work.</p>\n<p>If <code>findById</code> <em>did</em> return the same instance for the same id, your code would be prone to deadlock. Imagine that one thread is transferring from account 1 to account 2, while another thread is doing the reverse, transferring from 2 to 1:</p>\n<ol>\n<li>Thread one locks account 1</li>\n<li>Thread two locks account 2</li>\n<li>Thread one tries to lock account 2, can't and waits</li>\n<li>Thread two tries to lock account1, can't and waits</li>\n</ol>\n<p>Now both threads are waiting forever.</p>\n<p>You could avoid this problem by sorting all the account numbers which are going to be locked in a given transaction, and always locking them in that order.</p>\n","answer_id":68795395,"question_id":68791080},{"owner":{"profile_image":"https://www.gravatar.com/avatar/124cda7f0e8d259e69d49ed43868639e?s=256&d=identicon&r=PG","account_id":99786,"user_type":"registered","user_id":269361,"link":"https://stackoverflow.com/users/269361/fool4jesus","reputation":2155,"display_name":"fool4jesus","accept_rate":79},"content_license":"CC BY-SA 4.0","score":4,"is_accepted":true,"last_activity_date":1629045421,"creation_date":1629045421,"body":"<p>I don't think this would compile as is. For one thing, System.out.println does not throw InterruptedException. I think you have a mistaken idea that calling threadB.interrupt() will cause threadB to throw an InterruptedException. But it won't: it will only set the interrupt flag. Remember, InterruptedException is a checked exception: it just doesn't appear out of nowhere, something has to throw it.</p>\n<p>So, leaving that aside, how close is your example to what really happens?</p>\n<p>If you need to, in general, know &quot;who set my interrupted flag&quot; I don't think there's any straightforward way to know that. If you really, really needed to know that, you could use something like Aspect4J and weave in advice on the <code>interrupt()</code> method that saves that information.</p>\n<p>But if you have more control over your code (as in the example above), the answer is to use object encapsulation and have B not directly interrupt A, but rather call a method that does. Really, I think this is better practice anyway, since it lets your own code do what it needs to do on the interrupted case. This isn't tested, but it's the idea:</p>\n<pre><code>static class MyThread extends Thread {\n  String interrupter;\n\n  public void interrupt(String interrupter) {\n    this.interrupter = interrupter;\n    super.interrupt();\n  }\n\n  public void run() {\n    while (!this.isInterrupted()) {\n      // Do the thing\n    }\n    // Here you can see who interrupted you and do whatever\n  }\n}\n</code></pre>\n","answer_id":68793486,"question_id":68784557},{"owner":{"profile_image":"https://i.stack.imgur.com/jgnbc.jpg?s=256&g=1","account_id":2174289,"user_type":"registered","user_id":1925388,"link":"https://stackoverflow.com/users/1925388/anmol-singh-jaggi","reputation":8434,"display_name":"Anmol Singh Jaggi","accept_rate":81},"content_license":"CC BY-SA 4.0","score":8,"is_accepted":false,"last_activity_date":1629042563,"creation_date":1620486781,"body":"<p>The <a href=\"https://stackoverflow.com/a/63365785/1925388\">other answer</a> works fine but is too complicated.</p>\n<p>A simpler way is to just execute <a href=\"https://en.wikipedia.org/wiki/Topological_sorting#Kahn%27s_algorithm\" rel=\"noreferrer\">Kahn's algorithm</a> but in parallel.</p>\n<p>The key is to execute all the tasks in parallel for whom all dependencies have been executed.</p>\n<pre><code>import java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n\nclass DependencyManager {\nprivate final ConcurrentHashMap&lt;String, List&lt;String&gt;&gt; _dependencies = new ConcurrentHashMap&lt;&gt;();\nprivate final ConcurrentHashMap&lt;String, List&lt;String&gt;&gt; _reverseDependencies = new ConcurrentHashMap&lt;&gt;();\nprivate final ConcurrentHashMap&lt;String, Runnable&gt; _tasks = new ConcurrentHashMap&lt;&gt;();\nprivate final ConcurrentHashMap&lt;String, Integer&gt; _numDependenciesExecuted = new ConcurrentHashMap&lt;&gt;();\nprivate final  AtomicInteger _numTasksExecuted = new AtomicInteger(0);\nprivate final ExecutorService _executorService = Executors.newFixedThreadPool(16);\n\nprivate static Runnable getRunnable(DependencyManager dependencyManager, String taskId){\n    return () -&gt; {\n    try {\n        Thread.sleep(2000);  // A task takes 2 seconds to finish.\n        dependencyManager.taskCompleted(taskId);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    };\n}\n\n/**\n* In case a vertex is disconnected from the rest of the graph.\n* @param taskId The task id\n*/\npublic void addVertex(String taskId) {\n    _dependencies.putIfAbsent(taskId, new ArrayList&lt;&gt;());\n    _reverseDependencies.putIfAbsent(taskId, new ArrayList&lt;&gt;());\n    _tasks.putIfAbsent(taskId, getRunnable(this, taskId));\n    _numDependenciesExecuted.putIfAbsent(taskId, 0);\n}\n\nprivate void addEdge(String dependentTaskId, String dependeeTaskId) {\n    _dependencies.get(dependentTaskId).add(dependeeTaskId);\n    _reverseDependencies.get(dependeeTaskId).add(dependentTaskId);\n}\n\npublic void addDependency(String dependentTaskId, String dependeeTaskId) {\n    addVertex(dependentTaskId);\n    addVertex(dependeeTaskId);\n    addEdge(dependentTaskId, dependeeTaskId);\n}\n\nprivate void taskCompleted(String taskId) {\n    System.out.println(String.format(&quot;%s:: Task %s done!!&quot;, Instant.now(), taskId));\n    _numTasksExecuted.incrementAndGet();\n    _reverseDependencies.get(taskId).forEach(nextTaskId -&gt; {\n        _numDependenciesExecuted.computeIfPresent(nextTaskId, (__, currValue) -&gt; currValue + 1);\n        int numDependencies = _dependencies.get(nextTaskId).size();\n        int numDependenciesExecuted = _numDependenciesExecuted.get(nextTaskId);\n        if (numDependenciesExecuted == numDependencies) {\n        // All dependencies have been executed, so we can submit this task to the threadpool. \n            _executorService.submit(_tasks.get(nextTaskId));\n        }\n        });\n    if (_numTasksExecuted.get() == _tasks.size()) {\n        topoSortCompleted();\n    }\n}\n\nprivate void topoSortCompleted() {\n    System.out.println(&quot;Topo sort complete!!&quot;);\n    _executorService.shutdownNow();\n}\n\npublic void executeTopoSort() {\n    System.out.println(String.format(&quot;%s:: Topo sort started!!&quot;, Instant.now()));\n    _dependencies.forEach((taskId, dependencies) -&gt; {\n    if (dependencies.isEmpty()) {\n        _executorService.submit(_tasks.get(taskId));\n    }\n    });\n}\n}\n\npublic class TestParallelTopoSort {\n\npublic static void main(String[] args) {\n    DependencyManager dependencyManager = new DependencyManager();\n    dependencyManager.addDependency(&quot;8&quot;, &quot;5&quot;);\n    dependencyManager.addDependency(&quot;7&quot;, &quot;5&quot;);\n    dependencyManager.addDependency(&quot;7&quot;, &quot;6&quot;);\n    dependencyManager.addDependency(&quot;6&quot;, &quot;3&quot;);\n    dependencyManager.addDependency(&quot;6&quot;, &quot;4&quot;);\n    dependencyManager.addDependency(&quot;5&quot;, &quot;1&quot;);\n    dependencyManager.addDependency(&quot;5&quot;, &quot;2&quot;);\n    dependencyManager.addDependency(&quot;5&quot;, &quot;3&quot;);\n    dependencyManager.addDependency(&quot;4&quot;, &quot;1&quot;);\n    dependencyManager.executeTopoSort();\n    // Parallel version takes 8 seconds to execute.\n    // Serial version would have taken 16 seconds.\n\n}\n}\n</code></pre>\n<p>The Directed Acyclic Graph constructed in this example is this:</p>\n<p><a href=\"https://i.stack.imgur.com/ZBDTT.jpg\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/ZBDTT.jpg\" alt=\"Directed Acyclic Graph\" /></a></p>\n","answer_id":67449067,"question_id":63354899,"last_edit_date":1629042563},{"owner":{"profile_image":"https://i.stack.imgur.com/Klcqr.gif?s=256&g=1","account_id":292208,"user_type":"registered","user_id":2245707,"link":"https://stackoverflow.com/users/2245707/pveentjer","reputation":10665,"display_name":"pveentjer","accept_rate":17},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1629015407,"creation_date":1629014278,"body":"<p>The problem is that within a single JVM you have very little control on how much memory a single thread is going to use; unless you make use of offheap (e.g. using Unsafe or direct memory as AnatolyG already mentioned). If you have huge array allocations, you could also control these. But we need to know more about the data-structures that consume the most memory.</p>\n<p>But if you have orbitrary object graphs you don't have much control over, perhaps it smarter to model the problem using multiple processes. You have 1 intake controller process and then a bunch of worker processes. And on each process you can configure the maximum amount of heap a JVM is allowed to use.</p>\n<p>Bumping into memory limits on OS level can be a huge PITA because it could lead to swapping and this will makes all the threads in a system slow. Or even worse, OOM-killer. Make sure you set the vm.swappiness to a very low value to prevent premature swapping.</p>\n<p>Do you know up front how much memory a process is going to consume? If so, then you could keep track of the maximum amount of memory being consumed in the system and don't allow for new tasks in the system before tasks have completed.</p>\n<p>If you don't know up front the memory limits, then you could assume each tasks will use the maximum, but this can lead to under-utilization of memory.</p>\n","answer_id":68789701,"question_id":68746177,"last_edit_date":1629015407},{"owner":{"profile_image":"https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG","account_id":47283,"user_type":"registered","user_id":139985,"link":"https://stackoverflow.com/users/139985/stephen-c","reputation":703927,"display_name":"Stephen C","accept_rate":69},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1629002962,"creation_date":1629002962,"body":"<p>@rzwitserloot's <a href=\"https://stackoverflow.com/a/68785361/139985\">answer</a> covers just about everything.  (And what he says about correctness ... is correct.)</p>\n<p>The reason why <code>sleep()</code> or <code>println()</code> calls change the behavior is that they have undocumented (serendipitous) effects on the memory cache flushing behavior.</p>\n<p>In the case of <code>println</code>, the current implementation of the output stream stack involves calls to internal synchronized methods.  This is apparently sufficient to cause your flag's change in value to be visible to the second thread.</p>\n<p>In the case of <code>sleep</code>, the call causes the current thread's state to be saved to memory so that execution can switch to a different thread.</p>\n<p>But in either case, your modified code is &quot;working&quot; because of <em>undocumented</em> behavior.  This behavior could change between different Java versions, across different hardware or OS platforms and so on.</p>\n","answer_id":68788797,"question_id":68785125},{"owner":{"profile_image":"https://i.stack.imgur.com/Klcqr.gif?s=256&g=1","account_id":292208,"user_type":"registered","user_id":2245707,"link":"https://stackoverflow.com/users/2245707/pveentjer","reputation":10665,"display_name":"pveentjer","accept_rate":17},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1629002343,"creation_date":1628998377,"body":"<p>Your code is not working correctly because you are violating the Java Memory model (JMM). The problem with your code is that a happens-before edge is missing between the write of the 'flag' and the read of 'flag' and as a consequence your code is suffering from a data race. When there is a data-race, you can get unexpected behavior. Luckily it is better defined than a data-race with C++ where it can lead to undefined behavior.</p>\n<p>The compiler is the typical component that will break this  example. It could transform your code into:</p>\n<pre><code>if(!flag) return;\n\nwhile(true){\n   ...\n}\n</code></pre>\n<p>There is no point in checking flag in the loop if inside the loop the flag isn't changed. This optimization is called loop-invariant code-motion or hoisting. If you would make the flag field volatile, then happens-before edge between the write and the read will exist and the compiler can't apply optimize out the read. Instead it needs to read the flag from 'shared memory' (this include reading it from the coherent CPU cache).</p>\n<p>Please do not think that volatile forces flushing to main memory and writing from main memory. Main memory is just a spill bucket for whatever doesn't fit into the CPU cache. Caches on modern CPU's are always coherent. If for every volatile read/write you would need to access main memory, concurrent programs would become very slow. In most cases a volatile read/write can be resolved locally if there is no read/write miss and no cache coherence traffic with other CPU's or main memory is needed. The main 'flushing' that needs to be done to preserve ordering between loads and stores is that loads need to wait for the stores in the store buffer to drain; but this is before the store hits the cache. And even 'flushing' here is an inappropriate term since the store buffer is already draining to the cache as fast as possible.</p>\n<p>Also do not believe that volatile prevents using registers in the CPU; modern processors are all load-store architectures which mean that there are separate load/store instructions that load/store from memory into a register and most normal instructions like those executed by the ALUs can only deal with registers and do not have the ability to access memory. Even the X86 which from the outside if a register-memory architecture, after uops conversion becomes a load-store architecture. So registers are always used; the key part is how often registers needs to be synchronized with the cache.</p>\n<p>Apart from that, the JMM isn't defined in terms of registers and flushing to main memory, so it isn't a suitable mental model.</p>\n","answer_id":68788509,"question_id":68785125,"last_edit_date":1629002343},{"owner":{"profile_image":"https://i.stack.imgur.com/ZWEI3.jpg?s=256&g=1","account_id":322981,"user_type":"registered","user_id":642706,"link":"https://stackoverflow.com/users/642706/basil-bourque","reputation":310755,"display_name":"Basil Bourque","accept_rate":58},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":true,"last_activity_date":1628973041,"creation_date":1628969057,"body":"<h1>tl;dr</h1>\n<p>Do not bother trying to optimize a sub-second operation executed occasionally.</p>\n<h1>Details</h1>\n<p>You may have fallen into the trap known as <em>premature optimization</em>.</p>\n<p>I created two Java 16+ <a href=\"https://openjdk.java.net/jeps/395\" rel=\"nofollow noreferrer\">records</a> for your <code>Human</code> and <code>HumanInfo</code> classes.</p>\n<pre class=\"lang-java prettyprint-override\"><code>package work.basil.creation;\n\npublic record Human( String name , double height , double weight ) { }\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>package work.basil.creation;\n\npublic record HumanInfo( String name , double height ) {\n    public HumanInfo ( Human human ) {\n        this( human.name() , human.height() );\n    }\n}\n</code></pre>\n<p>Then I wrote this app to populate sample data of a million objects, followed by transcoding those objects from <code>Human</code> to <code>HumanInfo</code>.</p>\n<pre class=\"lang-java prettyprint-override\"><code>package work.basil.creation;\n\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class App {\n    public static void main ( String[] args ) {\n        App app = new App();\n        int limit = 1_000_000;\n        List &lt; Human &gt; humans = app.populateSampleData( limit );\n        List &lt; HumanInfo &gt; humanInfos = app.transcodeToHumanInfo( humans );\n    }\n\n    private List &lt; HumanInfo &gt; transcodeToHumanInfo ( final List &lt; Human &gt; humans ) {\n        Instant start = Instant.now();  // Benchmarking.\n        List &lt; HumanInfo &gt; humanInfos = humans.stream().map( human -&gt; new HumanInfo( human ) ).toList();\n        System.out.println( &quot;transcodeToHumanInfo  elapsed = &quot; + Duration.between( start , Instant.now() ) );\n        for ( int i = 0 ; i &lt; 10 ; i++ ) {\n            System.out.println( humanInfos.get( i ) );\n        }\n        return humanInfos;\n    }\n\n    private List &lt; Human &gt; populateSampleData ( final int limit ) {\n        List &lt; Human &gt; humans = new ArrayList &lt;&gt;( limit );\n        Instant start = Instant.now();\n        for ( int i = 0 ; i &lt; limit ; i++ ) {\n            humans.add( new Human( UUID.randomUUID().toString() , ThreadLocalRandom.current().nextDouble( 145d , 185d ) , ThreadLocalRandom.current().nextDouble( 45d , 90d ) ) );\n        }\n\n        // Dump to console.\n        System.out.println( &quot;populateSampleData elapsed = &quot; + Duration.between( start , Instant.now() ) );\n        for ( int i = 0 ; i &lt; 10 ; i++ ) {\n            System.out.println( humans.get( i ) );\n        }\n        return humans;\n    }\n}\n</code></pre>\n<p>In my experiments, I changed the <code>.stream</code> to <code>.parallelStream</code>. I ran each several times, always ignoring the first run. Results were quite consistent.</p>\n<p>I am running on <a href=\"http://jdk.java.net/17/\" rel=\"nofollow noreferrer\">early-access Java 17</a> optimized for Apple Silicon (not Intel) on my MacBook Pro (13-inch, M1, 2020) with 16 gigs of memory with macOS Big Sur 11.5.1, with 8 (4 performance and 4 efficiency) cores.</p>\n<h2>0.01x seconds</h2>\n<p>Results:</p>\n<ul>\n<li>Transcoding a <em><strong>million objects takes a hundredth of a second</strong></em> without concurrency. So no practical point in trying to improve on that.</li>\n<li>Changing that code from <code>.stream</code> to <code>.parallelStream</code> takes three times longer. Running concurrently <em>costs</em> you time rather than saving you time.</li>\n</ul>\n<p>Some arbitrarily selected run numbers.</p>\n<div class=\"s-table-container\">\n<table class=\"s-table\">\n<thead>\n<tr>\n<th style=\"text-align: right;\"><code>.stream</code></th>\n<th style=\"text-align: right;\"><code>.parallelStream</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: right;\">PT0.013089S<br />PT0.019682S<br />PT0.018813S</td>\n<td style=\"text-align: right;\">PT0.044404S<br />PT0.043849S<br />PT0.042643S</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>You asked:</p>\n<blockquote>\n<p>Is there a reason why multithreading does not help here?</p>\n</blockquote>\n<p>Because multithreading and concurrency are not magic, there is a cost, an <a href=\"https://en.wikipedia.org/wiki/Overhead_(business)\" rel=\"nofollow noreferrer\">“overhead”</a>. Setting up the threads, scheduling their execution times, coordinating their work, and collecting the results are all work that takes time to execute.</p>\n<p>When choosing to parallelize, you must consider the costs versus the benefits. This calculation should include some concrete evidence such as micro-benchmarking, as programmers are notoriously bad at guesstimating bottlenecks and optimizations.</p>\n","answer_id":68786399,"question_id":68786081,"last_edit_date":1628973041},{"owner":{"profile_image":"https://lh4.googleusercontent.com/-xIoh0ve8hKc/AAAAAAAAAAI/AAAAAAAAAEw/lmhFmElveRY/photo.jpg?sz=256","account_id":10125444,"user_type":"registered","user_id":7480973,"link":"https://stackoverflow.com/users/7480973/zachary-sang","reputation":17,"display_name":"Zachary Sang"},"content_license":"CC BY-SA 4.0","score":-1,"is_accepted":false,"last_activity_date":1628968867,"creation_date":1628959827,"body":"<blockquote>\n<p>Why fct.isFlag() in the while loop of main thread can't get the latest value without some sleep?</p>\n</blockquote>\n<p>I believe that what is happening here is that without the <code>Thread.sleep(1)</code> you have a tight loop (<a href=\"https://stackoverflow.com/a/2212986/7480973\">relevant definition</a>). This means means that the main thread is not getting the latest value because it is using the cached value (as you said also fixable by making the flag valuable volatile).</p>\n<p>When the <code>Thread.sleep()</code> is added, the tight loop is broken since this moves the thread out of the <code>Runnable</code> state. When a thread moves out of the <code>Runnable</code> state, it is moved off of the CPU. when resuming from <code>Thread.sleep()</code>, the CPU cached value are reloaded from memory, which gives the freshest flag value.</p>\n","answer_id":68785320,"question_id":68785125,"last_edit_date":1628968867},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG","account_id":401843,"user_type":"registered","user_id":768644,"link":"https://stackoverflow.com/users/768644/rzwitserloot","reputation":89863,"display_name":"rzwitserloot"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1628960158,"creation_date":1628960158,"body":"<p>The reason is The Evil Coin.</p>\n<p>The specification that is relevant here is the Java Memory Model (JMM).</p>\n<p>The JMM has the following aspect to it:</p>\n<p><strong>Any thread is free to make a local cached copy of a variable, or not, and may refer, according to its whims and the phase of the moon if it wants, to either that copy or not.</strong></p>\n<p>In other words, the thread flips a coin to decide what to do. It is evil, in that it won't flip heads/tails at a roughly 50/50 split. Assume it flips coins to mess with you: It works great for an hour or so, and then all of a sudden it starts failing when you pick up the work again tomorrow morning, and you have no idea what happened.</p>\n<p>Thus, in some of your invocations, that boolean field you're looking at is getting cached copies.</p>\n<p>Said differently:</p>\n<p><strong>If multiple threads are working with the same field, the behaviour of your application is undefined unless you establish HB/HA</strong>.</p>\n<p>The reason it works in this bizarre fashion is speed: Any other definition would mean a JVM has to run code a few orders of magnitude more slowly.</p>\n<p>The solution is to establish HB/HA: Happens-Before/Happens-After relationships.</p>\n<p>HB/HA works like this: If there is an HB/HA relationship between 2 lines of code, then it is impossible to observe the state as it was <strong>before</strong> the Happens-Before line ran, from the Happens-After line. In other words, if a field has value '5' before the HB line, and value '7' after the 'HB' line, then the HA line cannot possibly observe 5. It can observe 7, or some update that occurred afterwards.</p>\n<p>The spec lists a bunch of things that establish HB/HA:</p>\n<ul>\n<li>Any access to <code>volatile</code> fields. You can try that right now: Make that field <code>volatile</code>, it'll 'fix' it.</li>\n<li>The exiting of a <code>synchronized(x)</code> block is HB vs. entering a <code>synchronized(theSameX)</code> block in another thread (if that entering that block actually happens afterwards, of course).</li>\n<li>The <code>t.start()</code> method is HB relative to the first line in the <code>run()</code> of the thread you started.</li>\n<li>Within one thread, any line of code that is run before any other is HB (that's the trivial case).</li>\n</ul>\n<p>Some things within the JVM use this stuff.</p>\n<p>Tips:</p>\n<ul>\n<li>Generally, use stuff from the <code>java.util.concurrent</code> package.</li>\n<li>Try to avoid interacting with the same field from different threads.</li>\n<li>Consider databases or message queues or other systems with less finicky rules about inter-thread communications.</li>\n<li>If writing to fields that other threads are supposed to read, you <strong>must</strong> consider HB/HA.</li>\n<li>None of this is a guarantee. <strong>You can write broken code that nevertheless passes all tests today, and tomorrow, and next week, and on the production machine, but fails next month when you're giving that important demo to the big customer</strong>. Hence, <strong>here be dragons</strong>: If you mess, you may not know until the cost the bug imposes on you has ballooned out of control. Thus, avoid this stuff unless you really, really, really know what you are doing.</li>\n</ul>\n","answer_id":68785361,"question_id":68785125},{"owner":{"profile_image":"https://www.gravatar.com/avatar/d6d4c4b8d52a51d9f7f64c1e5f2de0b3?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":4569994,"user_type":"registered","user_id":3709922,"link":"https://stackoverflow.com/users/3709922/jignesh-m-khatri","reputation":1447,"display_name":"Jignesh M. Khatri","accept_rate":33},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1628930828,"creation_date":1628789462,"body":"<p>Here is the one of the solution to solve the given problem. It uses <code>wait</code> to wait the current thread after printing one letter and <code>notify</code> the other thread to print its letter, and same cycle repeats. The concept of Thread <code>wait</code> and <code>notify</code> is very well explained <a href=\"https://stackoverflow.com/a/13664082/3709922\">here</a>.</p>\n<p><strong>Short description:</strong></p>\n<p>To <code>wait</code> or <code>notify</code> any thread, it (invoking thread) must acquire the lock on any common object. In below example, each thread is acquiring the lock on <code>this</code> (self) (via synchronized <code>run</code> method) to <code>wait</code> and on <code>opponent</code> to notify it (the another thread).</p>\n<pre><code>public class App implements Runnable {\n    char c;\n    App opponent;\n    boolean go;\n\n    public App(char c, boolean go) {\n        this.c = c;\n        this.go = go;\n    }\n\n    public void setOpponent(App opponent) {\n        this.opponent = opponent;\n    }\n\n    public static void main(String[] args) {\n        App a = new App('a', true);\n        App b = new App('A', false);\n\n        Thread t1 = new Thread(a);\n        Thread t2 = new Thread(b);\n\n        a.setOpponent(b);\n        b.setOpponent(a);\n\n        t1.start();\n        t2.start();\n    }\n\n    @Override\n    public synchronized void run() {\n        for (char i = 0; i &lt; 26; i++) {\n\n            try {\n                if (go) {\n                    System.out.println(c++);\n                    this.wait();\n                    synchronized (opponent) {\n                        opponent.notify();\n                    }\n                } else {\n                    System.out.println(c++);\n                    synchronized (opponent) {\n                        opponent.notify();\n                    }\n                    this.wait();\n                }\n\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre>\n<p>Here is the more simplified and understandable version of above code. In this code, both the threads are acquiring lock on same <code>lock</code> object, printing the letter, going in <code>WAIT</code> state (so release the lock) and giving turn to other <code>BLOCKED</code> thread waiting for the lock on <code>lock</code>. The other thread then acquires the lock on <code>lock</code>, prints the letter, notifies the previous thread which was waiting on <code>lock</code> object, and goes into <code>WAIT</code> condition, thus releasing the lock.</p>\n<pre><code>public class App2 implements Runnable {\n    char c;\n    Object lock;\n    boolean go;\n\n    public App2(char c, boolean go) {\n        this.c = c;\n        this.go = go;\n    }\n\n    public void setLock(Object lock) {\n        this.lock = lock;\n    }\n\n    public static void main(String[] args) {\n        App2 a = new App2('a', true);\n        App2 b = new App2('A', false);\n\n        Thread t1 = new Thread(a);\n        Thread t2 = new Thread(b);\n\n        Object lock = new Object();\n\n        a.setLock(lock);\n        b.setLock(lock);\n\n        t1.start();\n        t2.start();\n    }\n\n    @Override\n    public void run() {\n\n        for (char i = 0; i &lt; 26; i++) {\n            synchronized (lock) {\n                try {\n                    if (go) {\n                    \n                        System.out.println(c++);\n                        lock.wait();\n                        lock.notify();\n                    \n                    } else {\n                    \n                        System.out.println(c++);\n                        lock.notify();\n                        lock.wait();\n                    \n                    }\n                } catch (InterruptedException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<p><strong>UPDATE:</strong></p>\n<p>Above two approaches will work in most of the cases, but will not guarantee that <code>t1</code> will be executed before <code>t2</code> every time. Though <code>t1</code> is started before <code>t2</code>, but it does not mean that thread scheduler will always pick <code>t1</code> to execute before <code>t2</code>. To be sure that <code>t1</code> will execute before <code>t2</code> in every case, we need to ensure that <code>t2</code> gets started once <code>t1</code> is in <code>RUNNABLE</code> state (i.e. running). Below is the one of the way of how we can achieve it:</p>\n<pre><code>public class App3 implements Runnable {\n    char c;\n    App3 opponent;\n    boolean go;\n    boolean createOpponent = false;\n\n    public App3(char c, boolean go) {\n        this.c = c;\n        this.go = go;\n    }\n\n    public void setOpponent(App3 opponent) {\n        this.opponent = opponent;\n    }\n\n    public void setCreateOpponent(boolean createOpponent) {\n        this.createOpponent = createOpponent;\n    }\n\n    public static void main(String[] args) {\n        App3 a = new App3('a', true);\n        App3 b = new App3('A', false);\n\n        Thread t1 = new Thread(a);\n\n        a.setOpponent(b);\n        a.setCreateOpponent(true);\n\n        b.setOpponent(a);\n\n        t1.start();\n    }\n\n    @Override\n    public synchronized void run() {\n        if (createOpponent) {\n            setCreateOpponent(false);\n            new Thread(opponent).start();\n        }\n        for (char i = 0; i &lt; 26; i++) {\n\n            try {\n                if (go) {\n                    System.out.println(c++);\n                    this.wait();\n                    synchronized (opponent) {\n                        opponent.notify();\n                    }\n                } else {\n                    System.out.println(c++);\n                    synchronized (opponent) {\n                        opponent.notify();\n                    }\n                    this.wait();\n                }\n\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre>\n","answer_id":68761907,"question_id":68760729,"last_edit_date":1628930828},{"owner":{"profile_image":"https://lh3.googleusercontent.com/-2DggdTBjTSg/AAAAAAAAAAI/AAAAAAAAKRk/8QidWyLl7Xk/photo.jpg?sz=256","account_id":460635,"user_type":"registered","user_id":4807449,"link":"https://stackoverflow.com/users/4807449/ronnie-horo","reputation":11,"display_name":"Ronnie Horo"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1628796881,"creation_date":1628796420,"body":"<p>Hope this helps...</p>\n<pre><code>public class ABCThread implements Runnable {\n    char c;\n    boolean flag;\n\n    public ABCThread(char c, boolean flag) {\n        this.c = c;\n        this.flag = flag;\n    }\n\n    @Override\n    public synchronized void run() {\n        for (char i = 0; i &lt; 52; i++) {\n            try {\n                if (flag) {\n                    System.out.println(c++);\n                    notifyAll();\n                    flag = false;\n                    wait(100);\n                } else {\n                    flag = true;\n                    wait(100);\n                }\n\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n\n        Thread t1 = new Thread(new ABCThread('a', true));\n        Thread t2 = new Thread(new ABCThread('A', false));\n\n        t1.start();\n        t2.start();\n\n    }\n}\n</code></pre>\n<p>or you can define separate methods for printing small and capital letters and run them in two separate threads</p>\n<pre><code>public class ABCThread {\n\n    boolean flag;\n\n    public ABCThread(boolean flag) {\n        this.flag = flag;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n\n        ABCThread abc = new ABCThread(false);\n\n        Thread t1 = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                try {\n                    abc.printSmallLetters();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n            }\n        });\n        Thread t2 = new Thread(new Runnable() {\n            public void run() {\n                try {\n                    abc.printCapitalLetters();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n\n        t1.start();\n        t2.start();\n\n    }\n\n    synchronized void printSmallLetters() throws InterruptedException {\n        for (char i = 'a'; i &lt; 'z'; i++) {\n            while (flag == true) {\n                wait();\n            }\n            System.out.println(i);\n            notifyAll();\n            flag = true;\n        }\n    }\n\n    synchronized void printCapitalLetters() throws InterruptedException {\n        for (char i = 'A'; i &lt; 'Z'; i++) {\n            while (flag == false) {\n                wait();\n            }\n            System.out.println(i);\n            notifyAll();\n            flag = false;\n        }\n    }\n}\n\n</code></pre>\n","answer_id":68763152,"question_id":68760729,"last_edit_date":1628796881},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b46fd0a429838cd67ea0650e953899be?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":22447688,"user_type":"registered","user_id":16651360,"link":"https://stackoverflow.com/users/16651360/marco","reputation":54,"display_name":"Marco"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1628795492,"creation_date":1628785297,"body":"<p><strong>Quick answer:</strong></p>\n<p>You can't force a thread to run at a certain moment. What you can do though is let those two run &quot;out of sync&quot; (not related to async coding).</p>\n<pre><code>Thread t1 = new Thread(new ABCThread('a'));\nThread.sleep(250);\nThread t2 = new Thread(new ABCThread('A'));\n</code></pre>\n<p>The 1st thread will print about every 500 ms and the 2nd thread will print at 250, 750, 1250, etc.\nNote that this would not be a correct way to solve this in real programs. But then again, you would also likely not add <code>Thread.sleep(500)</code> to the run method.</p>\n<p><strong>Better:</strong></p>\n<p>You need synchronization between the threads. Because you start two threads you can use a boolean.</p>\n<pre><code>public class ABCThread implements Runnable {\nchar c;\nstatic boolean synchronizer = false;\nboolean runOn;\n\npublic ABCThread(char c, boolean runOn) {\n    this.c = c;\n    this.runOn = runOn;\n}\n\n@Override\npublic synchronized void run() {\n    int count = 0;\n    while(count &lt; 26)\n    {\n        if(runOn != synchronizer) \n        {\n           Thread.sleep(100);\n           continue;\n        }\n        count++;\n        synchronizer = !synchronizer;\n        System.out.println(c++);\n        \n    }\n\n}\n\n    Thread t1 = new Thread(new ABCThread('a', false));\n    Thread t2 = new Thread(new ABCThread('A', true));\n</code></pre>\n<p>Just typing this out. It might not compile.\n<code>Thread.sleep(100)</code> is just some number. It could possibly be lower, but doesn't matter much for the question.</p>\n<p><strong>Even better</strong>\nThe previous code can run with only 2 threads! 1 will just stay stuck with synchronizer = false. If you add a third then the synchronizer won't work because it only has 2 states.\nYou could add an integer instead of the boolean and another integer amountOfThreads. The amountOfThreads will need to be set to the amount of threads you will start up. Then increase the atomic integer when the thread prints and if the synchronizer (the atomic int) is more than amountOfThreads, set it to 0.</p>\n","answer_id":68761029,"question_id":68760729,"last_edit_date":1628795492},{"owner":{"profile_image":"https://i.stack.imgur.com/PMmwr.jpg?s=256&g=1","account_id":4483794,"user_type":"registered","user_id":3647105,"link":"https://stackoverflow.com/users/3647105/liem-le","reputation":581,"display_name":"Liem Le"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1628788395,"creation_date":1628787663,"body":"<h1>What you need? A &quot;shared resource&quot; between threads.</h1>\n<h1>Further: A synchronous FSM (Finite state machine)</h1>\n<p>Below is code that demonstrated how to achieve that.</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class Main\n{\n    // The shared resource\n    public static class State {\n        \n        private int val;\n        private int nStates;\n\n        // Init value and number of states.\n        public State(int init, int nStates) {\n            this.val = init;\n            this.nStates = nStates;\n        }\n        \n        int get() {\n            return val;\n        }\n        // Define how to get to next state. For simple use case, just increase then modulo it. eg: 0, 1, 0, 1\n        // Avoid modulo in-case you need very very high performance.\n        void next() {\n            this.val = (this.val + 1) % nStates;\n        }\n    }\n    \n    public static class ABCThread implements Runnable{\n        private char c;\n        private State s;\n        private int type;\n        public ABCThread(char c, State s, int type) {\n            this.c = c;\n            this.s = s;\n            this.type = type;\n        }\n\n        @Override\n        public void run() {\n            try {\n            for (char i = 0; i &lt; 26; i++) {\n                // Do things synchronously\n                synchronized(s){\n                    while(s.get() != type) {\n                        // Wait for our turn.\n                        s.wait();\n                    }\n                    System.out.print(c++);\n                    // Update state\n                    s.next();\n                    // Notify to other threads to do their job.\n                    s.notifyAll();\n                }\n            }\n            }catch(Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n\n        // Define the state.\n        State s = new State(0, 2);\n\n\n        /* Uncomment this block to have 3 synchronous threads. Will print aA1bB2...\n        s = new State(0, 3);\n        Thread t3 = new Thread(new ABCThread('1', s, 2));\n        t3.start();\n        t3.join();\n        */\n        Thread t1 = new Thread(new ABCThread('a', s, 0));\n        Thread t2 = new Thread(new ABCThread('A', s, 1));\n\n\n        // Start threads\n        t1.start();\n        t2.start();\n        // Wait for these threads to finish before exit.\n        t1.join();\n        t2.join();\n    }\n}\n</code></pre>\n","answer_id":68761559,"question_id":68760729,"last_edit_date":1628788395},{"owner":{"profile_image":"https://www.gravatar.com/avatar/780a651189f64a2cbf4b7f62cf852005?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":7178634,"user_type":"registered","user_id":5483526,"link":"https://stackoverflow.com/users/5483526/matt-timmermans","reputation":55168,"display_name":"Matt Timmermans"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1628788097,"creation_date":1628787632,"body":"<p>You're supposed to use a <code>boolean</code> to control which thread prints:</p>\n<ol>\n<li>Thread 1 waits for the boolean to be false.  Then it prints and sets it true.</li>\n<li>Thread 2 waits for the boolean to be true.  Then it prints and sets it false.</li>\n</ol>\n<p>In this way, the threads will alternate.  Also, all of this will be much faster if you use signaling between threads instead of <code>sleep</code>:</p>\n<pre><code>import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class ABCThread implements Runnable {\n    static Object monitor = new Object();\n    static boolean turn = false;\n    \n    char c;\n    final boolean myTurn;\n\n    public ABCThread(char c, boolean myTurn) {\n        this.c = c;\n        this.myTurn = myTurn;\n    }\n\n    @Override\n    public void run() {\n\n        for (char i = 0; i &lt; 26; i++) {\n            synchronized(monitor) {\n                while (turn != myTurn) {\n                    try {\n                        // Note that the lock is release while I'm waiting,\n                        // So the other thread can claim it here.\n                        monitor.wait();\n                    } catch (Exception e) {\n                    }\n                }\n                System.out.println(c++);\n                turn = !myTurn;\n                monitor.notifyAll();\n            }\n        }\n\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n\n        Thread t1 = new Thread(new ABCThread('a', false));\n        Thread t2 = new Thread(new ABCThread('A', true));\n\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n\n    }\n}\n</code></pre>\n","answer_id":68761547,"question_id":68760729,"last_edit_date":1628788097},{"owner":{"profile_image":"https://lh3.googleusercontent.com/a-/AOh14GiYf8V11zSxXD852Bjjc3hlT1M4SpB5HMHFzJY5nw=k-s256","account_id":22446598,"user_type":"registered","user_id":16650432,"link":"https://stackoverflow.com/users/16650432/rakshith-b-s","reputation":45,"display_name":"Rakshith B S"},"content_license":"CC BY-SA 4.0","score":-1,"is_accepted":false,"last_activity_date":1628787861,"creation_date":1628784544,"body":"<p><img src=\"https://i.stack.imgur.com/qzP5C.png\" alt=\"output\" /></p>\n<p>just replace the println by print to get a series output like this\nother than that everything seems to be fine,\nyou can see the output i got in the screenshot above</p>\n","answer_id":68760859,"question_id":68760729,"last_edit_date":1628787861},{"owner":{"profile_image":"https://www.gravatar.com/avatar/3e4be83fe4b3ea871e3595d80172f118?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":19042414,"user_type":"registered","user_id":13902217,"link":"https://stackoverflow.com/users/13902217/jeka-fri","reputation":71,"display_name":"Jeka_FRI"},"content_license":"CC BY-SA 4.0","score":-2,"is_accepted":false,"last_activity_date":1628785755,"creation_date":1628784988,"body":"<p>No way. The order of execution of threads cannot be controlled).You can use Thread.yield(). But yield () - tries to tell the scheduler to execute the next thread, but it stays in the RUNNABLE state.</p>\n","answer_id":68760956,"question_id":68760729,"last_edit_date":1628785755},{"owner":{"profile_image":"https://www.gravatar.com/avatar/fed094516f56f32f79436c3bba9ff71b?s=256&d=identicon&r=PG","account_id":3087422,"user_type":"registered","user_id":2614310,"link":"https://stackoverflow.com/users/2614310/arvind-kumar","reputation":509,"display_name":"Arvind Kumar","accept_rate":14},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1627448454,"creation_date":1627448454,"body":"<p><strong>1st  Use case</strong> - Per thread context which gives thread safety as well as performance\nReal-time example in SpringFramework classes -</p>\n<ul>\n<li>LocaleContextHolder</li>\n<li>TransactionContextHolder</li>\n<li>RequestContextHolder</li>\n<li>DateTimeContextHolder</li>\n</ul>\n<p><strong>2nd Use case</strong> - When we don't want to share something among threads and at the same time don't want to use synchronize/lock due to performance cost\nexample - SimpleDateFormat to create the custom format for dates</p>\n<pre><code>import java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n/**\n * @author - GreenLearner(https://www.youtube.com/c/greenlearner)\n */\npublic class ThreadLocalDemo1 {\n    SimpleDateFormat sdf = new SimpleDateFormat(&quot;dd-mm-yyyy&quot;);//not thread safe\n    ThreadLocal&lt;SimpleDateFormat&gt; tdl1 = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(&quot;yyyy-dd-mm&quot;));\n\n    public static void main(String[] args) {\n        ThreadLocalDemo1 d1 = new ThreadLocalDemo1();\n\n        ExecutorService es = Executors.newFixedThreadPool(10);\n\n        for(int i=0; i&lt;100; i++) {\n            es.submit(() -&gt; System.out.println(d1.getDate(new Date())));\n        }\n        es.shutdown();\n    }\n\n    String getDate(Date date){\n\n//        String s = tsdf.get().format(date);\n        String s1 = tdl1.get().format(date);\n        return s1;\n    }\n}\n</code></pre>\n<p><strong>Usage Tips</strong></p>\n<ul>\n<li>Use local variables if possible. This way we can avoid using ThreadLocal</li>\n<li>Delegate the functionality to frameworks as and when possible</li>\n<li>If using ThreadLocal and setting the state into it then make sure to clean it after using otherwise it can become the major reason for <strong>OutOfMemoryError</strong></li>\n</ul>\n","answer_id":68554632,"question_id":817856},{"owner":{"profile_image":"https://i.stack.imgur.com/xvjto.png?s=256&g=1","account_id":6477138,"user_type":"registered","user_id":5015427,"link":"https://stackoverflow.com/users/5015427/ranojan","reputation":829,"display_name":"ranojan"},"content_license":"CC BY-SA 4.0","score":-1,"is_accepted":false,"last_activity_date":1624966050,"creation_date":1624966050,"body":"<p>Delete</p>\n<pre><code>&lt;style name=&quot;AppTheme.Launcher&quot;&gt;\n    &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/splashscreen&lt;/item&gt;\n&lt;/style&gt;\n</code></pre>\n<p>from style.xml file</p>\n","answer_id":68177787,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/1d80d2b74461600fd72673caebce4e24?s=256&d=identicon&r=PG","account_id":21829083,"user_type":"unregistered","user_id":16124211,"link":"https://stackoverflow.com/users/16124211/pluk","reputation":31,"display_name":"pluk"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1622783005,"creation_date":1622783005,"body":"<p>The <code>compute()</code> javadoc <a href=\"https://github.com/openjdk/jdk16u/blob/jdk16.0.1/src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java#L1876\" rel=\"nofollow noreferrer\">says</a> what this method does:</p>\n<blockquote>\n<p>Attempts to compute a mapping for the specified key and its current mapped value (or <code>null</code> if there is no current mapping).</p>\n</blockquote>\n<p>So <code>compute()</code> <strong>replaces</strong> a value for the key.</p>\n<p>To use <code>compute()</code> to modify the internal fields of some object (even the object is stored as a value in the map) is not what <code>compute()</code> was meant for.<br />\nTherefore, naturally, <code>compute()</code>'s specification/documentation guarantees (and even says) nothing about that.</p>\n<p>Regarding <code>happens-before</code>, there are multiple mentions in the documentation:</p>\n<ul>\n<li><a href=\"https://github.com/openjdk/jdk16u/blob/jdk16.0.1/src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java#L89\" rel=\"nofollow noreferrer\">ConcurrentHashMap</a>:\n<blockquote>\n<p>More formally, an update operation for a given key bears a <em>happens-before</em> relation with any (non-null) retrieval for that key reporting the updated value.</p>\n</blockquote>\n</li>\n<li><a href=\"https://github.com/openjdk/jdk16u/blob/jdk16.0.1/src/java.base/share/classes/java/util/concurrent/ConcurrentMap.java#L55\" rel=\"nofollow noreferrer\">ConcurrentMap</a>:\n<blockquote>\n<p>Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a <code>ConcurrentMap</code> as a key or value <em>happen-before</em> actions subsequent to the access or removal of that object from the <code>ConcurrentMap</code> in another thread.</p>\n</blockquote>\n</li>\n<li><a href=\"https://github.com/openjdk/jdk16u/blob/jdk16.0.1/src/java.base/share/classes/java/util/concurrent/package-info.java#L270\" rel=\"nofollow noreferrer\">java.util.concurrent</a>:\n<blockquote>\n<p>Actions in a thread prior to placing an object into any concurrent collection <em>happen-before</em> actions subsequent to the access or removal of that element from the collection in another thread.</p>\n</blockquote>\n</li>\n</ul>\n<p>The important thing is that the <code>happen-before</code> relation is only guaranteed between insertion/removal/retrieval of objects to/from the collection.<br />\nIn your case it is the same <code>State</code> object (only internal its fields are updated), so IMO according to documentation <code>ConcurrentHashMap</code> is even allowed to decide that nothing changed and skip the remaining synchronization steps.</p>\n","answer_id":67831727,"question_id":67825678},{"owner":{"profile_image":"https://www.gravatar.com/avatar/8cf8627c2f497949547cadc02c52b95f?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":4034876,"user_type":"registered","user_id":3319725,"link":"https://stackoverflow.com/users/3319725/anatolyg","reputation":1557,"display_name":"AnatolyG"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1621344860,"creation_date":1621330742,"body":"<p>This code has both of the classical concurrency problems: a race condition (a semantic problem) and a data race (a memory model related problem).</p>\n<ol>\n<li><code>Object.wait()</code> releases the object's monitor and another thread can enter into the synchronized block/method while the current one is waiting. Obviously, author's intention was to make the method atomic, but <code>Object.wait()</code> breaks the atomicity. As result, if we call <code>.increment()</code> from, let's say, 10 threads simultaneously and each thread calls the method 100_000 times, we get <code>count</code> &lt; 10 * 100_000 almost always, and this isn't what we'd like to. This is a race condition, a logical/semantic problem. We can rephrase the code... Since we release the monitor (this equals to the exit from the synchronized block), the code works as follows (like two separated synchronized parts):</li>\n</ol>\n<pre><code>    public void increment() { \n        int temp = incrementPart1(); \n        incrementPart2(temp); \n    }\n    \n    private synchronized int incrementPart1() {\n        int temp = count; \n        return temp; \n    }\n    \n    private synchronized void incrementPart2(int temp) {\n        count = temp + 1; \n    }\n</code></pre>\n<p>and, therefore, our <code>increment</code> increments the counter not atomically. Now, let's assume that 1st thread calls incrementPart1, then 2nd one calls incrementPart1, then 2nd one calls incrementPart2, and finally 1st one calls incrementPart2. We did 2 calls of the <code>increment()</code>, but the result is 1, not 2.</p>\n<ol start=\"2\">\n<li>Another problem is a data race. There is the Java Memory Model (JMM) described in the Java Language Specification (JLS). JMM introduces a Happens-before (HB) order between actions like volatile memory write/read, Object monitor's operations etc. <a href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4.5\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4.5</a> HB gives us guaranties that a value written by one thread will be visible by another one. Rules how to get these guaranties are also known as Safe Publication rules. The most common/useful ones are:</li>\n</ol>\n<ul>\n<li><p>Publish the value/reference via a volatile field (<a href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4.5\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4.5</a>), or as the consequence of this rule, via the AtomicX classes</p>\n</li>\n<li><p>Publish the value/reference through a properly locked field (<a href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4.5\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4.5</a>)</p>\n</li>\n<li><p>Use the static initializer to do the initializing stores\n(<a href=\"http://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html#jls-12.4\" rel=\"nofollow noreferrer\">http://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html#jls-12.4</a>)</p>\n</li>\n<li><p>Initialize the value/reference into a final field, which leads to the freeze action (<a href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.5\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.5</a>).</p>\n</li>\n</ul>\n<p>So, to have the counter correctly (as JMM has defined) visible, we must make it volatile</p>\n<pre><code>private volatile int count = 0;\n</code></pre>\n<p>or do the read over the same object monitor's synchronization</p>\n<pre><code>public synchronized int getCount() { return count; }\n</code></pre>\n<p>I'd say that in practice, on Intel processors, you read the correct value without any of these additional efforts, with just simple plain read, because of TSO (Total Store Ordering) implemented. But on a more relaxed architecture, like ARM, you get the problem. Follow JMM formally to be sure your code is really thread-safe and doesn't contain any data races.</p>\n","answer_id":67583683,"question_id":67576652,"last_edit_date":1621344860},{"owner":{"profile_image":"https://www.gravatar.com/avatar/45e3a1431bd08d4f8b1ce609c7924531?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":21225504,"user_type":"registered","user_id":15611270,"link":"https://stackoverflow.com/users/15611270/rocco","reputation":1108,"display_name":"Rocco"},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":true,"last_activity_date":1621333432,"creation_date":1621254735,"body":"<p>Actually you don't need to sleep, use proper queue classes instead, like <code>LinkedBlockingQueue</code>, I also remove the flags since you don't need them also, use <code>interrupt()</code> to stop a thread blocked waiting for a queue element:</p>\n<pre><code>private DatagramSocket socket;\nprivate byte[] buf = new byte[256];\nprivate List&lt;IUDPListener&gt; listeners = new ArrayList&lt;IUDPListener&gt;();\nprivate Thread runnerThread, listenerThread;\nprivate LinkedBlockingQueue&lt;MyObject&gt; list = new LinkedBlockingQueue&lt;MyObject&gt;();\n\npublic void init(int port) throws SocketException\n{\n    socket = new DatagramSocket(port);\n    \n    runnerThread = new Thread(this::listenLoopUDP);\n    runnerThread.setName(&quot;listenLoopUDP&quot;);\n    \n    listenerThread = new Thread(this::listenerThreadUDP);\n    listenerThread.setName(&quot;listenerThreadUDP&quot;);\n    \n    runnerThread.start();\n    listenerThread.start();\n}\n\nprivate void listenerThreadUDP() {\n    try {\n        while (true) {\n            MyObject info=list.take();\n            for (IUDPListener listener : listeners) {\n                listener.msgReceived(info);\n            }\n        }\n    } catch (InterruptedException ex) {\n        //Just quit\n    }\n}\n\npublic void listenLoopUDP() {\n    try {\n        while (true) {\n            DatagramPacket packet = new DatagramPacket(buf, buf.length);\n            socket.receive(packet);\n            String received = new String(packet.getData());\n            MyObject info = new MyObject(received);\n            list.put(info);\n        }\n    } catch (IOException e) {\n        Log.write(e);\n    } catch (InterruptedException e) {\n        Log.write(e);\n    } finally {\n        //Any exception above (or a runtime one) will activate this block where we do the cleanup and interrupt the other running thread\n        listenerThread.interrupt();\n        socket.close();\n    }\n}\n</code></pre>\n<p>I did a test with your 1ms client, printing both sent and received message and I have a perfect interleaving between the message, so the bottleneck is not in the receiving thread; with perfect interleaving I mean that in the console I get, as expected, the sent message from the client immediately followed from the received message.</p>\n","answer_id":67569728,"question_id":67566923,"last_edit_date":1621333432},{"owner":{"user_type":"does_not_exist","display_name":"user15793316"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1621287193,"creation_date":1621286439,"body":"<p>Why <code>int temp = count; wait(100); count = temp + 1;</code> is not thread-safe? One possible flow:</p>\n<ul>\n<li>First thread reads <code>count</code> (0), save it in <code>temp</code> for later, and waits, allowing second thread to run (lock released);<br/></li>\n<li>second thread reads <code>count</code> (also 0), saved in <code>temp</code>, and waits, eventually allowing first thread to continue;<br/></li>\n<li>first thread increments value from <code>temp</code> and saves in <code>count</code> (1);<br/></li>\n<li>but second thread still holds the old value of <code>count</code> (0) in <code>temp</code> - eventually it will run and store <code>temp+1</code> (1) into <code>count</code>, not incrementing its new value.</li>\n</ul>\n<p><sup>very simplified, just considering 2 threads</sup></p>\n<p>In short: <code>wait()</code> releases the lock allowing other (synchronized) method to run.</p>\n","answer_id":67577156,"question_id":67576652,"community_owned_date":1621286439,"last_edit_date":1621287193},{"owner":{"profile_image":"https://www.gravatar.com/avatar/d5eaa0398d86085f8751aae1bf3373fc?s=256&d=identicon&r=PG","account_id":369372,"user_type":"registered","user_id":716720,"link":"https://stackoverflow.com/users/716720/sergey-shcherbakov","reputation":4604,"display_name":"Sergey Shcherbakov","accept_rate":60},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1621279534,"creation_date":1621279534,"body":"<p>Check whether your use case allows solving the problem with keyboard interactive input. Instead of CoundDownLatch or Semaphore you could then expect manual input in System.in:</p>\n<pre><code>Scanner sc = new Scanner(System.in);\nsc.nextLine();\n</code></pre>\n<p>If you need that in unit tests, make sure that your environment is set up to read the user input, e.g. start the IntelliJ Idea with <code>-Deditable.java.test.console=true</code> option in Help -&gt; &quot;Edit Custom VM Options...&quot;</p>\n","answer_id":67575900,"question_id":27034958},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG","account_id":401843,"user_type":"registered","user_id":768644,"link":"https://stackoverflow.com/users/768644/rzwitserloot","reputation":89863,"display_name":"rzwitserloot"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1621271417,"creation_date":1621271417,"body":"<p>The Java Memory Model (JMM) is the relevant documentation here.</p>\n<blockquote>\n<p>t1 in the Main Method works as intended</p>\n</blockquote>\n<p>No, it doesn't. This is the first problem of the JMM: The JMM decrees areas where JVMs are free to do whatever they want. That means that the output of the JVM is <strong>non deterministic</strong> in effect: A JVM is free to always do A, or always do B, or flip a coin, or look at the phase of the moon, and more - and they still adhere to the spec. That's not just academic: The popular JVM impls out there all actually do this, because they can run far more efficiently that way.</p>\n<p>It means that effectively you can't test your code to detect that you messed up (by relying on the JVM's choice - which is bad), and if it seems to work right now, there's no guarantee it works tomorrow.</p>\n<p>Basically, the JMM allows the JVM to flip an evil coin sometimes: Evil in the sense that it will flip the same way every time during your dev and test cycle and then flips the other way just as you're giving that important demo.</p>\n<p>The only way to play the game, is <strong>to ensure the evil coin is never flipped in the first place</strong>.</p>\n<p>To do that, you need to remember the following rule:</p>\n<p><strong>All fields that are shared between threads must never be accessed unless HB/HA relationships are set up first, <em>OR</em> it is a read-only concept for the entirety of the concurrent process</strong>.</p>\n<p>In other words, here you have a field (<code>bookList</code>, or to be more specific, the backing array within the arraylist that bookList is pointing at) that is modified by one thread whilst another is running that also wants to read it, and  and thus, evil coinflips occur and this code is broken, whether your tests say so or not. You will 'randomly' observe some or all of the changes or not, or at least the JVM is free to let thread B see what thread A did or not in a haphazard fashion and you can't rely on any of it.</p>\n<p>HB/HA stands for 'happens-before/happens-after'. The JMM describes certain situations for which the JVM guarantees that it is not possible to observe the <em>lack</em> of change caused by the Happens-Before line in the Happens-After line.</p>\n<p>Without HB/HA, you get no such guarantee. To make that clear with an example:</p>\n<pre><code>class State {\n    static int a = 0, b = 0;\n}\n\nclass T1 implements Runnable {\n    public void run() {\n        Thread.sleep(randomAmount);\n        State.a = 10;\n        State.b = 20;\n    }\n}\n\nclass T2 implements Runnable {\n    public void run() {\n        Thread.sleep(randomAmount);\n        int myB = State.b;\n        int myA = State.a;\n        System.out.println(myA + &quot; &quot; + myB);\n    }\n}\n</code></pre>\n<p>If you run this code, fire up the two threads, then any of these outputs are all 'legal' - it is not a buggy JVM. Your code is the buggy code, and note that it is also legal for a JVM to never ever produce one or more of these answers. That should really sail home the point of that evil coin analogy - you just can't write software that doesn't solve HB/HA first, because it's a random clusterbomb otherwise:</p>\n<ul>\n<li><code>0 0</code></li>\n<li><code>10 20</code></li>\n<li><code>10 0</code></li>\n<li><code>0 20</code></li>\n</ul>\n<p>Note in particular that last one. That sure <strong>seems</strong> impossible. thread1 always writes a before it writes b, and thread 2 reads b before a, so can it possibly be that b does read 20, but somehow a is still 0? <strong>And yet, that is legal</strong>, and the reason is that the JVM likes to run quickly, and some JVM implementations (most, actually), will run code in parallel. The JVM merely guarantees that you can't observe things running in parallel unless you use timing to do so (and makes no guarantees on timing at all). If you wouldn't be able to observe it, it will run things in parallel for speed reasons.</p>\n<p>Thus, the JVM is free to run a=10 and b=20 in parallel.</p>\n<p>So, how do you establish HB/HA? That's quite a complicated topic; it involves the primitives <code>synchronized</code> and <code>volatile</code>, or using Java API that is thread-related, such as <code>AtomicLong</code>, <code>ConcurrentHashMap</code>, <code>someThread.start()</code>, etcetera. The docs will say (and the reason they establish HB/HA is generally because their implementations use synchronized/volatile under the hood).</p>\n<p>You're doing none of that, thus, no HB/HA relationships, thus this code is plain broken and not in a way that a test can ever reliably catch.</p>\n<p>In practice, though, trying to hand-manage this stuff is hard and error prone. Obviously it is: Just about any error you do make is by definition untestable.</p>\n<p>Use types that are much better suited to it. Peruse the <code>java.util.concurrent</code> package. For example, if you want one thread to be adding books and another to be removing them, you may want to look at <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/BlockingQueue.html\" rel=\"nofollow noreferrer\">BlockingQueue</a>.</p>\n<p>Removing a 'random' book is rather complicated and doesn't seem pragmatically solvable unless you go with a lock-the-world model. That works too, you'd just have to festoon all interaction with <code>bookList</code> in a synchronized block. But that mostly defeats the point of threads, as only one thread would ever actually be running (the other is waiting to acquire the synchronized lock).</p>\n<p>The takeaway lessons are:</p>\n<ul>\n<li>It is rocket science.</li>\n<li>Tests won't catch errors.</li>\n<li>Read the JMM if you really really want to do this. Learn about the ways to establish HB/HA and apply them. This requires knowing what <code>synchronized</code> and <code>volatile</code> actually do and is non-trivial to learn. If you misunderstood a few things but you don't realize you did, it is quite likely you'll never know until later when your code seems to randomly fail sometimes. This is not something a first-year java newbie should be tackling.</li>\n<li>Any concurrent access (interleaving reads/writes from different threads) on the same field are going to not work the way you want them to unless you pay extremely careful attention and set up HB/HA to make it reliable.</li>\n<li>Try to avoid concurrent access to fields, it's not that hard to do so:</li>\n<li>Peruse the j.u.concurrent package and use something from there, or</li>\n<li>arrange for communications between threads using a mechanism that's good at it, such as databases (which have transactions), or message queues such as RabbitMQ.</li>\n</ul>\n","answer_id":67574197,"question_id":67573852},{"owner":{"profile_image":"https://www.gravatar.com/avatar/9df50c377989a0a4a425884ce6ade1e9?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6426024,"user_type":"registered","user_id":4981150,"link":"https://stackoverflow.com/users/4981150/pieter12345","reputation":1723,"display_name":"Pieter12345"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1621266722,"creation_date":1621266722,"body":"<p>The <code>synchronized</code> keyword synchronizes access per object. Since you've created two <code>Arc</code> instances, both instances can execute the method at the same time. There are multiple solutions possible to synchronize execution of the loop within the <code>run</code> methods of your <code>Arc</code> instances:</p>\n<ul>\n<li>Only use a single instance of <code>Arc</code>. This might or might not be possible given your application.</li>\n<li>Enqueue runnable tasks instead of using an async executor. This makes most sense if your tasks should run on another thread, but not async.</li>\n<li>Use a <code>synchronized (LOCK_OBJ) {...code...}</code> block within the <code>run</code> method that synchronizes on some lock object that will be the same for both instances of <code>Arc</code> (i.e. <code>private static final Object LOCK_OBJ = new Object();</code>)</li>\n</ul>\n<p>Which decision is best really depends on your application, but at least this gives you some reasonable options.</p>\n","answer_id":67573072,"question_id":67572673},{"owner":{"profile_image":"https://www.gravatar.com/avatar/5cfe5f7d64f44be04f147295f5c7b88e?s=256&d=identicon&r=PG","account_id":71739,"user_type":"registered","user_id":207421,"link":"https://stackoverflow.com/users/207421/user207421","reputation":307163,"display_name":"user207421","accept_rate":82},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1621222152,"creation_date":1477188701,"body":"<blockquote>\n<p>I'd like a server to reject a connections after the number of connected clients reach a maximum value.</p>\n</blockquote>\n<p>Close the server socket.</p>\n<blockquote>\n<p>However, even though the server do not accept the connection, the socket on client side is created. Methods <code>socket.isBound</code> and <code>isConnected</code> both return true value.</p>\n</blockquote>\n<p>Correct. That's because TCP maintains a 'backlog queue' of incoming connections which have been completed but not yet accepted by the server application.</p>\n<blockquote>\n<p>So back to the main question. Do you have any ideas how could I reject the client from connecting when the ServerSocket will not be able to .accept() additional connection?</p>\n</blockquote>\n<p>Close the server socket while the number of connections is at its maximum.</p>\n<p>However due to the backlog this technique can never be perfect. There is no perfect solution. You could have the server immediately close excess connections, but the excess clients won't detect that until they try to send something. If you need perfection you will probably have to introduce an application protocol whereby the server sends something like 'ACCEPTED' or 'REJECTED' accordingly.</p>\n","answer_id":40198869,"question_id":40197514,"last_edit_date":1621222152},{"owner":{"profile_image":"https://i.stack.imgur.com/W6OMC.png?s=256&g=1","account_id":1056871,"user_type":"registered","user_id":1059372,"link":"https://stackoverflow.com/users/1059372/eugene","reputation":117749,"display_name":"Eugene","accept_rate":97},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1621218404,"creation_date":1621218053,"body":"<p>The explanation is really easy. What is the <em>default</em> value of <code>result.r1</code>? What type is <code>r1</code>? It's an <code>int</code>, and a <em>default</em> value for a <code>int</code> is <code>zero</code>. So when this <code>if (ta != null)</code> does not happen, meaning <code>ta</code> is <code>null</code>, your code will do nothing. That &quot;nothing&quot; translates into leaving <code>r1</code> to its default value - that is (you already know by now) <code>zero</code>. So when <code>ta == null</code> (and implicitly <code>a == null</code>), you leave <code>r1</code> to be <code>0</code>, though you do not do that <em>explicitly</em>.</p>\n<p>The solution is trivial:</p>\n<pre><code>@Actor\npublic void reader(I_Result result) {\n    A ta = a;\n    if (ta != null) {\n        result.r1 = ta.f;\n    } else {\n        result.r1 = -1;\n    }\n}\n</code></pre>\n<p>and:</p>\n<pre><code>@JCStressTest\n@State\n@Outcome(id = &quot;42&quot;, expect = Expect.ACCEPTABLE, desc = &quot;42 is OK&quot;)\n@Outcome(id = &quot;-1&quot;, expect = Expect.ACCEPTABLE, desc = &quot;-1 is OK too&quot;)\n</code></pre>\n<p>And now your code will never show <code>0</code>, if you read <code>a</code> to be non-null, you will always read <code>a.f</code> to be <code>42</code>. As far as your understanding goes, yes, all threads will see <code>42</code> once they see a reference to an instance of <code>A</code> - that is a <code>JLS</code> guarantee.</p>\n","answer_id":67563277,"question_id":67553393,"last_edit_date":1621218404},{"owner":{"profile_image":"https://www.gravatar.com/avatar/0f09e5543b8dba2d17370c2dc705fafe?s=256&d=identicon&r=PG","account_id":21618314,"user_type":"unregistered","user_id":15943754,"link":"https://stackoverflow.com/users/15943754/microbeast","reputation":11,"display_name":"microBeast"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1621187690,"creation_date":1621187690,"body":"<p>Another answer already explained why you have problems with <code>0</code> and <code>static</code>.<br />\nBut even with these problems fixed it could be difficult to reproduce partial initialization.<br />\nSo I would recommend you to take a look at the JCStress source code: it contains samples, and one of them (<a href=\"https://github.com/openjdk/jcstress/blob/master/jcstress-samples/src/main/java/org/openjdk/jcstress/samples/JMMSample_06_Finals.java\" rel=\"nofollow noreferrer\">JMMSample_06_Finals</a>) already does what you want.</p>\n","answer_id":67559880,"question_id":67553393},{"owner":{"profile_image":"https://www.gravatar.com/avatar/a4ff8881b435a054cae1f86bfb003958?s=256&d=identicon&r=PG","account_id":21615575,"user_type":"unregistered","user_id":15941436,"link":"https://stackoverflow.com/users/15941436/user","reputation":11,"display_name":"user"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1621165434,"creation_date":1621165434,"body":"<blockquote>\n<p>Now why is it that I see the value 0 in my output ?</p>\n</blockquote>\n<p>These is the case when <code>a == null</code> (and therefore <code>result.r1</code> remains <code>0</code>) in your <code>reader()</code> method.</p>\n<blockquote>\n<p>when I declare the field a as static. I get only 42 as my output, and why is that?</p>\n</blockquote>\n<p>You annotated <code>FinalField</code> with <code>@State</code>, therefore JCStress creates a new instance of <code>FinalField</code> for every execution.<br />\nIf <code>a</code> is an instance field in <code>FinalField</code>, then it is <code>null</code> initially in every execution.<br />\nIf <code>a</code> is a static field in <code>FinalField</code>, then it is shared across all executions and is <code>null</code> only in the first execution.</p>\n","answer_id":67556264,"question_id":67553393},{"owner":{"profile_image":"https://i.stack.imgur.com/V5sYj.jpg?s=256&g=1","account_id":4192718,"user_type":"registered","user_id":3434956,"link":"https://stackoverflow.com/users/3434956/mohsen-nour","reputation":1097,"display_name":"mohsen.nour","accept_rate":95},"content_license":"CC BY-SA 4.0","score":5,"is_accepted":false,"last_activity_date":1620072810,"creation_date":1538895637,"body":"<p>There are 3 scenarios for using a <strong>class helper</strong> like SimpleDateFormat in multithread code, which best one is use <strong>ThreadLocal</strong></p>\n<p>Scenarios</p>\n<p><strong>1-</strong> Using like <strong>share object</strong> by the help of <strong>lock or synchronization</strong> mechanism which makes the app <strong>slow</strong></p>\n<p><strong>Thread pool Scenarios</strong></p>\n<p><strong>2-</strong> Using as a <strong>local  object</strong> inside a method</p>\n<p>In thread pool, in this scenario, if we have <strong>4 thread</strong> each one has <strong>1000 task</strong> time  then we have<br />\n<strong>4000</strong> SimpleDateFormat <strong>object created</strong> and waiting for GC to erase them</p>\n<p><strong>3-</strong> Using <em><strong>ThreadLocal</strong></em></p>\n<p>In thread pool, if we have 4 thread and  we gave to <strong>each thread one SimpleDateFormat instance</strong><br />\nso we have <strong>4 threads</strong>, <strong>4 objects</strong> of SimpleDateFormat.</p>\n<p>There is no need of lock mechanism and object creation and destruction.  (Good time complexity and space complexity)</p>\n<p><a href=\"https://www.youtube.com/watch?v=sjMe9aecW_A\" rel=\"nofollow noreferrer\">https://www.youtube.com/watch?v=sjMe9aecW_A</a></p>\n","answer_id":52686202,"question_id":817856,"last_edit_date":1620072810},{"owner":{"profile_image":"https://www.gravatar.com/avatar/657174380e4f1bcadfffa53971e1c2e0?s=256&d=identicon&r=PG","account_id":8900272,"user_type":"registered","user_id":6643940,"link":"https://stackoverflow.com/users/6643940/h-a-h","reputation":2515,"display_name":"H.A.H."},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1615818656,"creation_date":1615818656,"body":"<p>First I want to point out that other answers are true.\nHowever, using the parameter in the constructor may not be the best idea for all of you.</p>\n<p>In many scenarios you will want to use &quot;Anonymous Inner Class&quot;, and override the <code>run()</code> method, because defining specific class for every use is painful.\n(<code>new MyRunnable(){...}</code>)</p>\n<p>And at the time you create that Runnable, the parameter may not be available to you to pass it in the constructor. If for example, you pass this object to a method, that will perform some work in separate thread and then call your runnable, applying the result from that work to it.</p>\n<p>In that case, using a method like this one:\n<code>public MyRunnable withParameter(Object parameter)</code>, may turn out to be far more useful choice.</p>\n<p>I do not claim that this is the best solution to the problem, but it will get the job done.</p>\n","answer_id":66639916,"question_id":877096},{"owner":{"profile_image":"https://graph.facebook.com/1447473648792894/picture?type=large","account_id":20871327,"user_type":"registered","user_id":15331210,"link":"https://stackoverflow.com/users/15331210/jorge-kasagian","reputation":11,"display_name":"Jorge Kasagian"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1614898390,"creation_date":1614876402,"body":"<p>There is the solution... I create rows into an array... and I use the array in the threads, Tu debes evitar use create rows into a thread because this method is monitored by thread safe</p>\n<p>Sorry, I dont speak english... I am trying too hard.</p>\n<pre><code>static int count=0;\n\n  \n\n    \n    XSSFWorkbook workbook = new XSSFWorkbook();\n    XSSFSheet sheet = workbook.createSheet(&quot;Products&quot;);\n    sheet.createFreezePane(0, 1); // this will freeze first five rows\n    \n    int rowCount = 0;\n    \n    rowCount = getExcelTittle(sucsCompetencia,sucsProveedor, sucsPuntoVenta, sheet, rowCount);  \n\n\n    // trucazo para multithread\n    List&lt;Row&gt; r = new ArrayList&lt;Row&gt;();\n    //List&lt;Drawing&gt; h = new ArrayList&lt;Drawing&gt;();\n    \n    //cell creation\n    for ( int j = 0 ; j &lt; ps.size() + 500 ; j++) {\n        r.add(sheet.createRow(j));\n        //h.add(sheet.createDrawingPatriarch());\n\n    }\n    // cells creation .. its a good idea do it \n    Map&lt;String,Cell&gt; cellMap = new HashMap&lt;String,Cell&gt;();\n    for (int j = 0 ; j &lt; r.size() ; j++) {\n        for ( int  i = 0 ; i &lt; 9 + sucsCompetencia.size() + sucsProveedor.size() + sucsPuntoVenta.size() ; i++) {\n            cellMap.put( j + &quot;-&quot; + i, r.get(j).createCell(i));\n        }\n\n\n    }       \n    \n    Stream&lt;Producto&gt; arrStream = ps.parallelStream();\n    arrStream.forEach(p-&gt;\n                        {   \n                            count++;\n        int contadorPropio = count;\n        \n        if (contadorPropio % 1000 == 0)  log.info(&quot;* Procesando Generacion Excel &quot; + contadorPropio + &quot; de &quot; + ps.size());\n        \n       // if (rowCount == 1000 ) break;\n        \n\n        \n        int columnCount = 0;\n        \n        \n        {\n            //IMPORTANTEEEEEEEE\n            Cell cell = cellMap.get(contadorPropio + &quot;-&quot; + columnCount++); \n            cell.setCellValue(p.getIdProducto());\n        }     \n</code></pre>\n","answer_id":66479401,"question_id":28626848,"last_edit_date":1614898390},{"owner":{"profile_image":"https://i.stack.imgur.com/jTteZ.jpg?s=256&g=1","account_id":6197622,"user_type":"registered","user_id":4828463,"link":"https://stackoverflow.com/users/4828463/faraz","reputation":6095,"display_name":"Faraz","accept_rate":91},"content_license":"CC BY-SA 4.0","score":10,"is_accepted":false,"last_activity_date":1614874382,"creation_date":1483076850,"body":"<p>From <a href=\"http://www.wrox.com/WileyCDA/WroxTitle/Professional-Java-for-Web-Applications.productCd-1118656466.html\" rel=\"nofollow noreferrer\"><em>Professional Java for Web Applications</em> by <em>Nicholas S. Williams</em></a></p>\n<blockquote>\n<p><strong>Using Threads for Transactions and Entity Managers</strong></p>\n</blockquote>\n<blockquote>\n<p>The transaction scope is limited to the thread the transaction begins in. The transaction manager then links the transaction to managed resources used in the same thread during the life of the transaction. When using the <a href=\"https://en.wikipedia.org/wiki/Java_Persistence_API\" rel=\"nofollow noreferrer\">Java Persistence API</a>, the resource you work with is the <a href=\"https://docs.oracle.com/javaee/7/api/javax/persistence/EntityManagerFactory.html\" rel=\"nofollow noreferrer\"><code>EntityManager</code></a>. It is the functional equivalent of Hibernate ORM’s <a href=\"https://docs.jboss.org/hibernate/orm/current/javadocs/org/hibernate/Session.html\" rel=\"nofollow noreferrer\"><code>Session</code></a> and JDBC’s <a href=\"https://docs.oracle.com/javase/8/docs/api/java/sql/Connection.html\" rel=\"nofollow noreferrer\"><code>Connection</code></a>. Normally, you would obtain an <code>EntityManager</code> from the <a href=\"https://docs.oracle.com/javaee/7/api/javax/persistence/EntityManagerFactory.html\" rel=\"nofollow noreferrer\"><code>EntityManagerFactory</code></a> before beginning a transaction and performing JPA actions. However, this does not work with the Spring Framework model of managing transactions on your behalf.\nThe solution to this problem is the <a href=\"https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/orm/jpa/support/SharedEntityManagerBean.html\" rel=\"nofollow noreferrer\"><code>org.springframework.orm.jpa.support.SharedEntityManagerBean</code></a>. When you configure JPA in Spring Framework, it creates a <code>SharedEntityManagerBean</code> that proxies the <code>EntityManager</code> interface. This proxy is then injected into your JPA repositories. When an <code>EntityManager</code> method is invoked on this proxy instance, the following happens in the background:</p>\n</blockquote>\n<blockquote>\n<p>➤➤ If the current thread already has a real <code>EntityManager</code> with an active transaction, it delegates the call to the method on that <code>EntityManager</code>.</p>\n</blockquote>\n<blockquote>\n<p>➤➤ Otherwise, Spring Framework obtains a new <code>EntityManager</code> from the\n<code>EntityManagerFactory</code>, starts a transaction, and binds both to the current thread. It then delegates the call to the method on that <code>EntityManager</code>. When the transaction is either committed or rolled back, Spring unbinds the transaction and the <code>EntityManager</code> from the thread and then closes the <code>EntityManager</code>. Future <code>@Transactional</code> actions on the same thread (even within the same request) start the process over again, obtaining a new <code>EntityManager</code> from the factory and beginning a new transaction. This way, no two threads use an <code>EntityManager</code> at the same time, and a given thread has only one transaction and one <code>EntityManager</code> active at any given time.</p>\n</blockquote>\n<p>(I paraphrased it a little the above piece)</p>\n<p>I think its self explanatory and answers your question. But I would like to add that, if you were not to use <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html\" rel=\"nofollow noreferrer\">Spring MVC</a> then you would have gotten the session using <code>SessionFactory</code> in Hibernate. Hibernate <code>Session</code>s represent the life of a transaction from start to finish. Depending on how your application is architected, that might be less than a second or several minutes; and in a web application, it could be one of several transactions in a request, a transaction lasting an entire request, or a transaction spanning multiple requests. A <code>Session</code>, which is not thread-safe and must be used <strong>only in one thread</strong> at a time, is responsible for managing the state of entities.</p>\n","answer_id":41391268,"question_id":41391209,"last_edit_date":1614874382},{"owner":{"profile_image":"https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG","account_id":47283,"user_type":"registered","user_id":139985,"link":"https://stackoverflow.com/users/139985/stephen-c","reputation":703927,"display_name":"Stephen C","accept_rate":69},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1614853894,"creation_date":1614853474,"body":"<blockquote>\n<p>How do they work.</p>\n</blockquote>\n<p>It is complicated.  There are whole books on this.</p>\n<blockquote>\n<p>do they share the same call stack,</p>\n</blockquote>\n<p>No.  Each thread has its own call stack.</p>\n<blockquote>\n<p>Can somebody please explain in detail how they work under the hook, and what is this parrarelism in multithreading</p>\n</blockquote>\n<p>Seriously, if you don't (yet) understand what parallelism is, you are not (yet) equipped to understand how multithreading works <em>under the hood</em>.</p>\n<p>I suggest that you start by reading the <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/\" rel=\"nofollow noreferrer\">Oracle Java tutorial on concurrency</a>.  Then if you need to understand threads more deeply, buy and read <a href=\"https://rads.stackoverflow.com/amzn/click/com/0321349601\" rel=\"nofollow noreferrer\" rel=\"nofollow noreferrer\">&quot;Java: Concurrency in Practice&quot; by Brian Goetz et al.</a></p>\n<p>When you have read ... and understood ... those things, you should be equipped to learn how threads work under the hood.  But the ability to read C and C++ code would also help, since that's what the JVM is implemented in <em>under the hood</em>.</p>\n","answer_id":66473102,"question_id":66472876,"last_edit_date":1614853894},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c13d09d5694714d174f87e89c18f8694?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6875198,"user_type":"registered","user_id":5283869,"link":"https://stackoverflow.com/users/5283869/gnupinguin","reputation":81,"display_name":"gnupinguin"},"content_license":"CC BY-SA 4.0","score":4,"is_accepted":false,"last_activity_date":1614845933,"creation_date":1614845933,"body":"<p>The bug was fixed for the 11.0.10 Java version.</p>\n","answer_id":66471075,"question_id":54485755},{"owner":{"profile_image":"https://lh3.googleusercontent.com/-3AdCEYHSZg4/AAAAAAAAAAI/AAAAAAAAAGU/_il24uqnDnY/photo.jpg?sz=256","account_id":15883826,"user_type":"registered","user_id":11460835,"link":"https://stackoverflow.com/users/11460835/vaibhav-jain","reputation":1,"display_name":"vaibhav jain"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1614834094,"creation_date":1614834094,"body":"<pre><code>Try this solution.....\n\npublic class Print1To20Using2Thread {\n    public static void main(String[] args) {\n        PrintNumber pn = new PrintNumber(new Object());\n        Thread t1 = new Thread(pn, &quot;First&quot;);\n        Thread t2 = new Thread(pn, &quot;Second&quot;);\n\n        t1.start();\n        t2.start();\n    }\n}\n\nclass PrintNumber implements Runnable {\n\n    Object lock;\n    int i = 0;\n    public PrintNumber(Object lock) {\n        this.lock = lock;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lock) {\n            for (; i &lt;= 20; i++) {\n                if (i == 11) {\n                    try {\n                        lock.wait(1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                System.out.print(&quot; &quot;+Thread.currentThread().getName() + &quot; &quot; + i);\n                lock.notifyAll();\n            }\n            System.out.println();\n        }\n    }\n}\n</code></pre>\n","answer_id":66468855,"question_id":24720849},{"owner":{"profile_image":"https://i.stack.imgur.com/6qIEl.png?s=256&g=1","account_id":330005,"user_type":"registered","user_id":653856,"link":"https://stackoverflow.com/users/653856/raghunandan","reputation":132780,"display_name":"Raghunandan","accept_rate":100},"content_license":"CC BY-SA 4.0","score":4,"is_accepted":true,"last_activity_date":1614821754,"creation_date":1364282387,"body":"<p>AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. <strong>AsyncTasks should ideally be used for short operations (a few seconds at the most.)</strong> If you need to keep <strong>threads running for long periods of time</strong>, it is <strong>highly recommended</strong> you use the various APIs provided by the java.util.concurrent pacakge such as <strong>Executor, ThreadPoolExecutor and FutureTask</strong>. (Straight from the doc).</p>\n<p><a href=\"http://developer.android.com/reference/android/os/AsyncTask.html\" rel=\"nofollow noreferrer\">http://developer.android.com/reference/android/os/AsyncTask.html</a>.</p>\n<p>An alternative to asynctask for long running operations is robospice.</p>\n<p><a href=\"https://github.com/octo-online/robospice\" rel=\"nofollow noreferrer\">https://github.com/octo-online/robospice</a></p>\n<p>Update:</p>\n<p>Asynctask is deprecated using coroutines or any other threading mechanism. Consider suing work manager for defferable jobs.</p>\n","answer_id":15631479,"question_id":15631304,"last_edit_date":1614821754},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b3ec9d9128a25ba6eae8a1d42c2eb04a?s=256&d=identicon&r=PG","account_id":1449510,"user_type":"registered","user_id":1366871,"link":"https://stackoverflow.com/users/1366871/dreamcrash","reputation":48192,"display_name":"dreamcrash","accept_rate":100},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1614793690,"creation_date":1541089673,"body":"<p>What you can do is to intercept the task parameter of the submit and enhanced that task to print what you want:</p>\n<pre><code>Object around(Runnable task) : call(* ExecutorService+.submit(Runnable, ..)) &amp;&amp; args( task)\n{\n    final long parentID = Thread.currentThread().getId();\n    Runnable newTask =  () -&gt; {\n            System.out.println(&quot;Parent Thread Id: &quot;+ parentID);\n            System.out.println(&quot;Child Thread Id: &quot;+Thread.currentThread().getId()); //?? - how to capture child thread id?\n            task.run();\n    };\n    return proceed(newTask);\n}\n</code></pre>\n<p>As soon as the asynchronous task is executed the id of the thread executing it will be print.</p>\n<p>A Running example:</p>\n<p><strong>Main.java:</strong></p>\n<pre><code>public class Main {\n    public static void main(String[] args) {\n        new Test().testExecutorService();\n    }\n}\n</code></pre>\n<p><strong>Test.java:</strong></p>\n<pre><code>public class Test {\n    public void testExecutorService() {\n        ExecutorService service = Executors.newSingleThreadExecutor();\n        service.submit(() -&gt;  System.out.println(&quot;working on the task&quot;));\n        try {\n            service.awaitTermination(2, TimeUnit.SECONDS);\n            service.shutdown();\n        }catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n</code></pre>\n<p><strong>Example.aj</strong></p>\n<pre><code>public aspect Example {\n     \n     Object around(Runnable task) : call(public Future&lt;?&gt; java.util.concurrent.ExecutorService+.submit(Runnable)) \n                        &amp;&amp; args(task)\n     {\n         final long parentID = Thread.currentThread().getId();\n         Runnable newTask =  () -&gt; {\n                 System.out.println(&quot;Parent Thread Id: &quot;+ parentID);\n                 System.out.println(&quot;Child Thread Id: &quot;+Thread.currentThread().getId()); \n                 task.run();\n         };\n         return proceed(newTask);\n     }\n}\n</code></pre>\n","answer_id":53105412,"question_id":53029722,"last_edit_date":1614793690},{"owner":{"profile_image":"https://i.stack.imgur.com/t2hoD.jpg?s=256&g=1","account_id":3211603,"user_type":"registered","user_id":2711488,"link":"https://stackoverflow.com/users/2711488/holger","reputation":289317,"display_name":"Holger"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":true,"last_activity_date":1614778466,"creation_date":1614778466,"body":"<p>When you set the thread local variable to an instance of <code>Bar</code>, the value has an implicit reference to its defining class loader, which is also the defining class loader of <code>Foo</code> and hence, has an implicit reference to its <code>static</code> variable <code>tl</code> holding the <code>ThreadLocal</code>.</p>\n<p>In contrast, the <code>String</code> class is defined by the bootstrap loader and has no implicit reference to the the <code>Foo</code> class.</p>\n<p>Now, a reference cycle is not preventing garbage collection per se. If only one object holds a reference to a member of the cycle and that object becomes unreachable, the entire cycle would become unreachable. The problem here is that the object still referencing the cycle is the <code>Thread</code> that is still alive.</p>\n<p>The specific value is associated with the combination of a <code>ThreadLocal</code> instance and a <code>Thread</code> instance and we’d wish that if <em>either</em> of them becomes unreachable, it would stop referencing the value. Unfortunately, no such feature exists. We can only associate a value with the reachability of one object, like with the key of a <code>WeakHashMap</code>, but not of two.</p>\n<p>In the OpenJDK implementation, the <code>Thread</code> is the owner of this construct, which makes it immune against values back-referencing the <code>Thread</code>. E.g.</p>\n<pre class=\"lang-java prettyprint-override\"><code>ThreadLocal&lt;Thread&gt; local = new ThreadLocal&lt;&gt;();\n\nReferenceQueue&lt;Thread&gt; q = new ReferenceQueue&lt;&gt;();\n\nSet&lt;Reference&lt;?&gt;&gt; refs = ConcurrentHashMap.newKeySet();\n\nnew Thread(() -&gt; {\n    Thread t = Thread.currentThread();\n    local.set(t);\n    refs.add(new WeakReference&lt;&gt;(t, q));\n}).start();\n\nReference&lt;?&gt; r;\nwhile((r = q.remove(2000)) == null) {\n    System.gc();\n}\n\nif(refs.remove(r)) System.out.println(&quot;Collected&quot;);\nelse System.out.println(&quot;Something very suspicuous is going on&quot;);\n</code></pre>\n<p>This will print <code>Collected</code>, indicating that the reference from the value to the <code>Thread</code> did not prevent the removal, unlike <code>put(t, t)</code> on a <code>WeakHashMap</code>.</p>\n<p>The price is that this construct is not immune against backreferences to the <code>ThreadLocal</code> instance.</p>\n<pre class=\"lang-java prettyprint-override\"><code>ReferenceQueue&lt;Object&gt; q = new ReferenceQueue&lt;&gt;();\n\nSet&lt;Reference&lt;?&gt;&gt; refs = ConcurrentHashMap.newKeySet();\n\ncreateThreadLocal(refs, q);\n\nReference&lt;?&gt; r;\nwhile((r = q.remove(2000)) == null) {\n    System.gc();\n}\n\nif(refs.remove(r)) System.out.println(&quot;Collected&quot;);\nelse System.out.println(&quot;Something very suspicuous is going on&quot;);\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>static void createThreadLocal(Set&lt;Reference&lt;?&gt;&gt; refs, ReferenceQueue&lt;Object&gt; q) {\n    ThreadLocal&lt;ThreadLocal&lt;?&gt;&gt; local = new ThreadLocal&lt;&gt;();\n    local.set(local);\n    refs.add(new WeakReference&lt;&gt;(local, q));\n}\n</code></pre>\n<p>This will hang forever, as the backreference from the <code>ThreadLocal</code> to itself prevents its garbage collection, as long as the associated thread is still alive.</p>\n<p>Your case is just a special variant of it, as the backreference is through the <code>Bar</code> instance, its defining loader, to <code>Foo</code>’s <code>static</code> variable. But the principle is the same.</p>\n<p>You only need to change the line</p>\n<pre class=\"lang-java prettyprint-override\"><code>loadClass();\n</code></pre>\n<p>to</p>\n<pre class=\"lang-java prettyprint-override\"><code>new Thread(new FutureTask(() -&gt; { loadClass(); return null; })).start();\n</code></pre>\n<p>to stop the value from being associated with the main thread. Then, the class loader and all associated classes and instances get garbage collected.</p>\n","answer_id":66458166,"question_id":66452567},{"owner":{"profile_image":"https://i.stack.imgur.com/SsTc7.jpg?s=256&g=1","account_id":2305297,"user_type":"registered","user_id":2024692,"link":"https://stackoverflow.com/users/2024692/cromax","reputation":1882,"display_name":"Cromax","accept_rate":100},"content_license":"CC BY-SA 4.0","score":34,"is_accepted":false,"last_activity_date":1610752470,"creation_date":1472503229,"body":"<p>This answer comes very late, but maybe someone will find it useful. It is about how to pass a parameter(s) to a <code>Runnable</code> without even declaring named class (handy for inliners):</p>\n<pre class=\"lang-java prettyprint-override\"><code>    String someValue = &quot;Just a demo, really...&quot;;\n\n    new Thread(new Runnable() {\n        private String myParam;\n\n        public Runnable init(String myParam) {\n            this.myParam = myParam;\n            return this;\n        }\n\n        @Override\n        public void run() {\n            System.out.println(&quot;This is called from another thread.&quot;);\n            System.out.println(this.myParam);\n        }\n    }.init(someValue)).start();\n</code></pre>\n<p>Of course you can postpone execution of <code>start</code> to some more convenient or appropriate moment. And it is up to you what will be the signature of <code>init</code> method (so it may take more and/or different arguments) and of course even its name, but basically you get an idea.</p>\n<p>In fact there is also another way of passing a parameter to an anonymous class, with the use of the initializer blocks. Consider this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>    String someValue = &quot;Another demo, no serious thing...&quot;;\n    int anotherValue = 42;\n\n    new Thread(new Runnable() {\n        private String myParam;\n        private int myOtherParam;\n        // instance initializer\n        {\n            this.myParam = someValue;\n            this.myOtherParam = anotherValue;\n        }\n\n        @Override\n        public void run() {\n            System.out.println(&quot;This comes from another thread.&quot;);\n            System.out.println(this.myParam + &quot;, &quot; + this.myOtherParam);\n        }\n    }).start();\n</code></pre>\n<p>So all happens inside of the initializer block.</p>\n","answer_id":39214833,"question_id":877096,"last_edit_date":1610752470},{"owner":{"profile_image":"https://www.gravatar.com/avatar/224c1fc80ce88c3e0f59f420ce575043?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":5378847,"user_type":"registered","user_id":4284764,"link":"https://stackoverflow.com/users/4284764/gerard-martinelli","reputation":39,"display_name":"Gerard Martinelli"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1608715032,"creation_date":1608715032,"body":"<p>I think I have resolved my concern.  In the JDialog ContenPane, I have created a JButton  with an actionListener, then before leaving the run method, I issue a doClic().  This execute what I want (for example return to the caller).  It works perfectly.</p>\n","answer_id":65421769,"question_id":65407356},{"owner":{"profile_image":"https://www.gravatar.com/avatar/8cf8627c2f497949547cadc02c52b95f?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":4034876,"user_type":"registered","user_id":3319725,"link":"https://stackoverflow.com/users/3319725/anatolyg","reputation":1557,"display_name":"AnatolyG"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1608649600,"creation_date":1608647818,"body":"<p>An ad-hock implementation of such step-by-step scenario may be based on CountDownLatch primitive like following:</p>\n<pre><code>import java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\n\npublic class FooOrchestration {\n    public static class Foo {\n        public void first() { print(&quot;first&quot;); }\n        public void second() { print(&quot;second&quot;); }\n        public void third() { print(&quot;third&quot;); }\n    }\n\n    static void print(String text) {\n        System.out.println(text);\n    }\n\n    static class Step extends Thread {\n        private final CountDownLatch starter = new CountDownLatch(1);\n        private final List&lt;Step&gt; nextSteps = new ArrayList&lt;&gt;();\n        private final Runnable action;\n\n        Step(final Runnable action) {\n            this.action = action;\n        }\n\n        @Override\n        public void run() {\n            try {\n                starter.await(); // wait until someone kicks the starter with countDown()\n                action.run();\n                for (Step s : nextSteps) { // let's start the following steps\n                    s.starter.countDown();\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                for (Step s : nextSteps) { // let's propagate \n                    s.interrupt(); // the interruption\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws Throwable {\n        Foo foo = new Foo();\n\n        Step firstStep = new Step(() -&gt; foo.first());\n        Step secondStep = new Step(() -&gt; foo.second());\n        Step thirdStep = new Step(() -&gt; foo.third());\n\n        firstStep.nextSteps.add(secondStep); // set sequence\n        secondStep.nextSteps.add(thirdStep); // of execution\n\n        thirdStep.start(); // order of start\n        secondStep.start(); // doesn't\n        firstStep.start(); // matter\n\n        firstStep.starter.countDown(); // kick the starterof the first step\n    }\n}\n</code></pre>\n<p>Also, the standard package java.concurrent provides more generic and flexible barrier Phaser <a href=\"https://www.baeldung.com/java-phaser\" rel=\"nofollow noreferrer\">https://www.baeldung.com/java-phaser</a> which allows to build different and complex scenarios of multi-threading executions easily.</p>\n","answer_id":65410571,"question_id":65382129,"last_edit_date":1608649600},{"owner":{"profile_image":"https://www.gravatar.com/avatar/ec430cc01ef4cf4ae63ebbe9e8596f72?s=256&d=identicon&r=PG","account_id":1547313,"user_type":"registered","user_id":1440565,"link":"https://stackoverflow.com/users/1440565/code-apprentice","reputation":82164,"display_name":"Code-Apprentice","accept_rate":59},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1608573471,"creation_date":1608569661,"body":"<p>You are correct. If two threads lock the same object, then one of the threads will block, which doesn't help with performance. If on the other hand, the two threads can run completely independently of each other, then there is a huge performance gain.</p>\n","answer_id":65396827,"question_id":65396228,"last_edit_date":1608573471},{"owner":{"profile_image":"https://i.stack.imgur.com/2VjzX.jpg?s=256&g=1","account_id":6696437,"user_type":"registered","user_id":5164318,"link":"https://stackoverflow.com/users/5164318/emandt","reputation":2557,"display_name":"emandt"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1608566738,"creation_date":1608566738,"body":"<p>You need something similar to:</p>\n<pre><code>/** Class for Synchronize two Threads */\nprivate static class SyncObj&lt;T&gt; {\n    @Nullable\n    private T mValue = null;\n    public SyncObj(@Nullable final T initValue) { this.mValue = initValue; }\n    public void set(@Nullable final T value) { this.mValue = value; }\n    @Nullable\n    public T get() { return this.mValue; }\n}\n\n/** A Thread is used instead of {@link AsyncPost} */\nprivate class AsyncPost extends Thread {\n    private Handler mAsyncPostHandler;\n    private final Handler mMainThreadHandler;\n    private boolean mOnPreExecuted = false;\n    public AsyncPost() {\n        mMainThreadHandler = new Handler(Looper.getMainLooper()) {\n            @UiThread @MainThread\n            @Override\n            public void handleMessage(@NonNull final Message message) {\n                switch (message.what) {\n                    case 111: {\n                        @Nullable\n                        final String cRequestText = (String)message.obj;\n                        if (cRequestText == null) break;\n                        dialog.setMessage(cRequestText);\n                        break;\n                    }\n                    default: { }    //all Runnables sent to &quot;mMainThreadHandler&quot; are executed &quot;here&quot;\n                }\n            }\n        };\n    }\n    @WorkerThread\n    @Override\n    public void run() {\n        Looper.prepare();\n        mAsyncPostHandler = new Handler(Looper.myLooper()) {\n            @Override\n            public void handleMessage(@NonNull final Message message) {\n                switch (message.what) {\n                    case -1: {\n                        final Looper cMyLooper = Looper.myLooper();\n                        if (cMyLooper != null) cMyLooper.quit();\n                        break;\n                    }\n                    case 555: {\n                        if (!mOnPreExecuted) {\n                                //esecuted on Main/UIThread at first API Request...\n                            OnMainThreadRun(new Runnable() {    //SAME AS &quot;onPreExecute()&quot;\n                                @Override\n                                public void run() { dialog = ProgressDialog.show(Sync_Bulk.this, &quot;&quot;, &quot;&quot;); }\n                            });\n                            mOnPreExecuted = true;\n                        }\n                        final List&lt;?&gt; cList = (List&lt;?&gt;)message.obj;\n                        if (cList == null) break;\n                        final SyncObj&lt;String&gt; cSyncObj = new SyncObj&lt;&gt;(null);\n                            //loop through the List\n                        @Nullable\n                        String cRequesteResult;\n                        for (final Object cItem : cList) {\n                                //call API Request for each item in the List...\n                            postRequest(cSyncObj, cItem);\n                            try {\n                                    //...wait until &quot;notify()&quot; is called\n                                synchronized (cSyncObj) {\n                                        //loop until &quot;SyncObj.set()&quot; was called with a valid Value\n                                    while ((cRequesteResult = cSyncObj.get()) == null) cSyncObj.wait();\n                                        //check SyncObj result\n                                    if (cRequesteResult.equals(&quot;OK&quot;)) {\n                                        Log.i(&quot;MainActivity&quot;, &quot;Request successfully&quot;);\n                                    } else {\n                                        Log.w(&quot;MainActivity&quot;, &quot;Request failed: &quot; + cRequesteResult);\n                                    }\n                                        //update the Dialog on Main/UIThread\n                                    OnProgressUpdate(cRequesteResult);\n                                }\n                            } catch (Exception e) {\n                                Log.e(&quot;MainActivity&quot;, &quot;Stopping all Request due to Exception: &quot; + e.getMessage());\n                            }\n                        }\n                            //terminate this Thread\n                        postToAsyncThread_Quit();\n                        break;\n                    }\n                }\n            }\n        };\n        Looper.loop();\n        this.OnMainThreadRun(new Runnable() {   //SAME AS &quot;OnPostExecute()&quot;\n            @Override\n            public void run() {\n                ..executed on Main/UIThread at the end of all..\n            }\n        });\n    }\n    /** Execute a {@link Runnable} on MainThread/UiThread */\n    @WorkerThread\n    private void OnMainThreadRun(@Nullable final Runnable runnable) {\n        if (runnable == null) return;\n        mMainThreadHandler.post(runnable);\n    }\n    @AnyThread\n    private void OnProgressUpdate(@Nullable final String text) { mMainThreadHandler.sendMessage(Message.obtain(mMainThreadHandler, 111, text)); }\n    /** Execute a {@link Runnable} on {@link AsyncPost} Thread */\n    @AnyThread\n    private void postToAsyncThread_DoRequests(@Nullable final List&lt;?&gt; list) { mAsyncPostHandler.sendMessage(Message.obtain(mAsyncPostHandler, 555, list)); }\n    /** Terminate {@link AsyncPost} Thread */\n    @AnyThread\n    private void postToAsyncThread_Quit() { mAsyncPostHandler.sendEmptyMessage(-1); }\n}\n\nprivate void postRequest(final SyncObj&lt;String&gt; syncObj, @NonNull final Object listItem) {\n        //execute API Request which will trigger one of Listener methods\n    doAsyncRequest(listItem, new ResponseListener() {\n        @Override\n        void onSuccess() {\n            synchronized (syncObj) {\n                syncObj.set(&quot;OK&quot;);\n                syncObj.notify();\n            }\n        }\n        @Override\n        void onFailed() {\n            synchronized (syncObj) {\n                syncObj.set(&quot;ERROR&quot;);\n                syncObj.notify();\n            }\n        }\n    });\n}\n\nprivate void doAllRequests(@Nullable final List&lt;?&gt; list) {\n    final AsyncPost cAsyncPost = new AsyncPost();\n    cAsyncPost.start();\n    cAsyncPost.postToAsyncThread_DoRequests(list);\n}\n</code></pre>\n<p>Just call &quot;doAllRequests(...)&quot; providing the appropriate List.\nA single &quot;OnPreExecute()&quot;-like will be executed at first API call and a single &quot;OnPostExecute()&quot;-like will be executed at the end of last APi call.\nAt each API Call (success or fail) &quot;case 111:&quot; will be called from the Main/UIThread.</p>\n","answer_id":65396071,"question_id":65393915},{"owner":{"profile_image":"https://i.stack.imgur.com/bh9Vd.png?s=256&g=1","account_id":16559,"user_type":"registered","user_id":36223,"link":"https://stackoverflow.com/users/36223/daveb","reputation":1856,"display_name":"DaveB"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1608564725,"creation_date":1608564725,"body":"<p>Using Platform.runLater() in a background thread is kind of a messy kludge that should probably be avoided.  JavaFX has mechanisms to handle this kind of thing which you should use.  Specifically, Task&lt;&gt; is designed to allow background threads to update data which is connected to JavaFX screen elements which need to be updated on the FXAT.</p>\n<p>You CAN do what you're trying to do with a JavaFX Task, but using  the Java Timer inside of it seems impossible, since there doesn't seem to be any way for a Java thread to wait on a Timer to complete.  So, instead I've used a &quot;for&quot; loop with a sleep to do the same thing.  It's clumsy, but it does demonstrate how to connect partial results from a Task to screen display:</p>\n<pre><code>public class Sample1 extends Application {\n\n    public static void main(String[] args) {\n        launch(args);\n    }\n\n    @Override\n    public void start(Stage primaryStage) {\n        Scene scene = new Scene(new Timer1(), 300, 200);\n        primaryStage.setScene(scene);\n        primaryStage.show();\n    }\n}\n\npublic class Timer1 extends VBox {\n\n    public Timer1() {\n        Text time = new Text();\n        Button startButton = new Button(&quot;Start&quot;);\n        Button stopButton = new Button(&quot;Stop&quot;);\n        getChildren().addAll(time, startButton, stopButton);\n        startButton.setOnAction(startEvt -&gt; {\n            Task&lt;Integer&gt; timerFxTask = new Task&lt;&gt;() {\n\n                {\n                    updateValue(0);\n                }\n\n                @Override\n                protected Integer call() throws Exception {\n                    for (int counter = 0; counter &lt;= 1000; counter++) {\n                        sleep(1000);\n                        updateValue(counter);\n                    }\n                    return 1000;\n                }\n            };\n            stopButton.setOnAction(stopEvt -&gt; timerFxTask.cancel());\n            time.textProperty().bind(Bindings.createStringBinding(() -&gt; timerFxTask.getValue().toString(),\n                    timerFxTask.valueProperty()));\n            Thread timerThread = new Thread(timerFxTask);\n            timerThread.start();\n        });\n    }\n}\n</code></pre>\n<p>But there is a better way to do what you're trying to do, which is essentially an animation - and JavaFX has a facility to do exactly this.  Usually, people use animations to morph the appearance of JavaFX screen elements, but you can also use it to animate the contents of a Text over time as well.  What I've done here is create an IntegerProperty which can be transitioned from a start value to an end value interpolated linearly over time and then bound that value to the TextProperty of a Text on the screen.  So you see it update once per second.</p>\n<pre><code>public class Sample1 extends Application {\n\n    public static void main(String[] args) {\n        launch(args);\n    }\n\n    @Override\n    public void start(Stage primaryStage) {\n        Scene scene = new Scene(new Timer2(), 300, 200);\n        primaryStage.setScene(scene);\n        primaryStage.show();\n    }\n}\n\npublic class Timer2 extends VBox {\n\n    public Timer2() {\n        Text time = new Text();\n        Button startButton = new Button(&quot;Start&quot;);\n        Button stopButton = new Button(&quot;Stop&quot;);\n        getChildren().addAll(time, startButton, stopButton);\n        startButton.setOnAction(startEvt -&gt; {\n            IntegerProperty counter = new SimpleIntegerProperty(0);\n            Timeline timeline = new Timeline(new KeyFrame(Duration.seconds(1000), new KeyValue(counter, 1000)));\n            stopButton.setOnAction(stopEvt -&gt; timeline.stop());\n            time.textProperty().bind(Bindings.createStringBinding(() -&gt; Integer.toString(counter.get()), counter));\n            timeline.play();\n        });\n    }\n}\n</code></pre>\n","answer_id":65395539,"question_id":65391501},{"owner":{"profile_image":"https://www.gravatar.com/avatar/6b2c535fac79e482b71f15de561f55ca?s=256&d=identicon&r=PG","account_id":60171,"user_type":"registered","user_id":179850,"link":"https://stackoverflow.com/users/179850/gray","reputation":115485,"display_name":"Gray","accept_rate":100},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1608555694,"creation_date":1608396600,"body":"<blockquote>\n<p>Does the value of AtomicReference will be set lazily if we assign a function to it which returns some array?</p>\n</blockquote>\n<p>First off, <code>AtomicReference.set()</code> is immediate and in no ways lazy.  If we look at your code, we see that <code>someFunc()</code> returns an <code>ArrayList</code> so this will be set immediately into <code>atomicStrings</code>.  Unfortunately, the strings are added to the list by another thread and there is no synchronization between the main thread, that is running <code>someFunc()</code> and creating the list, and the thread that is adding the strings to the list.  Anytime two different threads are accessing the same object, and especially mutating that object, you need to worry about mutex (race conditions) and memory synchronization.</p>\n<p>One thing you could use to fix your specific issue is to use a <code>BlockingQueue</code> which is a synchronized class instead of an <code>ArrayList</code>.  <code>BlockingQueue</code> take care of all of the memory synchronization and mutex locking to ensure that accesses from multiple threads are done appropriately.</p>\n<pre><code>BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;();\n</code></pre>\n<p>Then, when the inner thread calls <code>queue.add(&quot;a&quot;);</code> and then after the 10 seconds expire the main thread calls <code>queue.iterator()</code>, they will see the same collection of strings.  There is no need for the <code>AtomicReference</code> because the atomic class the main and the inner threads will be sharing is the <code>ArrayBlockingQueue </code>.</p>\n","answer_id":65372167,"question_id":65363568,"last_edit_date":1608555694},{"owner":{"profile_image":"https://www.gravatar.com/avatar/166994c436c6a1d69ee7af86f727d57f?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":14704600,"user_type":"registered","user_id":10619713,"link":"https://stackoverflow.com/users/10619713/jakob-tinhofer","reputation":345,"display_name":"Jakob Tinhofer"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1608551014,"creation_date":1608549117,"body":"<p>Ok, my comments are too long. This is how I would try to do it.</p>\n<ol>\n<li>Start the stopwatch on the application being loaded</li>\n<li>Create a new thread that launches itself every so often.</li>\n<li>Inside there, get the time from the Stopwatch in seconds (<code>sw.getTime(TimeUntis.seconds)</code>). Convert that to hours and minutes if you want <a href=\"https://stackoverflow.com/questions/6118922/convert-seconds-value-to-hours-minutes-seconds#:%7E:text=hours%20%3D%20totalSecs%20%2F%203600%3B%20minutes,%2C%20hours%2C%20minutes%2C%20seconds\">like shown in this SO post</a></li>\n<li>Then, write the time to the UI using <code>Platform.runLater(new Runnable(){ /* access ui element and write time here */ });</code></li>\n</ol>\n","answer_id":65391726,"question_id":65391501,"last_edit_date":1608551014},{"owner":{"profile_image":"https://www.gravatar.com/avatar/dd818daa34685a9be777abbadd91e4a1?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8666186,"user_type":"registered","user_id":6486622,"link":"https://stackoverflow.com/users/6486622/denis-zavedeev","reputation":7757,"display_name":"Denis Zavedeev"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1608485238,"creation_date":1608484458,"body":"<p>I guess, it is a problem from <a href=\"https://leetcode.com/problems/print-in-order/\" rel=\"nofollow noreferrer\">leetcode</a>.</p>\n<blockquote>\n<p>Currently I don't understand how to pass <code>Runnable</code> object to the synchronized methods (it's one the task conditions):</p>\n</blockquote>\n<p>The <code>runnable</code> could look like:</p>\n<pre><code>private static class PrintingRunnable implements Runnable {\n\n    private final String string;\n\n    public PrintingRunnable(String string) {\n        this.string = string;\n    }\n\n    @Override\n    public void run() {\n        System.out.print(string);\n    }\n}\n</code></pre>\n<p>and passed as:</p>\n<pre><code>foo.first(new PrintingRunnable(&quot;first&quot;));\nfoo.second(new PrintingRunnable(&quot;second&quot;));\nfoo.third(new PrintingRunnable(&quot;third&quot;));\n</code></pre>\n<hr />\n<p>Please note, that you are <strong>not required</strong> to supply your own <code>Runnable</code>s, or create <code>Thread</code>s to solve the problem, just implement the <code>first</code>, <code>second</code>, and <code>third</code> methods.</p>\n<hr />\n<p>In Java, <code>Runnable</code> is <em>nothing more</em> than some action that could be <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runnable.html#run()\" rel=\"nofollow noreferrer\"><code>run</code></a>. It may print something, or do anything else.</p>\n<p>It is possible that leetcode <strong>does not really print anything</strong>, but uses <em>something different to test submissions</em>. (And it does not matter for someone, who tries to solve the problem)</p>\n<p>But if you want to do it locally you can use the <code>PrintingRunnable</code> above:</p>\n<pre><code>public static void main(String[] args) throws InterruptedException {\n    Foo foo = new Foo();\n\n\n    new Thread(() -&gt; {\n        try {\n            foo.third(new PrintingRunnable(&quot;third&quot;));\n        } catch (InterruptedException exception) {\n            exception.printStackTrace();\n        }\n    }).start();\n    new Thread(() -&gt; {\n        try {\n            foo.first(new PrintingRunnable(&quot;first&quot;));\n        } catch (InterruptedException exception) {\n            exception.printStackTrace();\n        }\n    }).start();\n    new Thread(() -&gt; {\n        try {\n            foo.second(new PrintingRunnable(&quot;second&quot;));\n        } catch (InterruptedException exception) {\n            exception.printStackTrace();\n        }\n    }).start();\n}\n</code></pre>\n","answer_id":65382608,"question_id":65382129,"last_edit_date":1608485238},{"owner":{"profile_image":"https://i.stack.imgur.com/DLHqU.png?s=256&g=1","account_id":1223835,"user_type":"registered","user_id":1189885,"link":"https://stackoverflow.com/users/1189885/chrylis-cautiouslyoptimistic","reputation":75888,"display_name":"chrylis -cautiouslyoptimistic-","accept_rate":43},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":true,"last_activity_date":1608323859,"creation_date":1608323859,"body":"<p>You aren't &quot;assigning a function&quot; to it, you're <em>immediately evaluating</em> <code>someFunc</code> and placing the value (a reference to the list) in the <code>AtomicReference</code>.</p>\n<p>The atomic classes have special <em>happens-before</em> constraints, so anything that happens to the list in <code>someFunc</code> is guaranteed to be visible to anyone who retrieves the list from the reference, but your modifications to the list in your spawned thread have no <em>happens-before</em> relationship to the rest of your program. The behavior is undefined, up to and including <code>ConcurrentModificationException</code>.</p>\n","answer_id":65363616,"question_id":65363568},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG","account_id":2518243,"user_type":"registered","user_id":2189127,"link":"https://stackoverflow.com/users/2189127/james-d","reputation":203472,"display_name":"James_D"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1608232320,"creation_date":1608232320,"body":"<p>You can use a <a href=\"https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/CompletableFuture.html\" rel=\"nofollow noreferrer\"><code>CompletableFuture</code></a>:</p>\n<pre><code>public class USBDevice {\n    public Task&lt;Void&gt; readData() {\n        return new Task&lt;Void&gt;() {\n            @Override\n            protected Void call() throws Exception {\n\n                CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; {\n                    //read data through usb device and add it into array;\n                });\n                try {\n                    future.get(10, TimeUnit.SECONDS);\n                    // get here if read was successful\n                } catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                } catch (ExecutionException ee) {\n                    // exception was thrown by code reading usb device\n                } catch (TimeoutException te) {\n                    // timeout occurred\n                }\n                return null;\n            }\n        };\n    }\n}\n</code></pre>\n","answer_id":65346950,"question_id":65344341},{"owner":{"profile_image":"https://www.gravatar.com/avatar/2fe75f2132e516dbf8ee6de0097d765e?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":9374511,"user_type":"registered","user_id":8471807,"link":"https://stackoverflow.com/users/8471807/sachin-pete","reputation":21,"display_name":"Sachin Pete"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1603023508,"creation_date":1602962164,"body":"<pre><code>public class Print1To20 {\n\n    int couter=0;\n    static int N;\n\n    public void preven(){\n        synchronized (this) {\n            while(couter&lt;N) {\n                while(couter%2==0) {\n                    try {\n                        wait();\n                    } catch(Exception e) {\n                    }\n                    System.out.println(Thread.currentThread().getName()+&quot;:&quot;+couter);\n                }\n                couter++;\n                notify();\n            }\n        }\n    }\n    public void prodd(){\n        synchronized (this) {\n            while(couter&lt;N) {\n                while(couter%2==1) {\n                    try {\n                        wait();\n                    } catch(Exception e) {\n                    }\n                    System.out.println(Thread.currentThread().getName()+&quot;:&quot;+couter);\n                }\n                couter++;\n                notify();\n            }\n        }\n    }\n    \n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n\n        //  Thread t1= new Th;\n\n        //Thread t2= new Thread(new PrintOdd());\n\n        N=20;\n        Print1To20 pt= new Print1To20();\n        Thread t1= new Thread(new Runnable() {\n            @Override\n            public void run() {\n                // TODO Auto-generated method stub\n                pt.preven();\n            }\n        });\n\n        Thread t2= new Thread(new Runnable() {\n            @Override\n            public void run() {\n                // TODO Auto-generated method stub\n                pt.prodd();\n            }\n        });\n        t1.start();\n        t2.start();\n    }\n}\n</code></pre>\n<p>Ref: Reference taken from GeekforGeeks</p>\n","answer_id":64406380,"question_id":24720849,"last_edit_date":1603023508},{"owner":{"profile_image":"https://i.stack.imgur.com/o4wOg.jpg?s=256&g=1","account_id":3294086,"user_type":"registered","user_id":2771717,"link":"https://stackoverflow.com/users/2771717/autocrab","reputation":3607,"display_name":"Autocrab"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1602654131,"creation_date":1602654131,"body":"<p>It appears that your <code>runOnUiThread</code> code invokes after activity gets destroyed.</p>\n<p>You should check if activity is destroyed:</p>\n<pre><code>        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                final String folderSize = calculateFolderSize(); // my work\n                runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        if (!isDestroyed())\n                            textView.setText(folderSize + &quot; GB&quot;);\n                    }\n                });\n            }\n        });\n        thread.start();\n</code></pre>\n","answer_id":64347286,"question_id":64346783},{"owner":{"profile_image":"https://www.gravatar.com/avatar/54af3ad01b032767b05a7e98fede6d6e?s=256&d=identicon&r=PG","account_id":2360785,"user_type":"registered","user_id":2067492,"link":"https://stackoverflow.com/users/2067492/matt","reputation":11123,"display_name":"matt"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1601634137,"creation_date":1601630447,"body":"<p>Can we think of the arrow as a resource?</p>\n<pre><code>import java.util.concurrent.*;\n\n\npublic class Bowmen implements Runnable{\n    String name;\n    Bowmen target;\n    SynchronousQueue&lt;Object&gt; queue = new SynchronousQueue&lt;&gt;();\n    public Bowmen(String name){\n        this.name = name;\n    }\n    \n    public void shoot(String name, Object o) throws InterruptedException{\n        System.out.println(this.name + &quot; : &quot; + name + &quot; shot me.&quot;);\n        queue.put(o);\n    }\n    \n    public void run(){\n        try{\n            Object o = queue.take();\n            System.out.println(this.name + &quot; : I will shoot &quot; + target.name);\n            target.shoot(name, o);\n        } catch(InterruptedException e){\n            //just finish.\n        }\n    }\n    public void setTarget(Bowmen t){\n        target = t;\n    }\n    \n    public static void main(String[] args) throws Exception{\n        \n        Bowmen a = new Bowmen(&quot;a&quot;);\n        Bowmen b = new Bowmen(&quot;b&quot;);\n        \n        a.setTarget(b);\n        b.setTarget(a);\n        \n        for(int i = 0; i&lt;5; i++){\n            new Thread(a).start();\n            new Thread(b).start();\n        }\n        //all the threads are waiting because there is no resource to share yet.\n        a.shoot( null, new Object() );\n    }\n\n}\n</code></pre>\n<p>This will produce output</p>\n<blockquote>\n<p>a : null shot me.<br />\na : I will shoot b<br />\nb : a shot me.<br />\nb : I will shoot a<br />\n...</p>\n</blockquote>\n<p>It will end with &quot;a : b shot me.&quot; but the program will not finish because there isn't a thread taking from the queue to let the last call to shoot finish.</p>\n","answer_id":64169128,"question_id":64163535,"last_edit_date":1601634137},{"owner":{"profile_image":"https://www.gravatar.com/avatar/8a60e0393575feef649748f8f2e95c62?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6925906,"user_type":"registered","user_id":5317000,"link":"https://stackoverflow.com/users/5317000/suresh-mahalingam","reputation":95,"display_name":"Suresh Mahalingam"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1601563360,"creation_date":1600067590,"body":"<p>A round robin among N producers can be achieved using a PriorityBlockingQueue as follows.</p>\n<p>Maintain N AtomicInteger counters for each of the producers and a global counter as a tie breaker in case the producer counters are equal.</p>\n<p>When adding to the Q incement counter for the producer and also global counter and store into Q object. The comparator for Q will order based on Producer counter 1st and then the global counter value stored in the Q object.</p>\n<p>However when objects of one producer is empty for sometime in the Q the corresponding counter falls behind and it will start hogging the Q when objects start coming in.</p>\n<p>To avoid this maintain a volatile variable which is updated with the producer counter of the object when de-queued. After incrementing the producer counter during en-queue if the value is less than the last de-queued counter in volatile variable reset the counter to that value + 1.</p>\n","answer_id":63879647,"question_id":27737781,"last_edit_date":1601563360},{"owner":{"profile_image":"https://www.gravatar.com/avatar/16b7172bb346958c1b69e0229ba1ac4f?s=256&d=identicon&r=PG","account_id":1723085,"user_type":"registered","user_id":1578356,"link":"https://stackoverflow.com/users/1578356/newday","reputation":3842,"display_name":"newday","accept_rate":63},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1601527340,"creation_date":1601527340,"body":"<p>after using the get(1, TimeUnit.SECONDS); I started to see improvement on the server side as well (Reaching the threads less than 1 second) since we are not waiting more than 1 second on the client side.</p>\n<pre><code>while (true) {\n    clientMonitorServicesMap.forEach((k, v) -&gt; {\n      Future&lt;Boolean&gt; val = scheduledExecutorService.submit(new PollService(k));\n      try {\n        boolean result = val.get(1, TimeUnit.SECONDS);\n        System.out.println(&quot;service &quot; + k.getHost() + &quot;:&quot; + k.getPort() + &quot;status is &quot; + result);\n        if (result) {\n          List&lt;ClientMonitorService&gt; list = v.stream()\n                  //.filter(a -&gt; LocalDateTime.now().getSecond() % a.getServiceToMonitor().getFreqSec() == 0)\n                  .collect(Collectors.toList());\n          list.stream().forEach(a -&gt; System.out.println(a.getClientId()));\n        }\n\n      } catch (InterruptedException e) {\n       logger.log(Level.WARNING,&quot;Interrupted -&gt; &quot; + k.getHost()+&quot;:&quot;+k.getPort());\n      } catch (ExecutionException e) {\n        logger.log(Level.INFO,&quot;ExecutionException exception -&gt; &quot;+ k.getHost()+&quot;:&quot;+k.getPort());\n      } catch (TimeoutException e) {\n        logger.log(Level.INFO,&quot;TimeoutException exception -&gt; &quot;+ k.getHost()+&quot;:&quot;+k.getPort());\n      }\n\n    });\n  }\n</code></pre>\n","answer_id":64149186,"question_id":64112611},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG","account_id":401843,"user_type":"registered","user_id":768644,"link":"https://stackoverflow.com/users/768644/rzwitserloot","reputation":89863,"display_name":"rzwitserloot"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1601482101,"creation_date":1601482101,"body":"<p>The answer is non-trivial; the fact that there is a parent/child relationship between the threads is itself misleading. Threads don't as a rule care or get any special relationship with the thread that spawned it at all.</p>\n<p>Thus, the answer is a mix of: &quot;Parent/Child? I'm not sure those are appropriate terms to apply to the concept of 'a thread that is going to spawn another thread' and 'the thread that it spawned'&quot;, and &quot;the same way any two threads communicate with each other: Carefully, probably via things in the <code>java.util.concurrent</code> package, and really optimally threads should never communicate except through communication channels with built in transactional support, such as a database, or message queue libraries like rabbitMQ.</p>\n","answer_id":64141533,"question_id":64141492},{"owner":{"profile_image":"https://www.gravatar.com/avatar/8bea1f01a8f41b0714de4eddc3c93ce8?s=256&d=identicon&r=PG","account_id":11180480,"user_type":"registered","user_id":8207228,"link":"https://stackoverflow.com/users/8207228/ralf-kleberhoff","reputation":7021,"display_name":"Ralf Kleberhoff"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1601481197,"creation_date":1601481197,"body":"<p>From the code you posted, I see two places where you seem to get stuck:</p>\n<ul>\n<li>Filling out the <code>run()</code> method in the <code>ColumnCalculator</code>.</li>\n<li>Using threads with the <code>ColumnCalculator</code> to get the multiplication result.</li>\n</ul>\n<p>From the comment inside <code>ColumnCalculator</code> I deduce that its duty is to compute one specific column of the result matrix. So, for e.g. a 5-columns matrix, you need five <code>ColumnCalculator</code> instances to get the complete result.</p>\n<h2>ColumnCalculator.run()</h2>\n<p>Put in code that does the matrix multiplication, not for all columns, but only for the column <code>col_idx</code>. That means: copy the code from multiplyBy() and strip it down so that it doesn't loop over all result columns.</p>\n<h2>Matrix.multiplyByThreads()</h2>\n<p>Instead of using a fixed number of threads, I'd start with a simpler approach:</p>\n<p>For each column in the result, create one ColumnCalculator and one thread, and have that thread run that calculator.</p>\n<p>And then wait for all of them to finish.</p>\n<p>When you've mastered that approach and like to continue, then an optimization might be to limit the number of threads to e.g. 10 and have them compute result columns until they're all done, but I recommend to start with the simpler approach.</p>\n","answer_id":64141295,"question_id":64140757},{"owner":{"profile_image":"https://www.gravatar.com/avatar/cbf3044a40d8139345d51081d5fc4517?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6838496,"user_type":"registered","user_id":5259625,"link":"https://stackoverflow.com/users/5259625/gen","reputation":2450,"display_name":"Gen","accept_rate":56},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1601465970,"creation_date":1601465970,"body":"<p>if you need simultaneous execution and each time new thread you can find the solution here</p>\n<pre><code>public class SleepClass {\n    public static void main(String[] args) {\n        SleepClass s= new SleepClass();\n        s.m2(500);\n        s.m2(1000);\n    }\n    \n    public void m2(int time) {\n        SleepClass s= new SleepClass();\n        new Thread(() -&gt; {\n            s.m1(time);\n        }).start();\n    }\n    \n    public void m1(int time) {\n        \n        for(int i = 0; i&lt;= 10; i++) {\n            System.out.println(i);\n            try {\n                Thread.sleep(time);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        \n    }\n\n}\n</code></pre>\n","answer_id":64136807,"question_id":64134839},{"owner":{"profile_image":"https://www.gravatar.com/avatar/964b3f08a9f4f4b76d14b5eb33190038?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":4501201,"user_type":"registered","user_id":3659670,"link":"https://stackoverflow.com/users/3659670/conffusion","reputation":4375,"display_name":"Conffusion"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1601461731,"creation_date":1601461731,"body":"<p>You have to put your logic in a Runnable and launch it using new <code>Thread(runnable).start()</code>.\nTo pass parameters to each runnable define them as class variables so you can pass them via the constructor and use them in the <code>run</code> method:</p>\n<pre><code>public class SleepClass {\n\n    public static void main(String[] args) {\n        SleepClass s= new SleepClass();\n        s.m1(10000);\n        s.m1(20000);\n    }\n    \n    public void m1(int time) {\n        for(int i = 0; i&lt; 3; i++) {\n            new Thread(new Launcher(i,time)).start();\n        }\n    }\n\n    public class Launcher implements Runnable {\n        int i;\n        int time;\n        public Launcher(int i, int time) {\n            this.i=i;\n            this.time=time;\n        }\n        @Override\n        public void run() {\n            System.out.println(i);\n            try {\n                Thread.sleep(time);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }                   \n        }\n        \n    }\n}\n</code></pre>\n","answer_id":64135639,"question_id":64134839},{"owner":{"profile_image":"https://i.stack.imgur.com/HbwqU.jpg?s=256&g=1","account_id":4264857,"user_type":"registered","user_id":3488208,"link":"https://stackoverflow.com/users/3488208/surendar-d","reputation":5594,"display_name":"Surendar D","accept_rate":20},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1599478405,"creation_date":1563439626,"body":"<p>Please try this once.</p>\n<ol>\n<li>Create a drawable file splash_background.xml</li>\n</ol>\n\n<pre><code>&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;\n\n    &lt;item android:drawable=&quot;@color/{your color}&quot; /&gt;\n\n    &lt;item&gt;\n        &lt;bitmap\n            android:layout_width=&quot;@dimen/size_250&quot;\n            android:layout_height=&quot;@dimen/size_100&quot;\n            android:gravity=&quot;center&quot;\n            android:scaleType=&quot;fitXY&quot;\n            android:src=&quot;{your image}&quot;\n            android:tint=&quot;@color/colorPrimary&quot; /&gt;\n    &lt;/item&gt;\n\n&lt;/layer-list&gt;\n</code></pre>\n<ol start=\"2\">\n<li><p>Put this in styles.xml</p>\n<pre><code>  &lt;style name=&quot;SplashTheme&quot; parent=&quot;Theme.AppCompat.NoActionBar&quot;&gt;\n      &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/splash_background&lt;/item&gt;\n  &lt;/style&gt;\n</code></pre>\n</li>\n<li><p>In your AndroidMainfest.xml set the above theme to Launch activity.</p>\n<pre><code>    &lt;activity\n         android:name=&quot;.SplashScreenActivity&quot;\n         android:screenOrientation=&quot;portrait&quot;\n         android:theme=&quot;@style/SplashTheme&quot;\n         android:windowSoftInputMode=&quot;stateVisible|adjustResize&quot;&gt;\n         &lt;intent-filter&gt;\n             &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;\n\n             &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;\n         &lt;/intent-filter&gt;\n     &lt;/activity&gt;\n</code></pre>\n</li>\n</ol>\n","answer_id":57090517,"question_id":37437037,"last_edit_date":1599478405},{"owner":{"profile_image":"https://i.stack.imgur.com/jgnbc.jpg?s=256&g=1","account_id":2174289,"user_type":"registered","user_id":1925388,"link":"https://stackoverflow.com/users/1925388/anmol-singh-jaggi","reputation":8434,"display_name":"Anmol Singh Jaggi","accept_rate":81},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1597191007,"creation_date":1597176994,"body":"<p>We can create a DAG where each vertex of the graph is one of the tasks.<br />\nAfter that, we can compute its <a href=\"https://en.wikipedia.org/wiki/Topological_sorting#:%7E:text=In%20computer%20science%2C%20a%20topological,before%20v%20in%20the%20ordering.\" rel=\"nofollow noreferrer\">topological sorted</a> order.<br />\nWe can then decorate the Task class with a priority field and run the <code>ThreadPoolExecutor</code> with a <code>PriorityBlockingQueue</code> which compares Tasks using the priority field.</p>\n<p>The final trick is to override <code>run()</code> to first wait for all the dependent tasks to finish.</p>\n<p>Since each task waits indefinitely for its dependent tasks to finish, we cannot afford to let the thread-pool be completely occupied with tasks that are higher up in the topological sort order; the thread pool will get stuck forever.<br />\nTo avoid this, we just have to assign priorities to tasks according to the topological order.</p>\n<pre class=\"lang-java prettyprint-override\"><code>import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\nimport java.util.concurrent.PriorityBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\n\npublic class Testing {\n\n  private static Callable&lt;Void&gt; getCallable(String taskId){\n    return () -&gt; {\n      System.out.println(String.format(&quot;Task %s result&quot;, taskId));\n      Thread.sleep(100);\n      return null;\n    };\n  }\n\n  public static void main(String[] args) throws ExecutionException, InterruptedException {\n    Callable&lt;Void&gt; taskA = getCallable(&quot;A&quot;);\n    Callable&lt;Void&gt; taskB = getCallable(&quot;B&quot;);\n    Callable&lt;Void&gt; taskC = getCallable(&quot;C&quot;);\n    Callable&lt;Void&gt; taskD = getCallable(&quot;D&quot;);\n    Callable&lt;Void&gt; taskE = getCallable(&quot;E&quot;);\n    PrioritizedFutureTask&lt;Void&gt; pfTaskA = new PrioritizedFutureTask&lt;&gt;(taskA);\n    PrioritizedFutureTask&lt;Void&gt; pfTaskB = new PrioritizedFutureTask&lt;&gt;(taskB);\n    PrioritizedFutureTask&lt;Void&gt; pfTaskC = new PrioritizedFutureTask&lt;&gt;(taskC);\n    PrioritizedFutureTask&lt;Void&gt; pfTaskD = new PrioritizedFutureTask&lt;&gt;(taskD);\n    PrioritizedFutureTask&lt;Void&gt; pfTaskE = new PrioritizedFutureTask&lt;&gt;(taskE);\n    // Create a DAG graph.\n    pfTaskB.addDependency(pfTaskC).addDependency(pfTaskE);\n    pfTaskA.addDependency(pfTaskB).addDependency(pfTaskC).addDependency(pfTaskD);\n    // Now that we have a graph, we can just get its topological sorted order.\n    List&lt;PrioritizedFutureTask&lt;Void&gt;&gt; topological_sort = new ArrayList&lt;&gt;();\n    topological_sort.add(pfTaskE);\n    topological_sort.add(pfTaskC);\n    topological_sort.add(pfTaskB);\n    topological_sort.add(pfTaskD);\n    topological_sort.add(pfTaskA);\n    ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,\n        new PriorityBlockingQueue&lt;Runnable&gt;(1, new CustomRunnableComparator()));\n    // Its important to insert the tasks in the topological sorted order, otherwise its possible that the thread pool will be stuck forever.\n    for (int i = 0; i &lt; topological_sort.size(); i++) {\n      PrioritizedFutureTask&lt;Void&gt; pfTask = topological_sort.get(i);\n      pfTask.setPriority(i);\n      // The lower the priority, the sooner it will run.\n      executor.execute(pfTask);\n    }\n  }\n}\n\nclass PrioritizedFutureTask&lt;T&gt; extends FutureTask&lt;T&gt; implements Comparable&lt;PrioritizedFutureTask&lt;T&gt;&gt; {\n\n  private Integer _priority = 0;\n  private final Callable&lt;T&gt; callable;\n  private final List&lt;PrioritizedFutureTask&gt; _dependencies = new ArrayList&lt;&gt;();\n  ;\n\n  public PrioritizedFutureTask(Callable&lt;T&gt; callable) {\n    super(callable);\n    this.callable = callable;\n  }\n\n  public PrioritizedFutureTask(Callable&lt;T&gt; callable, Integer priority) {\n    this(callable);\n    _priority = priority;\n  }\n\n  public Integer getPriority() {\n    return _priority;\n  }\n\n  public PrioritizedFutureTask&lt;T&gt; setPriority(Integer priority) {\n    _priority = priority;\n    return this;\n  }\n\n  public PrioritizedFutureTask&lt;T&gt; addDependency(PrioritizedFutureTask dep) {\n    this._dependencies.add(dep);\n    return this;\n  }\n\n  @Override\n  public void run() {\n    for (PrioritizedFutureTask dep : _dependencies) {\n      try {\n        dep.get();\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n      } catch (ExecutionException e) {\n        e.printStackTrace();\n      }\n    }\n    super.run();\n  }\n\n  @Override\n  public int compareTo(PrioritizedFutureTask&lt;T&gt; other) {\n    if (other == null) {\n      throw new NullPointerException();\n    }\n    return getPriority().compareTo(other.getPriority());\n  }\n}\n\nclass CustomRunnableComparator implements Comparator&lt;Runnable&gt; {\n  @Override\n  public int compare(Runnable task1, Runnable task2) {\n    return ((PrioritizedFutureTask) task1).compareTo((PrioritizedFutureTask) task2);\n  }\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>Task E result\nTask C result\nTask B result\nTask D result\nTask A result\n</code></pre>\n<p>PS: <a href=\"https://github.com/Anmol-Singh-Jaggi/interview-notes/tree/master/notes/algo-ds-practice/problems/graph/standard/topo_sort\" rel=\"nofollow noreferrer\">Here</a> is a well-tested and simple implementation of topological sort in Python which you can easily port in Java.</p>\n","answer_id":63365785,"question_id":63354899,"last_edit_date":1597191007},{"owner":{"profile_image":"https://www.gravatar.com/avatar/901954b4bf4f56918ed39a925018c8d7?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":18497209,"user_type":"registered","user_id":13475352,"link":"https://stackoverflow.com/users/13475352/sergey-rymsha","reputation":91,"display_name":"Sergey Rymsha"},"content_license":"CC BY-SA 4.0","score":9,"is_accepted":false,"last_activity_date":1588799345,"creation_date":1588799345,"body":"<p>I run into the same issue and found the\n<a href=\"https://bugs.openjdk.java.net/browse/JDK-8241054\" rel=\"noreferrer\">bug report</a></p>\n\n<p>It is awaiting JDK 11.0.8 release.</p>\n","answer_id":61645456,"question_id":54485755},{"owner":{"profile_image":"https://www.gravatar.com/avatar/63f6b4cb480178c6809b5bbeae5a2429?s=256&d=identicon&r=PG","account_id":1242750,"user_type":"registered","user_id":1204940,"link":"https://stackoverflow.com/users/1204940/abhishek","reputation":642,"display_name":"Abhishek"},"content_license":"CC BY-SA 4.0","score":-1,"is_accepted":false,"last_activity_date":1588240348,"creation_date":1588240348,"body":"<p>I know this is very late to answer, but I think it will help many. \nYou can check for the existing socket if any by below code.</p>\n\n<pre><code>SocketAddress socketAddress = new InetSocketAddress(\"localhost\", 8091);\n    Socket socket = new Socket();\n    ServerSocket serverSocket = null;\n    try {\n        socket.connect(socketAddress);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    if(socket == null) {\n        try {\n            serverSocket = new ServerSocket(8091);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n</code></pre>\n\n<p>if not found a active socket on the same port and IP then it will start a new server socket or you can change it start socket only else you can connect to the existing socket.</p>\n","answer_id":61520614,"question_id":40197514},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c324bc64b1ba9913b27c9a89d9fc62c9?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8571883,"user_type":"registered","user_id":6422459,"link":"https://stackoverflow.com/users/6422459/digitshifter","reputation":821,"display_name":"DigitShifter"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1581801207,"creation_date":1581801207,"body":"<p><strong>Try this small example, to get a feel for ThreadLocal variable:</strong><br>\n<br></p>\n\n<pre><code>public class Book implements Runnable {\n    private static final ThreadLocal&lt;List&lt;String&gt;&gt; WORDS = ThreadLocal.withInitial(ArrayList::new);\n\n    private final String bookName; // It is also the thread's name\n    private final List&lt;String&gt; words;\n\n\n    public Book(String bookName, List&lt;String&gt; words) {\n        this.bookName = bookName;\n        this.words = Collections.unmodifiableList(words);\n    }\n\n    public void run() {\n        WORDS.get().addAll(words);\n        System.out.printf(\"Result %s: '%s'.%n\", bookName, String.join(\", \", WORDS.get()));\n    }\n\n    public static void main(String[] args) {\n        Thread t1 = new Thread(new Book(\"BookA\", Arrays.asList(\"wordA1\", \"wordA2\", \"wordA3\")));\n        Thread t2 = new Thread(new Book(\"BookB\", Arrays.asList(\"wordB1\", \"wordB2\")));\n        t1.start();\n        t2.start();\n    }\n}\n</code></pre>\n\n<p><br>\n<strong>Console output, if thread BookA is done first:</strong><br>\nResult BookA: 'wordA1, wordA2, wordA3'.<br>\nResult BookB: 'wordB1, wordB2'.<br>\n<br>\n<strong>Console output, if thread BookB is done first:</strong><br>\nResult BookB: 'wordB1, wordB2'.<br>\nResult BookA: 'wordA1, wordA2, wordA3'.<br>\n<br></p>\n","answer_id":60243198,"question_id":817856},{"owner":{"profile_image":"https://i.stack.imgur.com/X1Q3J.jpg?s=256&g=1","account_id":2593996,"user_type":"registered","user_id":2248045,"link":"https://stackoverflow.com/users/2248045/hitesh-singh","reputation":1971,"display_name":"Hitesh Singh"},"content_license":"CC BY-SA 4.0","score":126,"is_accepted":false,"last_activity_date":1575439237,"creation_date":1465455372,"body":"<p>please add this line into your app theme </p>\n\n<pre><code>&lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;\n</code></pre>\n\n<p>for more information : <a href=\"https://developer.android.com/topic/performance/vitals/launch-time#themed\" rel=\"noreferrer\">https://developer.android.com/topic/performance/vitals/launch-time#themed</a></p>\n","answer_id":37718830,"question_id":37437037,"last_edit_date":1575439237},{"owner":{"profile_image":"https://i.stack.imgur.com/K5WPD.jpg?s=256&g=1","account_id":1298254,"user_type":"registered","user_id":1248724,"link":"https://stackoverflow.com/users/1248724/zarathustra","reputation":2903,"display_name":"Zarathustra","accept_rate":67},"content_license":"CC BY-SA 4.0","score":10,"is_accepted":true,"last_activity_date":1569863738,"creation_date":1549993709,"body":"<p>As @jspcal said before disable TLS 1.3.</p>\n\n<p><strong>tl;dr</strong>: disable tlsv1.3 via extending/overwriting </p>\n\n<p><code>&lt;java_home&gt;/conf/security/java.security</code> the <code>jdk.tls.disabledAlgorithms</code> property</p>\n\n<p>Since my application is running in a docker container I changed the base image to disable tls1.3</p>\n\n<pre><code>FROM openjdk:11-jre\n...\n\nRUN sed -i \"/jdk.tls.disabledAlgorithms=/ s/=.*/=TLSv1.3, SSLv3, RC4, MD5withRSA, DH keySize &lt; 1024, EC keySize &lt; 224, DES40_CBC, RC4_40, 3DES_EDE_CBC/\" $(readlink -f /usr/bin/java | sed \"s:bin/java::\")/conf/security/java.security\n</code></pre>\n\n<p>As far as I know there is no way of setting this (security) property via a system property! See also <code>sun.security.util.DisabledAlgorithmConstraints#PROPERTY_TLS_DISABLED_ALGS</code> which actually ready the property.</p>\n\n<p><strong>Update</strong>: Bug is still present in 11.0.2</p>\n","answer_id":54655885,"question_id":54485755,"last_edit_date":1569863738},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c2aa0c3f639d473d15b08c2cafc9188c?s=256&d=identicon&r=PG","account_id":174482,"user_type":"registered","user_id":403872,"link":"https://stackoverflow.com/users/403872/abhijit-gaikwad","reputation":3102,"display_name":"Abhijit Gaikwad","accept_rate":83},"content_license":"CC BY-SA 4.0","score":15,"is_accepted":false,"last_activity_date":1557882823,"creation_date":1372659023,"body":"<ol>\n<li><p>ThreadLocal in Java had been introduced on JDK 1.2 but was later generified in JDK 1.5 to introduce type safety on ThreadLocal variable.</p></li>\n<li><p>ThreadLocal can be associated with Thread scope, all the code which is executed by Thread has access to ThreadLocal variables but two thread can not see each others ThreadLocal variable.</p></li>\n<li><p>Each thread holds an exclusive copy of ThreadLocal variable which becomes eligible to Garbage collection after thread finished or died, normally or due to any Exception, Given those ThreadLocal variable doesn't have any other live references.</p></li>\n<li><p>ThreadLocal variables in Java are generally private static fields in Classes and maintain its state inside Thread.</p></li>\n</ol>\n\n<p>Read more: <a href=\"https://javarevisited.blogspot.com/2012/05/how-to-use-threadlocal-in-java-benefits.html#ixzz2XltgbHTK\" rel=\"noreferrer\">ThreadLocal in Java - Example Program and Tutorial</a></p>\n","answer_id":17398338,"question_id":817856,"last_edit_date":1557882823},{"owner":{"profile_image":"https://www.gravatar.com/avatar/72641170cc9abff008d21ac50894803b?s=256&d=identicon&r=PG","account_id":20470,"user_type":"registered","user_id":48933,"link":"https://stackoverflow.com/users/48933/neil-coffey","reputation":21695,"display_name":"Neil Coffey","accept_rate":90},"content_license":"CC BY-SA 4.0","score":20,"is_accepted":false,"last_activity_date":1557882784,"creation_date":1241394605,"body":"<p>Essentially, when you need a <strong>variable's value to depend on the current thread</strong> and it <strong>isn't convenient for you to attach the value to the thread in some other way</strong> (for example, subclassing thread).</p>\n\n<p>A typical case is where <strong>some other framework has created the thread</strong> that your code is running in, e.g. a servlet container, or where it just makes more sense to use ThreadLocal because your variable is then \"in its logical place\" (rather than a variable hanging from a Thread subclass or in some other hash map).</p>\n\n<p>On my web site, I have some further <a href=\"https://www.javamex.com/tutorials/synchronization_concurrency_thread_local3.shtml\" rel=\"noreferrer\">discussion and examples of when to use ThreadLocal</a> that may also be of interest.</p>\n\n<p>Some people advocate using ThreadLocal as a way to attach a \"thread ID\" to each thread in certain concurrent algorithms where you need a thread number (see e.g. Herlihy &amp; Shavit). In such cases, check that you're really getting a benefit!</p>\n","answer_id":818364,"question_id":817856,"last_edit_date":1557882784},{"owner":{"profile_image":"https://www.gravatar.com/avatar/520c9c078b8d25980de17b8d4fe0ceba?s=256&d=identicon&r=PG","account_id":24436,"user_type":"registered","user_id":62130,"link":"https://stackoverflow.com/users/62130/esko-luontola","reputation":73314,"display_name":"Esko Luontola","accept_rate":39},"content_license":"CC BY-SA 4.0","score":200,"is_accepted":false,"last_activity_date":1557882754,"creation_date":1241444172,"body":"<p>Many frameworks use ThreadLocals to maintain some context related to the current thread. For example when the current transaction is stored in a ThreadLocal, you don't need to pass it as a parameter through every method call, in case someone down the stack needs access to it. Web applications might store information about the current request and session in a ThreadLocal, so that the application has easy access to them. With Guice you can use ThreadLocals when implementing <a href=\"https://github.com/google/guice/wiki/CustomScopes\" rel=\"noreferrer\">custom scopes</a> for the injected objects (Guice's default <a href=\"https://github.com/google/guice/wiki/Scopes\" rel=\"noreferrer\">servlet scopes</a> most probably use them as well).</p>\n\n<p>ThreadLocals are one sort of global variables (although slightly less evil because they are restricted to one thread), so you should be careful when using them to avoid unwanted side-effects and memory leaks. Design your APIs so that the ThreadLocal values will always be automatically cleared when they are not needed anymore and that incorrect use of the API won't be possible (for example <a href=\"https://github.com/orfjackal/dimdwarf/blob/453f7aee9efc364ebad80531c05081e255323c07/dimdwarf-core/src/main/java/net/orfjackal/dimdwarf/context/ThreadContext.java#L48-55\" rel=\"noreferrer\">like this</a>). ThreadLocals can be used to make the code cleaner, and in some rare cases they are the only way to make something work (my current project had two such cases; they are documented <a href=\"https://github.com/orfjackal/dimdwarf/wiki/Design-Guidelines\" rel=\"noreferrer\">here</a> under \"Static Fields and Global Variables\").</p>\n","answer_id":820131,"question_id":817856,"last_edit_date":1557882754},{"owner":{"profile_image":"https://www.gravatar.com/avatar/7ccd45f17734f7d050a186468bdc38eb?s=256&d=identicon&r=PG","account_id":25274,"user_type":"registered","user_id":64881,"link":"https://stackoverflow.com/users/64881/phil-m","reputation":6653,"display_name":"Phil M"},"content_license":"CC BY-SA 4.0","score":458,"is_accepted":false,"last_activity_date":1557882643,"creation_date":1241388129,"body":"<p>Since a <code>ThreadLocal</code> is a reference to data within a given <code>Thread</code>, you can end up with classloading leaks when using <code>ThreadLocal</code>s in application servers using thread pools. You need to be very careful about cleaning up any <code>ThreadLocal</code>s you <code>get()</code> or <code>set()</code> by using the <code>ThreadLocal</code>'s <code>remove()</code> method.</p>\n\n<p>If you do not clean up when you're done, any references it holds to classes loaded as part of a deployed webapp will remain in the <a href=\"https://web.archive.org/web/20070104122432/http://www.brokenbuild.com/blog/2006/08/04/java-jvm-gc-permgen-and-memory-options/\" rel=\"noreferrer\">permanent heap</a> and will never get garbage collected. Redeploying/undeploying the webapp will not clean up each <code>Thread</code>'s reference to your webapp's class(es) since the <code>Thread</code> is not something owned by your webapp. Each successive deployment will create a new instance of the class which will never be garbage collected.</p>\n\n<p>You will end up with out of memory exceptions due to <code>java.lang.OutOfMemoryError: PermGen space</code> and after some googling will probably just increase <code>-XX:MaxPermSize</code> instead of fixing the bug.</p>\n\n<p>If you do end up experiencing these problems, you can determine which thread and class is retaining these references by using <a href=\"http://www.eclipse.org/mat/\" rel=\"noreferrer\">Eclipse's Memory Analyzer</a> and/or by following <a href=\"http://frankkieviet.blogspot.com/2006/10/classloader-leaks-dreaded-permgen-space.html\" rel=\"noreferrer\">Frank Kieviet's guide</a> and <a href=\"http://frankkieviet.blogspot.com/2006/10/how-to-fix-dreaded-permgen-space.html\" rel=\"noreferrer\">followup</a>.</p>\n\n<p>Update: Re-discovered <a href=\"http://avasseur.blogspot.com/2003/11/threadlocal-and-memory-leaks.html\" rel=\"noreferrer\">Alex Vasseur's blog entry</a> that helped me track down some <code>ThreadLocal</code> issues I was having.</p>\n","answer_id":818120,"question_id":817856,"last_edit_date":1557882643},{"owner":{"profile_image":"https://i.stack.imgur.com/RDWxl.png?s=256&g=1","account_id":4342327,"user_type":"registered","user_id":3545273,"link":"https://stackoverflow.com/users/3545273/serge-ballesta","reputation":145474,"display_name":"Serge Ballesta","accept_rate":100},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1551107156,"creation_date":1405248589,"body":"<p>You are misusing <code>synchronized</code> and <code>wait</code> by calling wait on the object you used in <code>synchronized</code>, immediately, without having a check <em>inside</em> the synchronized block in a loop. <strong>NEVER DO THAT AGAIN</strong>. </p>\n\n<p>In fact here's what happen :</p>\n\n<ul>\n<li>at <code>synchronized</code> line you get a lock on <code>Constants.lock</code></li>\n<li>at <code>wait</code> line, you <strong>release</strong> the lock on <code>Constants.lock</code> and wait for a notify from another thread.</li>\n</ul>\n\n<p>So what is happening in your prog :</p>\n\n<ul>\n<li>first thread (no matter what it is) reaches <code>synchronized</code> and proceed blocking the second</li>\n<li>first thread releases the synchonizing lock and put itself in a wait state for a notify</li>\n<li>second thread goes through <code>synchronized</code> because first has released the lock</li>\n<li>both thread are now waiting for a notify that will never occur</li>\n</ul>\n","answer_id":24721873,"question_id":24720849,"last_edit_date":1551107156},{"owner":{"profile_image":"https://lh3.googleusercontent.com/-wzV0pRRmQn4/AAAAAAAAAAI/AAAAAAAAG9E/XR0AzCzVUSg/photo.jpg?sz=256","account_id":13384743,"user_type":"registered","user_id":9658981,"link":"https://stackoverflow.com/users/9658981/manav-sharma","reputation":11,"display_name":"Manav Sharma"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1551105690,"creation_date":1551105167,"body":"<p>Everyone on the Stack Overflow tried the same solution. Checkout a different implementation for the same.</p>\n\n<pre><code>public class PrintSequenceUsingTwo {\n\n    public static void main(String[] args) {\n        ThreadSequence sequence = new ThreadSequence();\n        Thread t1 = new Thread(()-&gt; {try {\n            sequence.print();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }},\"t1\");\n        Thread t2 = new Thread(()-&gt; {try {\n            sequence.print();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }},\"t2\");\n\n        t1.start();\n        t2.start();\n        try {\n            t1.join();\n            t2.join();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>\n\n<hr>\n\n<pre><code>class ThreadSequence {\n\n    private static int var = 0; \n    private int limit = 10;     //set the variable value upto which you want to print\n\n    public synchronized void print() throws InterruptedException {\n        while (var&lt;limit) {\n            notify();\n            System.out.println(\"Current Thread \"+Thread.currentThread().getName()+\" Value : \"+(++var));\n            wait();\n        }\n        notify();\n    }\n}\n</code></pre>\n","answer_id":54868462,"question_id":24720849,"last_edit_date":1551105690},{"owner":{"profile_image":"https://i.stack.imgur.com/VoV9s.jpg?s=256&g=1","account_id":485625,"user_type":"registered","user_id":902036,"link":"https://stackoverflow.com/users/902036/dz902","reputation":5104,"display_name":"dz902","accept_rate":60},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1550734743,"creation_date":1550734743,"body":"<p>This is interesting as the name \"readlock\" or \"reader-lock\" is probably a bit misleading.</p>\n\n<p>I found it easier to think it as a <strong>mode switch</strong>, you switch to <em>read-only mode</em>, or <em>write-only mode</em>. You switch mode by acquiring corresponding locks.</p>\n","answer_id":54801639,"question_id":33384822},{"owner":{"profile_image":"https://i.stack.imgur.com/vTEma.jpg?s=256&g=1","account_id":4208732,"user_type":"registered","user_id":3447032,"link":"https://stackoverflow.com/users/3447032/gokareless","reputation":1205,"display_name":"gokareless"},"content_license":"CC BY-SA 4.0","score":7,"is_accepted":false,"last_activity_date":1549897683,"creation_date":1549897683,"body":"<p>Duplicating <strong>@Solomon Slow</strong> comment here, as it helped me personally:</p>\n\n<blockquote>\n  <p>Read locks and write locks come in pairs: If thread <strong>R</strong> holds a <em>read lock</em>, it <strong>blocks</strong> thread <strong>W</strong> from obtaining the corresponding <em>write lock</em>, but it <strong>does not block</strong> thread <strong>S</strong> from getting the same <em>read lock</em>. A reader/writer lock pair allows any number of readers to \"own\" the read lock at the same time, OR it allows one writer to own the write lock, but it never allows a reader and a writer at the same time, and it never allows more than one writer at the same time.</p>\n</blockquote>\n","answer_id":54633486,"question_id":33384822},{"owner":{"profile_image":"https://www.gravatar.com/avatar/097d761861529df52a6800744f1074d2?s=256&d=identicon&r=PG","account_id":84127,"user_type":"registered","user_id":235354,"link":"https://stackoverflow.com/users/235354/jspcal","reputation":51115,"display_name":"jspcal"},"content_license":"CC BY-SA 4.0","score":9,"is_accepted":false,"last_activity_date":1549048805,"creation_date":1549048805,"body":"<p>Try disabling <code>TLSv1.3</code> or <code>SSLv3</code> to see if that helps.</p>\n\n<p>Set the system property on the command line: <code>-Djdk.tls.disabledAlgorithms=TLSv1.3</code></p>\n\n<p>Or define the property in <code>&lt;java_home&gt;/conf/security/java.security</code></p>\n\n<p>If you think it's an implementation bug, you may want to open an issue.</p>\n","answer_id":54485918,"question_id":54485755},{"owner":{"profile_image":"https://lh5.googleusercontent.com/-vTTwbpau6o4/AAAAAAAAAAI/AAAAAAAABbA/nMg4jej0wtY/photo.jpg?sz=256","account_id":8047963,"user_type":"registered","user_id":6067590,"link":"https://stackoverflow.com/users/6067590/akanshi-srivastava","reputation":1160,"display_name":"Akanshi Srivastava"},"content_license":"CC BY-SA 4.0","score":17,"is_accepted":false,"last_activity_date":1548662806,"creation_date":1548662806,"body":"<p>I added the following two lines in my theme\nunder styles.xml</p>\n\n<pre><code>    &lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;\n    &lt;item name=\"android:windowBackground\"&gt;@null&lt;/item&gt;\n</code></pre>\n\n<p>Worked like a charm</p>\n","answer_id":54397744,"question_id":37437037},{"owner":{"profile_image":"https://i.stack.imgur.com/9Q2UB.png?s=256&g=1","account_id":13184766,"user_type":"registered","user_id":9523162,"link":"https://stackoverflow.com/users/9523162/meyi","reputation":7674,"display_name":"meyi"},"content_license":"CC BY-SA 4.0","score":12,"is_accepted":false,"last_activity_date":1547777884,"creation_date":1547745165,"body":"<p>I know that I'm a few years late, but I came across this issue and took an unorthodox approach. I wanted to do it without making a new class, so this is what I came up with: </p>\n\n<pre><code>int x = 0;\nnew Thread((new Runnable() {\n     int x;\n     public void run() {\n        // stuff with x and whatever else you want\n     }\n     public Runnable pass(int x) {\n           this.x = x;\n           return this;\n     }\n}).pass(x)).start();\n</code></pre>\n","answer_id":54241038,"question_id":877096,"last_edit_date":1547777884},{"owner":{"profile_image":"https://www.gravatar.com/avatar/117cb4789d68e0d8c0ca17fd09948a1a?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":14685618,"user_type":"registered","user_id":10605704,"link":"https://stackoverflow.com/users/10605704/young","reputation":31,"display_name":"Young"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1541428261,"creation_date":1541428261,"body":"<p>[For Reference]ThreadLocal cannot solve update problems of shared object. It is recommended to use a staticThreadLocal object which is shared by all operations in the same thread.\n[Mandatory]remove() method must be implemented by ThreadLocal variables, especially when using thread pools in which threads are often reused. Otherwise, it may affect subsequent business logic and cause unexpected problems such as memory leak.</p>\n","answer_id":53156397,"question_id":817856},{"owner":{"profile_image":"https://www.gravatar.com/avatar/263ca357f9cf115f409fd3d8fe697503?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":2975624,"user_type":"registered","user_id":2526714,"link":"https://stackoverflow.com/users/2526714/v0ld3m0rt","reputation":874,"display_name":"v0ld3m0rt","accept_rate":95},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1539494359,"creation_date":1539494359,"body":"<p>You can find the explanation in the site mentioned in package declaraion:\nHere's the working code:</p>\n\n<pre><code>public class MultipleThreading {\n    int count = 1;\n    int MAX = 20;\n\n    public void printOdd() {\n    synchronized (this) {\n        while (count &lt; MAX) {\n        while (count % 2 == 0) {\n            try {\n            wait();\n            } catch (InterruptedException e) {\n            e.printStackTrace();\n            }\n        }\n        System.out.print(count + \" \");\n        count++;\n        notify();\n        }\n    }\n    }\n\n    public void printEven() {\n    synchronized (this) {\n        while (count &lt; MAX) {\n        while (count % 2 == 1) {\n            try {\n            wait();\n            } catch (InterruptedException e) {\n            e.printStackTrace();\n            }\n        }\n        System.out.print(count + \" \");\n        count++;\n        notify();\n        }\n    }\n    }\n\n    public static void main(String[] args) {\n    MultipleThreading mt = new MultipleThreading();\n    Thread t1 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n        mt.printEven();\n        }\n    });\n    Thread t2 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n        mt.printOdd();\n        }\n    });\n    t1.start();\n    t2.start();\n    }\n}\n</code></pre>\n","answer_id":52799710,"question_id":24720849},{"owner":{"profile_image":"https://i.stack.imgur.com/eNviq.png?s=256&g=1","account_id":5243963,"user_type":"registered","user_id":4190267,"link":"https://stackoverflow.com/users/4190267/indian","reputation":130,"display_name":"indian"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1538390322,"creation_date":1415353577,"body":"<p>The first difference is that <code>yield()</code> is a <code>Thread</code> method , <code>wait()</code> is at the origins <code>Object</code> method inheritid in <code>thread</code> as for all classes , that in the shape, in the background (using java doc) </p>\n\n<pre><code>wait()\n</code></pre>\n\n<p>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. In other words, this method behaves exactly as if it simply performs the call wait(0).</p>\n\n<pre><code>yield()\n</code></pre>\n\n<p>A hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint.</p>\n\n<p>and here you can see the <a href=\"http://javarevisited.blogspot.fr/2011/12/difference-between-wait-sleep-yield.html\" rel=\"nofollow noreferrer\">difference</a> between <a href=\"http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#yield()\" rel=\"nofollow noreferrer\">yield()</a> and <a href=\"http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#wait()\" rel=\"nofollow noreferrer\">wait()</a></p>\n","answer_id":26798351,"question_id":26798073,"last_edit_date":1538390322},{"owner":{"profile_image":"https://i.stack.imgur.com/QN0a6.jpg?s=256&g=1","account_id":6198641,"user_type":"registered","user_id":4829218,"link":"https://stackoverflow.com/users/4829218/calvin-k","reputation":114,"display_name":"Calvin K"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1537363352,"creation_date":1537363352,"body":"<p>Create a local variable in your class that <code>extends Thread</code> or <code>implements Runnable</code>.</p>\n\n<pre><code>public class Extractor extends Thread {\n    public String webpage = \"\";\n    public Extractor(String w){\n        webpage = w;\n    }\n    public void setWebpage(String l){\n        webpage = l;\n    }\n\n    @Override\n    public void run() {// l is link\n        System.out.println(webpage);\n    }\n    public String toString(){\n        return \"Page: \"+webpage;\n    }}\n</code></pre>\n\n<p>This way, you can pass a variable when you run it.</p>\n\n<pre><code>Extractor e = new Extractor(\"www.google.com\");\ne.start();\n</code></pre>\n\n<p>The output:</p>\n\n<pre><code>\"www.google.com\"\n</code></pre>\n","answer_id":52406906,"question_id":877096},{"owner":{"profile_image":"https://i.stack.imgur.com/63g7E.jpg?s=256&g=1","account_id":1252022,"user_type":"registered","user_id":6730571,"link":"https://stackoverflow.com/users/6730571/hugues-m","reputation":19996,"display_name":"Hugues M."},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1531412347,"creation_date":1531412347,"body":"<p>I've had the same issue on Ubuntu, with <code>openjdk-9-jdk-headless</code> installed, <code>jstack</code> alone would work fine but <code>jstack -m</code> would fail with same error as you.</p>\n\n<p>Installing <code>openjdk-9-dbg</code> (package that brings debug symbols) solved it.</p>\n","answer_id":51310395,"question_id":49516601},{"owner":{"profile_image":"https://i.stack.imgur.com/wOpca.jpg?s=256&g=1","account_id":1901420,"user_type":"registered","user_id":1717210,"link":"https://stackoverflow.com/users/1717210/tachedechoco","reputation":3763,"display_name":"TacheDeChoco"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1531397535,"creation_date":1531397535,"body":"<p>The same user is fine, but make also sure you are using the jstack that is bundled the <strong>exact same</strong> JVM as the one that is running the process 7219.</p>\n","answer_id":51305417,"question_id":49516601},{"owner":{"profile_image":"https://i.stack.imgur.com/SoIAb.jpg?s=256&g=1","account_id":8324600,"user_type":"registered","user_id":6255036,"link":"https://stackoverflow.com/users/6255036/krishna","reputation":1566,"display_name":"Krishna"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1530860546,"creation_date":1530860546,"body":"<pre><code>Style :- \n&lt;style name=\"SplashViewTheme\" parent=\"Theme.AppCompat.NoActionBar\"&gt;\n    &lt;item name=\"android:windowBackground\"&gt;@drawable/splash&lt;/item&gt;\n    &lt;item name=\"windowActionBar\"&gt;false&lt;/item&gt;\n    &lt;item name=\"windowNoTitle\"&gt;true&lt;/item&gt;\n&lt;/style&gt;\n\nIn Manifest :- \n&lt;activity android:name=\".SplashActivity\"\n        android:theme=\"@style/SplashViewTheme\"&gt;\n        &lt;intent-filter&gt;\n            &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n\n            &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n        &lt;/intent-filter&gt;\n    &lt;/activity&gt;\n</code></pre>\n","answer_id":51204730,"question_id":37437037},{"owner":{"profile_image":"https://i.stack.imgur.com/f4hTe.jpg?s=256&g=1","account_id":13723126,"user_type":"registered","user_id":9902575,"link":"https://stackoverflow.com/users/9902575/david-studer","reputation":105,"display_name":"David Studer"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1530190098,"creation_date":1530190098,"body":"<p>The issue is indeed not caused by the multithreading logic itself, it is caused by <strong>Eclipse</strong> and the respective <strong>JVM</strong>. Running the exact same code in <strong>Netbeans</strong> or on an <strong>Tomcat 8 Server</strong> did not lead to any problems. A reinstallation of Eclipse did not solve the malfunction within the Eclipse framework, but having the certainty that the issue does not cause any trouble on a server is sufficient for me to close the case. </p>\n\n<p>Thanks to <a href=\"https://stackoverflow.com/users/2563754/seelenvirtuose\">Seelenvirtuose</a> for the hints and his effort.</p>\n","answer_id":51083358,"question_id":51055780},{"owner":{"profile_image":"https://www.gravatar.com/avatar/7d4357beb6de2712b6b2171ebe4c499b?s=256&d=identicon&r=PG","account_id":3023214,"user_type":"registered","user_id":2563754,"link":"https://stackoverflow.com/users/2563754/seelenvirtuose","reputation":20361,"display_name":"Seelenvirtuose"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1530081892,"creation_date":1530081892,"body":"<blockquote>\n  <p>But every time I start running my own thread class as a new thread, the main class thread does not terminate anymore by itself.</p>\n</blockquote>\n\n<p>This is somewhat wrong. Your program does not terminate because there exists at least one non-daemon thread that still is running. The rule is: A Java program is terminated if all non-daemon threads are terminated.</p>\n\n<p>I modified your program to make this behavior clear:</p>\n\n<pre><code>public class OwnThread implements Runnable {\n    @Override\n    public void run() {\n        runForever();\n    }\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(new OwnThread());\n        thread.start();\n        runForever();\n    }\n\n    private static void runForever() {\n        while (true) {}\n    }\n}\n</code></pre>\n\n<p>Running that will create two threads that will run forever. One is the main thread which is started by running the program, and the other is the thread started inside the main method:</p>\n\n<p><a href=\"https://i.stack.imgur.com/kc9Qy.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/kc9Qy.png\" alt=\"enter image description here\"></a></p>\n\n<p>Modifying the above code by removing the call to <em>runForever</em> in the main method ...</p>\n\n<pre><code>public static void main(String[] args) {\n    Thread thread = new Thread(new OwnThread());\n    thread.start();\n}\n</code></pre>\n\n<p>... will result in a different thread picture:</p>\n\n<p><a href=\"https://i.stack.imgur.com/d86FX.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/d86FX.png\" alt=\"enter image description here\"></a></p>\n\n<p>Here the main thread is gone because it is terminated. But the other started thread is still running.</p>\n\n<p>Side note: Suddenly another thread appears - <code>DestroyJavaVM</code>. Have a look at the post <a href=\"https://stackoverflow.com/questions/34433267/destroyjavavm-thread-always-running\">DestroyJavaVM thread ALWAYS running</a> for more information.</p>\n","answer_id":51056168,"question_id":51055780},{"owner":{"profile_image":"https://i.stack.imgur.com/MUmw0.jpg?s=256&g=1","account_id":2629067,"user_type":"registered","user_id":2275474,"link":"https://stackoverflow.com/users/2275474/pritesh-patel","reputation":688,"display_name":"Pritesh Patel","accept_rate":100},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1528118288,"creation_date":1528118288,"body":"<p>The <strong>ThreadLocal</strong> class in Java enables you to create variables that can only be read and written by the same thread. Thus, even if two threads are executing the same code, and the code has a reference to a ThreadLocal variable, then the two threads cannot see each other's ThreadLocal variables.</p>\n\n<p><a href=\"http://tutorials.jenkov.com/java-concurrency/threadlocal.html\" rel=\"nofollow noreferrer\">Read more</a></p>\n","answer_id":50681599,"question_id":817856},{"owner":{"profile_image":"https://www.gravatar.com/avatar/4c1cbfeb8f960be43b662f976c47ca6b?s=256&d=identicon&r=PG","account_id":26685,"user_type":"registered","user_id":69689,"link":"https://stackoverflow.com/users/69689/overthink","reputation":24085,"display_name":"overthink","accept_rate":85},"content_license":"CC BY-SA 3.0","score":916,"is_accepted":true,"last_activity_date":1524678699,"creation_date":1241382377,"body":"<p>One possible (and common) use is when you have some object that is not thread-safe, but you want to avoid <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html\" rel=\"noreferrer\">synchronizing</a> access to that object (I'm looking at you, <a href=\"https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html\" rel=\"noreferrer\">SimpleDateFormat</a>).  Instead, give each thread its own instance of the object.</p>\n\n<p>For example:</p>\n\n<pre><code>public class Foo\n{\n    // SimpleDateFormat is not thread-safe, so give one to each thread\n    private static final ThreadLocal&lt;SimpleDateFormat&gt; formatter = new ThreadLocal&lt;SimpleDateFormat&gt;(){\n        @Override\n        protected SimpleDateFormat initialValue()\n        {\n            return new SimpleDateFormat(\"yyyyMMdd HHmm\");\n        }\n    };\n\n    public String formatIt(Date date)\n    {\n        return formatter.get().format(date);\n    }\n}\n</code></pre>\n\n<p><a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html\" rel=\"noreferrer\">Documentation</a>.</p>\n","answer_id":817926,"question_id":817856,"last_edit_date":1524678699},{"owner":{"profile_image":"https://www.gravatar.com/avatar/8ef359acdee98b1513720480264b6eac?s=256&d=identicon&r=PG","account_id":2849643,"user_type":"registered","user_id":2447120,"link":"https://stackoverflow.com/users/2447120/rakesh-chauhan","reputation":423,"display_name":"Rakesh Chauhan"},"content_license":"CC BY-SA 4.0","score":32,"is_accepted":false,"last_activity_date":1522247318,"creation_date":1443950915,"body":"<p>There is very good example in book <strong>Java Concurrency in Practice</strong>. Where author (<a href=\"https://en.wikipedia.org/wiki/Joshua_Bloch\" rel=\"noreferrer\">Joshua Bloch</a>) explains how Thread confinement is one of the simplest ways to achieve thread safety and <strong>ThreadLocal</strong> is more formal means of maintaining thread confinement. In the end he also explain how people can abuse it by using it as global variables.</p>\n<p>I have copied the text from the mentioned book but code 3.10 is missing as it is not much important to understand where ThreadLocal should be use.</p>\n<blockquote>\n<p>Thread-local variables are often used to prevent sharing in designs based on mutable Singletons or global variables. For example, a single-threaded application might maintain a global database connection that is initialized at startup to avoid having to pass a Connection to every method. Since JDBC connections may not be thread-safe, a multithreaded application that uses a global connection without additional coordination is not thread-safe either. By using a ThreadLocal to store the JDBC connection, as in ConnectionHolder in Listing 3.10, each thread will have its own connection.<br/></p>\n<p>ThreadLocal is widely used in implementing application frameworks. For example, J2EE containers associate a transaction context with an executing thread for the duration of an EJB call. This is easily implemented using a static Thread-Local holding the transaction context: when framework code needs to determine what transaction is currently running, it fetches the transaction context from this ThreadLocal. This is convenient in that it reduces the need to pass execution context information into every method, but couples any code that uses this mechanism to the framework.</p>\n<p>It is easy to abuse ThreadLocal by treating its thread confinement property as a license to use global variables or as a means of creating “hidden” method arguments. Like global variables, thread-local variables can detract from reusability and introduce hidden couplings among classes, and should therefore be used with care.</p>\n</blockquote>\n","answer_id":32931978,"question_id":817856,"last_edit_date":1592644375},{"owner":{"profile_image":"https://lh5.googleusercontent.com/-yRGGcWHl23g/AAAAAAAAAAI/AAAAAAAAAE8/rs-zYQv-l9I/photo.jpg?sz=256","account_id":9240608,"user_type":"registered","user_id":6864013,"link":"https://stackoverflow.com/users/6864013/prasad-reddy","reputation":399,"display_name":"prasad reddy"},"content_license":"CC BY-SA 3.0","score":38,"is_accepted":false,"last_activity_date":1521183452,"creation_date":1521183452,"body":"<p>Please copy and paste these two lines in your manifest app theme i.e res/styles/AppTheme. then it will work like charm..</p>\n\n<pre><code>&lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;\n&lt;item name=\"android:windowIsTranslucent\"&gt;true&lt;/item&gt;\n</code></pre>\n","answer_id":49314844,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b7e983bc66ab99bac7d0891527628145?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":3244300,"user_type":"registered","user_id":2736367,"link":"https://stackoverflow.com/users/2736367/sam","reputation":2975,"display_name":"Sam","accept_rate":75},"content_license":"CC BY-SA 3.0","score":40,"is_accepted":false,"last_activity_date":1520938475,"creation_date":1520938475,"body":"<p>Recommended way of solving this problem is missing in the answers. So I am adding my answer here. The white-screen-at-startup problem occurs because of the initial blank screen that the system process draws when launching the app. A common way to solve this is by turning off this initial screen by adding this to your <code>styles.xml</code> file.</p>\n\n<pre><code>&lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;\n</code></pre>\n\n<p>But according to android documentation this can result in longer startup time. Recommended way of avoiding this initial white screen according to google is to use activity's <code>windowBackground</code> theme attribute and provide a simple custom drawable for the starting activity.  </p>\n\n<p>Like this:</p>\n\n<p>Drawable Layout file, <code>my_drawable.xml</code></p>\n\n<pre><code>&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:opacity=\"opaque\"&gt;\n  &lt;!-- The background color, preferably the same as your normal theme --&gt;\n  &lt;item android:drawable=\"@android:color/white\"/&gt;\n  &lt;!-- Your product logo - 144dp color version of your app icon --&gt;\n  &lt;item&gt;\n    &lt;bitmap\n      android:src=\"@drawable/product_logo_144dp\"\n      android:gravity=\"center\"/&gt;\n  &lt;/item&gt;\n&lt;/layer-list&gt;\n</code></pre>\n\n<p>Create a new style in your <code>styles.xml</code></p>\n\n<pre><code>&lt;!-- Base application theme. --&gt;\n&lt;style name=\"AppTheme\"&gt;\n    &lt;!-- Customize your theme here. --&gt;               \n&lt;/style&gt;\n\n&lt;!-- Starting activity theme --&gt;\n&lt;style name=\"AppTheme.Launcher\"&gt;\n    &lt;item name=\"android:windowBackground\"&gt;@drawable/my_drawable&lt;/item&gt;\n&lt;/style&gt;\n</code></pre>\n\n<p>Add this theme to your starting activity in the Manifest file </p>\n\n<pre><code>&lt;activity ...\nandroid:theme=\"@style/AppTheme.Launcher\" /&gt;\n</code></pre>\n\n<p>And when you want to transition back to your normal theme call <code>setTheme(R.style.Apptheme)</code> before calling <code>super.onCreate()</code> and <code>setContentView()</code> </p>\n\n<pre><code>public class MainActivity extends AppCompatActivity {\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    // Make sure this is before calling super.onCreate\n    setTheme(R.style.Theme_MyApp);\n    super.onCreate(savedInstanceState);\n    // ...\n  }\n}\n</code></pre>\n\n<p>This is the recommended way to solve the problem and this is from google <a href=\"https://material.io/guidelines/patterns/launch-screens.html#\" rel=\"noreferrer\">Material Design</a> patterns.</p>\n","answer_id":49254344,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/dc8c4ddd99b446c28d2e1546c457e508?s=256&d=identicon&r=PG","account_id":4495,"user_type":"registered","user_id":6782,"link":"https://stackoverflow.com/users/6782/alnitak","reputation":335863,"display_name":"Alnitak","accept_rate":78},"content_license":"CC BY-SA 3.0","score":421,"is_accepted":true,"last_activity_date":1518710716,"creation_date":1242643303,"body":"<p>You need to pass the parameter in the constructor to the Runnable object:</p>\n\n<pre><code>public class MyRunnable implements Runnable {\n\n   public MyRunnable(Object parameter) {\n       // store parameter for later user\n   }\n\n   public void run() {\n   }\n}\n</code></pre>\n\n<p>and invoke it thus:</p>\n\n<pre><code>Runnable r = new MyRunnable(param_value);\nnew Thread(r).start();\n</code></pre>\n","answer_id":877113,"question_id":877096,"last_edit_date":1518710716},{"owner":{"profile_image":"https://www.gravatar.com/avatar/92649572223f7fa0485d3e87805159b4?s=256&d=identicon&r=PG","account_id":267334,"user_type":"registered","user_id":555451,"link":"https://stackoverflow.com/users/555451/stuart-cardall","reputation":2179,"display_name":"Stuart Cardall"},"content_license":"CC BY-SA 3.0","score":7,"is_accepted":false,"last_activity_date":1514541231,"creation_date":1514541231,"body":"<p>In Java 8 you can use <code>lambda</code> expressions with the <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html\" rel=\"noreferrer\">Concurrency API</a> &amp; the <code>ExecutorService</code> as a higher level replacement for working with threads directly:</p>\n\n<blockquote>\n  <p><code>newCachedThreadPool()</code> Creates a thread pool that creates new threads\n  as needed, but will reuse previously constructed threads when they are\n  available. These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks.</p>\n</blockquote>\n\n<pre><code>    private static final ExecutorService executor = Executors.newCachedThreadPool();\n\n    executor.submit(() -&gt; {\n        myFunction(myParam1, myParam2);\n    });\n</code></pre>\n\n<p>See also <code>executors</code> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html\" rel=\"noreferrer\">javadocs</a>.</p>\n","answer_id":48020642,"question_id":877096},{"owner":{"profile_image":"https://www.gravatar.com/avatar/3f3a232ec46927a08f59d4d4e59c6802?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":3401111,"user_type":"registered","user_id":2853221,"link":"https://stackoverflow.com/users/2853221/dev-amitabh","reputation":185,"display_name":"Dev Amitabh"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1513047641,"creation_date":1513047641,"body":"<p>Threadlocal provides a very easy way to achieve objects reusability with zero cost.</p>\n\n<p>I had a situation where multiple threads were creating an image of mutable cache, on each update notification.</p>\n\n<p>I used a Threadlocal on each thread, and then each thread would just need to reset old image and then update it again from the cache on each update notification.</p>\n\n<p>Usual reusable objects from object pools have thread safety cost associated with them, while this approach has none. </p>\n","answer_id":47764719,"question_id":817856},{"owner":{"profile_image":"https://www.gravatar.com/avatar/ddb4a32b3d7306760349340e46fd078d?s=256&d=identicon&r=PG","account_id":3750936,"user_type":"registered","user_id":3148734,"link":"https://stackoverflow.com/users/3148734/bpjoshi","reputation":1111,"display_name":"bpjoshi","accept_rate":75},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1512028724,"creation_date":1511992191,"body":"<p>Thread-local variables are often used to prevent sharing in designs based on\nmutable Singletons or global variables. </p>\n\n<p>It can be used in scenarios like making seperate JDBC connection for each thread when you are not using a Connection Pool.</p>\n\n<pre><code>private static ThreadLocal&lt;Connection&gt; connectionHolder\n           = new ThreadLocal&lt;Connection&gt;() {\n      public Connection initialValue() {\n           return DriverManager.getConnection(DB_URL);\n          }\n     };\n\npublic static Connection getConnection() {\n      return connectionHolder.get();\n} \n</code></pre>\n\n<p>When you call getConnection, it will return a connection associated with that thread.The same can be done with other properties like dateformat, transaction context that you don't want to share between threads. </p>\n\n<p>You could have also used local variables for the same, but these resource usually take up time in creation,so you don't want to create them again and again whenever you perform some business logic with them. However, ThreadLocal values are stored in the thread object itself and as soon as the thread is garbage collected, these values are gone too.</p>\n\n<p>This <a href=\"https://howtodoinjava.com/core-java/multi-threading/when-and-how-to-use-thread-local-variables/\" rel=\"nofollow noreferrer\">link</a> explains use of ThreadLocal very well.</p>\n","answer_id":47562423,"question_id":817856,"last_edit_date":1512028724},{"owner":{"profile_image":"https://i.stack.imgur.com/miNqr.jpg?s=256&g=1","account_id":4324639,"user_type":"registered","user_id":3531794,"link":"https://stackoverflow.com/users/3531794/dimos","reputation":8470,"display_name":"Dimos"},"content_license":"CC BY-SA 3.0","score":5,"is_accepted":false,"last_activity_date":1505561291,"creation_date":1505561291,"body":"<p><code>ThreadLocal</code> is useful, when you want to have some state that should not be shared amongst different threads, but it should be accessible from each thread during its whole lifetime.</p>\n\n<p>As an example, imagine a web application, where each request is served by a different thread. Imagine that for each request you need a piece of data multiple times, which is quite expensive to compute. However, that data might have changed for each incoming request, which means that you can't use a plain cache. A simple, quick solution to this problem would be to have a <code>ThreadLocal</code> variable holding access to this data, so that you have to calculate it only once for each request. Of course, this problem can also be solved without the use of <code>ThreadLocal</code>, but I devised it for illustration purposes. </p>\n\n<p>That said, have in mind that <code>ThreadLocal</code>s are essentially a form of global state. As a result, it has many other implications and should be used only after considering all the other possible solutions. </p>\n","answer_id":46253405,"question_id":817856},{"owner":{"profile_image":"https://i.stack.imgur.com/Auh5P.png?s=256&g=1","account_id":2075948,"user_type":"registered","user_id":4233197,"link":"https://stackoverflow.com/users/4233197/hiren-patel","reputation":52334,"display_name":"Hiren Patel","accept_rate":55},"content_license":"CC BY-SA 3.0","score":11,"is_accepted":false,"last_activity_date":1496909476,"creation_date":1496909476,"body":"<p>I had same issue, you have to update your style.</p>\n\n<p><strong>style.xml</strong></p>\n\n<pre><code>&lt;!-- Base application theme. --&gt;\n &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt;\n\n        &lt;!-- Customize your theme here. --&gt;\n        &lt;item name=\"drawerArrowStyle\"&gt;@style/DrawerArrowStyle&lt;/item&gt;\n        &lt;item name=\"android:windowNoTitle\"&gt;true&lt;/item&gt;\n        &lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;\n        &lt;item name=\"android:windowBackground\"&gt;@null&lt;/item&gt;\n        &lt;item name=\"android:windowIsTranslucent\"&gt;true&lt;/item&gt;\n\n &lt;/style&gt;\n</code></pre>\n\n<p>Your manifest file should looks like below.</p>\n\n<pre><code>&lt;application\n        android:name=\".MyApplication\"\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:theme=\"@style/AppTheme\"&gt;\n     // Other stuff\n&lt;/application&gt;\n</code></pre>\n\n<p><strong>Outout:</strong></p>\n\n<p><a href=\"https://i.stack.imgur.com/78a5r.gif\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/78a5r.gif\" alt=\"enter image description here\"></a></p>\n\n<p>Hope this would help you.</p>\n","answer_id":44430166,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/52f323891e5e487c80d4034887c31f1b?s=256&d=identicon&r=PG","account_id":3178228,"user_type":"registered","user_id":2685581,"link":"https://stackoverflow.com/users/2685581/ajay-kumar","reputation":4984,"display_name":"Ajay Kumar"},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1496153397,"creation_date":1496139866,"body":"<p>ThreadLocal is a specially provisioned functionality by JVM to provide an isolated storage space for threads only. like the value of instance scoped variable are bound to a given instance of a class only. each object has its only values and they can not see each other value. so is the concept of ThreadLocal variables, they are local to the thread in the sense of object instances other thread except for the one which created it, can not see it. <a href=\"https://itexpertsconsultant.wordpress.com/2017/05/29/threadlocal-example-with-java-8/\" rel=\"nofollow noreferrer\">See Here</a></p>\n\n<pre><code>import java.util.concurrent.atomic.AtomicInteger;\nimport java.util.stream.IntStream;\n\n\npublic class ThreadId {\nprivate static final AtomicInteger nextId = new AtomicInteger(1000);\n\n// Thread local variable containing each thread's ID\nprivate static final ThreadLocal&lt;Integer&gt; threadId = ThreadLocal.withInitial(() -&gt; nextId.getAndIncrement());\n\n\n// Returns the current thread's unique ID, assigning it if necessary\npublic static int get() {\n    return threadId.get();\n}\n\npublic static void main(String[] args) {\n\n    new Thread(() -&gt; IntStream.range(1, 3).forEach(i -&gt; {\n        System.out.println(Thread.currentThread().getName() + \" &gt;&gt; \" + new ThreadId().get());\n    })).start();\n\n    new Thread(() -&gt; IntStream.range(1, 3).forEach(i -&gt; {\n        System.out.println(Thread.currentThread().getName() + \" &gt;&gt; \" + new ThreadId().get());\n    })).start();\n\n    new Thread(() -&gt; IntStream.range(1, 3).forEach(i -&gt; {\n        System.out.println(Thread.currentThread().getName() + \" &gt;&gt; \" + new ThreadId().get());\n    })).start();\n\n}\n}\n</code></pre>\n","answer_id":44259643,"question_id":817856,"last_edit_date":1496153397},{"owner":{"profile_image":"https://i.stack.imgur.com/zw18i.png?s=256&g=1","account_id":1663234,"user_type":"registered","user_id":1531124,"link":"https://stackoverflow.com/users/1531124/ghostcat","reputation":138406,"display_name":"GhostCat","accept_rate":96},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":true,"last_activity_date":1493199636,"creation_date":1493199636,"body":"<p>What can be said so far: you use the ExecutorService to pass in tasks:</p>\n\n<pre><code>new StatusMultiThreading(id, username, psLog, connSTORY, connCF, mongoDatabase)\n</code></pre>\n\n<p>Later on, when you call <code>get()</code> the corresponding task is triggered. So that exception takes place inside that class of yours. </p>\n","answer_id":43630459,"question_id":43630406},{"owner":{"profile_image":"https://lh5.googleusercontent.com/-zJQot7cFQ8g/AAAAAAAAAAI/AAAAAAAAC8w/mLSR34VdUxk/photo.jpg?sz=256","account_id":9419272,"user_type":"registered","user_id":7803889,"link":"https://stackoverflow.com/users/7803889/javier-reinoso","reputation":11,"display_name":"Javier Reinoso"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1491120410,"creation_date":1491118425,"body":"<p>Just write the item in values/styles.xml:</p>\n\n<pre><code>&lt;item name=\"android:windowBackground\"&gt;@android:color/black&lt;/item&gt;\n</code></pre>\n\n<p>For example, in the AppTheme:</p>\n\n<pre><code>&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"&gt;\n    &lt;item name=\"windowNoTitle\"&gt;true&lt;/item&gt;\n    &lt;item name=\"windowActionBar\"&gt;false&lt;/item&gt;\n    &lt;item name=\"android:windowFullscreen\"&gt;true&lt;/item&gt;\n    &lt;item name=\"android:windowContentOverlay\"&gt;@null&lt;/item&gt;\n\n    &lt;item name=\"android:windowBackground\"&gt;@android:color/black&lt;/item&gt;\n\n    &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt;\n    &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt;\n    &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt;\n&lt;/style&gt;\n</code></pre>\n","answer_id":43165801,"question_id":37437037,"last_edit_date":1491120410},{"owner":{"profile_image":"https://i.stack.imgur.com/GGyFL.jpg?s=256&g=1","account_id":7201903,"user_type":"registered","user_id":5498855,"link":"https://stackoverflow.com/users/5498855/ivan-milisavljevic","reputation":2058,"display_name":"Ivan Milisavljevic"},"content_license":"CC BY-SA 3.0","score":102,"is_accepted":true,"last_activity_date":1490998158,"creation_date":1465301471,"body":"<p>The problem with white background is caused because of android's cold start while the app loads to memory, and it can be avoided with this:</p>\n\n<pre><code>public class OnboardingWithCenterAnimationActivity extends AppCompatActivity {\npublic static final int STARTUP_DELAY = 300;\npublic static final int ANIM_ITEM_DURATION = 1000;\npublic static final int ITEM_DELAY = 300;\n\nprivate boolean animationStarted = false;\n\n@Override\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    setTheme(R.style.AppTheme);\n    getWindow().getDecorView().setSystemUiVisibility(\n            View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_onboarding_center);\n}\n\n@Override\npublic void onWindowFocusChanged(boolean hasFocus) {\n\n    if (!hasFocus || animationStarted) {\n        return;\n    }\n\n    animate();\n\n    super.onWindowFocusChanged(hasFocus);\n}\n\nprivate void animate() {\n    ImageView logoImageView = (ImageView) findViewById(R.id.img_logo);\n    ViewGroup container = (ViewGroup) findViewById(R.id.container);\n\n    ViewCompat.animate(logoImageView)\n        .translationY(-250)\n        .setStartDelay(STARTUP_DELAY)\n        .setDuration(ANIM_ITEM_DURATION).setInterpolator(\n            new DecelerateInterpolator(1.2f)).start();\n\n    for (int i = 0; i &lt; container.getChildCount(); i++) {\n        View v = container.getChildAt(i);\n        ViewPropertyAnimatorCompat viewAnimator;\n\n        if (!(v instanceof Button)) {\n            viewAnimator = ViewCompat.animate(v)\n                    .translationY(50).alpha(1)\n                    .setStartDelay((ITEM_DELAY * i) + 500)\n                    .setDuration(1000);\n        } else {\n            viewAnimator = ViewCompat.animate(v)\n                    .scaleY(1).scaleX(1)\n                    .setStartDelay((ITEM_DELAY * i) + 500)\n                    .setDuration(500);\n        }\n\n        viewAnimator.setInterpolator(new DecelerateInterpolator()).start();\n    }\n}\n}\n</code></pre>\n\n<p>layout</p>\n\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;FrameLayout\nxmlns:android=\"http://schemas.android.com/apk/res/android\"\nxmlns:tools=\"http://schemas.android.com/tools\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\"\nandroid:background=\"?colorPrimary\"\nandroid:orientation=\"vertical\"\n&gt;\n\n&lt;LinearLayout\n    android:id=\"@+id/container\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:layout_gravity=\"center\"\n    android:gravity=\"center\"\n    android:orientation=\"vertical\"\n    android:paddingTop=\"144dp\"\n    tools:ignore=\"HardcodedText\"\n    &gt;\n\n    &lt;TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center_horizontal\"\n        android:layout_marginTop=\"16dp\"\n        android:alpha=\"0\"\n        android:text=\"Hello world\"         android:textAppearance=\"@style/TextAppearance.AppCompat.Widget.ActionBar.Title.Inverse\"\n        android:textColor=\"@android:color/white\"\n        android:textSize=\"22sp\"\n        tools:alpha=\"1\"\n        /&gt;\n\n    &lt;TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center_horizontal\"\n        android:layout_marginTop=\"8dp\"\n        android:alpha=\"0\"\n        android:gravity=\"center\"\n        android:text=\"This a nice text\"\n      android:textAppearance=\"@style/TextAppearance.AppCompat.Widget.ActionBar.Subtitle.Inverse\"\n        android:textSize=\"20sp\"\n        tools:alpha=\"1\"\n        /&gt;\n\n    &lt;Button\n        android:id=\"@+id/btn_choice1\"\n        android:layout_width=\"200dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginTop=\"48dp\"\n        android:scaleX=\"0\"\n        android:scaleY=\"0\"\n        android:text=\"A nice choice\"\n        android:theme=\"@style/Button\"\n        /&gt;\n\n    &lt;Button\n        android:id=\"@+id/btn_choice2\"\n        android:layout_width=\"200dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginTop=\"4dp\"\n        android:scaleX=\"0\"\n        android:scaleY=\"0\"\n        android:text=\"Far better!\"\n        android:theme=\"@style/Button\"\n        /&gt;\n\n&lt;/LinearLayout&gt;\n\n&lt;ImageView\n    android:id=\"@+id/img_logo\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:layout_gravity=\"center\"\n    android:src=\"@drawable/img_face\"\n    tools:visibility=\"gone\"\n    /&gt;\n&lt;/FrameLayout&gt;\n</code></pre>\n\n<p>img face</p>\n\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:opacity=\"opaque\"&gt;\n\n&lt;item android:drawable=\"?colorPrimary\"/&gt;\n&lt;item&gt;\n    &lt;bitmap\n        android:gravity=\"center\"\n        android:src=\"@drawable/img_face\"/&gt;\n&lt;/item&gt;\n</code></pre>\n\n<p></p>\n\n<p>Add this theme to your splashscreen in the manifest</p>\n\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;resources&gt;\n&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt;\n    &lt;!-- Customize your theme here. --&gt;\n    &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt;\n    &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt;\n    &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt;\n    &lt;item name=\"android:windowBackground\"&gt;@null&lt;/item&gt;\n&lt;/style&gt;\n\n&lt;style name=\"AppTheme.CenterAnimation\"&gt;\n    &lt;item name=\"android:windowBackground\"&gt;@drawable/ll_face_logo&lt;/item&gt;\n&lt;/style&gt;\n</code></pre>\n\n<p></p>\n\n<p>which will produce efect like this</p>\n\n<p><img src=\"https://raw.githubusercontent.com/saulmm/onboarding-examples-android/master/art/center.gif\" alt=\"a busy cat\"></p>\n\n<p>for more details and more solutions you can check this\n<a href=\"http://saulmm.github.io/avoding-android-cold-starts\" rel=\"noreferrer\">BlogPost</a></p>\n","answer_id":37679026,"question_id":37437037,"last_edit_date":1490998158},{"owner":{"profile_image":"https://i.stack.imgur.com/oZ1UM.gif?s=256&g=1","account_id":930090,"user_type":"registered","user_id":960115,"link":"https://stackoverflow.com/users/960115/jeff-g","reputation":4490,"display_name":"Jeff G","accept_rate":92},"content_license":"CC BY-SA 3.0","score":7,"is_accepted":false,"last_activity_date":1489186173,"creation_date":1489186173,"body":"<p>As of Java 8, you can use a lambda to capture parameters that are <a href=\"https://stackoverflow.com/a/20938132/960115\">effectively final</a>.  For example:</p>\n\n<pre><code>final String param1 = \"First param\";\nfinal int param2 = 2;\nnew Thread(() -&gt; {\n    // Do whatever you want here: param1 and param2 are in-scope!\n    System.out.println(param1);\n    System.out.println(param2);\n}).start();\n</code></pre>\n","answer_id":42729024,"question_id":877096,"last_edit_date":1495540988},{"owner":{"profile_image":"https://www.gravatar.com/avatar/6e4992cc0a3d78db161a3a1170148520?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6236104,"user_type":"registered","user_id":4851359,"link":"https://stackoverflow.com/users/4851359/infoj","reputation":681,"display_name":"infoj"},"content_license":"CC BY-SA 3.0","score":8,"is_accepted":false,"last_activity_date":1485703285,"creation_date":1440086295,"body":"<p>Two use cases where threadlocal variable can be used - <br/>\n1- When we have a requirement to associate state with a thread (e.g., a user ID or Transaction ID). That usually happens with a web application that every request going to a servlet has a unique transactionID associated with it.</p>\n\n<pre><code>// This class will provide a thread local variable which\n// will provide a unique ID for each thread\nclass ThreadId {\n    // Atomic integer containing the next thread ID to be assigned\n    private static final AtomicInteger nextId = new AtomicInteger(0);\n\n    // Thread local variable containing each thread's ID\n    private static final ThreadLocal&lt;Integer&gt; threadId =\n        ThreadLocal.&lt;Integer&gt;withInitial(()-&gt; {return nextId.getAndIncrement();});\n\n    // Returns the current thread's unique ID, assigning it if necessary\n    public static int get() {\n        return threadId.get();\n    }\n}\n</code></pre>\n\n<p>Note that here the method withInitial is implemented using lambda expression.<br/>\n2- Another use case is when we want to have a thread safe instance and we don't want to use synchronization as the performance cost with synchronization is more. One such case is when SimpleDateFormat is used. Since SimpleDateFormat is not thread safe so we have to provide mechanism to make it thread safe. </p>\n\n<pre><code>public class ThreadLocalDemo1 implements Runnable {\n    // threadlocal variable is created\n    private static final ThreadLocal&lt;SimpleDateFormat&gt; dateFormat = new ThreadLocal&lt;SimpleDateFormat&gt;(){\n        @Override\n        protected SimpleDateFormat initialValue(){\n            System.out.println(\"Initializing SimpleDateFormat for - \" + Thread.currentThread().getName() );\n            return new SimpleDateFormat(\"dd/MM/yyyy\");\n        }\n    };\n\n    public static void main(String[] args) {\n        ThreadLocalDemo1 td = new ThreadLocalDemo1();\n        // Two threads are created\n        Thread t1 = new Thread(td, \"Thread-1\");\n        Thread t2 = new Thread(td, \"Thread-2\");\n        t1.start();\n        t2.start();\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"Thread run execution started for \" + Thread.currentThread().getName());\n        System.out.println(\"Date formatter pattern is  \" + dateFormat.get().toPattern());\n        System.out.println(\"Formatted date is \" + dateFormat.get().format(new Date()));\n    } \n\n}\n</code></pre>\n","answer_id":32122972,"question_id":817856,"last_edit_date":1485703285},{"owner":{"profile_image":"https://www.gravatar.com/avatar/ee889ac6797f1f23ebb955164162bd39?s=256&d=identicon&r=PG","account_id":2019478,"user_type":"registered","user_id":1806005,"link":"https://stackoverflow.com/users/1806005/hi-my-name-is","reputation":4894,"display_name":"hi_my_name_is","accept_rate":56},"content_license":"CC BY-SA 3.0","score":5,"is_accepted":true,"last_activity_date":1483083594,"creation_date":1483083594,"body":"<p>you may want to play with <code>isolation</code> parameter of<code>@Transactional</code> annotation. Spring by default uses.. hm.. <code>DEFAULT</code> which is set by database, so may be different. You can try to use: <code>READ_UNCOMMITTED</code>. More info: <a href=\"http://www.byteslounge.com/tutorials/spring-transaction-isolation-tutorial\" rel=\"noreferrer\">http://www.byteslounge.com/tutorials/spring-transaction-isolation-tutorial</a></p>\n","answer_id":41392530,"question_id":41391209},{"owner":{"profile_image":"https://www.gravatar.com/avatar/7dfb3c6fe5d0c1f5121d7d6d311fa8ff?s=256&d=identicon&r=PG","account_id":1056981,"user_type":"registered","user_id":1059465,"link":"https://stackoverflow.com/users/1059465/znlyj","reputation":1109,"display_name":"znlyj","accept_rate":43},"content_license":"CC BY-SA 3.0","score":10,"is_accepted":false,"last_activity_date":1480420693,"creation_date":1367162549,"body":"<p>Webapp server may keep a thread pool, and a <code>ThreadLocal</code> var should be removed before response to the client, thus current thread may be reused by next request.</p>\n","answer_id":16264385,"question_id":817856,"last_edit_date":1480420693},{"owner":{"profile_image":"https://www.gravatar.com/avatar/4301e2847b861058706df775f913e02d?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8829249,"user_type":"registered","user_id":6596346,"link":"https://stackoverflow.com/users/6596346/paul","reputation":96,"display_name":"paul","accept_rate":40},"content_license":"CC BY-SA 3.0","score":-1,"is_accepted":false,"last_activity_date":1477174238,"creation_date":1477174238,"body":"<p>Instead of while true in you waitForClient method try this</p>\n\n<pre><code>private final int allowedClients = 10;\nprivate int connectedClients = 0;\npublic void waitForClient () {\n\nboolean isLogPrinted = false;\n\nwhile (connectedClients &lt;= allowedClients){\n    try {\n       if (clientCount &lt; serverThread.length){\n           System.out.println (\"Waiting for connection...\");\n           isLogPrinted = false;\n           addThread (serverSocket.accept());\n           connectedClients++;\n           System.out.println(\"Client count: \" + clientCount);\n       }\n       else {\n           if (!isLogPrinted){\n                System.out.println(\"MAXIMUM NUMBER OF CLIENTS REACHED! (\" + clientCount + \").\");\n                isLogPrinted = true;\n           }\n       }\n   } catch (IOException e) {\n       System.out.println(\"Error while waiting for new clients to connect: \" + e.getMessage());\n        }\n</code></pre>\n\n<p>}\n}</p>\n","answer_id":40197569,"question_id":40197514},{"owner":{"profile_image":"https://i.stack.imgur.com/oJtcB.jpg?s=256&g=1","account_id":6080415,"user_type":"registered","user_id":4746376,"link":"https://stackoverflow.com/users/4746376/sohail-zahid","reputation":8109,"display_name":"Sohail Zahid","accept_rate":73},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1471511197,"creation_date":1471511197,"body":"<p>Both properties works</p>\n\n<pre><code>    &lt;style name=\"AppBaseThemeDark\" parent=\"@style/Theme.AppCompat\"&gt;\n            &lt;!--your other properties --&gt;\n            &lt;!--&lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;--&gt;\n            &lt;item name=\"android:windowBackground\"&gt;@null&lt;/item&gt;\n            &lt;!--your other properties --&gt;\n    &lt;/style&gt;\n</code></pre>\n","answer_id":39014103,"question_id":37437037},{"owner":{"profile_image":"https://i.stack.imgur.com/XiFZh.jpg?s=256&g=1","account_id":1542133,"user_type":"registered","user_id":1955871,"link":"https://stackoverflow.com/users/1955871/rob","reputation":6317,"display_name":"Rob","accept_rate":75},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1469460315,"creation_date":1469460315,"body":"<p>While I am not familiar with Eclipse MAT and what it is showing you, it is proper behavior for some objects to go through the Finalizer queue.</p>\n\n<p>Under normal circumstances, any object that overrides the <code>finalize</code> method will be queued for finalization (which consists of calling the <code>finalize</code> method). The general idea is that when the garbage collector identifies an object as unreachable, it looks to see if the <code>finalize</code> method is overridden and has not yet been called. If <code>finalize</code> is defined and has not yet been called, then the object is queued for finalization, otherwise the memory is collected.</p>\n\n<p>The finalizer appears to be implemented as a queue that is serviced by a single thread. The thread processes each object in the queue by calling <code>finalize</code>. After the call to <code>finalize</code> completes, the object is removed from the queue.</p>\n\n<p>Subsequently, when the garbage collector again determines that the object is unreachable, it will find that <code>finalize</code> is overridden, but has already been called. The member is collected.</p>\n\n<p>Note that using this feature delays collection of garbage. And while it is a convenient way to clean up an object, the JVM does not guarantee when or even if the <code>finalize</code> method will be called.</p>\n\n<p>One related risk is \"finalizer starvation.\" You mention \"growing\" so perhaps this is an issue you are facing. If you create enough garbage that requires finalization and if that finalization takes too long, you can actually run out of memory because the single finalizer queue cannot keep up. There are a number of ways to deal with this situation:</p>\n\n<ul>\n<li>Make execution of <code>finalize</code> complete (infinite loops are bad) and quickly.</li>\n<li>Avoid synchronization in <code>finalize</code>.</li>\n<li>Make the Finalizer thread have the highest execution priority. This can be accomplished by creating a garbage instance that changes the thread priority in the finalizer - create one of these during app initialization.</li>\n</ul>\n\n<p>If you are seeing starvation, use a thread dump to see what the Finalizer thread is working on.</p>\n","answer_id":38571742,"question_id":38570732},{"owner":{"profile_image":"https://www.gravatar.com/avatar/4656523cbdc8a8a57fd218f93f035418?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6441501,"user_type":"registered","user_id":4991382,"link":"https://stackoverflow.com/users/4991382/mihir-patel","reputation":402,"display_name":"Mihir Patel"},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1468411201,"creation_date":1468409804,"body":"<p>No you can't pass parameters to the <code>run()</code> method. The signature tells you that (it has no parameters). Probably the easiest way to do this would be to use a purpose-built object that takes a parameter in the constructor and stores it in a final variable: </p>\n\n<pre><code>public class WorkingTask implements Runnable\n{\n    private final Object toWorkWith;\n\n    public WorkingTask(Object workOnMe)\n    {\n        toWorkWith = workOnMe;\n    }\n\n    public void run()\n    {\n        //do work\n    }\n}\n\n//...\nThread t = new Thread(new WorkingTask(theData));\nt.start();\n</code></pre>\n\n<p>Once you do that - you have to be careful of the data integrity of the object you pass into the 'WorkingTask'. The data will now exist in two different threads so you have to make sure it is Thread Safe.</p>\n","answer_id":38350646,"question_id":877096,"last_edit_date":1468411201},{"owner":{"profile_image":"https://www.gravatar.com/avatar/0d2acc7b8704bde598db2397d141d88f?s=256&d=identicon&r=PG","account_id":139857,"user_type":"registered","user_id":345718,"link":"https://stackoverflow.com/users/345718/patrick","reputation":799,"display_name":"Patrick"},"content_license":"CC BY-SA 3.0","score":8,"is_accepted":false,"last_activity_date":1468386642,"creation_date":1468386642,"body":"<p>Since this issue is still open at the time of writing (version 3.0.X) <a href=\"https://issues.jboss.org/browse/RESTEASY-1357\" rel=\"noreferrer\">RESTEASY: deprecated Apache classes cleanup</a></p>\n\n<p>You can go deeper to use the newer, non-deprecated classes instead to create you resteasy client. You will also have more control over how you want the pool to be etc.</p>\n\n<p>Here is what I did:</p>\n\n<pre><code>// This will create a threadsafe JAX-RS client using pooled connections.\n// Per default this implementation will create no more than than 2\n// concurrent connections per given route and no more 20 connections in\n// total. (see javadoc of PoolingHttpClientConnectionManager)\nPoolingHttpClientConnectionManager cm =\n        new PoolingHttpClientConnectionManager();\n\nCloseableHttpClient closeableHttpClient =\n        HttpClientBuilder.create().setConnectionManager(cm).build();\nApacheHttpClient4Engine engine =\n        new ApacheHttpClient4Engine(closeableHttpClient);\nreturn new ResteasyClientBuilder().httpEngine(engine).build();\n</code></pre>\n\n<p>Also <strong>make sure you release the connection</strong> after making a call. Calling response.close() will do that for you so probably put that in a finally block.</p>\n","answer_id":38343094,"question_id":33097230},{"owner":{"profile_image":"https://www.gravatar.com/avatar/bffea7de598020c514bdca3b0239d865?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8509289,"user_type":"registered","user_id":6379785,"link":"https://stackoverflow.com/users/6379785/gmetal","reputation":2918,"display_name":"gmetal"},"content_license":"CC BY-SA 3.0","score":21,"is_accepted":false,"last_activity_date":1465307102,"creation_date":1465307102,"body":"<p>Have you tried setting the<code>android:windowBackground</code> attribute in the theme of your launcher activity, to either a color or a drawable?</p>\n\n<p>For example this: </p>\n\n<pre><code>&lt;item name=\"android:windowBackground\"&gt;@android:color/black&lt;/item&gt;\n</code></pre>\n\n<p>when added to the Launcher activity theme will show a black color (rather than the white color) on startup. This is an easy trick to hide long initialisation, while showing your users something, <strong>and it works fine</strong> even if you subclass the Application object.</p>\n\n<p>Avoid using other constructs (even Threads) for doing long initialisation tasks, because you may end up not being able to control the lifecycle of such constructs. The Application object is the correct place for doing exactly this type of actions. </p>\n","answer_id":37681189,"question_id":37437037},{"owner":{"profile_image":"https://i.stack.imgur.com/eCkiz.jpg?s=256&g=1","account_id":3251487,"user_type":"registered","user_id":2741598,"link":"https://stackoverflow.com/users/2741598/vickyexpert","reputation":3147,"display_name":"Vickyexpert","accept_rate":50},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1464861962,"creation_date":1464861962,"body":"<p>As you are already aware why this white screen is there, as due to background processes or application initialization or large files, so just check below idea for overcome from this.</p>\n\n<p>To prevent this white screen on beginning of the app, one way is splash screen, this is just a way not final and you must have to use.</p>\n\n<p>When you will show splash screen from your splash.xml file, then also this issue will be remain same,</p>\n\n<p>So you have to create ont style in style.xml file for splash screen and there you have to set window background as your splash image and then apply that theme to your splash activity from manifest file. So now when you will run app, first it will set theme and by this way user will be able to see directly splash image instead of white screen.</p>\n","answer_id":37588748,"question_id":37437037},{"owner":{"profile_image":"https://i.stack.imgur.com/Q57nx.jpg?s=256&g=1","account_id":3016236,"user_type":"registered","user_id":4969827,"link":"https://stackoverflow.com/users/4969827/sergey-shustikov","reputation":15507,"display_name":"Sergey Shustikov"},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1464861958,"creation_date":1464861958,"body":"<p>Did you try to put initialization to <code>onActivityCreated</code>?</p>\n\n<p>Inside <code>Application</code> class :</p>\n\n<pre><code> registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() {\n            @Override\n            public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n                if(activity.getClass().equals(FirstActivity.class) {\n                    // try without runOnUiThread if it will not help\n                    activity.runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            new InitializatioTask().execute();\n                        }\n                    });\n                }\n            }\n\n            @Override\n            public void onActivityStarted(Activity activity) {\n\n            }\n\n            @Override\n            public void onActivityResumed(Activity activity) {\n\n            }\n\n            @Override\n            public void onActivityPaused(Activity activity) {\n\n            }\n\n            @Override\n            public void onActivityStopped(Activity activity) {\n\n            }\n\n            @Override\n            public void onActivitySaveInstanceState(Activity activity, Bundle outState) {\n\n            }\n\n            @Override\n            public void onActivityDestroyed(Activity activity) {\n\n            }\n        });\n</code></pre>\n","answer_id":37588747,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c039fcc583a7df47d9b415dcccd343a4?s=256&d=identicon&r=PG","account_id":1963159,"user_type":"registered","user_id":1764080,"link":"https://stackoverflow.com/users/1764080/shmuel","reputation":3916,"display_name":"Shmuel","accept_rate":65},"content_license":"CC BY-SA 3.0","score":21,"is_accepted":false,"last_activity_date":1464179937,"creation_date":1464179937,"body":"<p>First of all, to remove the white screen read this - <a href=\"https://www.bignerdranch.com/blog/splash-screens-the-right-way/\" rel=\"noreferrer\">https://www.bignerdranch.com/blog/splash-screens-the-right-way/</a></p>\n\n<p>But more importantly, optimize your initial load and defer any heavy work to when you have time to run it. Post your application class here if you want us to take a look at it.</p>\n","answer_id":37437432,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/7ca54b3b9ddb5fa296fa19ac520294ae?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":7265641,"user_type":"registered","user_id":6259238,"link":"https://stackoverflow.com/users/6259238/limestone","reputation":51,"display_name":"Limestone"},"content_license":"CC BY-SA 3.0","score":5,"is_accepted":false,"last_activity_date":1461726649,"creation_date":1461726649,"body":"<p>when?</p>\n\n<p>When an object is not thread-safe, instead of synchronization which hampers the scalability, give one object to every thread and keep it thread scope, which is ThreadLocal. One of most often used but not thread-safe objects are database Connection and JMSConnection. </p>\n\n<p>How ?</p>\n\n<p>One example is Spring framework uses ThreadLocal heavily for managing transactions behind the scenes by keeping these connection objects in ThreadLocal variables. At high level, when a transaction is started it gets the connection ( and disables the auto commit ) and keeps it in ThreadLocal. on further db calls it uses same connection to communicate with db. At the end, it takes the connection from ThreadLocal and commits ( or rollback ) the transaction and releases the connection. </p>\n\n<p>I think log4j also uses ThreadLocal for maintaining MDC.</p>\n","answer_id":36879565,"question_id":817856},{"owner":{"profile_image":"https://www.gravatar.com/avatar/077e85b58e7d2f715ce377c558d3b4ec?s=256&d=identicon&r=PG","account_id":179293,"user_type":"registered","user_id":411846,"link":"https://stackoverflow.com/users/411846/centic","reputation":15713,"display_name":"centic","accept_rate":80},"content_license":"CC BY-SA 3.0","score":13,"is_accepted":false,"last_activity_date":1459849119,"creation_date":1459846446,"body":"<p>Be aware: Apache POI explicitly does not support multi-threading access to the same workbook-object! This is because there are structures that are handled on a workbook-level, e.g. Styles, Comments, ...</p>\n\n<p>You will run into obscure errors and corrupted documents if you try to do this naively. </p>\n\n<p>The only guarantee that it makes is that separate workbooks in different threads will work fine, i.e. there is no thread-unsafe global state kept anywhere.</p>\n\n<p>The only way that should work would be to synchronize every access to the workbook via a synchronized block:</p>\n\n<pre><code>synchronized (workbook) {\n    ... access the sheet and the contents\n}\n</code></pre>\n\n<p>Read-only access might work, but again Apache POI does not make guarantees that concurrent read-access to the same workbook will work.</p>\n\n<p>Update: There is now a corresponding <a href=\"http://poi.apache.org/faq.html#faq-N101BC\" rel=\"noreferrer\">FAQ entry</a> stating this as well.</p>\n","answer_id":36421529,"question_id":28626848,"last_edit_date":1459849119},{"owner":{"profile_image":"https://www.gravatar.com/avatar/99266f63196c82aaeb18e36727424c07?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":3869264,"user_type":"registered","user_id":3204950,"link":"https://stackoverflow.com/users/3204950/rameshvanka","reputation":51,"display_name":"rameshvanka"},"content_license":"CC BY-SA 3.0","score":-1,"is_accepted":false,"last_activity_date":1459845993,"creation_date":1459844383,"body":"<p>Inside the main thread create the workbook, workbook create the sheets and distribute the sheets to worker thread. main thread should wait until all the worker thread completes. main thread workbook the flush the data into stream. then stream into file.</p>\n\n<p>If you want source code with example, send a mail to me. I will share ramesh.niwas@gmail.com</p>\n","answer_id":36420786,"question_id":28626848,"last_edit_date":1459845993},{"owner":{"profile_image":"https://www.gravatar.com/avatar/07a4fda1c1cd6f2a3168d7fbb72dcc16?s=256&d=identicon&r=PG","account_id":7882823,"user_type":"registered","user_id":5956116,"link":"https://stackoverflow.com/users/5956116/pavel-pscheidl","reputation":344,"display_name":"Pavel Pscheidl"},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1458491585,"creation_date":1458491585,"body":"<p>First, do not reuse WebTarget. For simplicity, you can always create new WebTarget.</p>\n\n<p>Second, if you're using Resteasy, you can add provided dependency for Resteasy client to your project. Example in Gradle:</p>\n\n<pre><code>    provided 'org.jboss.resteasy:resteasy-client:3.0.14.Final'\n</code></pre>\n\n<p>Then, you can create your connection like this:</p>\n\n<pre><code>        ResteasyClientBuilder builder = new ResteasyClientBuilder();\n        builder.connectionPoolSize(200);\n</code></pre>\n\n<p>There is no need to set maxPooledPerRoute, this is set automatically by RestEasy (can be found in RestEasyClientBuilder class source code).</p>\n\n<p>When you set connectionPoolSize, you will no longer get error when Client is reused and you can happily re-use them all across the application. I've tried this solution on many projects and it actually works well. But when you deploy your application to a non-resteasy container (like Glassfish), your code won't work and you will have to use ClientBuilder class again.</p>\n","answer_id":36116402,"question_id":33097230},{"owner":{"profile_image":"https://i.stack.imgur.com/xpNqK.jpg?s=256&g=1","account_id":426109,"user_type":"registered","user_id":807126,"link":"https://stackoverflow.com/users/807126/doug-stevenson","reputation":302042,"display_name":"Doug Stevenson"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":true,"last_activity_date":1457491340,"creation_date":1457491340,"body":"<p>You can remove previously posted Runnables using the <a href=\"http://developer.android.com/reference/android/os/Handler.html#removeCallbacks(java.lang.Runnable)\" rel=\"nofollow\">removeCallbacks()</a> method on the Handler used to post them.  You will need to have the <em>exact</em> reference to the Runnable posted.</p>\n\n<p>In your code, you post a Runnable while declaring it anonymously inline.  If you do that, won't retain a reference to that Runnable.  Instead, you can store the reference to that new Runnable in a member variable or something that won't be forgotten by the time you want to remove it.</p>\n\n<pre><code>private Runnable r;  // assign before use\nprivate Handler h;   // assign before use\n\nprivate void schedule() {\n    h.postDelayed(r, 99999);\n}\n\nprivate void cancel() {\n    h.removeCallbacks(r);\n}\n</code></pre>\n","answer_id":35881920,"question_id":35881814},{"owner":{"profile_image":"https://i.stack.imgur.com/7H9TF.png?s=256&g=1","account_id":2994830,"user_type":"registered","user_id":2541560,"link":"https://stackoverflow.com/users/2541560/kayaman","reputation":1,"display_name":"Kayaman"},"content_license":"CC BY-SA 3.0","score":3,"is_accepted":false,"last_activity_date":1456390979,"creation_date":1456390979,"body":"<p>Unless you call <code>p.waitFor();</code> your process will happily run concurrently alongside the process that it spawned (<code>p</code>).</p>\n","answer_id":35622631,"question_id":35622593},{"owner":{"profile_image":"https://www.gravatar.com/avatar/bb15dcf43c8fe4a01b9d16e93690e118?s=256&d=identicon&r=PG","account_id":543250,"user_type":"registered","user_id":912319,"link":"https://stackoverflow.com/users/912319/kanagavelu-sugumar","reputation":18874,"display_name":"Kanagavelu Sugumar","accept_rate":62},"content_license":"CC BY-SA 3.0","score":5,"is_accepted":false,"last_activity_date":1452144546,"creation_date":1449058064,"body":"<blockquote>\n  <p>ThreadLocal will ensure accessing the mutable object by the multiple\n  threads in the non synchronized method is synchronized, means making\n  the mutable object to be immutable within the method. <BR> <BR> This\n  is achieved by giving new instance of mutable object for each thread\n  try accessing it. So It is local copy to the each thread. This is some\n  hack on making instance variable in a method to be accessed like a\n  local variable. As you aware method local variable is only available\n  to the thread, one difference is; method local variables will not\n  available to the thread once method execution is over where as mutable\n  object shared with threadlocal will be available across multiple\n  methods till we clean it up.</p>\n</blockquote>\n\n<p><strong>By Definition:</strong></p>\n\n<blockquote>\n  <p>The ThreadLocal class in Java enables you to create variables that can\n  only be read and written by the same thread. Thus, even if two threads\n  are executing the same code, and the code has a reference to a\n  ThreadLocal variable, then the two threads cannot see each other's\n  ThreadLocal variables.</p>\n</blockquote>\n\n<p>Each <code>Thread</code> in java contains <code>ThreadLocalMap</code> in it. <BR>\nWhere <BR></p>\n\n<pre><code>Key = One ThreadLocal object shared across threads.\nvalue = Mutable object which has to be used synchronously, this will be instantiated for each thread.\n</code></pre>\n\n<p><strong>Achieving the ThreadLocal:</strong> </p>\n\n<p>Now create a wrapper class for ThreadLocal which is going to hold the mutable object like below (with or without <code>initialValue()</code>). <BR> Now getter and setter of this wrapper will work on threadlocal instance instead of mutable object.</p>\n\n<p>If getter() of threadlocal didn't find any value with in the threadlocalmap of the <code>Thread</code>; then it will invoke the initialValue() to get its private copy with respect to the thread.</p>\n\n<pre><code>class SimpleDateFormatInstancePerThread {\n\n    private static final ThreadLocal&lt;SimpleDateFormat&gt; dateFormatHolder = new ThreadLocal&lt;SimpleDateFormat&gt;() {\n\n        @Override\n        protected SimpleDateFormat initialValue() {\n            SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\") {\n                UUID id = UUID.randomUUID();\n                @Override\n                public String toString() {\n                    return id.toString();\n                };\n            };\n            System.out.println(\"Creating SimpleDateFormat instance \" + dateFormat +\" for Thread : \" + Thread.currentThread().getName());\n            return dateFormat;\n        }\n    };\n\n    /*\n     * Every time there is a call for DateFormat, ThreadLocal will return calling\n     * Thread's copy of SimpleDateFormat\n     */\n    public static DateFormat getDateFormatter() {\n        return dateFormatHolder.get();\n    }\n\n    public static void cleanup() {\n        dateFormatHolder.remove();\n    }\n}\n</code></pre>\n\n<p>Now <code>wrapper.getDateFormatter()</code> will call <code>threadlocal.get()</code> and that will check the <code>currentThread.threadLocalMap</code> contains <strong>this</strong> (threadlocal) instance.<BR>\nIf yes return the value (SimpleDateFormat) for corresponding threadlocal instance <BR>\nelse add the map with this threadlocal instance, initialValue(). <BR></p>\n\n<p>Herewith thread safety achieved on this mutable class; by each thread is working with its own mutable instance but with same ThreadLocal instance. Means All the thread will share the same ThreadLocal instance as key, but different SimpleDateFormat instance as value.</p>\n\n<p><a href=\"https://github.com/skanagavelu/yt.tech/blob/master/src/ThreadLocalTest.java\" rel=\"noreferrer\">https://github.com/skanagavelu/yt.tech/blob/master/src/ThreadLocalTest.java</a></p>\n","answer_id":34042362,"question_id":817856,"last_edit_date":1452144546},{"owner":{"profile_image":"https://i.stack.imgur.com/lwpFY.png?s=256&g=1","account_id":6764092,"user_type":"registered","user_id":5264490,"link":"https://stackoverflow.com/users/5264490/chromium","reputation":517,"display_name":"Chromium","accept_rate":100},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1452136702,"creation_date":1452136702,"body":"<p>There is a simple way of passing parameters into runnables.\nCode:</p>\n\n<pre><code>public void Function(final type variable) {\n    Runnable runnable = new Runnable() {\n        public void run() {\n            //Code adding here...\n        }\n    };\n    new Thread(runnable).start();\n}\n</code></pre>\n","answer_id":34646813,"question_id":877096},{"owner":{"profile_image":"https://www.gravatar.com/avatar/3e83e511e401770207ffbb0d31b8ffb4?s=256&d=identicon&r=PG","account_id":916980,"user_type":"registered","user_id":2580516,"link":"https://stackoverflow.com/users/2580516/warren-dew","reputation":8820,"display_name":"Warren Dew"},"content_license":"CC BY-SA 3.0","score":8,"is_accepted":false,"last_activity_date":1446016175,"creation_date":1446016175,"body":"<p>In the case of multithreaded code with both reads and writes, if a thread neglects to obtain a lock while reading, it risks reading inconsistent or garbage data due to a simultaneous write.  For example, it could read a long variable just as that long variable was being written, and it could read the high half of the old value and the low half of the new value, which means the value it read would be complete garbage, something that was never actually written.</p>\n\n<p>If a thread with a read lock writes without the write lock, it could cause other reading threads to read garbage data in a similar manner.</p>\n","answer_id":33384952,"question_id":33384822},{"owner":{"profile_image":"https://i.stack.imgur.com/XpMUU.jpg?s=256&g=1","account_id":1431364,"user_type":"registered","user_id":1353722,"link":"https://stackoverflow.com/users/1353722/lefloh","reputation":10713,"display_name":"lefloh","accept_rate":81},"content_license":"CC BY-SA 3.0","score":9,"is_accepted":false,"last_activity_date":1444797794,"creation_date":1444797794,"body":"<p>Your implementation is not thread-safe. When two threads access <code>someMethod</code> at the same time they are sharing the same <code>Client</code> and one will try to make a second request while the first one is not finished. </p>\n\n<p>You have two choices:</p>\n\n<ul>\n<li>Synchronize the access to the <code>Client</code> and <code>WebTarget</code> manually.</li>\n<li>Let the container manage concurrency by annotating the enclosing type with <code>@javax.ejb.Singleton</code> which guarantees thread safety. (see chapter 4.8.5 of the <a href=\"http://download.oracle.com/otn-pub/jcp/ejb-3.1-pfd-oth-JSpec/ejb-3_1-pfd-spec.pdf\" rel=\"noreferrer\">EJB specification</a>)</li>\n</ul>\n\n<p>If <code>someMethod</code> in a container managed environment I would use the second approach.</p>\n","answer_id":33116773,"question_id":33097230},{"owner":{"profile_image":"https://i.stack.imgur.com/rHVf5.jpg?s=256&g=1","account_id":2353205,"user_type":"registered","user_id":2061604,"link":"https://stackoverflow.com/users/2061604/andrei","reputation":43254,"display_name":"Andrei","accept_rate":73},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1441713166,"creation_date":1441712019,"body":"<h2>Specially for Android</h2>\n\n<p>For callback purposes I usually implement my own generic <code>Runnable</code> with input parameter(s):</p>\n\n<pre><code>public interface Runnable&lt;TResult&gt; {\n    void run(TResult result);\n}\n</code></pre>\n\n<p>Usage is simple:</p>\n\n<pre><code>myManager.doCallbackOperation(new Runnable&lt;MyResult&gt;() {\n    @Override\n    public void run(MyResult result) {\n        // do something with the result\n    }\n});\n</code></pre>\n\n<p>In manager:</p>\n\n<pre><code>public void doCallbackOperation(Runnable&lt;MyResult&gt; runnable) {\n    new AsyncTask&lt;Void, Void, MyResult&gt;() {\n        @Override\n        protected MyResult doInBackground(Void... params) {\n            // do background operation\n            return new MyResult(); // return resulting object\n        }\n\n        @Override\n        protected void onPostExecute(MyResult result) {\n            // execute runnable passing the result when operation has finished\n            runnable.run(result);\n        }\n    }.execute();\n}\n</code></pre>\n","answer_id":32456728,"question_id":877096,"last_edit_date":1441713166},{"owner":{"profile_image":"https://www.gravatar.com/avatar/1768cce8ccf2dffe3483b0ab5d7cfd74?s=256&d=identicon&r=PG","account_id":10987,"user_type":"registered","user_id":21005,"link":"https://stackoverflow.com/users/21005/mnementh","reputation":50685,"display_name":"Mnementh","accept_rate":78},"content_license":"CC BY-SA 3.0","score":9,"is_accepted":false,"last_activity_date":1440141330,"creation_date":1242643320,"body":"<p>To create a thread you normally create your own implementation of Runnable. Pass the parameters to the thread in the constructor of this class.</p>\n\n<pre><code>class MyThread implements Runnable{\n   private int a;\n   private String b;\n   private double c;\n\n   public MyThread(int a, String b, double c){\n      this.a = a;\n      this.b = b;\n      this.c = c;\n   }\n\n   public void run(){\n      doSomething(a, b, c);\n   }\n}\n</code></pre>\n","answer_id":877116,"question_id":877096,"last_edit_date":1440141330},{"owner":{"profile_image":"https://www.gravatar.com/avatar/699a9b2caefb52530d1c872bb2932d21?s=256&d=identicon&r=PG","account_id":22965,"user_type":"registered","user_id":57159,"link":"https://stackoverflow.com/users/57159/ian-ringrose","reputation":51428,"display_name":"Ian Ringrose","accept_rate":89},"content_license":"CC BY-SA 3.0","score":3,"is_accepted":false,"last_activity_date":1434388741,"creation_date":1434388741,"body":"<p>Caching, sometime you have to calculate the same value lots of time so by storing the last set of inputs to a method and the result you can speed the code up.    By using Thread Local Storage you avoid having to think about locking.</p>\n","answer_id":30851175,"question_id":817856},{"owner":{"profile_image":"https://i.stack.imgur.com/vpL92.jpg?s=256&g=1","account_id":1487826,"user_type":"registered","user_id":1404798,"link":"https://stackoverflow.com/users/1404798/thirumalvalavan","reputation":2690,"display_name":"Thirumalvalavan"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1426175165,"creation_date":1426175165,"body":"<p>Below code will help to someone,</p>\n\n<pre><code>public class MyClass {\n\nprivate static Object lock = new Object();\n\npublic static void main(String args[]){\n\n    Runnable runnable1 = new Runnable() {\n        @Override\n        public void run() {\n            for(int i=1; i&lt;20; i=i+2){\n                synchronized (lock) {\n                    System.out.println(\"Thread 1: \"+i);\n                    try {\n                        lock.notifyAll();\n                        lock.wait();\n                    } catch (InterruptedException e) {\n                        System.out.println(\"Error in Thread 1: \"+e.getMessage());\n                    }\n                }\n            }\n        }\n    };\n\n\n    Runnable runnable2 = new Runnable() {\n        @Override\n        public void run() {\n            for(int i=2; i&lt;=20; i=i+2){\n                synchronized (lock) {\n                    System.out.println(\"Thread 2: \"+i);\n                    try {\n                        lock.notifyAll();\n                        lock.wait();\n                    } catch (InterruptedException e) {\n                        System.out.println(\"Error in Thread 2: \"+e.getMessage());\n                    }\n                }\n            }\n        }\n    };\n\n    Thread thread1 = new Thread(runnable1);\n    Thread thread2 = new Thread(runnable2);\n\n    System.out.println(\"Thread Start: \");\n    thread1.start();\n    thread2.start();               \n}\n\n}\n</code></pre>\n","answer_id":29014237,"question_id":24720849},{"owner":{"profile_image":"https://www.gravatar.com/avatar/6196764c912dbcdd37f80cccf20d73b0?s=256&d=identicon&r=PG","account_id":5733087,"user_type":"registered","user_id":4528039,"link":"https://stackoverflow.com/users/4528039/t-gounelle","reputation":6013,"display_name":"T.Gounelle"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1424432344,"creation_date":1424432344,"body":"<p>You create a <code>XSSFWorkbook</code> by reading the file <code>C:/Test.xlsx</code> ; the constructor called is <a href=\"http://poi.apache.org/apidocs/org/apache/poi/xssf/usermodel/XSSFWorkbook.html#XSSFWorkbook(java.io.InputStream)\" rel=\"nofollow\"><code>XSSFWorkbook(InputStream)</code></a>, which constructs a <code>OPCPackage</code>. \nThis <code>C:/Test.xlsx</code> file has to be valid, i.e. not corrupted, not empty.</p>\n\n<p>If you want to create a <em>new</em> workbook, you should not read an empty file, but rather use the appropriate constructor.</p>\n\n<p>Regarding multi-threading, I haven't tested it but there are constraints on what the different threads can do (e.g. one per <code>XSSheet</code>). Look at this <a href=\"https://mail-archives.apache.org/mod_mbox/poi-user/201109.mbox/%3C1314859350817-4757295.post@n5.nabble.com%3E\" rel=\"nofollow\">mail archive</a>.</p>\n","answer_id":28628085,"question_id":28626848},{"owner":{"profile_image":"https://www.gravatar.com/avatar/0f72a37ab8103ebfa12561218367ec3a?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":395357,"user_type":"registered","user_id":758280,"link":"https://stackoverflow.com/users/758280/jeffrey","reputation":44547,"display_name":"Jeffrey","accept_rate":100},"content_license":"CC BY-SA 3.0","score":3,"is_accepted":true,"last_activity_date":1420236923,"creation_date":1420179624,"body":"<p>I feel like it's more straightforward to implement this with one <code>Queue</code> for each producer. One thread can't wait on multiple <code>Queue</code>s, but you could combine all of the <code>Queue</code>s into one helper class so that it doesn't need to.</p>\n\n<pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Queue;\nimport java.util.concurrent.PriorityBlockingQueue;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nimport javax.annotation.concurrent.GuardedBy;\n\npublic class RoundRobin&lt;P, E&gt; {\n    private final Lock lock = new ReentrantLock();\n    private final Condition added = lock.newCondition();\n\n    @GuardedBy(\"lock\") private final Map&lt;P, Queue&lt;E&gt;&gt; queues = new LinkedHashMap&lt;&gt;();\n\n    public boolean add(P producer, E item) {\n        lock.lock();\n        try {\n            if (!queues.containsKey(producer)) {\n                queues.put(producer, new PriorityBlockingQueue&lt;&gt;());\n            }\n\n            added.signalAll();\n            return queues.get(producer).add(item);\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public Iterator&lt;E&gt; roundRobinIterator() {\n        return new Iterator&lt;E&gt;() {\n            private Iterator&lt;? extends Queue&lt;E&gt;&gt; i = null;\n            private boolean singlePass = true;\n\n            @Override\n            public boolean hasNext() {\n                return true;\n            }\n\n            @Override\n            public E next() {\n                lock.lock();\n                try {\n                    while (true) {\n                        if (i == null || !i.hasNext()) {\n                            i = queues.values().iterator();\n                            singlePass = true;\n                        }\n\n                        while (i.hasNext()) {\n                            Queue&lt;E&gt; q = i.next();\n                            if (!q.isEmpty()) {\n                                if (singlePass) {\n                                    // copy the iterator to prevent\n                                    // ConcurrentModificationExceptions\n                                    singlePass = false;\n                                    i = copy(i);\n                                }\n                                return q.poll();\n                            }\n                        }\n\n                        if (singlePass) {\n                            // If singlePass is true then we just checked every\n                            // queue and they were all empty.\n                            // Wait for another element to be added.\n                            added.await();\n                        }\n                    }\n                } catch (InterruptedException e) {\n                    throw new NoSuchElementException(e.getMessage());\n                } finally {\n                    lock.unlock();\n                }\n            }\n\n            private &lt;T&gt; Iterator&lt;? extends T&gt; copy(Iterator&lt;? extends T&gt; i) {\n                List&lt;T&gt; copy = new ArrayList&lt;&gt;();\n                while (i.hasNext()) {\n                    copy.add(i.next());\n                }\n                return copy.iterator();\n            }\n        };\n    }\n}\n</code></pre>\n","answer_id":27738182,"question_id":27737781,"last_edit_date":1420236923},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b5daee5ebc4e63ae694a4a68c902c2e8?s=256&d=identicon&r=PG","account_id":27505,"user_type":"registered","user_id":72673,"link":"https://stackoverflow.com/users/72673/maurice-perry","reputation":32693,"display_name":"Maurice Perry","accept_rate":72},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1420186136,"creation_date":1420186136,"body":"<p>I think I would do something like that:</p>\n\n<pre><code>import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class RRQueue&lt;M&gt; {\n    private final ThreadLocal&lt;Queue&lt;M&gt;&gt; threadQueue = new ThreadLocal&lt;&gt;();\n    private final List&lt;Queue&lt;M&gt;&gt; queues;\n    private int current = 0;\n\n    public RRQueue() {\n        this.queues = new ArrayList&lt;&gt;();\n    }\n\n    public synchronized void add(M msg) {\n        Queue&lt;M&gt; queue = threadQueue.get();\n        if (queue == null) {\n            queue = new LinkedList&lt;&gt;(); // or whatever\n            queues.add(queue);\n            threadQueue.set(queue);\n        }\n        queue.add(msg);\n        notify();\n    }\n\n    public synchronized M get() throws InterruptedException {\n        while (true) {\n            for (int i = 0; i &lt; queues.size(); ++i) {\n                Queue&lt;M&gt; queue = queues.get(current);\n                current = (current+1)%queues.size();\n                if (!queue.isEmpty()) {\n                    return queue.remove();\n                }\n            }\n            wait();\n        }\n    }\n}\n</code></pre>\n","answer_id":27739235,"question_id":27737781},{"owner":{"profile_image":"https://www.gravatar.com/avatar/5cfe5f7d64f44be04f147295f5c7b88e?s=256&d=identicon&r=PG","account_id":71739,"user_type":"registered","user_id":207421,"link":"https://stackoverflow.com/users/207421/user207421","reputation":307163,"display_name":"user207421","accept_rate":82},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1420181770,"creation_date":1420181770,"body":"<p>It's all in how you allocate the IDs. Allocate them <em>N</em> apart, where <em>N</em> is the number of producers, and add each producer's index to that. Then reading them sequentially will yield a round-robin order. You'll have a tiny bit of bookkeeping to do to know when to increment the underlying ID, which will happen when you reach <em>Nx-1</em> for any <em>x</em>.</p>\n","answer_id":27738534,"question_id":27737781},{"owner":{"profile_image":"https://www.gravatar.com/avatar/d3c9a4e663c77df1fe4888da3ba85bcc?s=256&d=identicon&r=PG","account_id":37853,"user_type":"registered","user_id":108350,"link":"https://stackoverflow.com/users/108350/will","reputation":4899,"display_name":"will","accept_rate":32},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1419286796,"creation_date":1419286796,"body":"<p>One further option; this approach lets you use the Runnable item like an asynchronous function call.  If your task does not need to return a result, e.g. it just performs some action you don't need to worry about how you pass back an \"outcome\".</p>\n\n<p>This pattern lets you reuse an item, where you need some kind of internal state.  When not passing  parameter(s) in the constructor care is needed to mediate the programs access to parameters.  You may need more checks if your use-case involves different callers, etc.</p>\n\n<pre><code>public class MyRunnable implements Runnable \n{\n  private final Boolean PARAMETER_LOCK  = false;\n  private X parameter;\n\n  public MyRunnable(X parameter) {\n     this.parameter = parameter;\n  }\n\n  public void setParameter( final X newParameter ){\n\n      boolean done = false;\n      synchronize( PARAMETER_LOCK )\n      {\n          if( null == parameter )\n          {\n              parameter = newParameter;\n              done = true;\n          }\n      }\n      if( ! done )\n      {\n          throw new RuntimeException(\"MyRunnable - Parameter not cleared.\" );\n      }\n  }\n\n\n  public void clearParameter(){\n\n      synchronize( PARAMETER_LOCK )\n      {\n          parameter = null;\n      }\n  }\n\n\n  public void run() {\n\n      X localParameter;\n\n      synchronize( PARAMETER_LOCK )\n      {\n          localParameter = parameter;\n      }\n\n      if( null != localParameter )\n      {\n         clearParameter();   //-- could clear now, or later, or not at all ...\n         doSomeStuff( localParameter );\n      }\n\n  }\n</code></pre>\n\n<p>}</p>\n\n<p>Thread t = new Thread(new MyRunnable(parameter));\n   t.start();</p>\n\n<p>If you need a result of processing, you will also need to coordinate completion of MyRunnable when the sub-task finishes.  You could pass a call back or just wait on the Thread 't', etc.</p>\n","answer_id":27611318,"question_id":877096},{"owner":{"profile_image":"https://www.gravatar.com/avatar/293f86043bc0fb6dba1190ad388c9d27?s=256&d=identicon&r=PG","account_id":279913,"user_type":"registered","user_id":575338,"link":"https://stackoverflow.com/users/575338/mavarazy","reputation":7622,"display_name":"mavarazy","accept_rate":59},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1416477893,"creation_date":1416472636,"body":"<p>Why not just use await with timeout?</p>\n\n<pre><code>boolean await(long timeout, TimeUnit unit);\n</code></pre>\n\n<p>If the specified waiting time elapses then the value false is returned, otherwise true is returned on await completion.</p>\n\n<p><a href=\"https://stackoverflow.com/questions/15245629/abort-countdownlatch-await-after-time-out\">Abort countDownLatch.await() after time out</a></p>\n\n<p>If you want to stop execution of other threads, if any thread fails - you'll need some additional communication layer.</p>\n\n<p>For example:</p>\n\n<pre><code>AtomicBoolean kill = new AtomicBoolean(false);\nCountDownLatch latch = new CountDownLatch(SOME_NUM);\n\nclass Task extends Runnable {\n     public void run() {\n         try {\n              ....\n              if (kill.get())\n                  throw new Exception();\n              ....\n         } catch (Throwable throwable) {\n            kill.set(true);\n         } finally {\n            countDownLatch.countDown();\n         }\n     }\n}\n</code></pre>\n\n<p>If you just want to release count down on Throwable, regardless of other processes, you can do countDown in loop on Exception</p>\n\n<pre><code>class Task extends Runnable {\n     public void run() {\n         try {\n              ....\n         } catch (Throwable throwable) {\n            while(countDownLatch.getCount() != 0)\n               countDownLatch.countDown();\n         } finally {\n            countDownLatch.countDown();\n         }\n     }\n}\n</code></pre>\n\n<p>You can combine 2 countDown tasks</p>\n\n<pre><code>CountDownLatch A = new CountDownLatch(1);\nCountDownLatch B = new CountDownLatch(1);\n\nclass CountDownTracker extend Runnable {\n     public void run() {\n         B.await();\n         A.countDown();\n     }\n}\n\nclass Task extends Runnable {\n     public void run() {\n         try {\n              ....\n         } catch (Throwable throwable) {\n            A.countDown();\n         } finally {\n            B.countDown();\n         }\n     }\n}\n</code></pre>\n\n<p>in this case A will finish after completion, or any Task failure.</p>\n\n<p>And so on...</p>\n","answer_id":27035047,"question_id":27034958,"last_edit_date":1495542446},{"owner":{"profile_image":"https://i.stack.imgur.com/KQO5i.png?s=256&g=1","account_id":3359040,"user_type":"registered","user_id":2821298,"link":"https://stackoverflow.com/users/2821298/andreas-aumayr","reputation":1006,"display_name":"Andreas Aumayr"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1416474230,"creation_date":1416474230,"body":"<p>In addition to the other answers:</p>\n\n<p>it depends on what \"but if something fails\" means, but if failing means you catch an Exception in a worker thread, you may count down the latch within the catch clause as well. This of course changes the meaning of countDown from \"Successfully processed\" to \"processing complete\" - so your code has to handle this..</p>\n","answer_id":27035517,"question_id":27034958},{"owner":{"profile_image":"https://www.gravatar.com/avatar/f61fbcc7c59e134d888f2e34cd216658?s=256&d=identicon&r=PG","account_id":1390639,"user_type":"registered","user_id":1321564,"link":"https://stackoverflow.com/users/1321564/benjamin-m","reputation":23879,"display_name":"Benjamin M","accept_rate":71},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1416472443,"creation_date":1416472443,"body":"<p>You could use a <code>Semaphore</code>, which is close to a <code>CountDownLatch</code> and it's impl has methods for manipulating it: <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html\" rel=\"nofollow\">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html</a></p>\n","answer_id":27034992,"question_id":27034958},{"owner":{"profile_image":"https://i.stack.imgur.com/tr7wR.jpg?s=256&g=1","account_id":2524075,"user_type":"registered","user_id":2193767,"link":"https://stackoverflow.com/users/2193767/thelostmind","reputation":36076,"display_name":"TheLostMind","accept_rate":78},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1416472433,"creation_date":1416472433,"body":"<p>The <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html\" rel=\"nofollow\">CountDownLatch</a> has an overloaded <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html#await(long,%20java.util.concurrent.TimeUnit)\" rel=\"nofollow\">await()</a> method which takes <em>time</em> and <em>time unit</em> as inputs and releases the lock once the given time elapses</p>\n","answer_id":27034988,"question_id":27034958},{"owner":{"profile_image":"https://www.gravatar.com/avatar/67f2ccd17aa6fd622152ad88fc2ae784?s=256&d=identicon&r=PG","account_id":422870,"user_type":"registered","user_id":801894,"link":"https://stackoverflow.com/users/801894/solomon-slow","reputation":25925,"display_name":"Solomon Slow"},"content_license":"CC BY-SA 3.0","score":31,"is_accepted":true,"last_activity_date":1415369583,"creation_date":1415369124,"body":"<blockquote>\n  <p>aren't they both doing the same task - waiting so that other threads can execute?</p>\n</blockquote>\n\n<p>Not even close, because <code>yield()</code> does not <em>wait</em> for anything.</p>\n\n<p>Every thread can be in one of a number of different states:  <em>Running</em> means that the thread is actually running on a CPU, <em>Runnable</em> means that nothing is preventing the thread from running except, maybe the availability of a CPU for it to run on.  All of the other states can be lumped into a category called <em>blocked</em>.  A blocked thread is a thread that is waiting for something to happen before it can become runnable.</p>\n\n<p>The operating system <em>preempts</em> running threads on a regular basis:  Every so often (between 10 times per second and 100 times per second on most operating systems) the OS tags each running thread and says, \"your turn is up, go to the back of the run queue' (i.e., change state from running to runnable).  Then it lets whatever thread is at the head of the run queue use that CPU (i.e., become running again).</p>\n\n<p>When your program calls <code>Thread.yield()</code>, it's saying to the operating system, \"I still have work to do, but it might not be as important as the work that some other thread is doing.  Please send me to the back of the run queue right now.\"  If there is an available CPU for the thread to run on though, then it effectively will just keep running (i.e., the yield() call will immediately return).</p>\n\n<p>When your program calls <code>foobar.wait()</code> on the other hand, it's saying to the operating system, \"Block me until some other thread calls <code>foobar.notify()</code>.</p>\n\n<p>Yielding was first implemented on non-preemptive operating systems and, in non-preemptive threading libraries.  On a computer with only one CPU, the <em>only</em> way that more than one thread ever got to run was when the threads explicitly yielded to one another.</p>\n\n<p>Yielding also was useful for <em>busy waiting</em>.  That's where a thread waits for something to happen by sitting in a tight loop, testing the same condition over and over again.  If the condition depended on some other thread to do some work, the waiting thread would yield() each time around the loop in order to let the other thread do its work.</p>\n\n<p>Now that we have preemption and multiprocessor systems and libraries that provide us with higher-level synchronization objects, there is basically no reason why an application programs would need to call <code>yield()</code> anymore.</p>\n","answer_id":26803040,"question_id":26798073,"last_edit_date":1415369583},{"owner":{"profile_image":"https://i.stack.imgur.com/t2hoD.jpg?s=256&g=1","account_id":3211603,"user_type":"registered","user_id":2711488,"link":"https://stackoverflow.com/users/2711488/holger","reputation":289317,"display_name":"Holger"},"content_license":"CC BY-SA 3.0","score":8,"is_accepted":false,"last_activity_date":1415354856,"creation_date":1415354856,"body":"<p><code>wait</code> is for <em>waiting</em> on a condition. This might not jump into the eye when looking at the method as it is entirely up to you to define what kind of condition it is. But the API tries to force you to use it correctly by requiring that you own the monitor of the object on which you are waiting, which is necessary for a correct condition check in a multi-threaded environment.</p>\n\n<p>So a correct use of <code>wait</code> looks like:</p>\n\n<pre><code>synchronized(object) {\n  while( ! /* your defined condition */)\n    object.wait();\n  /* execute other critical actions if needed */\n}\n</code></pre>\n\n<p>And it must be paired with another thread executing code like:</p>\n\n<pre><code>synchronized(object) {\n  /* make your defined condition true */)\n  object.notify();\n}\n</code></pre>\n\n<hr>\n\n<p>In contrast <code>Thread.yield()</code> is just a <em>hint</em> that your thread might release the CPU at this point of time. It’s not specified whether it actually does anything and, regardless of whether the CPU has been released or not, it has no impact on the semantics in respect to the memory model. In other words, it does not create any relationship to other threads which would be required for accessing shared variables correctly.</p>\n\n<p>For example the following loop accessing <code>sharedVariable</code> (which is not declared <code>volatile</code>) might run forever without ever noticing updates made by other threads:</p>\n\n<pre><code>while(sharedVariable != expectedValue) Thread.yield();\n</code></pre>\n\n<p>While <code>Thread.yield</code> might help other threads to run (they will run anyway on most systems), it does <em>not</em> enforce re-reading the value of <code>sharedVariable</code> from the shared memory. Thus, without other constructs enforcing memory visibility, e.g. decaring <code>sharedVariable</code> as <code>volatile</code>, this loop is broken.</p>\n","answer_id":26798737,"question_id":26798073},{"owner":{"profile_image":"https://www.gravatar.com/avatar/38750c50c11e6054c2123073b17b18fc?s=256&d=identicon&r=PG","account_id":11369,"user_type":"registered","user_id":21886,"link":"https://stackoverflow.com/users/21886/richiehindle","reputation":274348,"display_name":"RichieHindle","accept_rate":88},"content_license":"CC BY-SA 3.0","score":11,"is_accepted":false,"last_activity_date":1393507894,"creation_date":1241381121,"body":"<p><a href=\"http://docs.oracle.com/javase/7/docs/api/java/lang/ThreadLocal.html\" rel=\"noreferrer\">The documentation</a> says it very well: \"each thread that accesses [a thread-local variable] (via its get or set method) has its own, independently initialized copy of the variable\".</p>\n\n<p>You use one when each thread must have its own copy of something.  By default, data is shared between threads.</p>\n","answer_id":817864,"question_id":817856,"last_edit_date":1393507894},{"owner":{"profile_image":"https://www.gravatar.com/avatar/33feea54e02fb1147b41d2edb88659dd?s=256&d=identicon&r=PG","account_id":3684,"user_type":"registered","user_id":5346,"link":"https://stackoverflow.com/users/5346/nick-fortescue","reputation":43315,"display_name":"Nick Fortescue","accept_rate":84},"content_license":"CC BY-SA 3.0","score":128,"is_accepted":false,"last_activity_date":1371901005,"creation_date":1242643307,"body":"<h3>For Anonymous classes:</h3>\n\n<p>In response to question edits here is how it works for Anonymous classes</p>\n\n<pre><code>   final X parameter = ...; // the final is important\n   Thread t = new Thread(new Runnable() {\n       p = parameter;\n       public void run() { \n         ...\n       };\n   t.start();\n</code></pre>\n\n<hr>\n\n<h3>Named classes:</h3>\n\n<p>You have a class that extends Thread (or implements Runnable) and a constructor with the parameters you'd like to pass. Then, when you create the new thread, you have to pass in the arguments, and then start the thread, something like this:</p>\n\n<pre><code>Thread t = new MyThread(args...);\nt.start();\n</code></pre>\n\n<p>Runnable is a much better solution than Thread BTW. So I'd prefer:</p>\n\n<pre><code>   public class MyRunnable implements Runnable {\n      private X parameter;\n      public MyRunnable(X parameter) {\n         this.parameter = parameter;\n      }\n\n      public void run() {\n      }\n   }\n   Thread t = new Thread(new MyRunnable(parameter));\n   t.start();\n</code></pre>\n\n<p>This answer is basically the same as this similar question: <a href=\"https://stackoverflow.com/questions/705037/how-to-pass-parameters-to-a-thread-object\">How to pass parameters to a Thread object</a></p>\n","answer_id":877115,"question_id":877096,"last_edit_date":1495542393},{"owner":{"profile_image":"https://www.gravatar.com/avatar/8be4691d697474170946184567d36814?s=256&d=identicon&r=PG","account_id":11385,"user_type":"registered","user_id":21925,"link":"https://stackoverflow.com/users/21925/robin","reputation":24062,"display_name":"Robin","accept_rate":62},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1367050373,"creation_date":1241442624,"body":"<p>As was mentioned by @unknown (google), it's usage is to define a global variable in which the value referenced can be unique in each thread.  It's usages typically entails storing some sort of contextual information that is linked to the current thread of execution.  </p>\n\n<p>We use it in a Java EE environment to pass user identity to classes that are not Java EE aware (don't have access to HttpSession, or the EJB SessionContext).  This way the code, which makes usage of identity for security based operations, can access the identity from anywhere, without having to explicitly pass it in every method call.</p>\n\n<p>The request/response cycle of operations in most Java EE calls makes this type of usage easy since it gives well defined entry and exit points to set and unset the ThreadLocal.</p>\n","answer_id":820028,"question_id":817856,"last_edit_date":1367050373},{"owner":{"profile_image":"https://i.stack.imgur.com/Y985l.jpg?s=256&g=1","account_id":259304,"user_type":"registered","user_id":542091,"link":"https://stackoverflow.com/users/542091/ovidiu-latcu","reputation":71887,"display_name":"Ovidiu Latcu","accept_rate":92},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1364282279,"creation_date":1364282279,"body":"<p>Actually the best way would be to use <a href=\"http://developer.android.com/guide/components/loaders.html\" rel=\"nofollow\"><code>Loaders</code></a>. More specific a <a href=\"http://developer.android.com/reference/android/content/CursorLoader.html\" rel=\"nofollow\"><code>CursorLoader</code></a>. The advantage of the <code>Loaders</code> compared to <code>AsyncTasks</code> and <code>Threads</code> is that the <code>Cursors</code> will be tied to your <code>Activity</code> or <code>Fragment</code> lifecycle. So you will not end up in trobule if your <code>AsyncTask</code> or <code>Thread</code> finishes after your <code>Activity</code> or <code>Fragment</code> are stopped, and try to notify a component that is no longer present.</p>\n\n<p>You can find some examples for <code>Loaders</code> here <a href=\"http://www.grokkingandroid.com/using-loaders-in-android/\" rel=\"nofollow\">How to Use Loaders</a>, and here <a href=\"http://www.androiddesignpatterns.com/2012/07/loaders-and-loadermanager-background.html\" rel=\"nofollow\">Life Before Loaders</a>.</p>\n","answer_id":15631449,"question_id":15631304},{"owner":{"profile_image":"https://www.gravatar.com/avatar/f214a9dce3ad4cadfcb376e7c7528b02?s=256&d=identicon&r=PG","account_id":1548782,"user_type":"registered","user_id":1441666,"link":"https://stackoverflow.com/users/1441666/nirali","reputation":13681,"display_name":"Nirali","accept_rate":100},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1364282075,"creation_date":1364282075,"body":"<p>AsyncTask is better compared to Thread</p>\n\n<p><strong>AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers.</strong></p>\n\n<p>And go through this <a href=\"https://stackoverflow.com/questions/6964011/handler-vs-asynctask-vs-thread?rq=1\"><strong>Handler vs AsyncTask vs Thread</strong></a></p>\n","answer_id":15631381,"question_id":15631304,"last_edit_date":1495535524},{"owner":{"profile_image":"https://www.gravatar.com/avatar/74674ffbf8adf72c0398a64d0615f128?s=256&d=identicon&r=PG","account_id":872021,"user_type":"registered","user_id":922653,"link":"https://stackoverflow.com/users/922653/colselaw","reputation":1069,"display_name":"Colselaw","accept_rate":60},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1359596255,"creation_date":1359596255,"body":"<p>Nothing really new here, but I discovered today that <code>ThreadLocal</code> is very useful when using Bean Validation in a web application. Validation messages are localized, but by default use <code>Locale.getDefault()</code>. You can configure the <code>Validator</code> with a different <code>MessageInterpolator</code>, but there's no way to specify the <code>Locale</code> when you call <code>validate</code>. So you could create a static <code>ThreadLocal&lt;Locale&gt;</code> (or better yet, a general container with other things you might need to be <code>ThreadLocal</code> and then have your custom <code>MessageInterpolator</code> pick the <code>Locale</code> from that. Next step is to write a <code>ServletFilter</code> which uses a session value or <code>request.getLocale()</code> to pick the locale and store it in your <code>ThreadLocal</code> reference.</p>\n","answer_id":14617072,"question_id":817856},{"owner":{"profile_image":"https://i.stack.imgur.com/hlWHy.jpg?s=256&g=1","account_id":1151383,"user_type":"registered","user_id":1133011,"link":"https://stackoverflow.com/users/1133011/david-kroukamp","reputation":36217,"display_name":"David Kroukamp","accept_rate":96},"content_license":"CC BY-SA 3.0","score":13,"is_accepted":true,"last_activity_date":1356721293,"creation_date":1356714034,"body":"<p>Its hard to tell what you are doing,</p>\n\n<p>but seems like you are trying to override <code>paint()</code> of a <code>Runnable</code> from within its <code>run()</code> method.</p>\n\n<p>This can surely not be done.</p>\n\n<p>The logic is </p>\n\n<ul>\n<li>Take a component</li>\n<li>Override its paint method to draw what we need</li>\n<li>Call method to update co-ordinates of rectangle (or in this case timer will do that)</li>\n<li>Than call <code>repaint()</code> on the component so paint method may be called again and redraw the rectangle with its new co-ordinates (Timer would also take care of repainting after changing co-ordinates of Rectangle)</li>\n<li>repeat last 2 steps as many times as needed/wanted</li>\n</ul>\n\n<p>(when I say <em>component</em> I actually mean <code>JPanel</code>, <em>paint method</em> refers to overridden <code>paintComponent(..)</code> of <code>JPanel</code> as this is best practice.)</p>\n\n<p><strong>Some suggestions:</strong></p>\n\n<p>1) Dont override <code>paint</code> rather use <code>JPanel</code> and override <code>paintComponent</code>. </p>\n\n<p>2) Dont forget to honor the <em>paint chain</em> and call <code>super.XXX</code> implementation of overridden <code>paintComponent(Graphics g)</code> (or any overridden method for that fact) unless purposefully leaving it out. i.e</p>\n\n<pre><code>class MyPanel extends JPanel {\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n\n         //do drawings here\n    }\n}\n</code></pre>\n\n<p>3) If drawing in <code>paintComponent</code> it is usually needed to override <code>getPreferredSize()</code> and return <code>Dimension</code>s which fit the contents/drawings of <code>JPanel</code>, i.e:</p>\n\n<pre><code>class MyPanel extends JPanel {\n    @Override\n    public Dimension getPreferredSize() {\n         return new Dimension(300,300);\n    }\n}\n</code></pre>\n\n<p>3) Look at <a href=\"http://docs.oracle.com/javase/tutorial/uiswing/misc/timer.html\"><code>Swing Timer</code></a> instead of <code>Thread.sleep(..)</code> as <code>sleep</code> will block GUI thread and make it seem to be frozen. i.e</p>\n\n<pre><code>Timer t = new Timer(10, new AbstractAction() {\n    int count = 20;\n    @Override\n    public void actionPerformed(ActionEvent ae) {\n        if (count &lt; 1000) {\n            //increment rectangles y position\n            //now repaint container so we can see changes in co-ordinates (unless you have a timer which repaints for you too)\n            count++;\n        } else {//counter is at 1000 stop the timer\n            ((Timer) ae.getSource()).stop();\n        }\n    }\n});\nt.start();\n</code></pre>\n\n<p>4) An alternative (because I see for now you are only moving a <code>Rectangle</code> which is not a Swing component) to Swing timer is <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/TimerTask.html\"><code>TimerTask</code></a>, and this can be used as long as no Swing components will be created/manipulated from within its <code>run()</code> method (as <code>TimerTask</code> does not run on EDT like Swing Timer). Note <code>revalidate()</code> and <code>repaint()</code> are <em>Thread-safe</em> so it can be used within <code>TimerTask</code>.</p>\n\n<p>The advantage of the above is unnecessary code is kept of EDT (i.e moving AWT rectangle by changing co-ords) i.e</p>\n\n<pre><code>    final TimerTask tt = new TimerTask() {\n        @Override\n        public void run() {\n            if (count &lt; 1000) {\n               //increment rectangles y position\n                //now repaint container so we can see changes in co-ordinates (unless you have a timer which repaints for you too)\n            count++;\n            } else {//counter is at 1000 stop the timer\n                cancel();\n            }\n        }\n    };\n\n    new Timer().scheduleAtFixedRate(tt, 0, 10);//start in 0milis and call run every 10 milis\n</code></pre>\n","answer_id":14072987,"question_id":14072940,"last_edit_date":1356721293},{"owner":{"profile_image":"https://www.gravatar.com/avatar/72fd1ca57aa0094fd5b9d0430f95c98e?s=256&d=identicon&r=PG","account_id":1640346,"user_type":"registered","user_id":1512926,"link":"https://stackoverflow.com/users/1512926/jeff-richley","reputation":1,"display_name":"Jeff Richley"},"content_license":"CC BY-SA 3.0","score":5,"is_accepted":false,"last_activity_date":1351018209,"creation_date":1351018209,"body":"<p>You have to be very careful with the ThreadLocal pattern.  There are some major down sides like Phil mentioned, but one that wasn't mentioned is to make sure that the code that sets up the ThreadLocal context isn't \"re-entrant.\"</p>\n\n<p>Bad things can happen when the code that sets the information gets run a second or third time because information on your thread can start to mutate when you didn't expect it.  So take care to make sure the ThreadLocal information hasn't been set before you set it again.</p>\n","answer_id":13037170,"question_id":817856},{"owner":{"profile_image":"https://i.stack.imgur.com/7auRa.png?s=256&g=1","account_id":1300215,"user_type":"registered","user_id":1250303,"link":"https://stackoverflow.com/users/1250303/java42","reputation":7638,"display_name":"Java42"},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1331499712,"creation_date":1330967720,"body":"<p>Parameter passing via the start() and run() methods:</p>\n\n<pre><code>// Tester\npublic static void main(String... args) throws Exception {\n    ThreadType2 t = new ThreadType2(new RunnableType2(){\n        public void run(Object object) {\n            System.out.println(\"Parameter=\"+object);\n        }});\n    t.start(\"the parameter\");\n}\n\n// New class 1 of 2\npublic class ThreadType2 {\n    final private Thread thread;\n    private Object objectIn = null;\n    ThreadType2(final RunnableType2 runnableType2) {\n        thread = new Thread(new Runnable() {\n            public void run() {\n                runnableType2.run(objectIn);\n            }});\n    }\n    public void start(final Object object) {\n        this.objectIn = object;\n        thread.start();\n    }\n    // If you want to do things like setDaemon(true); \n    public Thread getThread() {\n        return thread;\n    }\n}\n\n// New class 2 of 2\npublic interface RunnableType2 {\n    public void run(Object object);\n}\n</code></pre>\n","answer_id":9570940,"question_id":877096,"last_edit_date":1331499712},{"owner":{"profile_image":"https://www.gravatar.com/avatar/1738dc801b47a9191702b57447f3392c?s=256&d=identicon&r=PG","account_id":95724,"user_type":"registered","user_id":260541,"link":"https://stackoverflow.com/users/260541/rhu","reputation":963,"display_name":"rhu"},"content_license":"CC BY-SA 2.5","score":4,"is_accepted":true,"last_activity_date":1301871559,"creation_date":1301871559,"body":"<p>If you use Log4j, there is a specific mechanism for handling this type of logging pattern, split between two classes <a href=\"http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/NDC.html\" rel=\"nofollow\">org.apache.log4j.NDC</a> and <a href=\"http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/NDC.html\" rel=\"nofollow\">org.apache.log4j.MDC</a> ('Nested and Mapped Diagnostic Contexts').</p>\n\n<p>Have a browse at <a href=\"http://wiki.apache.org/logging-log4j/NDCvsMDC\" rel=\"nofollow\">NDC vs MDC - Which one should I use?</a> to see which is the best to use for your particular situation.</p>\n\n<p>Here's another link which describes MDC use in a bit more practical detail: <a href=\"http://onjava.com/pub/a/onjava/2002/08/07/log4j.html?page=3\" rel=\"nofollow\">Build Flexible Logs With log4j - O'Reilly Media</a></p>\n\n<p>Note that underlying storage mechanism MDC/NDC uses (I believe) is ThreadLocal anyway.</p>\n","answer_id":5533107,"question_id":5532864},{"owner":{"profile_image":"https://www.gravatar.com/avatar/087489aab3f24970d7a04fa604455df6?s=256&d=identicon&r=PG","account_id":289607,"user_type":"registered","user_id":590689,"link":"https://stackoverflow.com/users/590689/m-genova","reputation":377,"display_name":"m.genova"},"content_license":"CC BY-SA 2.5","score":1,"is_accepted":false,"last_activity_date":1301869686,"creation_date":1301869686,"body":"<p>I use your second approach in developed software (printserver), but threads have a long run so \"setName()\" don't add latency in processing.\nThe logging phase is very good showing thread name.</p>\n\n<p>I think \"setName()\" is a problema in two case:</p>\n\n<ol>\n<li>very short run;</li>\n<li>thread used by more actors with different id (but this is not your context, or not?).</li>\n</ol>\n\n<p>bye.</p>\n","answer_id":5532975,"question_id":5532864},{"owner":{"profile_image":"https://www.gravatar.com/avatar/48c0da7b99e8558e7180f5621573eac2?s=256&d=identicon&r=PG","account_id":37202,"user_type":"registered","user_id":106315,"link":"https://stackoverflow.com/users/106315/jwoolard","reputation":6114,"display_name":"jwoolard","accept_rate":93},"content_license":"CC BY-SA 2.5","score":18,"is_accepted":false,"last_activity_date":1242643876,"creation_date":1242643393,"body":"<p>When you create a thread, you need an instance of <code>Runnable</code>. The easiest way to pass in a parameter would be to pass it in as an argument to the constructor:</p>\n\n<pre><code>public class MyRunnable implements Runnable {\n\n    private volatile String myParam;\n\n    public MyRunnable(String myParam){\n        this.myParam = myParam;\n        ...\n    }\n\n    public void run(){\n        // do something with myParam here\n        ...\n    }\n\n}\n\nMyRunnable myRunnable = new myRunnable(\"Hello World\");\nnew Thread(myRunnable).start();\n</code></pre>\n\n<p>If you then want to change the parameter while the thread is running, you can simply add a setter method to your runnable class:</p>\n\n<pre><code>public void setMyParam(String value){\n    this.myParam = value;\n}\n</code></pre>\n\n<p>Once you have this, you can change the value of the parameter by calling like this:</p>\n\n<pre><code>myRunnable.setMyParam(\"Goodbye World\");\n</code></pre>\n\n<p>Of course, if you want to trigger an action when the parameter is changed, you will have to use locks, which makes things considerably more complex.</p>\n","answer_id":877118,"question_id":877096,"last_edit_date":1242643876},{"owner":{"profile_image":"https://i.stack.imgur.com/DVUwx.jpg?s=256&g=1","account_id":32251,"user_type":"registered","user_id":89266,"link":"https://stackoverflow.com/users/89266/dfa","reputation":114942,"display_name":"dfa","accept_rate":91},"content_license":"CC BY-SA 2.5","score":57,"is_accepted":false,"last_activity_date":1242643645,"creation_date":1242643248,"body":"<p>via constructor of a Runnable or Thread class</p>\n\n<pre><code>class MyThread extends Thread {\n\n    private String to;\n\n    public MyThread(String to) {\n        this.to = to;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"hello \" + to);\n    }\n}\n\npublic static void main(String[] args) {\n    new MyThread(\"world!\").start();\n}\n</code></pre>\n","answer_id":877104,"question_id":877096,"last_edit_date":1242643645},{"owner":{"profile_image":"https://www.gravatar.com/avatar/2c4d219e169610bd0ab7a4bcf5762e3a?s=256&d=identicon&r=PG","account_id":14954,"user_type":"registered","user_id":31136,"link":"https://stackoverflow.com/users/31136/bruno-conde","reputation":47917,"display_name":"bruno conde","accept_rate":50},"content_license":"CC BY-SA 2.5","score":10,"is_accepted":false,"last_activity_date":1242643598,"creation_date":1242643598,"body":"<p>You can either extend the <a href=\"http://java.sun.com/javase/6/docs/api/java/lang/Thread.html?is-external=true\" rel=\"noreferrer\"><code>Thread</code></a> <code>class</code> or the <a href=\"http://java.sun.com/javase/6/docs/api/java/lang/Runnable.html\" rel=\"noreferrer\"><code>Runnable</code></a> <code>class</code> and provide parameters as you want. There are simple examples in the <a href=\"http://java.sun.com/javase/6/docs/api/java/lang/Thread.html?is-external=true\" rel=\"noreferrer\">docs</a>. I'll port them here:</p>\n\n<pre><code> class PrimeThread extends Thread {\n     long minPrime;\n     PrimeThread(long minPrime) {\n         this.minPrime = minPrime;\n     }\n\n     public void run() {\n         // compute primes larger than minPrime\n          . . .\n     }\n }\n\n PrimeThread p = new PrimeThread(143);\n p.start();\n\n class PrimeRun implements Runnable {\n     long minPrime;\n     PrimeRun(long minPrime) {\n         this.minPrime = minPrime;\n     }\n\n     public void run() {\n         // compute primes larger than minPrime\n          . . .\n     }\n }\n\n\n PrimeRun p = new PrimeRun(143);\n new Thread(p).start();\n</code></pre>\n","answer_id":877132,"question_id":877096},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c53d539b59c19087182f0b1c53bb52de?s=256&d=identicon&r=PG","account_id":7450,"user_type":"registered","user_id":12960,"link":"https://stackoverflow.com/users/12960/brian-agnew","reputation":269220,"display_name":"Brian Agnew"},"content_license":"CC BY-SA 2.5","score":3,"is_accepted":false,"last_activity_date":1242643301,"creation_date":1242643301,"body":"<p>You can derive a class from Runnable, and during the construction (say) pass the parameter in.</p>\n\n<p>Then launch it using Thread.start(Runnable r);</p>\n\n<p>If you mean <em>whilst</em> the thread is running, then simply hold a reference to your derived object in the calling thread, and call the appropriate setter methods (synchronising where appropriate)</p>\n","answer_id":877112,"question_id":877096},{"owner":{"profile_image":"https://www.gravatar.com/avatar/1bf160a6e7f3d51d74f4f3d25982b75b?s=256&d=identicon&r=PG","account_id":27166,"user_type":"registered","user_id":71399,"link":"https://stackoverflow.com/users/71399/pauljwilliams","reputation":19089,"display_name":"pauljwilliams","accept_rate":65},"content_license":"CC BY-SA 2.5","score":7,"is_accepted":false,"last_activity_date":1242643262,"creation_date":1242643262,"body":"<p>Either write a class that implements Runnable, and pass whatever you need in a suitably defined constructor, or write a class that extends Thread with a suitably defined constructor that calls super() with appropriate parameters.</p>\n","answer_id":877106,"question_id":877096},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e9f9bb459497b506ded2b14cf67ba30d?s=256&d=identicon&r=PG","account_id":35470,"user_type":"registered","user_id":100464,"link":"https://stackoverflow.com/users/100464/user100464","reputation":17531,"display_name":"user100464","accept_rate":91},"content_license":"CC BY-SA 2.5","score":55,"is_accepted":false,"last_activity_date":1241382039,"creation_date":1241382039,"body":"<p>In Java, if you have a datum that can vary per-thread, your choices are to pass that datum around to every method that needs (or may need) it, or to associate the datum with the thread.  Passing the datum around everywhere may be workable if all your methods already need to pass around a common \"context\" variable.  </p>\n\n<p>If that's not the case, you may not want to clutter up your method signatures with an additional parameter.  In a non-threaded world, you could solve the problem with the Java equivalent of a global variable.  In a threaded word, the equivalent of a global variable is a thread-local variable.</p>\n","answer_id":817911,"question_id":817856},{"owner":{"profile_image":"https://www.gravatar.com/avatar/6b2c535fac79e482b71f15de561f55ca?s=256&d=identicon&r=PG","account_id":60171,"user_type":"registered","user_id":179850,"link":"https://stackoverflow.com/users/179850/gray","reputation":115485,"display_name":"Gray","accept_rate":100},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1676413077,"creation_date":1676413077,"body":"<blockquote>\n<p>while I was doing an exercise on the synchronization method I couldn't able to get a proper output but when I'm trying the same exercise by implementing Runnable it's working fine</p>\n</blockquote>\n<p>So your &quot;proper output&quot; is when the output is synchronized that each teacher enters, teaches, and exits before other teacher output is displayed.</p>\n<pre><code>Physics teacher enters class room\nPhysics teacher teaching students\nPhysics teacher exits class room\nEnglish teacher enters class room\nEnglish teacher teaching students\nEnglish teacher exits class room\nCS teacher enters class room\n...\n</code></pre>\n<p>When you have the <code>synchronize</code> keyword on a non-static method, the lock that gets enabled when the method is called is applied on the <em>instance</em> of the object that contains the method.  In the case of the <code>ClassRoom</code> <code>Runnable</code>, each of the threads is sharing <code>class_room</code>:</p>\n<pre><code>ClassRoom class_room = new ClassRoom();\nThread t1 = new Thread(class_room);\nThread t2 = new Thread(class_room);\nThread t3 = new Thread(class_room);\n</code></pre>\n<p>In this case the same <code>ClassRoom</code> object instance is being locked by all 3 threads and the synchronization ensures that only one thread executes the <code>run()</code> method at a time.  Excellent.</p>\n<p>Now let's look at the <code>Thread</code> case:</p>\n<pre><code>ClassRoom physics_class = new ClassRoom();\nClassRoom cs_class = new ClassRoom();\nClassRoom english_class = new ClassRoom();\n</code></pre>\n<p>In this case, there are 3 separate instances of <code>ClassRoom</code> so the <code>synchronized</code> keyword is locking on 3 different objects so each thread works independently.</p>\n<pre><code>Thread t1 = new Thread(new ClassRoom()); // &lt;- distinct instance\n</code></pre>\n<p>Aside from the locking issue, you don't want to do this if <code>ClassRoom</code> extends <code>Thread</code> because you are creating 2 <code>Thread</code> objects – the <code>ClassRoom</code> and the <code>new Thread(...)</code> that wraps the <code>ClassRoom</code> but only starting one of them.  This is very confusing and unnecessary.  <code>ClassRoom</code> should implement <code>Runnable</code> instead.</p>\n","answer_id":75453771,"question_id":75433400},{"owner":{"profile_image":"https://lh3.googleusercontent.com/a/AEdFTp7DA9dycOPxmVqchXxiKqTDCkZOCxgPtCijdF0B=k-s256","account_id":27771970,"user_type":"registered","user_id":21202100,"link":"https://stackoverflow.com/users/21202100/pt7092","reputation":11,"display_name":"pt7092 "},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1676292635,"creation_date":1676292557,"body":"<p>Yield(): When a running thread is stopped to give its space to another thread with a high priority, this is called Yield.Here the running thread changes to runnable thread.</p>\n<p>Wait(): A thread is waiting to get resources from a thread to continue its execution.</p>\n","answer_id":75436114,"question_id":26798073,"last_edit_date":1676292635},{"owner":{"profile_image":"https://lh3.googleusercontent.com/a/AEdFTp61CUpQI3VbC_PLq34lGLauPTVC9VC23rZkIOSpZw=k-s256","account_id":27772393,"user_type":"registered","user_id":21202467,"link":"https://stackoverflow.com/users/21202467/nasir-mushtaq","reputation":1,"display_name":"Nasir Mushtaq"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1676279114,"creation_date":1676279114,"body":"<p>Was facing the same issue,  Paul Samsotha's answer helped. Creating Client loads jersey jars and JARFile in java overrides finalize method putting lot of overhead on finalizer thread.</p>\n","answer_id":75433827,"question_id":38570732},{"owner":{"profile_image":"https://i.stack.imgur.com/zHTaT.png?s=256&g=1","account_id":39208,"user_type":"registered","user_id":112968,"link":"https://stackoverflow.com/users/112968/knittl","reputation":251260,"display_name":"knittl","accept_rate":68},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1676278578,"creation_date":1676278578,"body":"<p>With the <code>Runnable</code> implementation, you are sharing a single instance across all threads. In the former, you are having 3 separate instances.</p>\n<p>To match the behavior of separate threads with a runnable, you have to use separate runnables too:</p>\n<pre><code>public class ClassRoomApp  {\n\n    public static void main(String[] args) throws InterruptedException {\n        \n        Thread t1 = new Thread(new ClassRoom()); // &lt;- distinct instance\n        Thread t2 = new Thread(new ClassRoom()); // &lt;- distinct instance\n        Thread t3 = new Thread(new ClassRoom()); // &lt;- distinct instance\n            \n        t1.setName(&quot;Physics teacher&quot;);\n        t2.setName(&quot;CS teacher&quot;);\n        t3.setName(&quot;English teacher&quot;);\n    \n        t1.start();\n        t2.start();\n        t3.start();\n        \n    }\n\n}\n</code></pre>\n","answer_id":75433733,"question_id":75433400},{"owner":{"profile_image":"https://www.gravatar.com/avatar/97cbc5a26a5cfcdbb3fb718c3e066d87?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":21083132,"user_type":"registered","user_id":15496965,"link":"https://stackoverflow.com/users/15496965/henning","reputation":3240,"display_name":"Henning"},"content_license":"CC BY-SA 4.0","score":-1,"is_accepted":false,"last_activity_date":1676135847,"creation_date":1675979780,"body":"<p>Skipped lines are not counted when considering whether <code>maxItemCount</code> lines have been read.</p>\n<p>Instead of calculating the variable <code>toId</code> and passing it to <code>maxItemCount</code>, you need to pass the fixed value <code>range</code> to <code>maxItemCount</code>.</p>\n<p>edit: As the answer has been down-voted, I've pushed the <code>RangePartitioner</code> from the question and a <code>FixedRangePartitioner</code> to github. The latter sets <code>maxItemCount</code> to <code>range</code> and works as expected: <a href=\"https://github.com/hpoettker/so-partitioning\" rel=\"nofollow noreferrer\">https://github.com/hpoettker/so-partitioning</a></p>\n","answer_id":75404837,"question_id":55227133,"last_edit_date":1676135847},{"owner":{"profile_image":"https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG","account_id":47283,"user_type":"registered","user_id":139985,"link":"https://stackoverflow.com/users/139985/stephen-c","reputation":703927,"display_name":"Stephen C","accept_rate":69},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1676124875,"creation_date":1301873225,"body":"<blockquote>\n<p>What are the caveats for using thread.setName() apart from those mentioned in the javadoc? How does it affect performance? The peak frequency of calling thread.setName() would be about 200 per second and average about 0.3 per second.</p>\n</blockquote>\n<p>Performance should not be a significant issue.  <code>Thread.setName()</code> does a security check and then copies / sets an attribute.  The security check should be cheap unless your code is privileged code running in a security sandbox that forbids unprivileged calls to the <code>Thread.setName()</code> method.</p>\n<p><sup>In Java 9 and later, <code>setName</code> is going to tell the OS to change the native thread's name.  For Linux, Solaris, AIX and BSD (e.g. MacOS) this is done via a call to <code>pthread_setname_np</code> which makes a syscall under the hood.  With Windows, it does some weird thing with the Windows debugger ... and only works if there is a debugger already attached.  In Java 8, no attempt is made to change the native thread name.</sup></p>\n<p>The only other caveat I can think of is that thread names changing all of the time could be confusing if you are trying to debug threading behavior; e.g. looking at thread dumps, etc.o</p>\n","answer_id":5533219,"question_id":5532864,"last_edit_date":1676124875},{"owner":{"profile_image":"https://lh3.googleusercontent.com/-CNNlW_hAMJI/AAAAAAAAAAI/AAAAAAAAPFk/OfGtXwoVyTM/photo.jpg?sz=256","account_id":6183990,"user_type":"registered","user_id":4818628,"link":"https://stackoverflow.com/users/4818628/sergey-kosarev","reputation":71,"display_name":"Sergey Kosarev"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1676025693,"creation_date":1676025693,"body":"<p>There is <code>happens-before</code> between <code>Holder.read</code> and <code>Holder.write</code> methods obviously. But no any guaranties between <code>State.getAge</code> and <code>Holder.write</code>.\nif you want to read age you actually need to execute two operations:</p>\n<pre><code>(1) State state = holder.read(key);\n\n(2) int age = state.getAge();\n</code></pre>\n<p>So, if <code>Holder.write</code> in another thread happens after (1) but before (2), you may see old age value in (2).</p>\n","answer_id":75409974,"question_id":67825678},{"owner":{"profile_image":"https://i.stack.imgur.com/SEQOn.jpg?s=256&g=1","account_id":10611364,"user_type":"registered","user_id":7815223,"link":"https://stackoverflow.com/users/7815223/shagun-verma","reputation":163,"display_name":"Shagun Verma"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1675909718,"creation_date":1675909368,"body":"<p>To accomplish this, you have to use <code>Executors</code> in Java. The below code will be done the job for you-</p>\n<pre><code>btnPausePlay.setOnClickListener(view -&gt; {\n    btnPausePlay.setVisibility(View.GONE);\n    progressPausePlay.setVisibility(View.VISIBLE);\n    ExecutorService executorService =  Executors.newSingleThreadExecutor();\n        executorService.execute(() -&gt; {\n            // Implement your file download code here i.e.\n            // httpRequest_noBackgroundThread( urlStr, urlParams, fileStr, itf );\n        handler.post(() -&gt; {\n            btnPausePlay.setVisibility(View.VISIBLE);\n            progressPausePlay.setVisibility(View.GONE);\n        });\n    });\n});\n</code></pre>\n<p>When you press the btnPausePlay button, then it will become invisible and the progress bar becomes visible. After that, once the download is completed reverse will happen.</p>\n","answer_id":75393592,"question_id":75389536,"last_edit_date":1675909718},{"owner":{"profile_image":"https://www.gravatar.com/avatar/67f2ccd17aa6fd622152ad88fc2ae784?s=256&d=identicon&r=PG","account_id":422870,"user_type":"registered","user_id":801894,"link":"https://stackoverflow.com/users/801894/solomon-slow","reputation":25925,"display_name":"Solomon Slow"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1665068370,"creation_date":1665068370,"body":"<p>Not sure I understand what you're really trying to do, but changing your <code>run()</code> function so that it spends most of its time &quot;sleeping&quot; might improve the performance of your program:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public void run() {\n    System.out.println(&quot;it is running&quot;);\n    while(true) {\n        long timeUntilDelete = lastEdit - System.currentTimeMillis();\n        if (timeUntilDelete &gt; 0) {\n            try {\n                Thread.sleep(timeUntilDelete);\n            }\n            catch(InterruptedException ex) {\n                ...What you do here is up to you...\n            }\n            continue;\n        }\n        System.out.println(&quot;DELETE&quot;);\n        timerStart(12000);\n    }\n}\n</code></pre>\n","answer_id":73975979,"question_id":73968499},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG","account_id":401843,"user_type":"registered","user_id":768644,"link":"https://stackoverflow.com/users/768644/rzwitserloot","reputation":89863,"display_name":"rzwitserloot"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1665067435,"creation_date":1665067435,"body":"<p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/LockSupport.html#park()\" rel=\"nofollow noreferrer\">Reading docs</a> is fundamental.</p>\n<p>As the docs indicate, <code>LockSupport.park()</code> is allowed to spuriously return. In other words, the docs literally spell out:</p>\n<ul>\n<li>Q: &quot;Why did the park() call return so quickly?&quot;</li>\n<li>A: Because the JVM felt like it.</li>\n</ul>\n<p>LockSupport's locks are thread-global. There is exactly one semaphore (which LockSupport calls a 'permit') for each thread, you can't make more and you can't make less. Basically meaning, exactly one system within your JVM can use it, because if two use it, they confuse each other.</p>\n<p>As the docs also say:</p>\n<blockquote>\n<p>Basic thread blocking primitives for creating locks and other synchronization classes.</p>\n</blockquote>\n<p>Which in essence means: Why are you doing this? If you want locking behaviour, use e.g. <code>ReentrantLock</code> from the <code>java.util.concurrent</code> package; this isn't meant for you, and hence it has all sorts of bizarre weirdness in it, such as <code>park()</code>'s rule that it is allowed spurious returns.</p>\n<p>Most likely the <code>log.debug</code> code either [A] ends up calling <code>LockSupport.unpark(ownThread)</code> for some reason, which means the next <code>park()</code> call returns immediately, or [B] it's a timing matter. <code>log.debug</code> is not 'free', many log frameworks run 'in-place', meaning, the <code>log.debug</code> call actually goes out on disk and fsyncs, meaning, it takes a very long time indeed compared to your average non-disk-interacting java instruction (hundreds of instructions worth of time). That time is enough for the scheduler to fly by it, especially considering 'write to disk' or 'fsync' is a natural stopping point (threads in java are pre-emptive, but if you give the scheduler an excuse to pause your thread, it will usually take it).</p>\n<p>In the end, the docs are clear: You don't get an answer to your 'why' question. The specs give the JVM free reign not to have to explain to you why <code>park()</code> spuriously returns. Therefore there isn't much point chasing down the why for this case - even if you have an answer, tomorrow there can be a different reason. If your code can't handle spurious returns on <code>LockSupport.park()</code>, your code is by definition broken. Even if you can make it work on your machine, today, with this phase of the moon, then that's no guarantee it would work fine tomorrow.</p>\n<p>Once your code can handle spurious returns, figuring out why it spuriously returns here isn't interesting anymore. Thus, solution: Deal with spurious returns properly. Or, more likely, don't use this for locks, use something more friendly to end users.</p>\n","answer_id":73975752,"question_id":73975470},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e648659dd573c1161a370efa0f5e10d6?s=256&d=identicon&r=PG","account_id":238127,"user_type":"registered","user_id":506796,"link":"https://stackoverflow.com/users/506796/tenfour04","reputation":86162,"display_name":"Tenfour04","accept_rate":83},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1665061342,"creation_date":1665061342,"body":"<p>If you truly want to fire and forget, such that the coroutine will not be cancelled under any circumstance, GlobalScope is the right way to do it. The need to truly fire and forget is rare enough in practice that Kotlin gives you a warning about a &quot;fragile API&quot; if you use it, I think because so many newbies were using it for everything. This was especially a problem on Android (where Kotlin is primarily used), where long running tasks that should run even off-screen should be handled in services instead of coroutines.</p>\n<p>But, referring to your example, if <code>inventory</code> is something that could become obsolete and you want to free it to the GC at some point, you should use your own created CoroutineScope that you store in a property, so you can cancel it to clear any running coroutines and prevent them from hanging onto references that should be freed for the GC. If the scope might be used for more than one coroutine, then you should give it a <code>SupervisorJob()</code>.</p>\n<pre><code>private val coroutineScope = CoroutineScope(SupervisorJob())\n\nfun onEndOfLifecycle() { // some function called when cleaning up memory \n    coroutineScope.cancel()\n}\n</code></pre>\n","answer_id":73974282,"question_id":73973632},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e34d0dd755c1ca59cd89d4a4e566439a?s=256&d=identicon&r=PG","account_id":2226374,"user_type":"registered","user_id":1965042,"link":"https://stackoverflow.com/users/1965042/vcg","reputation":106,"display_name":"vcg"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1665028662,"creation_date":1665028662,"body":"<p>Hi so you could be using <code>ScheduledExecutorService</code>, take a look to oracle docs, you will find an example, I believe solves your problem</p>\n","answer_id":73968534,"question_id":73968499},{"owner":{"profile_image":"https://www.gravatar.com/avatar/6b2c535fac79e482b71f15de561f55ca?s=256&d=identicon&r=PG","account_id":60171,"user_type":"registered","user_id":179850,"link":"https://stackoverflow.com/users/179850/gray","reputation":115485,"display_name":"Gray","accept_rate":100},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1664922241,"creation_date":1664903717,"body":"<blockquote>\n<p>What can be the reasons for the above assumptions or the observations?</p>\n</blockquote>\n<p>One of the issues that you need to realize is that you will not get more than the core number of threads allocated in your thread-pool until the queue fills up.  I kid you not.  In your case, it's only when the 5 threads are busy and 10000 jobs are queued that the 6th thread will be started.</p>\n<p>I would set the <code>corePoolSize</code> and the <code>maxPoolSize</code> both to be 100 and then set the <code>keepAliveSeconds</code> to 30 or something if you want the core threads to drop down during periods of inactivity.  See this question for more details: <a href=\"https://stackoverflow.com/q/19528304/179850\">How to get the ThreadPoolExecutor to increase threads to max before queueing?</a></p>\n<p>Couple other comments:</p>\n<blockquote>\n<pre><code>int i = Thread.activeCount();\nlogger.info(&quot;Point 1: Active thread count : [{}]&quot;, i);\naskExecutor.execute(new Runnable() { ... });\nlogger.info(&quot;Point 2: Active thread count : [{}]&quot;, i);\n</code></pre>\n</blockquote>\n<p>The active-count won't change at point 2 since you aren't making another call to <code>Thread.activeCount()</code>.  Also, you are scheduling a job to be run by the thread-pool but that doesn't necessarily mean that a thread will be created.</p>\n<p>If you are using a <code>ThreadPoolExecutor</code> directly (as opposed to the Spring wrapper) then you could call <code>pool.getActiveCount()</code> and other methods to get a more accurate picture of the threads running in your thread pool.  The 114 threads running in your application may be associated with the tomcat handlers and other JVM threads instead of your pool specifically.  You can also use jconsole, jstack, or a <code>SIGQUIT</code> to dump the thread stacks and see how many threads are associated with your pool.  The thread names should be something like xxx-pool-1 or something unless you are using a thread-factory.</p>\n<p>Lastly a general comment.  Maybe this is obvious but you really should be trying to optimize your throughput as opposed to worrying about the number of threads.  100 may be too many threads if you are pounding the server too hard or if the job is computational or 100 may be too few if your HTTP connections take a while to be satisfied because of latency.</p>\n","answer_id":73951424,"question_id":73920478,"last_edit_date":1664922241},{"owner":{"profile_image":"https://i.stack.imgur.com/wOpca.jpg?s=256&g=1","account_id":1901420,"user_type":"registered","user_id":1717210,"link":"https://stackoverflow.com/users/1717210/tachedechoco","reputation":3763,"display_name":"TacheDeChoco"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1664813945,"creation_date":1664811858,"body":"<blockquote>\n<p>We have no control over their timeout time</p>\n</blockquote>\n<p>Do not care about the server timeouts. As an HTTP client, you can define your own timeouts, on two distinct levels:</p>\n<ul>\n<li>a <strong>connection</strong> timeout : how long max to reach the target server</li>\n<li>a <strong>read</strong> timeout : allowing you to give up after a certain amount of time (and potentially earlier than the server will abort) in case the HTTP response does not come</li>\n</ul>\n<p>See Spring doc on how to configure these two timeouts.</p>\n","answer_id":73937781,"question_id":73937447,"last_edit_date":1664813945},{"owner":{"profile_image":"https://www.gravatar.com/avatar/dc91a8e29fedbd6a6d7e03a8394009ab?s=256&d=identicon&r=PG","account_id":75804,"user_type":"registered","user_id":217324,"link":"https://stackoverflow.com/users/217324/nathan-hughes","reputation":94840,"display_name":"Nathan Hughes","accept_rate":96},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1664737739,"creation_date":1664717306,"body":"<p>Exceptions don't propagate across threads, for instance you need an UncaughtExceptionHandler to retrieve the exception thrown by another thread, see <a href=\"https://stackoverflow.com/q/6546193/217324\">How to catch an Exception from a thread</a>.</p>\n<p>So putting InterruptedException in the throws clause creates a false expectation, the exception still can't be thrown in one thread and caught in another. That's the only reason I can think of for not doing this, they are trying to communicate to the developer that the toplevel run method for a thread needs to handle everything. Putting InterruptedException in the throws clause dilutes this message, as the developer isn't forced to deal with it.</p>\n<p>But yes, they could have added InterruptedException to the throws clause of Runnable, that would make this case much simpler. But there are design goals in conflict. The designars want developers to be very aware of the exception behavior, including making  InterruptedException checked, but it's not having it in the throws clause that forces people to deal with it. The goal of letting simple things be easy and having a thread call sleep without a catch is at odds with that so it wasn't implemented.</p>\n","answer_id":73926210,"question_id":73926124,"last_edit_date":1664737739},{"owner":{"profile_image":"https://i.stack.imgur.com/MEVJT.jpg?s=256&g=1","account_id":6589671,"user_type":"registered","user_id":5091346,"link":"https://stackoverflow.com/users/5091346/andrii-abramov","reputation":10127,"display_name":"Andrii Abramov","accept_rate":72},"content_license":"CC BY-SA 4.0","score":8,"is_accepted":false,"last_activity_date":1664737068,"creation_date":1522142645,"body":"<p>Since Java 8 release, there is more declarative way to initialize <code>ThreadLocal</code>:</p>\n<pre><code>ThreadLocal&lt;String&gt; local = ThreadLocal.withInitial(() -&gt; &quot;init value&quot;);\n</code></pre>\n<p>Until Java 8 release you had to do the following:</p>\n<pre><code>ThreadLocal&lt;String&gt; local = new ThreadLocal&lt;String&gt;(){\n    @Override\n    protected String initialValue() {\n        return &quot;init value&quot;;\n    }\n};\n</code></pre>\n<p>Moreover, if instantiation method (constructor, factory method) of class that is used for <code>ThreadLocal</code> does not take any parameters, you can simply use method references (introduced in Java 8):</p>\n<pre><code>class NotThreadSafe {\n    // no parameters\n    public NotThreadSafe(){}\n}\n    \nThreadLocal&lt;NotThreadSafe&gt; container = ThreadLocal.withInitial(NotThreadSafe::new);\n</code></pre>\n<p><strong>Note:</strong>\nEvaluation is lazy since you are passing <code>java.util.function.Supplier</code> lambda that is evaluated only when <code>ThreadLocal#get</code> is called but value was not previously evaluated.</p>\n","answer_id":49509030,"question_id":817856,"last_edit_date":1664737068},{"owner":{"profile_image":"https://i.stack.imgur.com/WAhD8.png?s=256&g=1","account_id":1129864,"user_type":"registered","user_id":1116216,"link":"https://stackoverflow.com/users/1116216/michele-la-ferla","reputation":6795,"display_name":"Michele La Ferla","accept_rate":100},"content_license":"CC BY-SA 4.0","score":7,"is_accepted":false,"last_activity_date":1662061119,"creation_date":1464877239,"body":"<p>Within the lifecycle callback methods, you can declare how your activity behaves when the user leaves and re-enters the activity. Remember that the way Android is designed, there is a lifecycle for each and every app. If you put too much load to the <code>onCreate()</code> method (which is the method used to load the layout files and initalise any controls you have in it), then the white screen will become more visible, as the layout file will take longer to load.</p>\n<p>I suggest using several different methods when starting an activity. Such are the <code>onStart()</code> (being called as the first thing once the app is loaded), <code>onActivityCreated()</code> (being called after the layout is displayed and useful if you are making any data processing upon starting the activity).</p>\n<p>To make it easier for you, below is the official activity lifecycle diagram (from <a href=\"http://web.archive.org/web/20140218132043/http://developer.android.com/training/basics/activity-lifecycle/starting.html\" rel=\"nofollow noreferrer\">http://web.archive.org/web/20140218132043/http://developer.android.com/training/basics/activity-lifecycle/starting.html</a>):</p>\n<p><a href=\"https://i.stack.imgur.com/KozRu.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/KozRu.png\" alt=\"enter image description here\" /></a></p>\n","answer_id":37594546,"question_id":37437037,"last_edit_date":1662061119},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e442a53d36f9351aee11b5ecb8369691?s=256&d=identicon&r=PG","account_id":6520,"user_type":"registered","user_id":11002,"link":"https://stackoverflow.com/users/11002/tgdavies","reputation":10523,"display_name":"tgdavies","accept_rate":75},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1659525121,"creation_date":1659525121,"body":"<p>Why not simply:</p>\n<pre><code>ExecutorService executorService = Executors.newSingleThreadExecutor();\n        executorService.submit((Runnable) () -&gt; {\n            while (true) {\n                try {\n                    ...\n                } catch (Exception e) {\n                    // log\n                }\n            }\n        });\n</code></pre>\n<p>There doesn't seem to be any need for a <code>Callable</code> or a <code>Future</code>.</p>\n","answer_id":73220736,"question_id":73220654},{"owner":{"profile_image":"https://i.stack.imgur.com/b5Dq4.jpg?s=256&g=1","account_id":476019,"user_type":"registered","user_id":886697,"link":"https://stackoverflow.com/users/886697/stanislav-bashkyrtsev","reputation":14699,"display_name":"Stanislav Bashkyrtsev","accept_rate":92},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1654931009,"creation_date":1654928561,"body":"<p>I don't think you're measuring what you think you're measuring. You have 100 tasks and you measure how much time each task takes to finish. Suppose each takes 2sec. So if we execute them one after another it'll be 2sec * 100.</p>\n<p>Now suppose you run them in 8 threads and 8 cores. This doesn't (ideally) change the amount of time each task takes, so you still have 2sec for each task. And you again have 2sec * 100 of <em>summed</em> time. But the overall execution time changes - it's <code>(2sec * 100) / 8</code> because this <em>summed</em> time is now spread across 8 cores instead of 1.</p>\n<p>So what you need to measure is the total time it takes for the program to run. Just measure it in <code>runBenchmark()</code> method:</p>\n<pre><code>private void runBenchmark() throws Exception {\n  try {\n      long started = System.nanoTime();\n      for (int i = 0; i &lt; numThreads; i++)\n          benchMarkResultsFuture.add(executorService.submit(new BenchmarkThread(numOperationsPerThread)));\n      for (Future&lt;BenchmarkResult&gt; resultFuture : benchMarkResultsFuture)\n          resultFuture.get();\n\n      long timeToComplete = (System.nanoTime() - started) / 1000;\n      System.out.println(&quot;=====runBenchmark() FINISHED in &quot; + timeToComplete);\n  } finally {\n      executorService.shutdown();\n  }\n}\n</code></pre>\n","answer_id":72582182,"question_id":72582076,"last_edit_date":1654931009},{"owner":{"profile_image":"https://i.stack.imgur.com/Klcqr.gif?s=256&g=1","account_id":292208,"user_type":"registered","user_id":2245707,"link":"https://stackoverflow.com/users/2245707/pveentjer","reputation":10665,"display_name":"pveentjer","accept_rate":17},"content_license":"CC BY-SA 4.0","score":4,"is_accepted":false,"last_activity_date":1654927764,"creation_date":1654927764,"body":"<p>This could be the cause of the problem:</p>\n<pre><code>  private static final Random RANDOM = new Random();\n</code></pre>\n<p>Because this is contended between all threads.</p>\n<p>Try a ThreadLocalRandom instead.</p>\n<p>Also, I would use a more reliable benchmarking approach like JMH.</p>\n","answer_id":72582123,"question_id":72582076},{"owner":{"profile_image":"https://lh3.googleusercontent.com/a/AATXAJxX9Iix5-V4Afy0vaosyCz1npCO7X3fhNOxSnIe=k-s256","account_id":25423725,"user_type":"registered","user_id":19229200,"link":"https://stackoverflow.com/users/19229200/scizora","reputation":21,"display_name":"Scizora"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1654922791,"creation_date":1654922791,"body":"<p>Hi just to update after deploying and testing my code the implementation of shutdown hooks and setting to daemon solved this issue of threads running despite closing the jar file via cmd/pressing x. I am still looking at the Executor service as an alternative way to encapsulate my code better but tbh its still quite hard to grasp its concepts. It would be fantastic if there was an example of its implementation!</p>\n","answer_id":72581802,"question_id":72429901},{"owner":{"profile_image":"https://i.stack.imgur.com/ZWEI3.jpg?s=256&g=1","account_id":322981,"user_type":"registered","user_id":642706,"link":"https://stackoverflow.com/users/642706/basil-bourque","reputation":310755,"display_name":"Basil Bourque","accept_rate":58},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1654919342,"creation_date":1654919342,"body":"<p>Currently in Java, threads are quite expensive, being mapped directly one-to-one to host OS threads. They impact both memory usage and CPU usage. So we usually limit the number of threads to a few, often roughly the number of cores or so. So increasing/decreasing the size of the thread pool is not likely to make sense nowadays.</p>\n<h1>Virtual threads in <em>Project Loom</em></h1>\n<p>Sounds like your scenario is ideal for the <a href=\"https://openjdk.java.net/jeps/425\" rel=\"nofollow noreferrer\">virtual threads</a> (<a href=\"https://en.wikipedia.org/wiki/Fiber_(computer_science)\" rel=\"nofollow noreferrer\">fibers</a>) coming from the <a href=\"https://wiki.openjdk.java.net/display/loom/Main\" rel=\"nofollow noreferrer\"><em>Project Loom</em></a> project. Many virtual threads are mapped to a single host OS thread.</p>\n<p>In today's Java threading, if the Java code blocks, the host OS thread blocks. No further work is performed on that thread. With virtual threads, when the Java code blocks the virtual thread is dismounted from its assigned host OS thread, and “parked”. When that code eventually returns, and therefore needs further execution, it is mounted onto another host OS thread. This parking and mounting of virtual threads is <em>much</em> faster than blocking/unblocking of host OS threads. Virtual threads have much less impact on memory and and CPU. So we can have thousands, or even millions, of threads running simultaneously on conventional hardware.</p>\n<p>In your scenario where your work load may go up or down, the virtual thread facility in Project Loom will automatically manage the thread pool and scheduling. You should see vastly improved throughput with no effort on your part.</p>\n<p>A few caveats:</p>\n<ul>\n<li>Cheap threads can still do expensive things. So you may need to manage or limit your particular concurrent tasks to avoid blowing out memory or overburdening other resources.</li>\n<li>Virtual threads only make sense for tasks that block. That means most common Java work. But for entirely CPU bound tasks such as video encoding/decoding with little to no logging, storage I/O, network I/O, etc. you would stick with conventional Java threads.</li>\n<li>There may be some situations where the particular content in your task may prevent the parking while blocked. You may choose to alter your code a bit to enable the virtual thread from being “pinned” to the host OS thread. This may be especially the case with the initial releases of Loom. This situation is fluid right now in pre-release Loom, so we will need to stay informed as to changes.</li>\n</ul>\n<p>Virtual threads and other Project Loom features are available as preview features in Java 19, with experimental builds available now.</p>\n<p>For more information, see the articles, presentations, and interviews by members of the Project Loom team such as Ron Pressler and Alan Bateman.</p>\n","answer_id":72581584,"question_id":72580556},{"owner":{"profile_image":"https://lh3.googleusercontent.com/a/AATXAJzJlRNdxfu9SC29izHRXdSfvH-4Ns7e7qVBN1Yq=k-s256","account_id":25335362,"user_type":"registered","user_id":19154594,"link":"https://stackoverflow.com/users/19154594/rohit-dakota","reputation":13,"display_name":"Rohit Dakota"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1654850384,"creation_date":1654850384,"body":"<p>You should associate the properties map with the user session or request</p>\n","answer_id":72571407,"question_id":45265777},{"owner":{"profile_image":"https://i.stack.imgur.com/FKKLW.jpg?s=256&g=1","account_id":404649,"user_type":"registered","user_id":773113,"link":"https://stackoverflow.com/users/773113/mike-nakis","reputation":57192,"display_name":"Mike Nakis","accept_rate":72},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1654848295,"creation_date":1654848295,"body":"<p>All the stuff about android, java, C#, xamarin, bluetooth, etc. is irrelevant. This question is essentially asking how to build a socket server application for a small number of clients, where &quot;small&quot; here means that you have the luxury of spawning one thread per client. (If you were to serve a large number of clients, then you would have to resort to a threadpool, but in your case that would be an unnecessary complication.)</p>\n<p>The way we build a socket server application for a small number of clients is as follows:</p>\n<ol>\n<li>One thread (the &quot;Accept&quot; thread) does nothing but an endless loop where it invokes <code>serverSocket.Accept()</code>.</li>\n<li>When a socket connection is established, the &quot;Accept&quot; thread creates a &quot;Session&quot; thread for the connected socket. So, we have one &quot;Session&quot; thread per client.</li>\n<li>Each &quot;Session&quot; thread receives packets from a client and sends packets back to the client. When a &quot;Session&quot; thread has something to useful to show to the user, the &quot;Session&quot; thread &quot;posts&quot; a message to the GUI thread, which means that it sends it in a thread-safe way. Different GUI systems support different means of accomplishing this; I am not sure about Xamarin, perhaps with <code>MessagingCenter.Send()</code>.</li>\n</ol>\n","answer_id":72570970,"question_id":72557561},{"owner":{"profile_image":"https://www.gravatar.com/avatar/18b9001fd20c1e089d19f4a1e994bcdc?s=256&d=identicon&r=PG","account_id":6482932,"user_type":"registered","user_id":5019386,"link":"https://stackoverflow.com/users/5019386/mahmoud-ben-hassine","reputation":29552,"display_name":"Mahmoud Ben Hassine"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1654843263,"creation_date":1654843263,"body":"<p>While it is possible to make the commit interval and thread pool size configurable and change them at startup time, it is not possible to change them at runtime (ie &quot;in-flight&quot;) once the job execution has started.</p>\n<p>Making the commit interval and thread pool size configurable (via application/system properties or passing them as job parameters) will allow you to empirically adapt the values to best utilize your resources without having to recompile/repackage your application.</p>\n<p>The <em>runtime</em> dynamism you are looking for is not available by default, but you can always implement the <code>Step</code> interface and use it as part of a Spring Batch job next to other step types provided out-of-the-box by the framework.</p>\n","answer_id":72570061,"question_id":72567117},{"owner":{"profile_image":"https://www.gravatar.com/avatar/dc91a8e29fedbd6a6d7e03a8394009ab?s=256&d=identicon&r=PG","account_id":75804,"user_type":"registered","user_id":217324,"link":"https://stackoverflow.com/users/217324/nathan-hughes","reputation":94840,"display_name":"Nathan Hughes","accept_rate":96},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1654778339,"creation_date":1654715348,"body":"<p>The notify/notifyAll methods tell the scheduler to notify one/all of the threads currently waiting on the lock that notify or notifyAll was called on. But if a thread hasn't started waiting yet then it doesn't get notified.</p>\n<p>The solution is to introduce a condition variable that keeps wait from being called if the notifying has happened already. Define it in the same scope as your lock:</p>\n<pre><code>public static volatile boolean ready = false;\n</code></pre>\n<p>Then use it to guard the wait block, like this:</p>\n<pre><code>while (!ready) {\n    object.wait();\n}\n</code></pre>\n<p>The code calling notify/notifyAll needs to set the variable (it doesn't matter what order you do it in because the notification doesn't happen until the lock is released):</p>\n<pre><code>synchronized (object) {\n    ready = true;\n    object.notifyAll();\n}\n</code></pre>\n<p>What happens:</p>\n<p>If the waiting thread gets to the waiting part before the notifying thread does its notifying, then the waiting thread finds ready is false, so it enters the wait method, releases the lock, and stays there.  Then the notifying thread changes the flag to true and wakes up the waiting thread, which can leave the wait, reacquire the lock, and then leave the loop now that the flag is set.</p>\n<p>But if the notifying thread does its notify before the other thread waits, that's ok, because the ready flag now prevents the thread from entering the wait, it can skip over it.</p>\n<p>Further reading: <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html</a></p>\n","answer_id":72551003,"question_id":72547510,"last_edit_date":1654778339},{"owner":{"profile_image":"https://i.stack.imgur.com/qHEzx.png?s=256&g=1","account_id":3192259,"user_type":"registered","user_id":2696260,"link":"https://stackoverflow.com/users/2696260/m-deinum","reputation":117619,"display_name":"M. Deinum"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":true,"last_activity_date":1654761035,"creation_date":1654760603,"body":"<p>Do something like this.</p>\n<pre><code>ExecutorService exector = Executors.newCachedThreadPool();\n\npublic List&lt;ResultDto&gt; queryAll(List&lt;String&gt; ids) throws ExecutionException, InterruptedException {\n\n    List&lt;CompletableFuture&gt; cfs = new ArrayList&lt;&gt;(ids.size());\n    for (String id : ids) {\n      CompletableFuture cf = Completableuture.supplyAsync(() -&gt; getResult(id), exector);\n      cfs.add(cf);\n    }\n    CompletableFuture allOfThem = CompletableFuture.allOf(cfs.toArray(new CompletableFuture[0]);\n \n    CompletableFuture&lt;List&lt;ResultDto&gt;&gt; allCompletableFutures = allOfThem .thenApply(future -&gt; {\n    return cfs.stream()\n            .map(completableFuture -&gt; completableFuture.join())\n            .collect(Collectors.toList());\n});\n    return allCompletableFutures.get();\n}\n\nResultDto getResult(String id) {\n    String remoteResult = &quot; httpUtils.get()&quot; + id;\n    BaseData baseData = new BaseData();\n    baseData.setBaseInfo(&quot;baseData&quot; + id);\n    baseData.setRemoteInfo(remoteResult);\n    ResultDto resultDto = new ResultDto();\n    resultDto.setBaseData(baseData);\n    return resultDto;\n}\n</code></pre>\n<p>This will give you a non-blocking solution (it will only block in the end).</p>\n<p>Or you can make it even easier and just use a <code>parallelStream</code> and use the default fork-join pool.</p>\n<pre class=\"lang-java prettyprint-override\"><code>public List&lt;ResultDto&gt; queryAll(List&lt;String&gt; ids) throws ExecutionException, InterruptedException {\n    return ids.parallelStream().map(id -&gt; getResult(id)).collect(Collectors.toList());\n}\n\nResultDto getResult(String id) {\n    String remoteResult = &quot; httpUtils.get()&quot; + id;\n    BaseData baseData = new BaseData();\n    baseData.setBaseInfo(&quot;baseData&quot; + id);\n    baseData.setRemoteInfo(remoteResult);\n    ResultDto resultDto = new ResultDto();\n    resultDto.setBaseData(baseData);\n    return resultDto;\n}\n</code></pre>\n<p>You can probably decide which is better to read...</p>\n","answer_id":72556469,"question_id":72556212,"last_edit_date":1654761035},{"owner":{"profile_image":"https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG","account_id":47283,"user_type":"registered","user_id":139985,"link":"https://stackoverflow.com/users/139985/stephen-c","reputation":703927,"display_name":"Stephen C","accept_rate":69},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1654760346,"creation_date":1654759924,"body":"<blockquote>\n<p>Some people say that: the thread pool get method is Blocking methods, so it is no different from writing without threads.</p>\n</blockquote>\n<p>They are correct.  If you call <code>get()</code> at that point, it immediately blocks until the that particular task has completed.  So the 2nd task isn't submitted until the first one completes ... and so on.</p>\n<p>What you need to do is submit all of the tasks before calling <code>get()</code>. Something like the following pseudo-code.</p>\n<pre><code>List&lt;Future&gt; futures\nfor each id in ids:\n   futures.add(executor.submit(...))\n\nfor each future in futures:\n   result = future.get()\n   results.add(process(result))\n</code></pre>\n<p>If you can arrange that each task does the processing of its result, you potentially get more parallelism.</p>\n<p>As noted, you could use <code>CompleteableFuture.allOf</code> instead of the second loop.</p>\n","answer_id":72556323,"question_id":72556212,"last_edit_date":1654760346},{"owner":{"profile_image":"https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8532578,"user_type":"registered","user_id":6395627,"link":"https://stackoverflow.com/users/6395627/slaw","reputation":39918,"display_name":"Slaw"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1654719209,"creation_date":1654719209,"body":"<p>The problem, I believe, is in your <code>SpiderUtils</code> class. More specifically, this method:</p>\n<blockquote>\n<pre class=\"lang-java prettyprint-override\"><code>public static boolean isLinkURLValid(URI url) {\n    return url.getHost().equalsIgnoreCase(baseUrl.getHost()) &amp;&amp;\n            !containsURL(linksCrawled, url) &amp;&amp;\n            !containsURL(linksInProgress, url) &amp;&amp;\n            !url.getPath().contains(&quot;.&quot;);\n}\n</code></pre>\n</blockquote>\n<p>And this method:</p>\n<blockquote>\n<pre class=\"lang-java prettyprint-override\"><code>public static boolean containsURL(ArrayList&lt;URI&gt; urls, URI left) {\n    return urls.stream().anyMatch(right -&gt; urlsMatch(left, right));\n}\n</code></pre>\n</blockquote>\n<p>Both these methods are not <code>synchronized</code>, which means multiple threads can execute them at the same time. This is likely not a problem for the <code>containsURL(...)</code> method. Given what it does, it has no reason to be <code>synchronized</code> (neither it, nor the <code>urlsMatch(...)</code> method, rely on any external state). The problem is with how the <code>isLinkURLValid(...)</code> method passes both <code>linksCrawled</code> and <code>linksInProgress</code> to the <code>containsURL(...)</code> method.</p>\n<p>These list variables are static, and thus the same instances are passed to the <code>isLinkURLValid(...)</code> method on different threads. This would be okay, if all you did was stream the elements of these lists (i.e., only <em>read</em> from the lists). However, elsewhere in your code you also <em>add elements</em> to these lists (i.e., you <em>write</em> to the lists). These writes are performed in <code>synchronized</code> methods, but that doesn't matter because you're reading the lists without synchronizing on the same object. So, your code is vulnerable to <code>ConcurrentModificationException</code>s (you cannot modify a non-concurrent collection while iterating over it).</p>\n<p><em>I believe</em> the solution would be to simply make the <code>isLinkURLValid(...)</code> method <code>synchronized</code>, but I'm not 100% positive as I haven't tested it.</p>\n","answer_id":72551685,"question_id":72525288},{"owner":{"profile_image":"https://i.stack.imgur.com/5EJGg.png?s=256&g=1","account_id":4104221,"user_type":"registered","user_id":3368818,"link":"https://stackoverflow.com/users/3368818/woodchuck","reputation":3989,"display_name":"Woodchuck","accept_rate":75},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1649619176,"creation_date":1649617272,"body":"<p>I don't exactly follow what you're looking for. But it sounds like you're looking to execute those methods in a multi-threaded way.</p>\n<p>If that's the case, you appear to be missing some things, such as the <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html\" rel=\"nofollow noreferrer\">synchronized</a> keyword and the <a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html\" rel=\"nofollow noreferrer\">Runnable</a> interface.</p>\n<p>The following is an example to perhaps get you started down the right path. It runs as it is, but I'm sure you'll need to tweak it to accomplish your goal:</p>\n<pre><code>package SatrancSaatiRunner ;\n\nimport java.util.Scanner;\n\npublic class SatrancSaatiRunner {\n    static int beyazZamani = 60;\n    static int siyahZamani = 60;\n\n    static boolean BeyazinSirasi = false;\n    static boolean SiyahinSirasi = false;// rakip baslar\n\n    static boolean zamanVarMi = true;\n\n    public static void main(String[] args) throws InterruptedException {\n\n        SatrancSaatiRunner s = new SatrancSaatiRunner();\n\n        for (int i = 0; i &lt; 999; i++) {\n\n            //Scanner scanner = new Scanner(System.in);\n            System.out.println(&quot;Beyaz hamle yaptiktan sonra 1 e basmali&quot;);\n            System.out.println(&quot;Siyah hamle yaptiktan sonra 2 e basmali&quot;);\n\n            //int kiminSirasi = scanner.nextInt();\n            //if (kiminSirasi == 1) {\n            //    saatCalistirSiyah(BeyazinSirasi, siyahZamani, zamanVarMi, beyazZamani, siyahZamani);\n\n            //} else if (kiminSirasi == 2) {\n            //      saatCalistirBeyaz(BeyazinSirasi, siyahZamani, zamanVarMi, beyazZamani, siyahZamani);\n            //}\n        //}\n      }\n\n        Thread t1 = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                try {\n                    s.saatCalistirSiyah(BeyazinSirasi, siyahZamani, zamanVarMi, beyazZamani, siyahZamani);\n                } catch (InterruptedException e) {\n                    System.out.println(e);\n                }\n            }\n        });\n\n        Thread t2 = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                try {\n                    s.saatCalistirBeyaz(BeyazinSirasi, siyahZamani, zamanVarMi, beyazZamani, siyahZamani);\n                } catch (InterruptedException e) {\n                    System.out.println(e);\n                }\n            }\n        });\n\n        t1.start();\n        t2.start();\n\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void saatCalistirBeyaz(boolean beyazinSirasi, int siyahZamani, boolean zamanVarMi, int beyazZamani,\n            int siyahZamani1) throws InterruptedException {\n        synchronized (this) {\n            System.out.println(&quot;***Hamle Beyazda***&quot;);\n            while (true) {\n                siyahZamani++;\n                beyazZamani--;\n                System.out.print(&quot;Beyaz: &quot; + beyazZamani + &quot; &quot;);\n                System.out.print(&quot;Siyah: &quot; + siyahZamani);\n                System.out.print(&quot;\\u000C&quot;);\n                Thread.sleep(1000);\n\n                if (beyazZamani &lt;= 0 || siyahZamani &lt;= 0) {\n                    break;\n                }\n            }\n        }\n    }\n\n    private void saatCalistirSiyah(boolean beyazinSirasi, int siyahZamani, boolean zamanVarMi, int beyazZamani,\n            int siyahZamani1) throws InterruptedException {\n        System.out.println(&quot;***Hamle Siyahta***&quot;);\n        while (true) {\n            beyazZamani++;\n            siyahZamani--;\n            System.out.print(&quot;Beyaz: &quot; + beyazZamani + &quot; &quot;);\n            System.out.print(&quot;Siyah: &quot; + siyahZamani);\n            System.out.print(&quot;\\u000C&quot;);\n            Thread.sleep(1000);\n\n            if (beyazZamani &lt;= 0 || siyahZamani &lt;= 0) {\n                break;\n            }\n        }\n    }\n}\n</code></pre>\n","answer_id":71819697,"question_id":71817703,"last_edit_date":1649619176},{"owner":{"profile_image":"https://www.gravatar.com/avatar/1f698e72460b5a8c716a0c1cea91b81e?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":13429972,"user_type":"registered","user_id":9690075,"link":"https://stackoverflow.com/users/9690075/zysaaa","reputation":1807,"display_name":"zysaaa"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1646282321,"creation_date":1646282321,"body":"<p>When a thread is woken up(<code>wait</code>-&gt;<code>runnable</code>), it needs to judge again whether the current <code>counter</code> is less than <code>LIMIT</code>, otherwise, it will continue to print until <code>while (counter &lt;= LIMIT)</code> does not hold.(That's why <code>11</code> and <code>12</code> are printed too).</p>\n<p>I would suggest that you determine in advance how many times each thread will loop(This will make the code simpler):</p>\n<pre><code>    // thread1\n    // prints 1, 4, 7, 10, ...\n    synchronized void printAPStartingFrom1() {\n        int count = LIMIT % 3 == 0 ? LIMIT / 3 : LIMIT / 3 + 1;\n        for (int i = 0; i &lt; count; i++) {\n            while (counter % 3 != 1) {\n                wait();\n            }\n            printAndAddCounter();\n            notifyAll();\n        }\n    }\n    // thread2\n    // prints 2, 5, 8, 11, ...\n    synchronized void printAPStartingFrom1() {\n        int count = (LIMIT - 1) % 3 == 0 ? LIMIT / 3 : LIMIT / 3 + 1;\n        for (int i = 0; i &lt; count; i++) {\n            while (counter % 3 != 2) {\n                wait();\n            }\n            printAndAddCounter();\n            notifyAll();\n        }\n    }\n    // thread3\n    // prints 3, 6, 9, 12, ...\n    synchronized void printAPStartingFrom1() {\n        int count = LIMIT / 3;\n        for (int i = 0; i &lt; count; i++) {\n            while (counter % 3 != 0) {\n                wait();\n            }\n            printAndAddCounter();\n            notifyAll();\n        }\n    }\n</code></pre>\n","answer_id":71332202,"question_id":71328425},{"owner":{"profile_image":"https://www.gravatar.com/avatar/6b2c535fac79e482b71f15de561f55ca?s=256&d=identicon&r=PG","account_id":60171,"user_type":"registered","user_id":179850,"link":"https://stackoverflow.com/users/179850/gray","reputation":115485,"display_name":"Gray","accept_rate":100},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":true,"last_activity_date":1646246685,"creation_date":1646246685,"body":"<blockquote>\n<p>java.lang.IllegalStateException: No thread-bound request found:</p>\n</blockquote>\n<p>This exception is trying to tell you that there is no current request being processed by the <code>HttpServletRequest</code> that has been auto-wired into your class.</p>\n<p>Something is calling the <code>putData()</code> method but not as through a call to the HTTP controller.  You mention that you are using the &quot;Kafka Consumer&quot; so maybe it is the consumer code which is calling <code>putData()</code>?  You can't call it because the method needs to have a web request context to work since it needs the request headers and cookie information.</p>\n<p>You should probably separate out the data persistence code so that both the controller <code>putData()</code> method and the kafka consumer can both call it.</p>\n","answer_id":71327704,"question_id":71311675},{"owner":{"profile_image":"https://www.gravatar.com/avatar/bc9274828a5770ef2f992f78fa8f3339?s=256&d=identicon&r=PG","account_id":1306332,"user_type":"registered","user_id":1255267,"link":"https://stackoverflow.com/users/1255267/tastywheat","reputation":2147,"display_name":"TastyWheat"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1646243274,"creation_date":1646243274,"body":"<p>The documentation is unfortunately not very clear about what can and can't be reused safely. When in doubt reuse nothing. However, if you're determined to minimize overhead you can safely reuse most objects depending on the methods called.</p>\n<p>Starting with your code, here's some comments about what's happening:</p>\n<pre class=\"lang-java prettyprint-override\"><code>// (1) Store an instance of Client with its own configuration\nprivate static Client client = ClientBuilder.newClient();\n// (2) Store an instance of WebTarget with its own configuration (inherited from client)\nprivate static WebTarget webTarget = client.target(&quot;someBaseUrl&quot;);\n...\npublic static String someMethod(String arg1, String arg2)\n{\n    // (3) New instance of WebTarget (copy entrTarget config) with &quot;arg1&quot; param\n    // (4) New instance of WebTarget (copy anonymous config) with &quot;arg2&quot; param\n    WebTarget target = entrTarget.queryParam(&quot;arg1&quot;, arg1).queryParam(&quot;arg2&quot;, arg2);\n    // (5) New instance of Invocation.Builder (copy target config)\n    // (6) Invoke GET request with stored configuration\n    Response response = target.request().get();\n    final String result = response.readEntity(String.class);\n    response.close();\n    return result;\n}\n</code></pre>\n<p>I commented on the code as-is but I'm guessing <code>(3)</code> should've referenced the static <code>webTarget</code> field.</p>\n<p>A lot of objects are getting created here. Every time an object is created there's a new instance with its own copy of the configuration (so it won't affect its predecessors). In this particular case there should be no race conditions, but there are definitely ways in which this could go wrong.</p>\n<p>If on or before <code>(3)</code> you had done something like this (assuming these are legitimate properties):</p>\n<pre class=\"lang-java prettyprint-override\"><code>WebTarget target = webTarget.property(&quot;foo&quot;, fooProperty).queryParam(&quot;arg1&quot;, arg1);\n</code></pre>\n<p>Then you would be altering the configuration of the static <code>webTarget</code> field and that could cause a race condition. There are many ways to alter the configuration from the static fields so you either need to guard them carefully or just not have them at all.</p>\n<p>Also, be aware that pretty much every object that spawns from the original <code>client</code> will have a reference to it for the purpose of determining if the httpEngine has been closed. So unless you're trying to gracefully shutdown your application it's likely never a good idea to close the client.</p>\n<p>And I found out all of this by digging through the source code because there's really no good reference.</p>\n","answer_id":71327053,"question_id":33097230},{"owner":{"profile_image":"https://i.stack.imgur.com/W6OMC.png?s=256&g=1","account_id":1056871,"user_type":"registered","user_id":1059372,"link":"https://stackoverflow.com/users/1059372/eugene","reputation":117749,"display_name":"Eugene","accept_rate":97},"content_license":"CC BY-SA 4.0","score":4,"is_accepted":false,"last_activity_date":1646233694,"creation_date":1645609597,"body":"<p>The <a href=\"https://stackoverflow.com/a/71212240/1059372\">accepted answer</a> is simple, yet great. <code>volatile</code> is rarely explained and used for safe publishing, yet it provides the needed guarantees.</p>\n<p>imho, to properly prove that this works with volatile, there are some things that need explaining.</p>\n<p>The first one is &quot;program order&quot;, or the perceivable order in which things happen within a thread. We can draw this to easier grasp things:</p>\n<pre><code> --------------- T1 -------------\n | write to num or this.num=num |\n --------------------------------\n                 |\n                \\|/  (PO)\n --------------- T1 -------------\n |    write Wrapper instance    |\n --------------------------------\n                 |\n                \\|/  (??)\n --------------- T2 -------------\n |    read Wrapper instance     |\n --------------------------------\n                 |\n                \\|/  (PO)\n --------------- T2 -------------\n |      read num first time     |\n --------------------------------\n                 |\n                \\|/  (PO)\n --------------- T2 -------------\n |      read num second time    |\n --------------------------------\n</code></pre>\n<p><code>T1</code> and <code>T2</code> are thread1 and thread2 and <code>PO</code> is program order. Now a rule in the <code>JLS</code> says this:</p>\n<blockquote>\n<p>If x and y are actions of the same thread and x comes before y in program order, then hb(x, y).</p>\n</blockquote>\n<p>As such we can replace <code>PO</code> in the above drawing with <code>HB</code> (happens-before).</p>\n<p>At the same time, if <code>wrapper</code> instance is <em>not</em> volatile, there is no special relation between <em>writing</em> to <code>wrapper</code> (from <code>T1</code>) and <em>reading</em> from <code>wrapper</code> in <code>T2</code>.</p>\n<p>We need to also introduce here <em>happen-before consistency</em>:</p>\n<blockquote>\n<p>a <em>read</em> sees the last <em>write</em> in happens-before order, or <em>any other</em> write.</p>\n</blockquote>\n<p>Since we do not have a full chain of happens-before here (that <code>??</code> does not establish one), we get that : &quot;...or any other read&quot;, which means we can read <em>different</em> values in those two reads of <code>num</code> (in that <code>num != num</code>).</p>\n<hr />\n<p>If you make <code>wrapper</code> instance <code>volatile</code>, <code>JLS</code> says that:</p>\n<blockquote>\n<p>A write to a volatile field (§8.3.1.4) happens-before every subsequent read of that field.</p>\n</blockquote>\n<p>As such, we have this now:</p>\n<pre><code> --------------- T1 -------------\n | write to num or this.num=num |\n --------------------------------\n                 |\n                \\|/  (HB)\n --------------- T1 -------------\n |    write Wrapper instance    |\n --------------------------------\n                 |\n                \\|/  (HB)\n --------------- T2 -------------\n |    read Wrapper instance     |\n --------------------------------\n                 |\n                \\|/  (HB)\n --------------- T2 -------------\n |      read num first time     |\n --------------------------------\n                 |\n                \\|/  (HB)\n --------------- T2 -------------\n |      read num second time    |\n --------------------------------\n</code></pre>\n<p>Now, happens-before consistency says : &quot;a <em>read</em> sees the last <em>write</em> in happens-before order...&quot;; the key part here is &quot;in happens-before order&quot;. This means that <em>both</em> reads of <code>num</code> will see the write of it (again: in happens before order).</p>\n","answer_id":71234632,"question_id":71212008,"last_edit_date":1646233694},{"owner":{"profile_image":"https://www.gravatar.com/avatar/a287ffec5b98c1e185187f04bbe8d424?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":10957698,"user_type":"registered","user_id":8051929,"link":"https://stackoverflow.com/users/8051929/echo-zeng","reputation":61,"display_name":"Echo Zeng"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1646226073,"creation_date":1646226073,"body":"<p>Like if you want a row in this table, and you do not want any cell would be changed during the period, so you can add one read-lock.</p>\n<p>Other guys can also read, it doesn't matter.</p>\n","answer_id":71323151,"question_id":33384822},{"owner":{"profile_image":"https://i.stack.imgur.com/t2hoD.jpg?s=256&g=1","account_id":3211603,"user_type":"registered","user_id":2711488,"link":"https://stackoverflow.com/users/2711488/holger","reputation":289317,"display_name":"Holger"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1646216677,"creation_date":1646216677,"body":"<p>You should not create a new <code>ScheduledThreadPoolExecutor</code> within the method. An executor is supposed to be reused. And you should call <code>shutdown()</code> on it once you really don’t need it anymore.</p>\n<p>But more important is that, since the scheduled action is performed by a different thread, <em>it must use <code>synchronized</code></em> when accessing the mutable state.</p>\n<p>This leads to the point you’re missing about <code>wait()</code>. The only way for the condition you’re waiting for to correctly become fulfilled, is by having another thread performing the necessary steps within a <code>synchronized</code> block and calling <code>notify()</code> or <code>notifyAll()</code>, both methods insisting on being called within that <code>synchronized</code> block.</p>\n<p>This can only work, when <code>wait()</code> releases the lock, so the other thread can acquire it and do the duty. And <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long,int)\" rel=\"nofollow noreferrer\">that’s precisely what <code>wait</code> does</a>:</p>\n<blockquote>\n<p>This method causes the current thread (referred to here as <em>T</em>) to place itself in the wait set for this object and then to relinquish any and all synchronization claims on this object. Note that only the locks on this object are relinquished; any other objects on which the current thread may be synchronized remain locked while the thread waits.</p>\n<p>Thread <em>T</em> then becomes disabled for thread scheduling purposes and lies dormant until one of the following occurs:</p>\n<p>…</p>\n<p>The thread <em>T</em> is then removed from the wait set for this object and re-enabled for thread scheduling. It competes in the usual manner with other threads for the right to synchronize on the object; once it has regained control of the object, all its synchronization claims on the object are restored to the status quo ante - that is, to the situation as of the time that the <code>wait</code> method was invoked. Thread <em>T</em> then returns from the invocation of the <code>wait</code> method. Thus, on return from the <code>wait</code> method, the synchronization state of the object and of thread <em>T</em> is exactly as it was when the <code>wait</code> method was invoked.</p>\n</blockquote>\n<p><sup>Note that <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait()\" rel=\"nofollow noreferrer\">the documentation of the no-arg <code>wait</code> method</a> redirects to the <code>wait(long,int)</code> documentation shown above</sup></p>\n<p>So the issue of your code is not that the initiating thread synchronizes but that the pool’s thread does not.</p>\n<pre class=\"lang-java prettyprint-override\"><code>static final ScheduledThreadPoolExecutor EXEC = new ScheduledThreadPoolExecutor(1);\n\npublic synchronized void joinClass(UUID student) throws InterruptedException {\n    this.students.add(student);\n\n    if(students.size() == 1) {\n        lecture = true;\n        EXEC.schedule(new Runnable() {\n            @Override\n            public void run() {\n                synchronized(OuterClassName.this) {\n                    students.clear();\n                    lecture = false;\n                    OuterClassName.this.notifyAll();\n                }\n            }\n        }, LECTURE_DURATION, TimeUnit.MILLISECONDS);\n    }\n    while(lecture) wait();\n}\n</code></pre>\n<p>As a side note, there is no reason to remove single elements in a loop to empty a list, <code>clear()</code> does the job. In case of an <code>ArrayList</code>, repeatedly calling <code>remove(0)</code> is the worst way to clear it.</p>\n<p>It’s also important to keep in mind that an inner class instance is a different object than the outer class instance. It’s simpler when using a lambda expression:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public synchronized void joinClass(UUID student) throws InterruptedException {\n    this.students.add(student);\n\n    if(students.size() == 1) {\n        lecture = true;\n        EXEC.schedule(() -&gt; {\n            synchronized(this) {\n                students.clear();\n                lecture = false;\n                notifyAll();\n            }\n        }, LECTURE_DURATION, TimeUnit.MILLISECONDS);\n    }\n\n    while(lecture) wait();\n}\n</code></pre>\n","answer_id":71321045,"question_id":71096361},{"owner":{"profile_image":"https://www.gravatar.com/avatar/2361856f85f6f797554dab9e867f868c?s=256&d=identicon&r=PG","account_id":24334457,"user_type":"unregistered","user_id":18272775,"link":"https://stackoverflow.com/users/18272775/user18272775","reputation":31,"display_name":"user18272775"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1645482567,"creation_date":1645482567,"body":"<p><a href=\"https://stackoverflow.com/a/71212240\">The answer above</a> is correct.</p>\n<p>Just keep in mind that  <code>effectively immutable + safe publication</code> behaves unintuitively in some cases.<br />\nFor instance:</p>\n<ol>\n<li><p>If</p>\n<ul>\n<li>at first <code>thread 1</code> safely publishes object <code>o</code> to <code>thread 2</code></li>\n<li>then <code>thread 2</code> unsafely publishes object <code>o</code> to <code>thread 3</code></li>\n</ul>\n<p>in the end <code>thread 3</code> can see object <code>o</code> in an inconsistent state<br />\nSee <a href=\"https://stackoverflow.com/questions/10254456/effectively-immutable-object/10254521#comment13189477_10254521\">[1]</a> and <a href=\"https://stackoverflow.com/q/66214096\">[2]</a></p>\n</li>\n<li><p>also <a href=\"https://shipilev.net/blog/2016/close-encounters-of-jmm-kind/#wishful-volatiles-are-finals\" rel=\"nofollow noreferrer\">this</a></p>\n</li>\n</ol>\n<p>Real immutable objects have no such problems.</p>\n","answer_id":71213773,"question_id":71212008},{"owner":{"profile_image":"https://i.stack.imgur.com/7H9TF.png?s=256&g=1","account_id":2994830,"user_type":"registered","user_id":2541560,"link":"https://stackoverflow.com/users/2541560/kayaman","reputation":1,"display_name":"Kayaman"},"content_license":"CC BY-SA 4.0","score":7,"is_accepted":true,"last_activity_date":1645473905,"creation_date":1645473019,"body":"<p>No, because <code>volatile</code> being used establishes a happens-before relationship. Without it various reorderings and other things are allowed, which make the inconsistent state possible, but with it the JVM must give you the expected outcome.</p>\n<p>In this case <code>volatile</code> is <strong>not</strong> used for the visibility effects (threads seeing up to date values), but the safe publishing provided by the happpens-before. This feature of <code>volatile</code> is often left out when its use is explained.</p>\n","answer_id":71212240,"question_id":71212008,"last_edit_date":1645473905},{"owner":{"profile_image":"https://i.stack.imgur.com/21IXR.jpg?s=256&g=1","account_id":1662506,"user_type":"registered","user_id":1530504,"link":"https://stackoverflow.com/users/1530504/asok-buzz","reputation":1874,"display_name":"asok Buzz","accept_rate":36},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1645074489,"creation_date":1645074489,"body":"<p>You should have <code>colors.xml</code> on values-night (create alongside values folder if it doesn't already exist) folder for dark theme colors.\neg.</p>\n<pre><code>&lt;resources&gt;\n    &lt;color name=&quot;status_bar&quot;&gt;#0e0e0e&lt;/color&gt;\n&lt;/resources&gt;\n</code></pre>\n<p>(<code>colors.xml</code> on regular values folder will be used for light theme)</p>\n<p>And on <code>styles.xml</code> which supplies your app theme you will have entry for background and statusbar which takes necessary values.\neg.</p>\n<pre><code>&lt;style name=&quot;Theme.&lt;AppName&gt;&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;\n        &lt;item name=&quot;colorPrimary&quot;&gt;@color/red700&lt;/item&gt;\n        &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/red900&lt;/item&gt;\n        &lt;item name=&quot;colorAccent&quot;&gt;@color/red700&lt;/item&gt;\n        &lt;item name=&quot;android:statusBarColor&quot;&gt;@color/status_bar&lt;/item&gt;\n        &lt;item name=&quot;android:background&quot;&gt;@color/status_bar&lt;/item&gt;\n    &lt;/style&gt;\n</code></pre>\n<p>This style is referenced on AndroidManifest.xml file</p>\n<pre><code>android:theme=&quot;@style/Theme.&lt;AppName&gt;&quot;&gt;\n</code></pre>\n","answer_id":71152787,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/53aa3f0985b383044bf3f33643ffde76?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":14584795,"user_type":"registered","user_id":10534012,"link":"https://stackoverflow.com/users/10534012/darkman","reputation":2961,"display_name":"Darkman"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1644908921,"creation_date":1644899177,"body":"<p>No idea if this going to solve your problem but it might give you an idea.</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class Main\n{\n    public static void main(String[] args) throws Exception\n    {\n        Classroom classroom = new Classroom();\n        Student studentA = new Student(&quot;Student A&quot;, classroom);\n        Student studentB = new Student(&quot;Student B&quot;, classroom);\n        Student studentC = new Student(&quot;Student C&quot;, classroom);\n        Student studentD = new Student(&quot;Student D&quot;, classroom);\n        \n        studentA.enterClass();\n        Thread.sleep(1000L); //1000 m/s early.\n        classroom.start();\n        Thread.sleep(1000L); //1 second late.\n        studentB.enterClass();\n        Thread.sleep(500L); //Late for 1.5 seconds.\n        studentC.enterClass();\n        classroom.join();\n        Thread.sleep(2000L); //Class has ended.\n        studentD.enterClass();\n        System.out.println(&quot;Main Thread&quot;);\n    }\n}\n\nclass Student implements Runnable\n{\n    public String name;\n    private Classroom classroom;\n    public Thread thread;\n    \n    Student(String name, Classroom classroom)\n    {\n        this.name = name;\n        this.classroom = classroom;\n        thread = new Thread(this);\n    }\n    public void enterClass()\n    {\n        thread.start();\n    }\n    public synchronized void exitClass()\n    {\n        this.notify();\n    }\n    @Override\n    public void run()\n    {\n        try {\n            System.out.println(name + &quot; entering the class.&quot;);\n            classroom.joinClass(this);\n            synchronized(this) {\n                while(!classroom.hasEnded) this.wait();\n            }\n            System.out.println(name + &quot; existing the class.&quot;);\n        } catch(Exception e) {}\n    }\n}\n\nclass Classroom implements Runnable\n{\n    private static final long LECTURE_DURATION = 3000L;\n    private Thread thread;\n    public volatile boolean hasEnded;\n    private List&lt;Student&gt; students;\n    \n    Classroom()\n    {\n        students = new ArrayList&lt;Student&gt;();\n        thread = new Thread(this);\n    }\n    public void start()\n    {\n        thread.start();\n    }\n    public void join() throws Exception\n    {\n        thread.join();\n    }\n    @Override\n    public void run()\n    {\n        System.out.println(&quot;Class starting...&quot;);\n        try {\n            Thread.sleep(LECTURE_DURATION);\n        } catch(Exception e) {}\n        hasEnded = true;\n        System.out.println(&quot;Class ended&quot;);\n        for(Student s : students) s.exitClass();\n    }\n    public void joinClass(Student student) throws Exception\n    {\n        if(!hasEnded) {\n            System.out.println(student.name + &quot; joins the class.&quot;);\n            students.add(student);\n        }\n    }\n}\n</code></pre>\n<p>Here is the output. It may vary in your system.</p>\n<pre><code>Student A entering the class.\nStudent A joins the class.\nClass starting...\nStudent B entering the class.\nStudent B joins the class.\nStudent C entering the class.\nStudent C joins the class.\nClass ended\nStudent B existing the class.\nStudent A existing the class.\nStudent C existing the class.\nMain Thread\nStudent D entering the class.\nStudent D existing the class.\n</code></pre>\n","answer_id":71121105,"question_id":71096361,"last_edit_date":1644908921},{"owner":{"profile_image":"https://i.stack.imgur.com/RDWxl.png?s=256&g=1","account_id":4342327,"user_type":"registered","user_id":3545273,"link":"https://stackoverflow.com/users/3545273/serge-ballesta","reputation":145474,"display_name":"Serge Ballesta","accept_rate":100},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1636974569,"creation_date":1636974348,"body":"<p>Let us look carefully to your test code:</p>\n<pre><code>    GameServer server = new GameServer();\n</code></pre>\n<p>Ok, this lines creates a server, and the test thread is ready to execute next line</p>\n<pre><code>    server.start(9000);\n</code></pre>\n<p>Ok, the test thread starts the server, and <strong>will be ready to execute the next line when the <code>start</code> method will return</strong>.</p>\n<p>What happens in <code>start</code>:</p>\n<pre><code>    System.out.println(&quot;Server started !!!&quot;);\n</code></pre>\n<p>Ok, you should see that message</p>\n<pre><code>    serverSocket = new ServerSocket(port);\n</code></pre>\n<p>Ok, you have created a <code>ServerSocket</code></p>\n<pre><code>    while (true) {\n        new Thread(new GameClientHandler(serverSocket.accept())).start();\n    }\n</code></pre>\n<p>ok you a waiting for a connection (at <code>serverSocket.accept()</code>), will create a new thread to handle it as soon as you will get one, and loop again.</p>\n<p>But as this point, the test thread is waiting and will never go to the following line to start the first connection. And it will remain stuck unless <em>something else</em> (maybe another thread) starts those damned connections.</p>\n","answer_id":69973382,"question_id":69973062,"last_edit_date":1636974569},{"owner":{"profile_image":"https://www.gravatar.com/avatar/0f3e2abdf89734028a734c821c4fab78?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8775035,"user_type":"registered","user_id":6560579,"link":"https://stackoverflow.com/users/6560579/ackdari","reputation":3254,"display_name":"Ackdari"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1636973254,"creation_date":1636973254,"body":"<p>The method <code>GameServer.start</code> will only return with an exception. That is because you have the while-loop.</p>\n<p>So your test execution will start the server and wait for someone to open a connection, but that never happens.</p>\n","answer_id":69973143,"question_id":69973062},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG","account_id":401843,"user_type":"registered","user_id":768644,"link":"https://stackoverflow.com/users/768644/rzwitserloot","reputation":89863,"display_name":"rzwitserloot"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1636927783,"creation_date":1636927783,"body":"<p>Sure it is. However, 'wake the thread' does not mean 'it will fly ahead and IMMEDIATELY start running this very instant in time, whilst your thread has to do the extremely slow move of.. looping a for loop'.</p>\n<p>It could (that's one of the problems of threads: Things are arbitrary, and arbitrary is bad, because it's untestable. There is no fix for this, other than not using threads that require synchronization, for example by doing all state communication via transactions and a database)... but it usually won't.</p>\n<p>Your dropBall runs to its natural end, then it releases the lock (as the dropBall method is synchronized). Only now can the other thread's takeBall move on from its wait (wait doesn't JUST wait for a notify - it also releases the lock and can't continue until it has both been notified AND it can re-acquire the lock, which initially it by definition cannot, because you can't notify without holding the lock).</p>\n<p>What actually happens is this:</p>\n<ul>\n<li>Player2's thread is watching out for the ball's lock being available; it currently is not.</li>\n<li>Player1's thread releases the lock, hops back to your for loop that loops 25 times, executes the takeBall method and re-acquires the lock.</li>\n<li>Sometime later Player2 looks up and goes: Oh, wait, WHAT? Oh nuts! I missed it!</li>\n</ul>\n<p>Locks are not guaranteed to be 'fair'. Because fair locks take time and the JVM is designed to fulfill all guarantees as fast as possible (and thus, doesn't give you unpromised freebies), JVM locks as a consequence are pretty much never fair except on <em>extremely</em> bizarro combinations of JVM impl, OS, and hardware.</p>\n<p>Shove a sleep in between the dropping and the re-taking and you'll likely see something you were expecting. Now the VM/OS/hardware either [A] actually lets player2's thread grab the lock and actually take the ball, or [B] twiddle its thumbs.</p>\n<p>Note that the <code>Thread.sleep</code> you'll be writing MUST NOT be in any place where you hold the lock. Given that the entirety of the takeBall method is synchronized, don't do it there; do it in your for loop. (And as a side note, catch an exception and do nothing? <em><strong>That is extremely bad, don't ever do that</strong></em><sup>1</sup> - I fixed that for you too):</p>\n<pre><code>try {\n  ball.takeBall();\n  sleep(1000);\n  ball.dropBall();\n  sleep(100);\n} catch (Exception e) {\n  throw new RuntimeException(&quot;Unhandled&quot;, e);\n}\n</code></pre>\n<p>[1] Unless you truly intend for code to silently ignore the error and carry on like nothing happened. There are times where that is the right move but extremely rare and not something a newbie should be meddling with. Far too easy to misunderstand something and then get utterly lost because crucial information (namely, that an error occured, where it occurred, why, and the details surrounding) got discarded.</p>\n","answer_id":69967575,"question_id":69967482},{"owner":{"profile_image":"https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG","account_id":47283,"user_type":"registered","user_id":139985,"link":"https://stackoverflow.com/users/139985/stephen-c","reputation":703927,"display_name":"Stephen C","accept_rate":69},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":true,"last_activity_date":1636864683,"creation_date":1636863799,"body":"<p>The <code>final</code> makes no difference here.  The code is not thread-safe, whether the <code>final</code> is there or not.</p>\n<p>There are two reasons that this is not thread-safe.</p>\n<ol>\n<li><p>You are publishing (and potentially mutating) the state of <code>Dummy</code> before its constructor has completed.  This is unsafe whether or not the variable is <code>final</code>.</p>\n</li>\n<li><p>You are returning a shared mutable object in the <code>getIntegers()</code> call.  So that means that the caller <em>could</em> change it, and a second caller may or may not see the results ... due to lack of synchronization.  Once again <code>final</code> makes no difference to this.</p>\n</li>\n</ol>\n<hr />\n<p>The thread-safety guarantees of <code>final</code> are limited.  Here's what the <a href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.5\" rel=\"nofollow noreferrer\">JLS</a> says:</p>\n<blockquote>\n<p><code>final</code> fields also allow programmers to implement thread-safe immutable objects without synchronization. A thread-safe immutable object is seen as immutable by all threads, even if a data race is used to pass references to the immutable object between threads. This can provide safety guarantees against misuse of an immutable class by incorrect or malicious code. <strong><code>final</code> fields must be used correctly to provide a guarantee of immutability.</strong></p>\n<p>An object is considered to be completely initialized when its constructor finishes. A thread that can only see a reference to an object after that object has been completely initialized is guaranteed to see the correctly initialized values for that object's <code>final</code> fields.</p>\n</blockquote>\n<p>The takeaways are that the <code>final</code> guarantees only apply to <strong>immutable</strong> objects, and they only apply <strong>after</strong> the return of the object's constructor.</p>\n<p>In your example does not satisfy either of these prerequisites.  Therefore, the guarantees do not apply.</p>\n","answer_id":69960265,"question_id":69960082,"last_edit_date":1636864683},{"owner":{"profile_image":"https://i.stack.imgur.com/ZWEI3.jpg?s=256&g=1","account_id":322981,"user_type":"registered","user_id":642706,"link":"https://stackoverflow.com/users/642706/basil-bourque","reputation":310755,"display_name":"Basil Bourque","accept_rate":58},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1636857098,"creation_date":1636831831,"body":"<p>To quote the <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/join.html\" rel=\"nofollow noreferrer\">Oracle tutorial</a>:</p>\n<blockquote>\n<p><code>t.join()</code> causes the current thread to pause execution until t's thread terminates</p>\n</blockquote>\n<p>So effectively you are not making any real use of threading. On every pass through your <code>for</code> loop, you launch a thread but then wait for it to complete. No point in doing that, you could forgo the threads and just sequentially do your tasks’ work within the current thread.</p>\n<hr />\n<p>In modern Java, we rarely need to address the <code>Thread</code> class directly. Instead we submit our <code>Runnable</code>/<code>Callable</code> task to an <code>ExecutorService</code>.</p>\n<p>To schedule repeated calculations every 5 seconds, use a <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/ScheduledExecutorService.html\" rel=\"nofollow noreferrer\"><code>ScheduledExecutorService</code></a>.</p>\n<pre><code>ScheduledExecutorService ses = Executors. newSingleThreadScheduledExecutor() ;\n…\nses.scheduleAtFixedRate( myStatsCalcRunnable , 1 , 5 , TimeUnit.SECONDS ) ;\n</code></pre>\n<p>Caution: Be sure to eventually shut down your executor services. Otherwise their backing thread pools may continue running indefinitely, like a zombie 🧟‍♂️.</p>\n<p>Change this:</p>\n<pre><code>public class FestivalStatisticsThread extends Thread { … } \n</code></pre>\n<p>… with a <code>run</code> method into:</p>\n<pre><code>public class FestivalStatistics { … } \n</code></pre>\n<p>… with a <code>recalculate</code> method. Call that <code>recalculate</code> method from the <code>Runnable</code> task submitted to your scheduled executor service.</p>\n<p>Or perhaps that functionality should just be a part of the <code>Gate</code> class. (I’m not sure. I’d have to think more on that.)</p>\n<hr />\n<p>85,000 simultaneous threads may be too much of a burden on common hardware. Instead, start an executor service with a limited number of threads. Then submit your 85,000 tasks as <code>Runnable</code>/<code>Callable</code> objects. The executor service takes care of feeding those tasks to be executed on those limited number of threads.</p>\n<p>In the future, if <a href=\"https://wiki.openjdk.java.net/display/loom/Main\" rel=\"nofollow noreferrer\"><em>Project Loom</em></a> succeeds, you will be able to use 85,000 (or even millions) <em>virtual</em> threads (also known as “fibers”) at a time. To learn more, see the more recent talks by Ron Pressler or other members of the Loom team. Experimental builds based on early-access Java 18 are available now. The Loom team seeks feedback.</p>\n<hr />\n<p>All of these topics have been addressed already on Stack Overflow.  Search to learn more. I myself have written multiple Answers with code examples, as have others.</p>\n<hr />\n<p>By the way, I would make <code>FestivalGate</code> more encapsulated. The other classes should not have access to, or even know about, its internal use of a synchronized <code>List</code>. Add methods to collect and report on tickets.</p>\n<hr />\n<p>Here is some quick code I wrote as a demonstration of topics discussed above.</p>\n<p>Use at your own risk; I’ve not done any serious testing nor a thoughtful code review.</p>\n<p>Perhaps I have oversimplified your domain problem. You could of course expand or rearrange as needed. But hopefully this shows clearly how to use executor service.</p>\n<p>We have a basic <code>Ticket</code> class to represent each ticket. We use a <a href=\"https://openjdk.java.net/jeps/395\" rel=\"nofollow noreferrer\">record</a> here to define that class. We nest the enum of ticket types.</p>\n<pre class=\"lang-java prettyprint-override\"><code>package work.basil.festival;\n\nimport java.util.UUID;\n\npublic record Ticket( UUID id , Type type )\n{\n    enum Type\n    { FULL_VIP, FREE_PASS, ONE_DAY, ONE_DAY_VIP }\n}\n</code></pre>\n<p>We have a <code>Gate</code> class to hold our domain logic. We nest a <code>Statistics</code> class to hold our reported summary of tickets taken so far.</p>\n<pre class=\"lang-java prettyprint-override\"><code>package work.basil.festival;\n\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.*;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.stream.Collectors;\n\npublic class Gate\n{\n    final private Set &lt; Ticket &gt; ticketsTaken;\n\n    public Gate ( )\n    {\n        this.ticketsTaken = new HashSet &lt;&gt;();\n    }\n\n    synchronized public boolean takeTicket ( final Ticket ticket )\n    {\n        // Simulate hard work by sleeping some random amount of time.\n        int millis = ThreadLocalRandom.current().nextInt( 2 );\n        try { Thread.sleep( millis ); }catch ( InterruptedException e ) { e.printStackTrace(); }\n        return this.ticketsTaken.add( ticket );\n    }\n\n    synchronized public List &lt; Ticket &gt; ticketsTaken ( )\n    {\n        return List.copyOf( this.ticketsTaken );  // Returns unmodifiable list of the `Ticket` objects contained in our private member set.\n    }\n\n    record Statistics( Instant when , int countTicketsTaken , Map &lt; Ticket.Type, Integer &gt; countOfTicketsTakenByType )\n    {\n    }\n\n    synchronized public Statistics statistics ( )\n    {\n        int count = this.countTicketsTaken();\n        Map &lt; Ticket.Type, Integer &gt; map = this.reportCountOfTicketsTakenByType();\n        if ( count != map.values().stream().mapToInt( Integer :: intValue ).sum() ) { throw new IllegalStateException( &quot;Counts do not match in Gate.Statistics. Error # 898e905f-9432-4195-a3e0-118bede2872d.&quot; ); }\n        return new Statistics( Instant.now() , count , map );\n    }\n\n    private int countTicketsTaken ( )\n    {\n        return this.ticketsTaken.size();\n    }\n\n    private Map &lt; Ticket.Type, Integer &gt; reportCountOfTicketsTakenByType ( )\n    {\n        // We use `AtomicInteger` here not for thread-safety, but for the convenience of its `incrementAndGet` method.\n        Map &lt; Ticket.Type, AtomicInteger &gt; map = new EnumMap &lt; Ticket.Type, AtomicInteger &gt;( Ticket.Type.class );\n        Arrays.stream( Ticket.Type.values() ).forEach( type -&gt; map.put( type , new AtomicInteger( 0 ) ) ); // Initialize the map, so each ticket-type has an atomic integer set to zero.\n        this.ticketsTaken.stream().forEach( ticket -&gt; map.get( ticket.type() ).incrementAndGet() );\n\n        // Convert the AtomicInteger values to simply `Integer` values.\n        Map &lt; Ticket.Type, Integer &gt; result = map.entrySet().stream().collect( Collectors.toMap( Map.Entry :: getKey , atomicInteger -&gt; atomicInteger.getValue().intValue() ) );\n        return Map.copyOf( result ); // Return an unmodifiable map, as a good practice.\n    }\n}\n</code></pre>\n<p>And we have an <code>App</code> class to drive a demonstration.</p>\n<pre class=\"lang-java prettyprint-override\"><code>package work.basil.festival;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\nimport java.util.concurrent.*;\nimport java.util.stream.IntStream;\n\n/**\n * Hello world!\n */\npublic class App\n{\n    public static void main ( String[] args )\n    {\n        System.out.println( &quot;Hello World!&quot; );\n\n        App app = new App();\n        app.demo();\n    }\n\n    private void demo ( )\n    {\n        final List &lt; Ticket &gt; ticketsToTake = this.generateTicketsForFestival();\n\n        Gate gate = new Gate();\n\n        // Report every five seconds on the progress of our gate taking tickets.\n        ScheduledExecutorService reportingExecutorService = Executors.newSingleThreadScheduledExecutor();\n        reportingExecutorService.scheduleAtFixedRate( ( ) -&gt; System.out.println( gate.statistics() ) , 0 , 5 , TimeUnit.SECONDS );\n\n        ExecutorService ticketTakingExecutorService = Executors.newFixedThreadPool( 7 );\n        for ( Ticket ticket : ticketsToTake )\n        {\n            ticketTakingExecutorService.submit( ( ) -&gt; gate.takeTicket( ticket ) );\n        }\n        ticketTakingExecutorService.shutdown();\n        try { ticketTakingExecutorService.awaitTermination( 10 , TimeUnit.MINUTES ); } catch ( InterruptedException e ) { e.printStackTrace(); }\n        reportingExecutorService.shutdown();\n        try { reportingExecutorService.awaitTermination( 10 , TimeUnit.MINUTES ); } catch ( InterruptedException e ) { e.printStackTrace(); }\n\n        System.out.println( &quot;« FIN » &quot; + gate.statistics() );\n    }\n\n    private List &lt; Ticket &gt; generateTicketsForFestival ( )\n    {\n        List &lt; Ticket &gt; tickets = new ArrayList &lt;&gt;();\n        for ( int i = 0 ; i &lt; 85_000 ; i++ )\n        {\n            tickets.add(\n                    new Ticket(\n                            UUID.randomUUID() ,  // Randomly generate a UUID, to identify uniquely each ticket.\n                            Ticket.Type.values()[ ThreadLocalRandom.current().nextInt( Ticket.Type.values().length ) ]  // Randomly pick one of the ticket types.\n                    )\n            );\n        }\n        return List.copyOf( tickets );\n    }\n}\n</code></pre>\n<p>When run on an 8-core M1 MacBook Pro.</p>\n<pre class=\"lang-none prettyprint-override\"><code>Hello World!\nStatistics[when=2021-11-14T02:28:52.746596Z, countTicketsTaken=0, countOfTicketsTakenByType={FREE_PASS=0, ONE_DAY=0, ONE_DAY_VIP=0, FULL_VIP=0}]\nStatistics[when=2021-11-14T02:28:57.800514Z, countTicketsTaken=7517, countOfTicketsTakenByType={FREE_PASS=1862, ONE_DAY=1953, ONE_DAY_VIP=1889, FULL_VIP=1813}]\nStatistics[when=2021-11-14T02:29:02.804886Z, countTicketsTaken=15128, countOfTicketsTakenByType={FREE_PASS=3791, ONE_DAY=3788, ONE_DAY_VIP=3775, FULL_VIP=3774}]\nStatistics[when=2021-11-14T02:29:07.746712Z, countTicketsTaken=22819, countOfTicketsTakenByType={FREE_PASS=5764, ONE_DAY=5653, ONE_DAY_VIP=5703, FULL_VIP=5699}]\nStatistics[when=2021-11-14T02:29:12.769943Z, countTicketsTaken=30577, countOfTicketsTakenByType={FREE_PASS=7687, ONE_DAY=7631, ONE_DAY_VIP=7641, FULL_VIP=7618}]\nStatistics[when=2021-11-14T02:29:17.803627Z, countTicketsTaken=38146, countOfTicketsTakenByType={FREE_PASS=9553, ONE_DAY=9552, ONE_DAY_VIP=9554, FULL_VIP=9487}]\nStatistics[when=2021-11-14T02:29:22.785355Z, countTicketsTaken=45896, countOfTicketsTakenByType={FREE_PASS=11455, ONE_DAY=11497, ONE_DAY_VIP=11499, FULL_VIP=11445}]\nStatistics[when=2021-11-14T02:29:27.768809Z, countTicketsTaken=53563, countOfTicketsTakenByType={FREE_PASS=13448, ONE_DAY=13393, ONE_DAY_VIP=13386, FULL_VIP=13336}]\nStatistics[when=2021-11-14T02:29:32.739398Z, countTicketsTaken=61189, countOfTicketsTakenByType={FREE_PASS=15358, ONE_DAY=15291, ONE_DAY_VIP=15310, FULL_VIP=15230}]\nStatistics[when=2021-11-14T02:29:37.751764Z, countTicketsTaken=68758, countOfTicketsTakenByType={FREE_PASS=17214, ONE_DAY=17136, ONE_DAY_VIP=17226, FULL_VIP=17182}]\nStatistics[when=2021-11-14T02:29:42.759303Z, countTicketsTaken=76446, countOfTicketsTakenByType={FREE_PASS=19136, ONE_DAY=19057, ONE_DAY_VIP=19171, FULL_VIP=19082}]\nStatistics[when=2021-11-14T02:29:47.768858Z, countTicketsTaken=84030, countOfTicketsTakenByType={FREE_PASS=21086, ONE_DAY=20930, ONE_DAY_VIP=21062, FULL_VIP=20952}]\n« FIN » Statistics[when=2021-11-14T02:29:48.406351Z, countTicketsTaken=85000, countOfTicketsTakenByType={FREE_PASS=21321, ONE_DAY=21174, ONE_DAY_VIP=21305, FULL_VIP=21200}]\n</code></pre>\n","answer_id":69957568,"question_id":69954623,"last_edit_date":1636857098},{"owner":{"profile_image":"https://i.stack.imgur.com/5ovO7.png?s=256&g=1","account_id":9713597,"user_type":"registered","user_id":7204683,"link":"https://stackoverflow.com/users/7204683/umair","reputation":615,"display_name":"Umair","accept_rate":38},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1636835220,"creation_date":1636835220,"body":"<p>It is possible to use synchronized blocks inside a Java Lambda Expression and inside anonymous classes.</p>\n<p>Note: You have forgotten to add code snippet as no code snippet is visible in your code , So I ma adding my own code snippet to make clear my point.</p>\n<pre><code>    import java.util.function.Consumer;\n\npublic class SynchronizedExample {\n\n  public static void main(String[] args) {\n\n    Consumer&lt;String&gt; func = (String param) -&gt; {\n\n      synchronized(SynchronizedExample.class) {\n\n        System.out.println(\n            Thread.currentThread().getName() +\n                    &quot; step 1: &quot; + param);\n\n        try {\n          Thread.sleep( (long) (Math.random() * 1000));\n        } catch (InterruptedException e) {\n          e.printStackTrace();\n        }\n\n        System.out.println(\n            Thread.currentThread().getName() +\n                    &quot; step 2: &quot; + param);\n      }\n\n    };\n\n\n    Thread thread1 = new Thread(() -&gt; {\n        func.accept(&quot;Parameter&quot;);\n    }, &quot;Thread 1&quot;);\n\n    Thread thread2 = new Thread(() -&gt; {\n        func.accept(&quot;Parameter&quot;);\n    }, &quot;Thread 2&quot;);\n\n    thread1.start();\n    thread2.start();\n  }\n}\n</code></pre>\n","answer_id":69957970,"question_id":69957844},{"owner":{"profile_image":"https://i.stack.imgur.com/VlLm5.jpg?s=256&g=1","account_id":11179150,"user_type":"registered","user_id":8203686,"link":"https://stackoverflow.com/users/8203686/wangsir","reputation":374,"display_name":"wangsir"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1636815741,"creation_date":1636815741,"body":"<p>I had the same problem when using HSDB on openjdk-8. Installing lib <code>sudo apt-get install openjdk-8-dbg</code> works.</p>\n","answer_id":69955469,"question_id":49516601},{"owner":{"profile_image":"https://www.gravatar.com/avatar/1f698e72460b5a8c716a0c1cea91b81e?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":13429972,"user_type":"registered","user_id":9690075,"link":"https://stackoverflow.com/users/9690075/zysaaa","reputation":1807,"display_name":"zysaaa"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1636813384,"creation_date":1636813384,"body":"<p><code>ExecutorService</code> in Java, for example, is a producer-consumer model with a series of worker threads trying to fetch tasks from a work queue. I might close the thread pool by <code>ExecutorService#shutdownNow</code>, this method will set the thread pool state to <code>STOP</code> and interrupt each worker. Take a look at <code>shutdownNow</code> method and worker's run method(I removed the irrelevant code):</p>\n<pre><code>  public List&lt;Runnable&gt; shutdownNow() {\n            advanceRunState(STOP);\n            interruptWorkers();\n  }\n</code></pre>\n<pre><code>final void runWorker(Worker w) {\n        try {\n            while (task != null || (task = getTask()) != null) {\n                // ...\n            }\n        } \n    }\n</code></pre>\n<pre><code> private Runnable getTask() {\n        boolean timedOut = false; // Did the last poll() time out?\n        for (;;) {\n            // ...\n            // Check if queue empty only if necessary.\n            if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {\n                decrementWorkerCount();\n                return null;\n            }\n            try {\n                Runnable r = timed ?\n                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                    workQueue.take();\n                if (r != null)\n                    return r;\n                timedOut = true;\n            } \n        }\n    }\n</code></pre>\n<p>I think this is an example of using Flag &amp; interrupt to stop consumers. I don't think it's inelegant.</p>\n","answer_id":69955150,"question_id":69950945},{"owner":{"profile_image":"https://i.stack.imgur.com/9G6ke.png?s=256&g=1","account_id":439045,"user_type":"registered","user_id":827704,"link":"https://stackoverflow.com/users/827704/artyom-chernetsov","reputation":1394,"display_name":"Artyom Chernetsov","accept_rate":71},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1636774485,"creation_date":1636774485,"body":"<p>My approach would be to use framework with back-pressure mechanism support, for example <a href=\"https://vertx.io/docs/vertx-reactive-streams/java/\" rel=\"nofollow noreferrer\">vert.x reactive streams</a>.</p>\n<p>Good examples of systems handling back-pressure built on vert.x can be found in the book <a href=\"https://vertx.io/docs/vertx-reactive-streams/java/\" rel=\"nofollow noreferrer\">vert.x in action</a></p>\n","answer_id":69951248,"question_id":69950945},{"owner":{"profile_image":"https://i.stack.imgur.com/Poqe8.png?s=256&g=1","account_id":10898797,"user_type":"registered","user_id":8011734,"link":"https://stackoverflow.com/users/8011734/marwa-eltayeb","reputation":1961,"display_name":"Marwa Eltayeb"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1634784057,"creation_date":1634784057,"body":"<p>According to <strong>Google's recommendation</strong> <a href=\"https://developer.android.com/topic/performance/vitals/launch-time\" rel=\"nofollow noreferrer\">Here</a>, you <em>should not</em> prevent this white screen from launching. You can use this theme attribute to turn off the initial blank screen that the system process draws when launching the app.</p>\n<pre><code>&lt;item name=&quot;android:windowDisablePreview&quot;&gt;true&lt;/item&gt;\n</code></pre>\n<p>However, <strong>This approach is not recommended</strong> because it can result in a longer startup time than apps that don’t suppress the preview window. Also, it forces the user to wait with no feedback while the activity launches, making them wonder if the app is functioning properly.</p>\n<p>They recommend to use the activity's windowBackground theme attribute to provide a simple custom drawable for the starting activity instead of disabling the preview window.</p>\n<p>Therefore, here is the recommended solution:</p>\n<p>First, create a new drawable file for example startup_screen.xml</p>\n<pre><code> &lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:opacity=&quot;opaque&quot;&gt;\n    &lt;!-- The background color, preferably the same as normal theme --&gt;\n    &lt;item android:drawable=&quot;@android:color/white&quot;/&gt;\n    &lt;!-- Product logo - 144dp color version of App icon --&gt;\n    &lt;item&gt;\n        &lt;bitmap\n            android:src=&quot;@drawable/logo&quot;\n            android:gravity=&quot;center&quot;/&gt;\n    &lt;/item&gt;\n &lt;/layer-list&gt;\n</code></pre>\n<p>Second, reference it from your style file. If you use Night mode. Add it in both themes.xml files.</p>\n<pre><code>&lt;!-- Start Up Screen --&gt;\n&lt;style name=&quot;AppThemeLauncher&quot; parent=&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;&gt;\n     &lt;item name=&quot;android:statusBarColor&quot; tools:targetApi=&quot;l&quot;&gt;@color/lightGray&lt;/item&gt;\n     &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/startup_screen&lt;/item&gt;\n&lt;/style&gt;\n</code></pre>\n<p>If you notice, I added statusBarColor attribute to change the color of status Bar according to my custom design.</p>\n<p>Then, Add <em>AppThemeLauncher</em> Theme in your current activity.</p>\n<pre><code>&lt;activity\n    android:name=&quot;.MainActivity&quot;\n    android:theme=&quot;@style/AppThemeLauncher&quot;/&gt;\n</code></pre>\n<p>If you want to transition back to your normal theme, call setTheme(R.style.AppTheme) before calling super.onCreate() and setContentView():</p>\n<pre><code>class MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        // Make sure this is before calling super.onCreate\n        setTheme(R.style.AppTheme)\n        super.onCreate(savedInstanceState)\n        // ...\n    }\n}\n</code></pre>\n","answer_id":69655199,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/3c5fa52b5efec6532a8f33a920789d6d?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6089387,"user_type":"registered","user_id":4752240,"link":"https://stackoverflow.com/users/4752240/tuda224","reputation":1,"display_name":"tuda224"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1629096564,"creation_date":1629096564,"body":"<p>In my opinion you aren't testing a multithread scenario.</p>\n<p>You have one thread that is accessing everything one after each other. From the question I assume that this is not your intention.</p>\n<p>What I also like is using a locker object of type ReentrantLock(). Then you have a single instance of the object and lock it before the synchronized code block and you can unlock it when the work is done.</p>\n<p>Like in the following example (taken and adapted from <a href=\"https://winterbe.com/posts/2015/04/30/java8-concurrency-tutorial-synchronized-locks-examples/\" rel=\"nofollow noreferrer\">https://winterbe.com/posts/2015/04/30/java8-concurrency-tutorial-synchronized-locks-examples/</a>):</p>\n<pre><code>ReentrantLock lock = new ReentrantLock();\n\nvoid transaction(Long accountIdOne, Long accountIdTwo, int value) {\n    Account accountOne = accountRepository.findById(accountIdOne).orElseThrow();\n    Account accountTwo = accountRepository.findById(accountIdTwo).orElseThrow();\n\n    lock.lock();\n    try {\n        accountOne.withdrawal(value);\n        this.update(accountOne);\n        accountTwo.send(value);\n        this.update(accountTwo);\n    } finally {\n        lock.unlock();\n    }\n}\n</code></pre>\n","answer_id":68798496,"question_id":68791080},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG","account_id":401843,"user_type":"registered","user_id":768644,"link":"https://stackoverflow.com/users/768644/rzwitserloot","reputation":89863,"display_name":"rzwitserloot"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":true,"last_activity_date":1629077177,"creation_date":1629077177,"body":"<p>Make threads. A thousand if you want.</p>\n<p>At the CPU core level, here's what's happening:</p>\n<ul>\n<li>The CPU core is chugging along, doing work for a given websocket.</li>\n<li>Pretty soon the core runs into a road block: Half of an incoming bunch of data has arrived, the rest is still making its way down the network cable, and thus the CPU can't continue until it arrives. Alternatively, the code that the CPU core is running is sending data out, but the network card's buffer is full, so now the CPU core has to wait for that network card to find its way to sending another packet down the cable before there's room.</li>\n<li>Of course, if there's work to do (say, you have 10 cores in the box, and 15 web users are simultaneously connected, that leaves at least 5 users of your web site waiting around right now) - then the CPU should <strong>not</strong> just start twiddling its thumbs. It should go do <em>something</em>.</li>\n<li>In practice, then, there's a whole boatload of memory that WAS relevant that no longer is (all that memory that contained all that state and other 'working items' that was neccessary to do the work for the websocket that we were working on, but which is currently 'blocked' by the network), and a whole bunch of memory that wasn't relevant that now becomes relevant (All the state and working memory of a websocket connection that was earlier put in the 'have yourself a bit of a timeout and wait around for the network packet to arrive' - for which the network packet has since arrived, so if a CPU core is free to do work, it can now go do work).</li>\n<li>This is called a 'context switch', and it is <strong>ridiculously expensive</strong>, 500+ cycles worth. It is also <strong>completely unavoidable</strong>. You have to make the context switch. You can't avoid it. That means a cost is paid, and about 500 cycles worth just go down the toilet. It's what it is.</li>\n</ul>\n<p>The thing is, there are 2 ways to pay that cost: You can switch to another thread, which is all sorts of context switching. Or, you have a single thread running so-called 'async' code that manages all this stuff itself and hops to another job to do, but then there's still a context switch.</p>\n<p>Specifically, CPUs can't interact with memory at all anymore these days and haven't for the past decade. They can only interact with a CPU cache page. machine code is actually not really 'run directly' anymore, instead there's a level below that where a CPU notices it's about to run an instruction that touches some memory and will then map that memory command (after all, CPUs can no longer interact with it at all, memory is <em>far</em> too slow to wait for it) to the right spot in the cache. It'll also notice if the memory you're trying to access with your machinecode isn't in a cache page associated with that core at all, in which case it'll fire a page miss interrupt which causes the memory subsystem of your CPU/memory bus to 'evict a page' (write all back out to main memory) and then load in the right page, and only then does the CPU continue.</p>\n<p>This all happens 'under the hood', you don't have to write code to switch pages, the CPU manages it automatically. But it's a heavy cost. Not quite as heavy as a thread switch but almost as heavy.</p>\n<p><strong>CONCLUSION: Threads are good, have many of them. It ensures CPUs won't twiddle their thumbs when there is work to do. Note that there are MANY blog posts that extoll the virtues of async, claiming that threads 'do not scale'. They are wrong. Threads scale fine, and async code also pays the cost of context switching, all the time.</strong></p>\n<p>In case you weren't aware, 'async code' is code that tries to never sleep (never do something that would ever wait. So, instead of writing 'getMeTheNextBlockOfBytesFromTheNetworkCard', you'd write: &quot;onceBytesAreAvailableRunThis(code goes here)`). Writing async code in java is possible but incredibly difficult compared to using threads.</p>\n<p>Even in the extremely rare cases where async code would be a significant win, Project Loom is close to completion which will grant java the ability to have thread-like things that you can manually manage (so-called fibers). That is the route the OpenJDK has chosen for this. In that sense, even if you think async is the answer, no it's not. Wait for Project Loom to complete, instead. If you want to read more, read <a href=\"https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/\" rel=\"nofollow noreferrer\">What color is your function?</a>, and <a href=\"http://callbackhell.com\" rel=\"nofollow noreferrer\">callback hell</a>. Neither post is java-specific but covers some of the more serious problems inherent in async.</p>\n","answer_id":68796545,"question_id":68796254},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e442a53d36f9351aee11b5ecb8369691?s=256&d=identicon&r=PG","account_id":6520,"user_type":"registered","user_id":11002,"link":"https://stackoverflow.com/users/11002/tgdavies","reputation":10523,"display_name":"tgdavies","accept_rate":75},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1629062177,"creation_date":1629062177,"body":"<p>If we run the following code:</p>\n<pre><code>Account accountOneA = accountRepository.findById(1L).orElseThrow();\nAccount accountOneB = accountRepository.findById(1L).orElseThrow();\n</code></pre>\n<p>We expect that <code>accountOneA.equals(accountOneB)</code> will be true, assuming that <code>Account</code> has a sensible <code>equals()</code> implementation.</p>\n<p>We <em>don't</em> expect that <code>accountOneA == accountOneB</code> will be true, because <code>AccountRepository</code> will be creating a new object for the result of each query. We want this behaviour for thread safety, as two transactions might modify the data in different ways, to be reconciled when they try to save it.</p>\n<p>The <code>synchronized</code> keyword locks a <em>particular Object</em>, so for it to work, each thread must be synchronising using the same instance.</p>\n<p>That's why your synchronisation doesn't work.</p>\n<p>If <code>findById</code> <em>did</em> return the same instance for the same id, your code would be prone to deadlock. Imagine that one thread is transferring from account 1 to account 2, while another thread is doing the reverse, transferring from 2 to 1:</p>\n<ol>\n<li>Thread one locks account 1</li>\n<li>Thread two locks account 2</li>\n<li>Thread one tries to lock account 2, can't and waits</li>\n<li>Thread two tries to lock account1, can't and waits</li>\n</ol>\n<p>Now both threads are waiting forever.</p>\n<p>You could avoid this problem by sorting all the account numbers which are going to be locked in a given transaction, and always locking them in that order.</p>\n","answer_id":68795395,"question_id":68791080},{"owner":{"profile_image":"https://www.gravatar.com/avatar/124cda7f0e8d259e69d49ed43868639e?s=256&d=identicon&r=PG","account_id":99786,"user_type":"registered","user_id":269361,"link":"https://stackoverflow.com/users/269361/fool4jesus","reputation":2155,"display_name":"fool4jesus","accept_rate":79},"content_license":"CC BY-SA 4.0","score":4,"is_accepted":true,"last_activity_date":1629045421,"creation_date":1629045421,"body":"<p>I don't think this would compile as is. For one thing, System.out.println does not throw InterruptedException. I think you have a mistaken idea that calling threadB.interrupt() will cause threadB to throw an InterruptedException. But it won't: it will only set the interrupt flag. Remember, InterruptedException is a checked exception: it just doesn't appear out of nowhere, something has to throw it.</p>\n<p>So, leaving that aside, how close is your example to what really happens?</p>\n<p>If you need to, in general, know &quot;who set my interrupted flag&quot; I don't think there's any straightforward way to know that. If you really, really needed to know that, you could use something like Aspect4J and weave in advice on the <code>interrupt()</code> method that saves that information.</p>\n<p>But if you have more control over your code (as in the example above), the answer is to use object encapsulation and have B not directly interrupt A, but rather call a method that does. Really, I think this is better practice anyway, since it lets your own code do what it needs to do on the interrupted case. This isn't tested, but it's the idea:</p>\n<pre><code>static class MyThread extends Thread {\n  String interrupter;\n\n  public void interrupt(String interrupter) {\n    this.interrupter = interrupter;\n    super.interrupt();\n  }\n\n  public void run() {\n    while (!this.isInterrupted()) {\n      // Do the thing\n    }\n    // Here you can see who interrupted you and do whatever\n  }\n}\n</code></pre>\n","answer_id":68793486,"question_id":68784557},{"owner":{"profile_image":"https://i.stack.imgur.com/jgnbc.jpg?s=256&g=1","account_id":2174289,"user_type":"registered","user_id":1925388,"link":"https://stackoverflow.com/users/1925388/anmol-singh-jaggi","reputation":8434,"display_name":"Anmol Singh Jaggi","accept_rate":81},"content_license":"CC BY-SA 4.0","score":8,"is_accepted":false,"last_activity_date":1629042563,"creation_date":1620486781,"body":"<p>The <a href=\"https://stackoverflow.com/a/63365785/1925388\">other answer</a> works fine but is too complicated.</p>\n<p>A simpler way is to just execute <a href=\"https://en.wikipedia.org/wiki/Topological_sorting#Kahn%27s_algorithm\" rel=\"noreferrer\">Kahn's algorithm</a> but in parallel.</p>\n<p>The key is to execute all the tasks in parallel for whom all dependencies have been executed.</p>\n<pre><code>import java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n\nclass DependencyManager {\nprivate final ConcurrentHashMap&lt;String, List&lt;String&gt;&gt; _dependencies = new ConcurrentHashMap&lt;&gt;();\nprivate final ConcurrentHashMap&lt;String, List&lt;String&gt;&gt; _reverseDependencies = new ConcurrentHashMap&lt;&gt;();\nprivate final ConcurrentHashMap&lt;String, Runnable&gt; _tasks = new ConcurrentHashMap&lt;&gt;();\nprivate final ConcurrentHashMap&lt;String, Integer&gt; _numDependenciesExecuted = new ConcurrentHashMap&lt;&gt;();\nprivate final  AtomicInteger _numTasksExecuted = new AtomicInteger(0);\nprivate final ExecutorService _executorService = Executors.newFixedThreadPool(16);\n\nprivate static Runnable getRunnable(DependencyManager dependencyManager, String taskId){\n    return () -&gt; {\n    try {\n        Thread.sleep(2000);  // A task takes 2 seconds to finish.\n        dependencyManager.taskCompleted(taskId);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    };\n}\n\n/**\n* In case a vertex is disconnected from the rest of the graph.\n* @param taskId The task id\n*/\npublic void addVertex(String taskId) {\n    _dependencies.putIfAbsent(taskId, new ArrayList&lt;&gt;());\n    _reverseDependencies.putIfAbsent(taskId, new ArrayList&lt;&gt;());\n    _tasks.putIfAbsent(taskId, getRunnable(this, taskId));\n    _numDependenciesExecuted.putIfAbsent(taskId, 0);\n}\n\nprivate void addEdge(String dependentTaskId, String dependeeTaskId) {\n    _dependencies.get(dependentTaskId).add(dependeeTaskId);\n    _reverseDependencies.get(dependeeTaskId).add(dependentTaskId);\n}\n\npublic void addDependency(String dependentTaskId, String dependeeTaskId) {\n    addVertex(dependentTaskId);\n    addVertex(dependeeTaskId);\n    addEdge(dependentTaskId, dependeeTaskId);\n}\n\nprivate void taskCompleted(String taskId) {\n    System.out.println(String.format(&quot;%s:: Task %s done!!&quot;, Instant.now(), taskId));\n    _numTasksExecuted.incrementAndGet();\n    _reverseDependencies.get(taskId).forEach(nextTaskId -&gt; {\n        _numDependenciesExecuted.computeIfPresent(nextTaskId, (__, currValue) -&gt; currValue + 1);\n        int numDependencies = _dependencies.get(nextTaskId).size();\n        int numDependenciesExecuted = _numDependenciesExecuted.get(nextTaskId);\n        if (numDependenciesExecuted == numDependencies) {\n        // All dependencies have been executed, so we can submit this task to the threadpool. \n            _executorService.submit(_tasks.get(nextTaskId));\n        }\n        });\n    if (_numTasksExecuted.get() == _tasks.size()) {\n        topoSortCompleted();\n    }\n}\n\nprivate void topoSortCompleted() {\n    System.out.println(&quot;Topo sort complete!!&quot;);\n    _executorService.shutdownNow();\n}\n\npublic void executeTopoSort() {\n    System.out.println(String.format(&quot;%s:: Topo sort started!!&quot;, Instant.now()));\n    _dependencies.forEach((taskId, dependencies) -&gt; {\n    if (dependencies.isEmpty()) {\n        _executorService.submit(_tasks.get(taskId));\n    }\n    });\n}\n}\n\npublic class TestParallelTopoSort {\n\npublic static void main(String[] args) {\n    DependencyManager dependencyManager = new DependencyManager();\n    dependencyManager.addDependency(&quot;8&quot;, &quot;5&quot;);\n    dependencyManager.addDependency(&quot;7&quot;, &quot;5&quot;);\n    dependencyManager.addDependency(&quot;7&quot;, &quot;6&quot;);\n    dependencyManager.addDependency(&quot;6&quot;, &quot;3&quot;);\n    dependencyManager.addDependency(&quot;6&quot;, &quot;4&quot;);\n    dependencyManager.addDependency(&quot;5&quot;, &quot;1&quot;);\n    dependencyManager.addDependency(&quot;5&quot;, &quot;2&quot;);\n    dependencyManager.addDependency(&quot;5&quot;, &quot;3&quot;);\n    dependencyManager.addDependency(&quot;4&quot;, &quot;1&quot;);\n    dependencyManager.executeTopoSort();\n    // Parallel version takes 8 seconds to execute.\n    // Serial version would have taken 16 seconds.\n\n}\n}\n</code></pre>\n<p>The Directed Acyclic Graph constructed in this example is this:</p>\n<p><a href=\"https://i.stack.imgur.com/ZBDTT.jpg\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/ZBDTT.jpg\" alt=\"Directed Acyclic Graph\" /></a></p>\n","answer_id":67449067,"question_id":63354899,"last_edit_date":1629042563},{"owner":{"profile_image":"https://i.stack.imgur.com/Klcqr.gif?s=256&g=1","account_id":292208,"user_type":"registered","user_id":2245707,"link":"https://stackoverflow.com/users/2245707/pveentjer","reputation":10665,"display_name":"pveentjer","accept_rate":17},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1629015407,"creation_date":1629014278,"body":"<p>The problem is that within a single JVM you have very little control on how much memory a single thread is going to use; unless you make use of offheap (e.g. using Unsafe or direct memory as AnatolyG already mentioned). If you have huge array allocations, you could also control these. But we need to know more about the data-structures that consume the most memory.</p>\n<p>But if you have orbitrary object graphs you don't have much control over, perhaps it smarter to model the problem using multiple processes. You have 1 intake controller process and then a bunch of worker processes. And on each process you can configure the maximum amount of heap a JVM is allowed to use.</p>\n<p>Bumping into memory limits on OS level can be a huge PITA because it could lead to swapping and this will makes all the threads in a system slow. Or even worse, OOM-killer. Make sure you set the vm.swappiness to a very low value to prevent premature swapping.</p>\n<p>Do you know up front how much memory a process is going to consume? If so, then you could keep track of the maximum amount of memory being consumed in the system and don't allow for new tasks in the system before tasks have completed.</p>\n<p>If you don't know up front the memory limits, then you could assume each tasks will use the maximum, but this can lead to under-utilization of memory.</p>\n","answer_id":68789701,"question_id":68746177,"last_edit_date":1629015407},{"owner":{"profile_image":"https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG","account_id":47283,"user_type":"registered","user_id":139985,"link":"https://stackoverflow.com/users/139985/stephen-c","reputation":703927,"display_name":"Stephen C","accept_rate":69},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1629002962,"creation_date":1629002962,"body":"<p>@rzwitserloot's <a href=\"https://stackoverflow.com/a/68785361/139985\">answer</a> covers just about everything.  (And what he says about correctness ... is correct.)</p>\n<p>The reason why <code>sleep()</code> or <code>println()</code> calls change the behavior is that they have undocumented (serendipitous) effects on the memory cache flushing behavior.</p>\n<p>In the case of <code>println</code>, the current implementation of the output stream stack involves calls to internal synchronized methods.  This is apparently sufficient to cause your flag's change in value to be visible to the second thread.</p>\n<p>In the case of <code>sleep</code>, the call causes the current thread's state to be saved to memory so that execution can switch to a different thread.</p>\n<p>But in either case, your modified code is &quot;working&quot; because of <em>undocumented</em> behavior.  This behavior could change between different Java versions, across different hardware or OS platforms and so on.</p>\n","answer_id":68788797,"question_id":68785125},{"owner":{"profile_image":"https://i.stack.imgur.com/Klcqr.gif?s=256&g=1","account_id":292208,"user_type":"registered","user_id":2245707,"link":"https://stackoverflow.com/users/2245707/pveentjer","reputation":10665,"display_name":"pveentjer","accept_rate":17},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1629002343,"creation_date":1628998377,"body":"<p>Your code is not working correctly because you are violating the Java Memory model (JMM). The problem with your code is that a happens-before edge is missing between the write of the 'flag' and the read of 'flag' and as a consequence your code is suffering from a data race. When there is a data-race, you can get unexpected behavior. Luckily it is better defined than a data-race with C++ where it can lead to undefined behavior.</p>\n<p>The compiler is the typical component that will break this  example. It could transform your code into:</p>\n<pre><code>if(!flag) return;\n\nwhile(true){\n   ...\n}\n</code></pre>\n<p>There is no point in checking flag in the loop if inside the loop the flag isn't changed. This optimization is called loop-invariant code-motion or hoisting. If you would make the flag field volatile, then happens-before edge between the write and the read will exist and the compiler can't apply optimize out the read. Instead it needs to read the flag from 'shared memory' (this include reading it from the coherent CPU cache).</p>\n<p>Please do not think that volatile forces flushing to main memory and writing from main memory. Main memory is just a spill bucket for whatever doesn't fit into the CPU cache. Caches on modern CPU's are always coherent. If for every volatile read/write you would need to access main memory, concurrent programs would become very slow. In most cases a volatile read/write can be resolved locally if there is no read/write miss and no cache coherence traffic with other CPU's or main memory is needed. The main 'flushing' that needs to be done to preserve ordering between loads and stores is that loads need to wait for the stores in the store buffer to drain; but this is before the store hits the cache. And even 'flushing' here is an inappropriate term since the store buffer is already draining to the cache as fast as possible.</p>\n<p>Also do not believe that volatile prevents using registers in the CPU; modern processors are all load-store architectures which mean that there are separate load/store instructions that load/store from memory into a register and most normal instructions like those executed by the ALUs can only deal with registers and do not have the ability to access memory. Even the X86 which from the outside if a register-memory architecture, after uops conversion becomes a load-store architecture. So registers are always used; the key part is how often registers needs to be synchronized with the cache.</p>\n<p>Apart from that, the JMM isn't defined in terms of registers and flushing to main memory, so it isn't a suitable mental model.</p>\n","answer_id":68788509,"question_id":68785125,"last_edit_date":1629002343},{"owner":{"profile_image":"https://i.stack.imgur.com/ZWEI3.jpg?s=256&g=1","account_id":322981,"user_type":"registered","user_id":642706,"link":"https://stackoverflow.com/users/642706/basil-bourque","reputation":310755,"display_name":"Basil Bourque","accept_rate":58},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":true,"last_activity_date":1628973041,"creation_date":1628969057,"body":"<h1>tl;dr</h1>\n<p>Do not bother trying to optimize a sub-second operation executed occasionally.</p>\n<h1>Details</h1>\n<p>You may have fallen into the trap known as <em>premature optimization</em>.</p>\n<p>I created two Java 16+ <a href=\"https://openjdk.java.net/jeps/395\" rel=\"nofollow noreferrer\">records</a> for your <code>Human</code> and <code>HumanInfo</code> classes.</p>\n<pre class=\"lang-java prettyprint-override\"><code>package work.basil.creation;\n\npublic record Human( String name , double height , double weight ) { }\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>package work.basil.creation;\n\npublic record HumanInfo( String name , double height ) {\n    public HumanInfo ( Human human ) {\n        this( human.name() , human.height() );\n    }\n}\n</code></pre>\n<p>Then I wrote this app to populate sample data of a million objects, followed by transcoding those objects from <code>Human</code> to <code>HumanInfo</code>.</p>\n<pre class=\"lang-java prettyprint-override\"><code>package work.basil.creation;\n\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class App {\n    public static void main ( String[] args ) {\n        App app = new App();\n        int limit = 1_000_000;\n        List &lt; Human &gt; humans = app.populateSampleData( limit );\n        List &lt; HumanInfo &gt; humanInfos = app.transcodeToHumanInfo( humans );\n    }\n\n    private List &lt; HumanInfo &gt; transcodeToHumanInfo ( final List &lt; Human &gt; humans ) {\n        Instant start = Instant.now();  // Benchmarking.\n        List &lt; HumanInfo &gt; humanInfos = humans.stream().map( human -&gt; new HumanInfo( human ) ).toList();\n        System.out.println( &quot;transcodeToHumanInfo  elapsed = &quot; + Duration.between( start , Instant.now() ) );\n        for ( int i = 0 ; i &lt; 10 ; i++ ) {\n            System.out.println( humanInfos.get( i ) );\n        }\n        return humanInfos;\n    }\n\n    private List &lt; Human &gt; populateSampleData ( final int limit ) {\n        List &lt; Human &gt; humans = new ArrayList &lt;&gt;( limit );\n        Instant start = Instant.now();\n        for ( int i = 0 ; i &lt; limit ; i++ ) {\n            humans.add( new Human( UUID.randomUUID().toString() , ThreadLocalRandom.current().nextDouble( 145d , 185d ) , ThreadLocalRandom.current().nextDouble( 45d , 90d ) ) );\n        }\n\n        // Dump to console.\n        System.out.println( &quot;populateSampleData elapsed = &quot; + Duration.between( start , Instant.now() ) );\n        for ( int i = 0 ; i &lt; 10 ; i++ ) {\n            System.out.println( humans.get( i ) );\n        }\n        return humans;\n    }\n}\n</code></pre>\n<p>In my experiments, I changed the <code>.stream</code> to <code>.parallelStream</code>. I ran each several times, always ignoring the first run. Results were quite consistent.</p>\n<p>I am running on <a href=\"http://jdk.java.net/17/\" rel=\"nofollow noreferrer\">early-access Java 17</a> optimized for Apple Silicon (not Intel) on my MacBook Pro (13-inch, M1, 2020) with 16 gigs of memory with macOS Big Sur 11.5.1, with 8 (4 performance and 4 efficiency) cores.</p>\n<h2>0.01x seconds</h2>\n<p>Results:</p>\n<ul>\n<li>Transcoding a <em><strong>million objects takes a hundredth of a second</strong></em> without concurrency. So no practical point in trying to improve on that.</li>\n<li>Changing that code from <code>.stream</code> to <code>.parallelStream</code> takes three times longer. Running concurrently <em>costs</em> you time rather than saving you time.</li>\n</ul>\n<p>Some arbitrarily selected run numbers.</p>\n<div class=\"s-table-container\">\n<table class=\"s-table\">\n<thead>\n<tr>\n<th style=\"text-align: right;\"><code>.stream</code></th>\n<th style=\"text-align: right;\"><code>.parallelStream</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: right;\">PT0.013089S<br />PT0.019682S<br />PT0.018813S</td>\n<td style=\"text-align: right;\">PT0.044404S<br />PT0.043849S<br />PT0.042643S</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>You asked:</p>\n<blockquote>\n<p>Is there a reason why multithreading does not help here?</p>\n</blockquote>\n<p>Because multithreading and concurrency are not magic, there is a cost, an <a href=\"https://en.wikipedia.org/wiki/Overhead_(business)\" rel=\"nofollow noreferrer\">“overhead”</a>. Setting up the threads, scheduling their execution times, coordinating their work, and collecting the results are all work that takes time to execute.</p>\n<p>When choosing to parallelize, you must consider the costs versus the benefits. This calculation should include some concrete evidence such as micro-benchmarking, as programmers are notoriously bad at guesstimating bottlenecks and optimizations.</p>\n","answer_id":68786399,"question_id":68786081,"last_edit_date":1628973041},{"owner":{"profile_image":"https://lh4.googleusercontent.com/-xIoh0ve8hKc/AAAAAAAAAAI/AAAAAAAAAEw/lmhFmElveRY/photo.jpg?sz=256","account_id":10125444,"user_type":"registered","user_id":7480973,"link":"https://stackoverflow.com/users/7480973/zachary-sang","reputation":17,"display_name":"Zachary Sang"},"content_license":"CC BY-SA 4.0","score":-1,"is_accepted":false,"last_activity_date":1628968867,"creation_date":1628959827,"body":"<blockquote>\n<p>Why fct.isFlag() in the while loop of main thread can't get the latest value without some sleep?</p>\n</blockquote>\n<p>I believe that what is happening here is that without the <code>Thread.sleep(1)</code> you have a tight loop (<a href=\"https://stackoverflow.com/a/2212986/7480973\">relevant definition</a>). This means means that the main thread is not getting the latest value because it is using the cached value (as you said also fixable by making the flag valuable volatile).</p>\n<p>When the <code>Thread.sleep()</code> is added, the tight loop is broken since this moves the thread out of the <code>Runnable</code> state. When a thread moves out of the <code>Runnable</code> state, it is moved off of the CPU. when resuming from <code>Thread.sleep()</code>, the CPU cached value are reloaded from memory, which gives the freshest flag value.</p>\n","answer_id":68785320,"question_id":68785125,"last_edit_date":1628968867},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG","account_id":401843,"user_type":"registered","user_id":768644,"link":"https://stackoverflow.com/users/768644/rzwitserloot","reputation":89863,"display_name":"rzwitserloot"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1628960158,"creation_date":1628960158,"body":"<p>The reason is The Evil Coin.</p>\n<p>The specification that is relevant here is the Java Memory Model (JMM).</p>\n<p>The JMM has the following aspect to it:</p>\n<p><strong>Any thread is free to make a local cached copy of a variable, or not, and may refer, according to its whims and the phase of the moon if it wants, to either that copy or not.</strong></p>\n<p>In other words, the thread flips a coin to decide what to do. It is evil, in that it won't flip heads/tails at a roughly 50/50 split. Assume it flips coins to mess with you: It works great for an hour or so, and then all of a sudden it starts failing when you pick up the work again tomorrow morning, and you have no idea what happened.</p>\n<p>Thus, in some of your invocations, that boolean field you're looking at is getting cached copies.</p>\n<p>Said differently:</p>\n<p><strong>If multiple threads are working with the same field, the behaviour of your application is undefined unless you establish HB/HA</strong>.</p>\n<p>The reason it works in this bizarre fashion is speed: Any other definition would mean a JVM has to run code a few orders of magnitude more slowly.</p>\n<p>The solution is to establish HB/HA: Happens-Before/Happens-After relationships.</p>\n<p>HB/HA works like this: If there is an HB/HA relationship between 2 lines of code, then it is impossible to observe the state as it was <strong>before</strong> the Happens-Before line ran, from the Happens-After line. In other words, if a field has value '5' before the HB line, and value '7' after the 'HB' line, then the HA line cannot possibly observe 5. It can observe 7, or some update that occurred afterwards.</p>\n<p>The spec lists a bunch of things that establish HB/HA:</p>\n<ul>\n<li>Any access to <code>volatile</code> fields. You can try that right now: Make that field <code>volatile</code>, it'll 'fix' it.</li>\n<li>The exiting of a <code>synchronized(x)</code> block is HB vs. entering a <code>synchronized(theSameX)</code> block in another thread (if that entering that block actually happens afterwards, of course).</li>\n<li>The <code>t.start()</code> method is HB relative to the first line in the <code>run()</code> of the thread you started.</li>\n<li>Within one thread, any line of code that is run before any other is HB (that's the trivial case).</li>\n</ul>\n<p>Some things within the JVM use this stuff.</p>\n<p>Tips:</p>\n<ul>\n<li>Generally, use stuff from the <code>java.util.concurrent</code> package.</li>\n<li>Try to avoid interacting with the same field from different threads.</li>\n<li>Consider databases or message queues or other systems with less finicky rules about inter-thread communications.</li>\n<li>If writing to fields that other threads are supposed to read, you <strong>must</strong> consider HB/HA.</li>\n<li>None of this is a guarantee. <strong>You can write broken code that nevertheless passes all tests today, and tomorrow, and next week, and on the production machine, but fails next month when you're giving that important demo to the big customer</strong>. Hence, <strong>here be dragons</strong>: If you mess, you may not know until the cost the bug imposes on you has ballooned out of control. Thus, avoid this stuff unless you really, really, really know what you are doing.</li>\n</ul>\n","answer_id":68785361,"question_id":68785125},{"owner":{"profile_image":"https://www.gravatar.com/avatar/d6d4c4b8d52a51d9f7f64c1e5f2de0b3?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":4569994,"user_type":"registered","user_id":3709922,"link":"https://stackoverflow.com/users/3709922/jignesh-m-khatri","reputation":1447,"display_name":"Jignesh M. Khatri","accept_rate":33},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1628930828,"creation_date":1628789462,"body":"<p>Here is the one of the solution to solve the given problem. It uses <code>wait</code> to wait the current thread after printing one letter and <code>notify</code> the other thread to print its letter, and same cycle repeats. The concept of Thread <code>wait</code> and <code>notify</code> is very well explained <a href=\"https://stackoverflow.com/a/13664082/3709922\">here</a>.</p>\n<p><strong>Short description:</strong></p>\n<p>To <code>wait</code> or <code>notify</code> any thread, it (invoking thread) must acquire the lock on any common object. In below example, each thread is acquiring the lock on <code>this</code> (self) (via synchronized <code>run</code> method) to <code>wait</code> and on <code>opponent</code> to notify it (the another thread).</p>\n<pre><code>public class App implements Runnable {\n    char c;\n    App opponent;\n    boolean go;\n\n    public App(char c, boolean go) {\n        this.c = c;\n        this.go = go;\n    }\n\n    public void setOpponent(App opponent) {\n        this.opponent = opponent;\n    }\n\n    public static void main(String[] args) {\n        App a = new App('a', true);\n        App b = new App('A', false);\n\n        Thread t1 = new Thread(a);\n        Thread t2 = new Thread(b);\n\n        a.setOpponent(b);\n        b.setOpponent(a);\n\n        t1.start();\n        t2.start();\n    }\n\n    @Override\n    public synchronized void run() {\n        for (char i = 0; i &lt; 26; i++) {\n\n            try {\n                if (go) {\n                    System.out.println(c++);\n                    this.wait();\n                    synchronized (opponent) {\n                        opponent.notify();\n                    }\n                } else {\n                    System.out.println(c++);\n                    synchronized (opponent) {\n                        opponent.notify();\n                    }\n                    this.wait();\n                }\n\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre>\n<p>Here is the more simplified and understandable version of above code. In this code, both the threads are acquiring lock on same <code>lock</code> object, printing the letter, going in <code>WAIT</code> state (so release the lock) and giving turn to other <code>BLOCKED</code> thread waiting for the lock on <code>lock</code>. The other thread then acquires the lock on <code>lock</code>, prints the letter, notifies the previous thread which was waiting on <code>lock</code> object, and goes into <code>WAIT</code> condition, thus releasing the lock.</p>\n<pre><code>public class App2 implements Runnable {\n    char c;\n    Object lock;\n    boolean go;\n\n    public App2(char c, boolean go) {\n        this.c = c;\n        this.go = go;\n    }\n\n    public void setLock(Object lock) {\n        this.lock = lock;\n    }\n\n    public static void main(String[] args) {\n        App2 a = new App2('a', true);\n        App2 b = new App2('A', false);\n\n        Thread t1 = new Thread(a);\n        Thread t2 = new Thread(b);\n\n        Object lock = new Object();\n\n        a.setLock(lock);\n        b.setLock(lock);\n\n        t1.start();\n        t2.start();\n    }\n\n    @Override\n    public void run() {\n\n        for (char i = 0; i &lt; 26; i++) {\n            synchronized (lock) {\n                try {\n                    if (go) {\n                    \n                        System.out.println(c++);\n                        lock.wait();\n                        lock.notify();\n                    \n                    } else {\n                    \n                        System.out.println(c++);\n                        lock.notify();\n                        lock.wait();\n                    \n                    }\n                } catch (InterruptedException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<p><strong>UPDATE:</strong></p>\n<p>Above two approaches will work in most of the cases, but will not guarantee that <code>t1</code> will be executed before <code>t2</code> every time. Though <code>t1</code> is started before <code>t2</code>, but it does not mean that thread scheduler will always pick <code>t1</code> to execute before <code>t2</code>. To be sure that <code>t1</code> will execute before <code>t2</code> in every case, we need to ensure that <code>t2</code> gets started once <code>t1</code> is in <code>RUNNABLE</code> state (i.e. running). Below is the one of the way of how we can achieve it:</p>\n<pre><code>public class App3 implements Runnable {\n    char c;\n    App3 opponent;\n    boolean go;\n    boolean createOpponent = false;\n\n    public App3(char c, boolean go) {\n        this.c = c;\n        this.go = go;\n    }\n\n    public void setOpponent(App3 opponent) {\n        this.opponent = opponent;\n    }\n\n    public void setCreateOpponent(boolean createOpponent) {\n        this.createOpponent = createOpponent;\n    }\n\n    public static void main(String[] args) {\n        App3 a = new App3('a', true);\n        App3 b = new App3('A', false);\n\n        Thread t1 = new Thread(a);\n\n        a.setOpponent(b);\n        a.setCreateOpponent(true);\n\n        b.setOpponent(a);\n\n        t1.start();\n    }\n\n    @Override\n    public synchronized void run() {\n        if (createOpponent) {\n            setCreateOpponent(false);\n            new Thread(opponent).start();\n        }\n        for (char i = 0; i &lt; 26; i++) {\n\n            try {\n                if (go) {\n                    System.out.println(c++);\n                    this.wait();\n                    synchronized (opponent) {\n                        opponent.notify();\n                    }\n                } else {\n                    System.out.println(c++);\n                    synchronized (opponent) {\n                        opponent.notify();\n                    }\n                    this.wait();\n                }\n\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre>\n","answer_id":68761907,"question_id":68760729,"last_edit_date":1628930828},{"owner":{"profile_image":"https://lh3.googleusercontent.com/-2DggdTBjTSg/AAAAAAAAAAI/AAAAAAAAKRk/8QidWyLl7Xk/photo.jpg?sz=256","account_id":460635,"user_type":"registered","user_id":4807449,"link":"https://stackoverflow.com/users/4807449/ronnie-horo","reputation":11,"display_name":"Ronnie Horo"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1628796881,"creation_date":1628796420,"body":"<p>Hope this helps...</p>\n<pre><code>public class ABCThread implements Runnable {\n    char c;\n    boolean flag;\n\n    public ABCThread(char c, boolean flag) {\n        this.c = c;\n        this.flag = flag;\n    }\n\n    @Override\n    public synchronized void run() {\n        for (char i = 0; i &lt; 52; i++) {\n            try {\n                if (flag) {\n                    System.out.println(c++);\n                    notifyAll();\n                    flag = false;\n                    wait(100);\n                } else {\n                    flag = true;\n                    wait(100);\n                }\n\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n\n        Thread t1 = new Thread(new ABCThread('a', true));\n        Thread t2 = new Thread(new ABCThread('A', false));\n\n        t1.start();\n        t2.start();\n\n    }\n}\n</code></pre>\n<p>or you can define separate methods for printing small and capital letters and run them in two separate threads</p>\n<pre><code>public class ABCThread {\n\n    boolean flag;\n\n    public ABCThread(boolean flag) {\n        this.flag = flag;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n\n        ABCThread abc = new ABCThread(false);\n\n        Thread t1 = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                try {\n                    abc.printSmallLetters();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n            }\n        });\n        Thread t2 = new Thread(new Runnable() {\n            public void run() {\n                try {\n                    abc.printCapitalLetters();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n\n        t1.start();\n        t2.start();\n\n    }\n\n    synchronized void printSmallLetters() throws InterruptedException {\n        for (char i = 'a'; i &lt; 'z'; i++) {\n            while (flag == true) {\n                wait();\n            }\n            System.out.println(i);\n            notifyAll();\n            flag = true;\n        }\n    }\n\n    synchronized void printCapitalLetters() throws InterruptedException {\n        for (char i = 'A'; i &lt; 'Z'; i++) {\n            while (flag == false) {\n                wait();\n            }\n            System.out.println(i);\n            notifyAll();\n            flag = false;\n        }\n    }\n}\n\n</code></pre>\n","answer_id":68763152,"question_id":68760729,"last_edit_date":1628796881},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b46fd0a429838cd67ea0650e953899be?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":22447688,"user_type":"registered","user_id":16651360,"link":"https://stackoverflow.com/users/16651360/marco","reputation":54,"display_name":"Marco"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1628795492,"creation_date":1628785297,"body":"<p><strong>Quick answer:</strong></p>\n<p>You can't force a thread to run at a certain moment. What you can do though is let those two run &quot;out of sync&quot; (not related to async coding).</p>\n<pre><code>Thread t1 = new Thread(new ABCThread('a'));\nThread.sleep(250);\nThread t2 = new Thread(new ABCThread('A'));\n</code></pre>\n<p>The 1st thread will print about every 500 ms and the 2nd thread will print at 250, 750, 1250, etc.\nNote that this would not be a correct way to solve this in real programs. But then again, you would also likely not add <code>Thread.sleep(500)</code> to the run method.</p>\n<p><strong>Better:</strong></p>\n<p>You need synchronization between the threads. Because you start two threads you can use a boolean.</p>\n<pre><code>public class ABCThread implements Runnable {\nchar c;\nstatic boolean synchronizer = false;\nboolean runOn;\n\npublic ABCThread(char c, boolean runOn) {\n    this.c = c;\n    this.runOn = runOn;\n}\n\n@Override\npublic synchronized void run() {\n    int count = 0;\n    while(count &lt; 26)\n    {\n        if(runOn != synchronizer) \n        {\n           Thread.sleep(100);\n           continue;\n        }\n        count++;\n        synchronizer = !synchronizer;\n        System.out.println(c++);\n        \n    }\n\n}\n\n    Thread t1 = new Thread(new ABCThread('a', false));\n    Thread t2 = new Thread(new ABCThread('A', true));\n</code></pre>\n<p>Just typing this out. It might not compile.\n<code>Thread.sleep(100)</code> is just some number. It could possibly be lower, but doesn't matter much for the question.</p>\n<p><strong>Even better</strong>\nThe previous code can run with only 2 threads! 1 will just stay stuck with synchronizer = false. If you add a third then the synchronizer won't work because it only has 2 states.\nYou could add an integer instead of the boolean and another integer amountOfThreads. The amountOfThreads will need to be set to the amount of threads you will start up. Then increase the atomic integer when the thread prints and if the synchronizer (the atomic int) is more than amountOfThreads, set it to 0.</p>\n","answer_id":68761029,"question_id":68760729,"last_edit_date":1628795492},{"owner":{"profile_image":"https://i.stack.imgur.com/PMmwr.jpg?s=256&g=1","account_id":4483794,"user_type":"registered","user_id":3647105,"link":"https://stackoverflow.com/users/3647105/liem-le","reputation":581,"display_name":"Liem Le"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1628788395,"creation_date":1628787663,"body":"<h1>What you need? A &quot;shared resource&quot; between threads.</h1>\n<h1>Further: A synchronous FSM (Finite state machine)</h1>\n<p>Below is code that demonstrated how to achieve that.</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class Main\n{\n    // The shared resource\n    public static class State {\n        \n        private int val;\n        private int nStates;\n\n        // Init value and number of states.\n        public State(int init, int nStates) {\n            this.val = init;\n            this.nStates = nStates;\n        }\n        \n        int get() {\n            return val;\n        }\n        // Define how to get to next state. For simple use case, just increase then modulo it. eg: 0, 1, 0, 1\n        // Avoid modulo in-case you need very very high performance.\n        void next() {\n            this.val = (this.val + 1) % nStates;\n        }\n    }\n    \n    public static class ABCThread implements Runnable{\n        private char c;\n        private State s;\n        private int type;\n        public ABCThread(char c, State s, int type) {\n            this.c = c;\n            this.s = s;\n            this.type = type;\n        }\n\n        @Override\n        public void run() {\n            try {\n            for (char i = 0; i &lt; 26; i++) {\n                // Do things synchronously\n                synchronized(s){\n                    while(s.get() != type) {\n                        // Wait for our turn.\n                        s.wait();\n                    }\n                    System.out.print(c++);\n                    // Update state\n                    s.next();\n                    // Notify to other threads to do their job.\n                    s.notifyAll();\n                }\n            }\n            }catch(Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n\n        // Define the state.\n        State s = new State(0, 2);\n\n\n        /* Uncomment this block to have 3 synchronous threads. Will print aA1bB2...\n        s = new State(0, 3);\n        Thread t3 = new Thread(new ABCThread('1', s, 2));\n        t3.start();\n        t3.join();\n        */\n        Thread t1 = new Thread(new ABCThread('a', s, 0));\n        Thread t2 = new Thread(new ABCThread('A', s, 1));\n\n\n        // Start threads\n        t1.start();\n        t2.start();\n        // Wait for these threads to finish before exit.\n        t1.join();\n        t2.join();\n    }\n}\n</code></pre>\n","answer_id":68761559,"question_id":68760729,"last_edit_date":1628788395},{"owner":{"profile_image":"https://www.gravatar.com/avatar/780a651189f64a2cbf4b7f62cf852005?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":7178634,"user_type":"registered","user_id":5483526,"link":"https://stackoverflow.com/users/5483526/matt-timmermans","reputation":55168,"display_name":"Matt Timmermans"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1628788097,"creation_date":1628787632,"body":"<p>You're supposed to use a <code>boolean</code> to control which thread prints:</p>\n<ol>\n<li>Thread 1 waits for the boolean to be false.  Then it prints and sets it true.</li>\n<li>Thread 2 waits for the boolean to be true.  Then it prints and sets it false.</li>\n</ol>\n<p>In this way, the threads will alternate.  Also, all of this will be much faster if you use signaling between threads instead of <code>sleep</code>:</p>\n<pre><code>import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class ABCThread implements Runnable {\n    static Object monitor = new Object();\n    static boolean turn = false;\n    \n    char c;\n    final boolean myTurn;\n\n    public ABCThread(char c, boolean myTurn) {\n        this.c = c;\n        this.myTurn = myTurn;\n    }\n\n    @Override\n    public void run() {\n\n        for (char i = 0; i &lt; 26; i++) {\n            synchronized(monitor) {\n                while (turn != myTurn) {\n                    try {\n                        // Note that the lock is release while I'm waiting,\n                        // So the other thread can claim it here.\n                        monitor.wait();\n                    } catch (Exception e) {\n                    }\n                }\n                System.out.println(c++);\n                turn = !myTurn;\n                monitor.notifyAll();\n            }\n        }\n\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n\n        Thread t1 = new Thread(new ABCThread('a', false));\n        Thread t2 = new Thread(new ABCThread('A', true));\n\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n\n    }\n}\n</code></pre>\n","answer_id":68761547,"question_id":68760729,"last_edit_date":1628788097},{"owner":{"profile_image":"https://lh3.googleusercontent.com/a-/AOh14GiYf8V11zSxXD852Bjjc3hlT1M4SpB5HMHFzJY5nw=k-s256","account_id":22446598,"user_type":"registered","user_id":16650432,"link":"https://stackoverflow.com/users/16650432/rakshith-b-s","reputation":45,"display_name":"Rakshith B S"},"content_license":"CC BY-SA 4.0","score":-1,"is_accepted":false,"last_activity_date":1628787861,"creation_date":1628784544,"body":"<p><img src=\"https://i.stack.imgur.com/qzP5C.png\" alt=\"output\" /></p>\n<p>just replace the println by print to get a series output like this\nother than that everything seems to be fine,\nyou can see the output i got in the screenshot above</p>\n","answer_id":68760859,"question_id":68760729,"last_edit_date":1628787861},{"owner":{"profile_image":"https://www.gravatar.com/avatar/3e4be83fe4b3ea871e3595d80172f118?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":19042414,"user_type":"registered","user_id":13902217,"link":"https://stackoverflow.com/users/13902217/jeka-fri","reputation":71,"display_name":"Jeka_FRI"},"content_license":"CC BY-SA 4.0","score":-2,"is_accepted":false,"last_activity_date":1628785755,"creation_date":1628784988,"body":"<p>No way. The order of execution of threads cannot be controlled).You can use Thread.yield(). But yield () - tries to tell the scheduler to execute the next thread, but it stays in the RUNNABLE state.</p>\n","answer_id":68760956,"question_id":68760729,"last_edit_date":1628785755},{"owner":{"profile_image":"https://www.gravatar.com/avatar/fed094516f56f32f79436c3bba9ff71b?s=256&d=identicon&r=PG","account_id":3087422,"user_type":"registered","user_id":2614310,"link":"https://stackoverflow.com/users/2614310/arvind-kumar","reputation":509,"display_name":"Arvind Kumar","accept_rate":14},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1627448454,"creation_date":1627448454,"body":"<p><strong>1st  Use case</strong> - Per thread context which gives thread safety as well as performance\nReal-time example in SpringFramework classes -</p>\n<ul>\n<li>LocaleContextHolder</li>\n<li>TransactionContextHolder</li>\n<li>RequestContextHolder</li>\n<li>DateTimeContextHolder</li>\n</ul>\n<p><strong>2nd Use case</strong> - When we don't want to share something among threads and at the same time don't want to use synchronize/lock due to performance cost\nexample - SimpleDateFormat to create the custom format for dates</p>\n<pre><code>import java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n/**\n * @author - GreenLearner(https://www.youtube.com/c/greenlearner)\n */\npublic class ThreadLocalDemo1 {\n    SimpleDateFormat sdf = new SimpleDateFormat(&quot;dd-mm-yyyy&quot;);//not thread safe\n    ThreadLocal&lt;SimpleDateFormat&gt; tdl1 = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(&quot;yyyy-dd-mm&quot;));\n\n    public static void main(String[] args) {\n        ThreadLocalDemo1 d1 = new ThreadLocalDemo1();\n\n        ExecutorService es = Executors.newFixedThreadPool(10);\n\n        for(int i=0; i&lt;100; i++) {\n            es.submit(() -&gt; System.out.println(d1.getDate(new Date())));\n        }\n        es.shutdown();\n    }\n\n    String getDate(Date date){\n\n//        String s = tsdf.get().format(date);\n        String s1 = tdl1.get().format(date);\n        return s1;\n    }\n}\n</code></pre>\n<p><strong>Usage Tips</strong></p>\n<ul>\n<li>Use local variables if possible. This way we can avoid using ThreadLocal</li>\n<li>Delegate the functionality to frameworks as and when possible</li>\n<li>If using ThreadLocal and setting the state into it then make sure to clean it after using otherwise it can become the major reason for <strong>OutOfMemoryError</strong></li>\n</ul>\n","answer_id":68554632,"question_id":817856},{"owner":{"profile_image":"https://i.stack.imgur.com/xvjto.png?s=256&g=1","account_id":6477138,"user_type":"registered","user_id":5015427,"link":"https://stackoverflow.com/users/5015427/ranojan","reputation":829,"display_name":"ranojan"},"content_license":"CC BY-SA 4.0","score":-1,"is_accepted":false,"last_activity_date":1624966050,"creation_date":1624966050,"body":"<p>Delete</p>\n<pre><code>&lt;style name=&quot;AppTheme.Launcher&quot;&gt;\n    &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/splashscreen&lt;/item&gt;\n&lt;/style&gt;\n</code></pre>\n<p>from style.xml file</p>\n","answer_id":68177787,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/1d80d2b74461600fd72673caebce4e24?s=256&d=identicon&r=PG","account_id":21829083,"user_type":"unregistered","user_id":16124211,"link":"https://stackoverflow.com/users/16124211/pluk","reputation":31,"display_name":"pluk"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1622783005,"creation_date":1622783005,"body":"<p>The <code>compute()</code> javadoc <a href=\"https://github.com/openjdk/jdk16u/blob/jdk16.0.1/src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java#L1876\" rel=\"nofollow noreferrer\">says</a> what this method does:</p>\n<blockquote>\n<p>Attempts to compute a mapping for the specified key and its current mapped value (or <code>null</code> if there is no current mapping).</p>\n</blockquote>\n<p>So <code>compute()</code> <strong>replaces</strong> a value for the key.</p>\n<p>To use <code>compute()</code> to modify the internal fields of some object (even the object is stored as a value in the map) is not what <code>compute()</code> was meant for.<br />\nTherefore, naturally, <code>compute()</code>'s specification/documentation guarantees (and even says) nothing about that.</p>\n<p>Regarding <code>happens-before</code>, there are multiple mentions in the documentation:</p>\n<ul>\n<li><a href=\"https://github.com/openjdk/jdk16u/blob/jdk16.0.1/src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java#L89\" rel=\"nofollow noreferrer\">ConcurrentHashMap</a>:\n<blockquote>\n<p>More formally, an update operation for a given key bears a <em>happens-before</em> relation with any (non-null) retrieval for that key reporting the updated value.</p>\n</blockquote>\n</li>\n<li><a href=\"https://github.com/openjdk/jdk16u/blob/jdk16.0.1/src/java.base/share/classes/java/util/concurrent/ConcurrentMap.java#L55\" rel=\"nofollow noreferrer\">ConcurrentMap</a>:\n<blockquote>\n<p>Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a <code>ConcurrentMap</code> as a key or value <em>happen-before</em> actions subsequent to the access or removal of that object from the <code>ConcurrentMap</code> in another thread.</p>\n</blockquote>\n</li>\n<li><a href=\"https://github.com/openjdk/jdk16u/blob/jdk16.0.1/src/java.base/share/classes/java/util/concurrent/package-info.java#L270\" rel=\"nofollow noreferrer\">java.util.concurrent</a>:\n<blockquote>\n<p>Actions in a thread prior to placing an object into any concurrent collection <em>happen-before</em> actions subsequent to the access or removal of that element from the collection in another thread.</p>\n</blockquote>\n</li>\n</ul>\n<p>The important thing is that the <code>happen-before</code> relation is only guaranteed between insertion/removal/retrieval of objects to/from the collection.<br />\nIn your case it is the same <code>State</code> object (only internal its fields are updated), so IMO according to documentation <code>ConcurrentHashMap</code> is even allowed to decide that nothing changed and skip the remaining synchronization steps.</p>\n","answer_id":67831727,"question_id":67825678},{"owner":{"profile_image":"https://www.gravatar.com/avatar/8cf8627c2f497949547cadc02c52b95f?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":4034876,"user_type":"registered","user_id":3319725,"link":"https://stackoverflow.com/users/3319725/anatolyg","reputation":1557,"display_name":"AnatolyG"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1621344860,"creation_date":1621330742,"body":"<p>This code has both of the classical concurrency problems: a race condition (a semantic problem) and a data race (a memory model related problem).</p>\n<ol>\n<li><code>Object.wait()</code> releases the object's monitor and another thread can enter into the synchronized block/method while the current one is waiting. Obviously, author's intention was to make the method atomic, but <code>Object.wait()</code> breaks the atomicity. As result, if we call <code>.increment()</code> from, let's say, 10 threads simultaneously and each thread calls the method 100_000 times, we get <code>count</code> &lt; 10 * 100_000 almost always, and this isn't what we'd like to. This is a race condition, a logical/semantic problem. We can rephrase the code... Since we release the monitor (this equals to the exit from the synchronized block), the code works as follows (like two separated synchronized parts):</li>\n</ol>\n<pre><code>    public void increment() { \n        int temp = incrementPart1(); \n        incrementPart2(temp); \n    }\n    \n    private synchronized int incrementPart1() {\n        int temp = count; \n        return temp; \n    }\n    \n    private synchronized void incrementPart2(int temp) {\n        count = temp + 1; \n    }\n</code></pre>\n<p>and, therefore, our <code>increment</code> increments the counter not atomically. Now, let's assume that 1st thread calls incrementPart1, then 2nd one calls incrementPart1, then 2nd one calls incrementPart2, and finally 1st one calls incrementPart2. We did 2 calls of the <code>increment()</code>, but the result is 1, not 2.</p>\n<ol start=\"2\">\n<li>Another problem is a data race. There is the Java Memory Model (JMM) described in the Java Language Specification (JLS). JMM introduces a Happens-before (HB) order between actions like volatile memory write/read, Object monitor's operations etc. <a href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4.5\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4.5</a> HB gives us guaranties that a value written by one thread will be visible by another one. Rules how to get these guaranties are also known as Safe Publication rules. The most common/useful ones are:</li>\n</ol>\n<ul>\n<li><p>Publish the value/reference via a volatile field (<a href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4.5\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4.5</a>), or as the consequence of this rule, via the AtomicX classes</p>\n</li>\n<li><p>Publish the value/reference through a properly locked field (<a href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4.5\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4.5</a>)</p>\n</li>\n<li><p>Use the static initializer to do the initializing stores\n(<a href=\"http://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html#jls-12.4\" rel=\"nofollow noreferrer\">http://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html#jls-12.4</a>)</p>\n</li>\n<li><p>Initialize the value/reference into a final field, which leads to the freeze action (<a href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.5\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.5</a>).</p>\n</li>\n</ul>\n<p>So, to have the counter correctly (as JMM has defined) visible, we must make it volatile</p>\n<pre><code>private volatile int count = 0;\n</code></pre>\n<p>or do the read over the same object monitor's synchronization</p>\n<pre><code>public synchronized int getCount() { return count; }\n</code></pre>\n<p>I'd say that in practice, on Intel processors, you read the correct value without any of these additional efforts, with just simple plain read, because of TSO (Total Store Ordering) implemented. But on a more relaxed architecture, like ARM, you get the problem. Follow JMM formally to be sure your code is really thread-safe and doesn't contain any data races.</p>\n","answer_id":67583683,"question_id":67576652,"last_edit_date":1621344860},{"owner":{"profile_image":"https://www.gravatar.com/avatar/45e3a1431bd08d4f8b1ce609c7924531?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":21225504,"user_type":"registered","user_id":15611270,"link":"https://stackoverflow.com/users/15611270/rocco","reputation":1108,"display_name":"Rocco"},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":true,"last_activity_date":1621333432,"creation_date":1621254735,"body":"<p>Actually you don't need to sleep, use proper queue classes instead, like <code>LinkedBlockingQueue</code>, I also remove the flags since you don't need them also, use <code>interrupt()</code> to stop a thread blocked waiting for a queue element:</p>\n<pre><code>private DatagramSocket socket;\nprivate byte[] buf = new byte[256];\nprivate List&lt;IUDPListener&gt; listeners = new ArrayList&lt;IUDPListener&gt;();\nprivate Thread runnerThread, listenerThread;\nprivate LinkedBlockingQueue&lt;MyObject&gt; list = new LinkedBlockingQueue&lt;MyObject&gt;();\n\npublic void init(int port) throws SocketException\n{\n    socket = new DatagramSocket(port);\n    \n    runnerThread = new Thread(this::listenLoopUDP);\n    runnerThread.setName(&quot;listenLoopUDP&quot;);\n    \n    listenerThread = new Thread(this::listenerThreadUDP);\n    listenerThread.setName(&quot;listenerThreadUDP&quot;);\n    \n    runnerThread.start();\n    listenerThread.start();\n}\n\nprivate void listenerThreadUDP() {\n    try {\n        while (true) {\n            MyObject info=list.take();\n            for (IUDPListener listener : listeners) {\n                listener.msgReceived(info);\n            }\n        }\n    } catch (InterruptedException ex) {\n        //Just quit\n    }\n}\n\npublic void listenLoopUDP() {\n    try {\n        while (true) {\n            DatagramPacket packet = new DatagramPacket(buf, buf.length);\n            socket.receive(packet);\n            String received = new String(packet.getData());\n            MyObject info = new MyObject(received);\n            list.put(info);\n        }\n    } catch (IOException e) {\n        Log.write(e);\n    } catch (InterruptedException e) {\n        Log.write(e);\n    } finally {\n        //Any exception above (or a runtime one) will activate this block where we do the cleanup and interrupt the other running thread\n        listenerThread.interrupt();\n        socket.close();\n    }\n}\n</code></pre>\n<p>I did a test with your 1ms client, printing both sent and received message and I have a perfect interleaving between the message, so the bottleneck is not in the receiving thread; with perfect interleaving I mean that in the console I get, as expected, the sent message from the client immediately followed from the received message.</p>\n","answer_id":67569728,"question_id":67566923,"last_edit_date":1621333432},{"owner":{"user_type":"does_not_exist","display_name":"user15793316"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1621287193,"creation_date":1621286439,"body":"<p>Why <code>int temp = count; wait(100); count = temp + 1;</code> is not thread-safe? One possible flow:</p>\n<ul>\n<li>First thread reads <code>count</code> (0), save it in <code>temp</code> for later, and waits, allowing second thread to run (lock released);<br/></li>\n<li>second thread reads <code>count</code> (also 0), saved in <code>temp</code>, and waits, eventually allowing first thread to continue;<br/></li>\n<li>first thread increments value from <code>temp</code> and saves in <code>count</code> (1);<br/></li>\n<li>but second thread still holds the old value of <code>count</code> (0) in <code>temp</code> - eventually it will run and store <code>temp+1</code> (1) into <code>count</code>, not incrementing its new value.</li>\n</ul>\n<p><sup>very simplified, just considering 2 threads</sup></p>\n<p>In short: <code>wait()</code> releases the lock allowing other (synchronized) method to run.</p>\n","answer_id":67577156,"question_id":67576652,"community_owned_date":1621286439,"last_edit_date":1621287193},{"owner":{"profile_image":"https://www.gravatar.com/avatar/d5eaa0398d86085f8751aae1bf3373fc?s=256&d=identicon&r=PG","account_id":369372,"user_type":"registered","user_id":716720,"link":"https://stackoverflow.com/users/716720/sergey-shcherbakov","reputation":4604,"display_name":"Sergey Shcherbakov","accept_rate":60},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1621279534,"creation_date":1621279534,"body":"<p>Check whether your use case allows solving the problem with keyboard interactive input. Instead of CoundDownLatch or Semaphore you could then expect manual input in System.in:</p>\n<pre><code>Scanner sc = new Scanner(System.in);\nsc.nextLine();\n</code></pre>\n<p>If you need that in unit tests, make sure that your environment is set up to read the user input, e.g. start the IntelliJ Idea with <code>-Deditable.java.test.console=true</code> option in Help -&gt; &quot;Edit Custom VM Options...&quot;</p>\n","answer_id":67575900,"question_id":27034958},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG","account_id":401843,"user_type":"registered","user_id":768644,"link":"https://stackoverflow.com/users/768644/rzwitserloot","reputation":89863,"display_name":"rzwitserloot"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1621271417,"creation_date":1621271417,"body":"<p>The Java Memory Model (JMM) is the relevant documentation here.</p>\n<blockquote>\n<p>t1 in the Main Method works as intended</p>\n</blockquote>\n<p>No, it doesn't. This is the first problem of the JMM: The JMM decrees areas where JVMs are free to do whatever they want. That means that the output of the JVM is <strong>non deterministic</strong> in effect: A JVM is free to always do A, or always do B, or flip a coin, or look at the phase of the moon, and more - and they still adhere to the spec. That's not just academic: The popular JVM impls out there all actually do this, because they can run far more efficiently that way.</p>\n<p>It means that effectively you can't test your code to detect that you messed up (by relying on the JVM's choice - which is bad), and if it seems to work right now, there's no guarantee it works tomorrow.</p>\n<p>Basically, the JMM allows the JVM to flip an evil coin sometimes: Evil in the sense that it will flip the same way every time during your dev and test cycle and then flips the other way just as you're giving that important demo.</p>\n<p>The only way to play the game, is <strong>to ensure the evil coin is never flipped in the first place</strong>.</p>\n<p>To do that, you need to remember the following rule:</p>\n<p><strong>All fields that are shared between threads must never be accessed unless HB/HA relationships are set up first, <em>OR</em> it is a read-only concept for the entirety of the concurrent process</strong>.</p>\n<p>In other words, here you have a field (<code>bookList</code>, or to be more specific, the backing array within the arraylist that bookList is pointing at) that is modified by one thread whilst another is running that also wants to read it, and  and thus, evil coinflips occur and this code is broken, whether your tests say so or not. You will 'randomly' observe some or all of the changes or not, or at least the JVM is free to let thread B see what thread A did or not in a haphazard fashion and you can't rely on any of it.</p>\n<p>HB/HA stands for 'happens-before/happens-after'. The JMM describes certain situations for which the JVM guarantees that it is not possible to observe the <em>lack</em> of change caused by the Happens-Before line in the Happens-After line.</p>\n<p>Without HB/HA, you get no such guarantee. To make that clear with an example:</p>\n<pre><code>class State {\n    static int a = 0, b = 0;\n}\n\nclass T1 implements Runnable {\n    public void run() {\n        Thread.sleep(randomAmount);\n        State.a = 10;\n        State.b = 20;\n    }\n}\n\nclass T2 implements Runnable {\n    public void run() {\n        Thread.sleep(randomAmount);\n        int myB = State.b;\n        int myA = State.a;\n        System.out.println(myA + &quot; &quot; + myB);\n    }\n}\n</code></pre>\n<p>If you run this code, fire up the two threads, then any of these outputs are all 'legal' - it is not a buggy JVM. Your code is the buggy code, and note that it is also legal for a JVM to never ever produce one or more of these answers. That should really sail home the point of that evil coin analogy - you just can't write software that doesn't solve HB/HA first, because it's a random clusterbomb otherwise:</p>\n<ul>\n<li><code>0 0</code></li>\n<li><code>10 20</code></li>\n<li><code>10 0</code></li>\n<li><code>0 20</code></li>\n</ul>\n<p>Note in particular that last one. That sure <strong>seems</strong> impossible. thread1 always writes a before it writes b, and thread 2 reads b before a, so can it possibly be that b does read 20, but somehow a is still 0? <strong>And yet, that is legal</strong>, and the reason is that the JVM likes to run quickly, and some JVM implementations (most, actually), will run code in parallel. The JVM merely guarantees that you can't observe things running in parallel unless you use timing to do so (and makes no guarantees on timing at all). If you wouldn't be able to observe it, it will run things in parallel for speed reasons.</p>\n<p>Thus, the JVM is free to run a=10 and b=20 in parallel.</p>\n<p>So, how do you establish HB/HA? That's quite a complicated topic; it involves the primitives <code>synchronized</code> and <code>volatile</code>, or using Java API that is thread-related, such as <code>AtomicLong</code>, <code>ConcurrentHashMap</code>, <code>someThread.start()</code>, etcetera. The docs will say (and the reason they establish HB/HA is generally because their implementations use synchronized/volatile under the hood).</p>\n<p>You're doing none of that, thus, no HB/HA relationships, thus this code is plain broken and not in a way that a test can ever reliably catch.</p>\n<p>In practice, though, trying to hand-manage this stuff is hard and error prone. Obviously it is: Just about any error you do make is by definition untestable.</p>\n<p>Use types that are much better suited to it. Peruse the <code>java.util.concurrent</code> package. For example, if you want one thread to be adding books and another to be removing them, you may want to look at <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/BlockingQueue.html\" rel=\"nofollow noreferrer\">BlockingQueue</a>.</p>\n<p>Removing a 'random' book is rather complicated and doesn't seem pragmatically solvable unless you go with a lock-the-world model. That works too, you'd just have to festoon all interaction with <code>bookList</code> in a synchronized block. But that mostly defeats the point of threads, as only one thread would ever actually be running (the other is waiting to acquire the synchronized lock).</p>\n<p>The takeaway lessons are:</p>\n<ul>\n<li>It is rocket science.</li>\n<li>Tests won't catch errors.</li>\n<li>Read the JMM if you really really want to do this. Learn about the ways to establish HB/HA and apply them. This requires knowing what <code>synchronized</code> and <code>volatile</code> actually do and is non-trivial to learn. If you misunderstood a few things but you don't realize you did, it is quite likely you'll never know until later when your code seems to randomly fail sometimes. This is not something a first-year java newbie should be tackling.</li>\n<li>Any concurrent access (interleaving reads/writes from different threads) on the same field are going to not work the way you want them to unless you pay extremely careful attention and set up HB/HA to make it reliable.</li>\n<li>Try to avoid concurrent access to fields, it's not that hard to do so:</li>\n<li>Peruse the j.u.concurrent package and use something from there, or</li>\n<li>arrange for communications between threads using a mechanism that's good at it, such as databases (which have transactions), or message queues such as RabbitMQ.</li>\n</ul>\n","answer_id":67574197,"question_id":67573852},{"owner":{"profile_image":"https://www.gravatar.com/avatar/9df50c377989a0a4a425884ce6ade1e9?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6426024,"user_type":"registered","user_id":4981150,"link":"https://stackoverflow.com/users/4981150/pieter12345","reputation":1723,"display_name":"Pieter12345"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1621266722,"creation_date":1621266722,"body":"<p>The <code>synchronized</code> keyword synchronizes access per object. Since you've created two <code>Arc</code> instances, both instances can execute the method at the same time. There are multiple solutions possible to synchronize execution of the loop within the <code>run</code> methods of your <code>Arc</code> instances:</p>\n<ul>\n<li>Only use a single instance of <code>Arc</code>. This might or might not be possible given your application.</li>\n<li>Enqueue runnable tasks instead of using an async executor. This makes most sense if your tasks should run on another thread, but not async.</li>\n<li>Use a <code>synchronized (LOCK_OBJ) {...code...}</code> block within the <code>run</code> method that synchronizes on some lock object that will be the same for both instances of <code>Arc</code> (i.e. <code>private static final Object LOCK_OBJ = new Object();</code>)</li>\n</ul>\n<p>Which decision is best really depends on your application, but at least this gives you some reasonable options.</p>\n","answer_id":67573072,"question_id":67572673},{"owner":{"profile_image":"https://www.gravatar.com/avatar/5cfe5f7d64f44be04f147295f5c7b88e?s=256&d=identicon&r=PG","account_id":71739,"user_type":"registered","user_id":207421,"link":"https://stackoverflow.com/users/207421/user207421","reputation":307163,"display_name":"user207421","accept_rate":82},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1621222152,"creation_date":1477188701,"body":"<blockquote>\n<p>I'd like a server to reject a connections after the number of connected clients reach a maximum value.</p>\n</blockquote>\n<p>Close the server socket.</p>\n<blockquote>\n<p>However, even though the server do not accept the connection, the socket on client side is created. Methods <code>socket.isBound</code> and <code>isConnected</code> both return true value.</p>\n</blockquote>\n<p>Correct. That's because TCP maintains a 'backlog queue' of incoming connections which have been completed but not yet accepted by the server application.</p>\n<blockquote>\n<p>So back to the main question. Do you have any ideas how could I reject the client from connecting when the ServerSocket will not be able to .accept() additional connection?</p>\n</blockquote>\n<p>Close the server socket while the number of connections is at its maximum.</p>\n<p>However due to the backlog this technique can never be perfect. There is no perfect solution. You could have the server immediately close excess connections, but the excess clients won't detect that until they try to send something. If you need perfection you will probably have to introduce an application protocol whereby the server sends something like 'ACCEPTED' or 'REJECTED' accordingly.</p>\n","answer_id":40198869,"question_id":40197514,"last_edit_date":1621222152},{"owner":{"profile_image":"https://i.stack.imgur.com/W6OMC.png?s=256&g=1","account_id":1056871,"user_type":"registered","user_id":1059372,"link":"https://stackoverflow.com/users/1059372/eugene","reputation":117749,"display_name":"Eugene","accept_rate":97},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1621218404,"creation_date":1621218053,"body":"<p>The explanation is really easy. What is the <em>default</em> value of <code>result.r1</code>? What type is <code>r1</code>? It's an <code>int</code>, and a <em>default</em> value for a <code>int</code> is <code>zero</code>. So when this <code>if (ta != null)</code> does not happen, meaning <code>ta</code> is <code>null</code>, your code will do nothing. That &quot;nothing&quot; translates into leaving <code>r1</code> to its default value - that is (you already know by now) <code>zero</code>. So when <code>ta == null</code> (and implicitly <code>a == null</code>), you leave <code>r1</code> to be <code>0</code>, though you do not do that <em>explicitly</em>.</p>\n<p>The solution is trivial:</p>\n<pre><code>@Actor\npublic void reader(I_Result result) {\n    A ta = a;\n    if (ta != null) {\n        result.r1 = ta.f;\n    } else {\n        result.r1 = -1;\n    }\n}\n</code></pre>\n<p>and:</p>\n<pre><code>@JCStressTest\n@State\n@Outcome(id = &quot;42&quot;, expect = Expect.ACCEPTABLE, desc = &quot;42 is OK&quot;)\n@Outcome(id = &quot;-1&quot;, expect = Expect.ACCEPTABLE, desc = &quot;-1 is OK too&quot;)\n</code></pre>\n<p>And now your code will never show <code>0</code>, if you read <code>a</code> to be non-null, you will always read <code>a.f</code> to be <code>42</code>. As far as your understanding goes, yes, all threads will see <code>42</code> once they see a reference to an instance of <code>A</code> - that is a <code>JLS</code> guarantee.</p>\n","answer_id":67563277,"question_id":67553393,"last_edit_date":1621218404},{"owner":{"profile_image":"https://www.gravatar.com/avatar/0f09e5543b8dba2d17370c2dc705fafe?s=256&d=identicon&r=PG","account_id":21618314,"user_type":"unregistered","user_id":15943754,"link":"https://stackoverflow.com/users/15943754/microbeast","reputation":11,"display_name":"microBeast"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1621187690,"creation_date":1621187690,"body":"<p>Another answer already explained why you have problems with <code>0</code> and <code>static</code>.<br />\nBut even with these problems fixed it could be difficult to reproduce partial initialization.<br />\nSo I would recommend you to take a look at the JCStress source code: it contains samples, and one of them (<a href=\"https://github.com/openjdk/jcstress/blob/master/jcstress-samples/src/main/java/org/openjdk/jcstress/samples/JMMSample_06_Finals.java\" rel=\"nofollow noreferrer\">JMMSample_06_Finals</a>) already does what you want.</p>\n","answer_id":67559880,"question_id":67553393},{"owner":{"profile_image":"https://www.gravatar.com/avatar/a4ff8881b435a054cae1f86bfb003958?s=256&d=identicon&r=PG","account_id":21615575,"user_type":"unregistered","user_id":15941436,"link":"https://stackoverflow.com/users/15941436/user","reputation":11,"display_name":"user"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1621165434,"creation_date":1621165434,"body":"<blockquote>\n<p>Now why is it that I see the value 0 in my output ?</p>\n</blockquote>\n<p>These is the case when <code>a == null</code> (and therefore <code>result.r1</code> remains <code>0</code>) in your <code>reader()</code> method.</p>\n<blockquote>\n<p>when I declare the field a as static. I get only 42 as my output, and why is that?</p>\n</blockquote>\n<p>You annotated <code>FinalField</code> with <code>@State</code>, therefore JCStress creates a new instance of <code>FinalField</code> for every execution.<br />\nIf <code>a</code> is an instance field in <code>FinalField</code>, then it is <code>null</code> initially in every execution.<br />\nIf <code>a</code> is a static field in <code>FinalField</code>, then it is shared across all executions and is <code>null</code> only in the first execution.</p>\n","answer_id":67556264,"question_id":67553393},{"owner":{"profile_image":"https://i.stack.imgur.com/V5sYj.jpg?s=256&g=1","account_id":4192718,"user_type":"registered","user_id":3434956,"link":"https://stackoverflow.com/users/3434956/mohsen-nour","reputation":1097,"display_name":"mohsen.nour","accept_rate":95},"content_license":"CC BY-SA 4.0","score":5,"is_accepted":false,"last_activity_date":1620072810,"creation_date":1538895637,"body":"<p>There are 3 scenarios for using a <strong>class helper</strong> like SimpleDateFormat in multithread code, which best one is use <strong>ThreadLocal</strong></p>\n<p>Scenarios</p>\n<p><strong>1-</strong> Using like <strong>share object</strong> by the help of <strong>lock or synchronization</strong> mechanism which makes the app <strong>slow</strong></p>\n<p><strong>Thread pool Scenarios</strong></p>\n<p><strong>2-</strong> Using as a <strong>local  object</strong> inside a method</p>\n<p>In thread pool, in this scenario, if we have <strong>4 thread</strong> each one has <strong>1000 task</strong> time  then we have<br />\n<strong>4000</strong> SimpleDateFormat <strong>object created</strong> and waiting for GC to erase them</p>\n<p><strong>3-</strong> Using <em><strong>ThreadLocal</strong></em></p>\n<p>In thread pool, if we have 4 thread and  we gave to <strong>each thread one SimpleDateFormat instance</strong><br />\nso we have <strong>4 threads</strong>, <strong>4 objects</strong> of SimpleDateFormat.</p>\n<p>There is no need of lock mechanism and object creation and destruction.  (Good time complexity and space complexity)</p>\n<p><a href=\"https://www.youtube.com/watch?v=sjMe9aecW_A\" rel=\"nofollow noreferrer\">https://www.youtube.com/watch?v=sjMe9aecW_A</a></p>\n","answer_id":52686202,"question_id":817856,"last_edit_date":1620072810},{"owner":{"profile_image":"https://www.gravatar.com/avatar/657174380e4f1bcadfffa53971e1c2e0?s=256&d=identicon&r=PG","account_id":8900272,"user_type":"registered","user_id":6643940,"link":"https://stackoverflow.com/users/6643940/h-a-h","reputation":2515,"display_name":"H.A.H."},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1615818656,"creation_date":1615818656,"body":"<p>First I want to point out that other answers are true.\nHowever, using the parameter in the constructor may not be the best idea for all of you.</p>\n<p>In many scenarios you will want to use &quot;Anonymous Inner Class&quot;, and override the <code>run()</code> method, because defining specific class for every use is painful.\n(<code>new MyRunnable(){...}</code>)</p>\n<p>And at the time you create that Runnable, the parameter may not be available to you to pass it in the constructor. If for example, you pass this object to a method, that will perform some work in separate thread and then call your runnable, applying the result from that work to it.</p>\n<p>In that case, using a method like this one:\n<code>public MyRunnable withParameter(Object parameter)</code>, may turn out to be far more useful choice.</p>\n<p>I do not claim that this is the best solution to the problem, but it will get the job done.</p>\n","answer_id":66639916,"question_id":877096},{"owner":{"profile_image":"https://graph.facebook.com/1447473648792894/picture?type=large","account_id":20871327,"user_type":"registered","user_id":15331210,"link":"https://stackoverflow.com/users/15331210/jorge-kasagian","reputation":11,"display_name":"Jorge Kasagian"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1614898390,"creation_date":1614876402,"body":"<p>There is the solution... I create rows into an array... and I use the array in the threads, Tu debes evitar use create rows into a thread because this method is monitored by thread safe</p>\n<p>Sorry, I dont speak english... I am trying too hard.</p>\n<pre><code>static int count=0;\n\n  \n\n    \n    XSSFWorkbook workbook = new XSSFWorkbook();\n    XSSFSheet sheet = workbook.createSheet(&quot;Products&quot;);\n    sheet.createFreezePane(0, 1); // this will freeze first five rows\n    \n    int rowCount = 0;\n    \n    rowCount = getExcelTittle(sucsCompetencia,sucsProveedor, sucsPuntoVenta, sheet, rowCount);  \n\n\n    // trucazo para multithread\n    List&lt;Row&gt; r = new ArrayList&lt;Row&gt;();\n    //List&lt;Drawing&gt; h = new ArrayList&lt;Drawing&gt;();\n    \n    //cell creation\n    for ( int j = 0 ; j &lt; ps.size() + 500 ; j++) {\n        r.add(sheet.createRow(j));\n        //h.add(sheet.createDrawingPatriarch());\n\n    }\n    // cells creation .. its a good idea do it \n    Map&lt;String,Cell&gt; cellMap = new HashMap&lt;String,Cell&gt;();\n    for (int j = 0 ; j &lt; r.size() ; j++) {\n        for ( int  i = 0 ; i &lt; 9 + sucsCompetencia.size() + sucsProveedor.size() + sucsPuntoVenta.size() ; i++) {\n            cellMap.put( j + &quot;-&quot; + i, r.get(j).createCell(i));\n        }\n\n\n    }       \n    \n    Stream&lt;Producto&gt; arrStream = ps.parallelStream();\n    arrStream.forEach(p-&gt;\n                        {   \n                            count++;\n        int contadorPropio = count;\n        \n        if (contadorPropio % 1000 == 0)  log.info(&quot;* Procesando Generacion Excel &quot; + contadorPropio + &quot; de &quot; + ps.size());\n        \n       // if (rowCount == 1000 ) break;\n        \n\n        \n        int columnCount = 0;\n        \n        \n        {\n            //IMPORTANTEEEEEEEE\n            Cell cell = cellMap.get(contadorPropio + &quot;-&quot; + columnCount++); \n            cell.setCellValue(p.getIdProducto());\n        }     \n</code></pre>\n","answer_id":66479401,"question_id":28626848,"last_edit_date":1614898390},{"owner":{"profile_image":"https://i.stack.imgur.com/jTteZ.jpg?s=256&g=1","account_id":6197622,"user_type":"registered","user_id":4828463,"link":"https://stackoverflow.com/users/4828463/faraz","reputation":6095,"display_name":"Faraz","accept_rate":91},"content_license":"CC BY-SA 4.0","score":10,"is_accepted":false,"last_activity_date":1614874382,"creation_date":1483076850,"body":"<p>From <a href=\"http://www.wrox.com/WileyCDA/WroxTitle/Professional-Java-for-Web-Applications.productCd-1118656466.html\" rel=\"nofollow noreferrer\"><em>Professional Java for Web Applications</em> by <em>Nicholas S. Williams</em></a></p>\n<blockquote>\n<p><strong>Using Threads for Transactions and Entity Managers</strong></p>\n</blockquote>\n<blockquote>\n<p>The transaction scope is limited to the thread the transaction begins in. The transaction manager then links the transaction to managed resources used in the same thread during the life of the transaction. When using the <a href=\"https://en.wikipedia.org/wiki/Java_Persistence_API\" rel=\"nofollow noreferrer\">Java Persistence API</a>, the resource you work with is the <a href=\"https://docs.oracle.com/javaee/7/api/javax/persistence/EntityManagerFactory.html\" rel=\"nofollow noreferrer\"><code>EntityManager</code></a>. It is the functional equivalent of Hibernate ORM’s <a href=\"https://docs.jboss.org/hibernate/orm/current/javadocs/org/hibernate/Session.html\" rel=\"nofollow noreferrer\"><code>Session</code></a> and JDBC’s <a href=\"https://docs.oracle.com/javase/8/docs/api/java/sql/Connection.html\" rel=\"nofollow noreferrer\"><code>Connection</code></a>. Normally, you would obtain an <code>EntityManager</code> from the <a href=\"https://docs.oracle.com/javaee/7/api/javax/persistence/EntityManagerFactory.html\" rel=\"nofollow noreferrer\"><code>EntityManagerFactory</code></a> before beginning a transaction and performing JPA actions. However, this does not work with the Spring Framework model of managing transactions on your behalf.\nThe solution to this problem is the <a href=\"https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/orm/jpa/support/SharedEntityManagerBean.html\" rel=\"nofollow noreferrer\"><code>org.springframework.orm.jpa.support.SharedEntityManagerBean</code></a>. When you configure JPA in Spring Framework, it creates a <code>SharedEntityManagerBean</code> that proxies the <code>EntityManager</code> interface. This proxy is then injected into your JPA repositories. When an <code>EntityManager</code> method is invoked on this proxy instance, the following happens in the background:</p>\n</blockquote>\n<blockquote>\n<p>➤➤ If the current thread already has a real <code>EntityManager</code> with an active transaction, it delegates the call to the method on that <code>EntityManager</code>.</p>\n</blockquote>\n<blockquote>\n<p>➤➤ Otherwise, Spring Framework obtains a new <code>EntityManager</code> from the\n<code>EntityManagerFactory</code>, starts a transaction, and binds both to the current thread. It then delegates the call to the method on that <code>EntityManager</code>. When the transaction is either committed or rolled back, Spring unbinds the transaction and the <code>EntityManager</code> from the thread and then closes the <code>EntityManager</code>. Future <code>@Transactional</code> actions on the same thread (even within the same request) start the process over again, obtaining a new <code>EntityManager</code> from the factory and beginning a new transaction. This way, no two threads use an <code>EntityManager</code> at the same time, and a given thread has only one transaction and one <code>EntityManager</code> active at any given time.</p>\n</blockquote>\n<p>(I paraphrased it a little the above piece)</p>\n<p>I think its self explanatory and answers your question. But I would like to add that, if you were not to use <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html\" rel=\"nofollow noreferrer\">Spring MVC</a> then you would have gotten the session using <code>SessionFactory</code> in Hibernate. Hibernate <code>Session</code>s represent the life of a transaction from start to finish. Depending on how your application is architected, that might be less than a second or several minutes; and in a web application, it could be one of several transactions in a request, a transaction lasting an entire request, or a transaction spanning multiple requests. A <code>Session</code>, which is not thread-safe and must be used <strong>only in one thread</strong> at a time, is responsible for managing the state of entities.</p>\n","answer_id":41391268,"question_id":41391209,"last_edit_date":1614874382},{"owner":{"profile_image":"https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG","account_id":47283,"user_type":"registered","user_id":139985,"link":"https://stackoverflow.com/users/139985/stephen-c","reputation":703927,"display_name":"Stephen C","accept_rate":69},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1614853894,"creation_date":1614853474,"body":"<blockquote>\n<p>How do they work.</p>\n</blockquote>\n<p>It is complicated.  There are whole books on this.</p>\n<blockquote>\n<p>do they share the same call stack,</p>\n</blockquote>\n<p>No.  Each thread has its own call stack.</p>\n<blockquote>\n<p>Can somebody please explain in detail how they work under the hook, and what is this parrarelism in multithreading</p>\n</blockquote>\n<p>Seriously, if you don't (yet) understand what parallelism is, you are not (yet) equipped to understand how multithreading works <em>under the hood</em>.</p>\n<p>I suggest that you start by reading the <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/\" rel=\"nofollow noreferrer\">Oracle Java tutorial on concurrency</a>.  Then if you need to understand threads more deeply, buy and read <a href=\"https://rads.stackoverflow.com/amzn/click/com/0321349601\" rel=\"nofollow noreferrer\" rel=\"nofollow noreferrer\">&quot;Java: Concurrency in Practice&quot; by Brian Goetz et al.</a></p>\n<p>When you have read ... and understood ... those things, you should be equipped to learn how threads work under the hood.  But the ability to read C and C++ code would also help, since that's what the JVM is implemented in <em>under the hood</em>.</p>\n","answer_id":66473102,"question_id":66472876,"last_edit_date":1614853894},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c13d09d5694714d174f87e89c18f8694?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6875198,"user_type":"registered","user_id":5283869,"link":"https://stackoverflow.com/users/5283869/gnupinguin","reputation":81,"display_name":"gnupinguin"},"content_license":"CC BY-SA 4.0","score":4,"is_accepted":false,"last_activity_date":1614845933,"creation_date":1614845933,"body":"<p>The bug was fixed for the 11.0.10 Java version.</p>\n","answer_id":66471075,"question_id":54485755},{"owner":{"profile_image":"https://lh3.googleusercontent.com/-3AdCEYHSZg4/AAAAAAAAAAI/AAAAAAAAAGU/_il24uqnDnY/photo.jpg?sz=256","account_id":15883826,"user_type":"registered","user_id":11460835,"link":"https://stackoverflow.com/users/11460835/vaibhav-jain","reputation":1,"display_name":"vaibhav jain"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1614834094,"creation_date":1614834094,"body":"<pre><code>Try this solution.....\n\npublic class Print1To20Using2Thread {\n    public static void main(String[] args) {\n        PrintNumber pn = new PrintNumber(new Object());\n        Thread t1 = new Thread(pn, &quot;First&quot;);\n        Thread t2 = new Thread(pn, &quot;Second&quot;);\n\n        t1.start();\n        t2.start();\n    }\n}\n\nclass PrintNumber implements Runnable {\n\n    Object lock;\n    int i = 0;\n    public PrintNumber(Object lock) {\n        this.lock = lock;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lock) {\n            for (; i &lt;= 20; i++) {\n                if (i == 11) {\n                    try {\n                        lock.wait(1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                System.out.print(&quot; &quot;+Thread.currentThread().getName() + &quot; &quot; + i);\n                lock.notifyAll();\n            }\n            System.out.println();\n        }\n    }\n}\n</code></pre>\n","answer_id":66468855,"question_id":24720849},{"owner":{"profile_image":"https://i.stack.imgur.com/6qIEl.png?s=256&g=1","account_id":330005,"user_type":"registered","user_id":653856,"link":"https://stackoverflow.com/users/653856/raghunandan","reputation":132780,"display_name":"Raghunandan","accept_rate":100},"content_license":"CC BY-SA 4.0","score":4,"is_accepted":true,"last_activity_date":1614821754,"creation_date":1364282387,"body":"<p>AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. <strong>AsyncTasks should ideally be used for short operations (a few seconds at the most.)</strong> If you need to keep <strong>threads running for long periods of time</strong>, it is <strong>highly recommended</strong> you use the various APIs provided by the java.util.concurrent pacakge such as <strong>Executor, ThreadPoolExecutor and FutureTask</strong>. (Straight from the doc).</p>\n<p><a href=\"http://developer.android.com/reference/android/os/AsyncTask.html\" rel=\"nofollow noreferrer\">http://developer.android.com/reference/android/os/AsyncTask.html</a>.</p>\n<p>An alternative to asynctask for long running operations is robospice.</p>\n<p><a href=\"https://github.com/octo-online/robospice\" rel=\"nofollow noreferrer\">https://github.com/octo-online/robospice</a></p>\n<p>Update:</p>\n<p>Asynctask is deprecated using coroutines or any other threading mechanism. Consider suing work manager for defferable jobs.</p>\n","answer_id":15631479,"question_id":15631304,"last_edit_date":1614821754},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b3ec9d9128a25ba6eae8a1d42c2eb04a?s=256&d=identicon&r=PG","account_id":1449510,"user_type":"registered","user_id":1366871,"link":"https://stackoverflow.com/users/1366871/dreamcrash","reputation":48192,"display_name":"dreamcrash","accept_rate":100},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1614793690,"creation_date":1541089673,"body":"<p>What you can do is to intercept the task parameter of the submit and enhanced that task to print what you want:</p>\n<pre><code>Object around(Runnable task) : call(* ExecutorService+.submit(Runnable, ..)) &amp;&amp; args( task)\n{\n    final long parentID = Thread.currentThread().getId();\n    Runnable newTask =  () -&gt; {\n            System.out.println(&quot;Parent Thread Id: &quot;+ parentID);\n            System.out.println(&quot;Child Thread Id: &quot;+Thread.currentThread().getId()); //?? - how to capture child thread id?\n            task.run();\n    };\n    return proceed(newTask);\n}\n</code></pre>\n<p>As soon as the asynchronous task is executed the id of the thread executing it will be print.</p>\n<p>A Running example:</p>\n<p><strong>Main.java:</strong></p>\n<pre><code>public class Main {\n    public static void main(String[] args) {\n        new Test().testExecutorService();\n    }\n}\n</code></pre>\n<p><strong>Test.java:</strong></p>\n<pre><code>public class Test {\n    public void testExecutorService() {\n        ExecutorService service = Executors.newSingleThreadExecutor();\n        service.submit(() -&gt;  System.out.println(&quot;working on the task&quot;));\n        try {\n            service.awaitTermination(2, TimeUnit.SECONDS);\n            service.shutdown();\n        }catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n</code></pre>\n<p><strong>Example.aj</strong></p>\n<pre><code>public aspect Example {\n     \n     Object around(Runnable task) : call(public Future&lt;?&gt; java.util.concurrent.ExecutorService+.submit(Runnable)) \n                        &amp;&amp; args(task)\n     {\n         final long parentID = Thread.currentThread().getId();\n         Runnable newTask =  () -&gt; {\n                 System.out.println(&quot;Parent Thread Id: &quot;+ parentID);\n                 System.out.println(&quot;Child Thread Id: &quot;+Thread.currentThread().getId()); \n                 task.run();\n         };\n         return proceed(newTask);\n     }\n}\n</code></pre>\n","answer_id":53105412,"question_id":53029722,"last_edit_date":1614793690},{"owner":{"profile_image":"https://i.stack.imgur.com/t2hoD.jpg?s=256&g=1","account_id":3211603,"user_type":"registered","user_id":2711488,"link":"https://stackoverflow.com/users/2711488/holger","reputation":289317,"display_name":"Holger"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":true,"last_activity_date":1614778466,"creation_date":1614778466,"body":"<p>When you set the thread local variable to an instance of <code>Bar</code>, the value has an implicit reference to its defining class loader, which is also the defining class loader of <code>Foo</code> and hence, has an implicit reference to its <code>static</code> variable <code>tl</code> holding the <code>ThreadLocal</code>.</p>\n<p>In contrast, the <code>String</code> class is defined by the bootstrap loader and has no implicit reference to the the <code>Foo</code> class.</p>\n<p>Now, a reference cycle is not preventing garbage collection per se. If only one object holds a reference to a member of the cycle and that object becomes unreachable, the entire cycle would become unreachable. The problem here is that the object still referencing the cycle is the <code>Thread</code> that is still alive.</p>\n<p>The specific value is associated with the combination of a <code>ThreadLocal</code> instance and a <code>Thread</code> instance and we’d wish that if <em>either</em> of them becomes unreachable, it would stop referencing the value. Unfortunately, no such feature exists. We can only associate a value with the reachability of one object, like with the key of a <code>WeakHashMap</code>, but not of two.</p>\n<p>In the OpenJDK implementation, the <code>Thread</code> is the owner of this construct, which makes it immune against values back-referencing the <code>Thread</code>. E.g.</p>\n<pre class=\"lang-java prettyprint-override\"><code>ThreadLocal&lt;Thread&gt; local = new ThreadLocal&lt;&gt;();\n\nReferenceQueue&lt;Thread&gt; q = new ReferenceQueue&lt;&gt;();\n\nSet&lt;Reference&lt;?&gt;&gt; refs = ConcurrentHashMap.newKeySet();\n\nnew Thread(() -&gt; {\n    Thread t = Thread.currentThread();\n    local.set(t);\n    refs.add(new WeakReference&lt;&gt;(t, q));\n}).start();\n\nReference&lt;?&gt; r;\nwhile((r = q.remove(2000)) == null) {\n    System.gc();\n}\n\nif(refs.remove(r)) System.out.println(&quot;Collected&quot;);\nelse System.out.println(&quot;Something very suspicuous is going on&quot;);\n</code></pre>\n<p>This will print <code>Collected</code>, indicating that the reference from the value to the <code>Thread</code> did not prevent the removal, unlike <code>put(t, t)</code> on a <code>WeakHashMap</code>.</p>\n<p>The price is that this construct is not immune against backreferences to the <code>ThreadLocal</code> instance.</p>\n<pre class=\"lang-java prettyprint-override\"><code>ReferenceQueue&lt;Object&gt; q = new ReferenceQueue&lt;&gt;();\n\nSet&lt;Reference&lt;?&gt;&gt; refs = ConcurrentHashMap.newKeySet();\n\ncreateThreadLocal(refs, q);\n\nReference&lt;?&gt; r;\nwhile((r = q.remove(2000)) == null) {\n    System.gc();\n}\n\nif(refs.remove(r)) System.out.println(&quot;Collected&quot;);\nelse System.out.println(&quot;Something very suspicuous is going on&quot;);\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>static void createThreadLocal(Set&lt;Reference&lt;?&gt;&gt; refs, ReferenceQueue&lt;Object&gt; q) {\n    ThreadLocal&lt;ThreadLocal&lt;?&gt;&gt; local = new ThreadLocal&lt;&gt;();\n    local.set(local);\n    refs.add(new WeakReference&lt;&gt;(local, q));\n}\n</code></pre>\n<p>This will hang forever, as the backreference from the <code>ThreadLocal</code> to itself prevents its garbage collection, as long as the associated thread is still alive.</p>\n<p>Your case is just a special variant of it, as the backreference is through the <code>Bar</code> instance, its defining loader, to <code>Foo</code>’s <code>static</code> variable. But the principle is the same.</p>\n<p>You only need to change the line</p>\n<pre class=\"lang-java prettyprint-override\"><code>loadClass();\n</code></pre>\n<p>to</p>\n<pre class=\"lang-java prettyprint-override\"><code>new Thread(new FutureTask(() -&gt; { loadClass(); return null; })).start();\n</code></pre>\n<p>to stop the value from being associated with the main thread. Then, the class loader and all associated classes and instances get garbage collected.</p>\n","answer_id":66458166,"question_id":66452567},{"owner":{"profile_image":"https://i.stack.imgur.com/SsTc7.jpg?s=256&g=1","account_id":2305297,"user_type":"registered","user_id":2024692,"link":"https://stackoverflow.com/users/2024692/cromax","reputation":1882,"display_name":"Cromax","accept_rate":100},"content_license":"CC BY-SA 4.0","score":34,"is_accepted":false,"last_activity_date":1610752470,"creation_date":1472503229,"body":"<p>This answer comes very late, but maybe someone will find it useful. It is about how to pass a parameter(s) to a <code>Runnable</code> without even declaring named class (handy for inliners):</p>\n<pre class=\"lang-java prettyprint-override\"><code>    String someValue = &quot;Just a demo, really...&quot;;\n\n    new Thread(new Runnable() {\n        private String myParam;\n\n        public Runnable init(String myParam) {\n            this.myParam = myParam;\n            return this;\n        }\n\n        @Override\n        public void run() {\n            System.out.println(&quot;This is called from another thread.&quot;);\n            System.out.println(this.myParam);\n        }\n    }.init(someValue)).start();\n</code></pre>\n<p>Of course you can postpone execution of <code>start</code> to some more convenient or appropriate moment. And it is up to you what will be the signature of <code>init</code> method (so it may take more and/or different arguments) and of course even its name, but basically you get an idea.</p>\n<p>In fact there is also another way of passing a parameter to an anonymous class, with the use of the initializer blocks. Consider this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>    String someValue = &quot;Another demo, no serious thing...&quot;;\n    int anotherValue = 42;\n\n    new Thread(new Runnable() {\n        private String myParam;\n        private int myOtherParam;\n        // instance initializer\n        {\n            this.myParam = someValue;\n            this.myOtherParam = anotherValue;\n        }\n\n        @Override\n        public void run() {\n            System.out.println(&quot;This comes from another thread.&quot;);\n            System.out.println(this.myParam + &quot;, &quot; + this.myOtherParam);\n        }\n    }).start();\n</code></pre>\n<p>So all happens inside of the initializer block.</p>\n","answer_id":39214833,"question_id":877096,"last_edit_date":1610752470},{"owner":{"profile_image":"https://www.gravatar.com/avatar/224c1fc80ce88c3e0f59f420ce575043?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":5378847,"user_type":"registered","user_id":4284764,"link":"https://stackoverflow.com/users/4284764/gerard-martinelli","reputation":39,"display_name":"Gerard Martinelli"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1608715032,"creation_date":1608715032,"body":"<p>I think I have resolved my concern.  In the JDialog ContenPane, I have created a JButton  with an actionListener, then before leaving the run method, I issue a doClic().  This execute what I want (for example return to the caller).  It works perfectly.</p>\n","answer_id":65421769,"question_id":65407356},{"owner":{"profile_image":"https://www.gravatar.com/avatar/8cf8627c2f497949547cadc02c52b95f?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":4034876,"user_type":"registered","user_id":3319725,"link":"https://stackoverflow.com/users/3319725/anatolyg","reputation":1557,"display_name":"AnatolyG"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1608649600,"creation_date":1608647818,"body":"<p>An ad-hock implementation of such step-by-step scenario may be based on CountDownLatch primitive like following:</p>\n<pre><code>import java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\n\npublic class FooOrchestration {\n    public static class Foo {\n        public void first() { print(&quot;first&quot;); }\n        public void second() { print(&quot;second&quot;); }\n        public void third() { print(&quot;third&quot;); }\n    }\n\n    static void print(String text) {\n        System.out.println(text);\n    }\n\n    static class Step extends Thread {\n        private final CountDownLatch starter = new CountDownLatch(1);\n        private final List&lt;Step&gt; nextSteps = new ArrayList&lt;&gt;();\n        private final Runnable action;\n\n        Step(final Runnable action) {\n            this.action = action;\n        }\n\n        @Override\n        public void run() {\n            try {\n                starter.await(); // wait until someone kicks the starter with countDown()\n                action.run();\n                for (Step s : nextSteps) { // let's start the following steps\n                    s.starter.countDown();\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                for (Step s : nextSteps) { // let's propagate \n                    s.interrupt(); // the interruption\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws Throwable {\n        Foo foo = new Foo();\n\n        Step firstStep = new Step(() -&gt; foo.first());\n        Step secondStep = new Step(() -&gt; foo.second());\n        Step thirdStep = new Step(() -&gt; foo.third());\n\n        firstStep.nextSteps.add(secondStep); // set sequence\n        secondStep.nextSteps.add(thirdStep); // of execution\n\n        thirdStep.start(); // order of start\n        secondStep.start(); // doesn't\n        firstStep.start(); // matter\n\n        firstStep.starter.countDown(); // kick the starterof the first step\n    }\n}\n</code></pre>\n<p>Also, the standard package java.concurrent provides more generic and flexible barrier Phaser <a href=\"https://www.baeldung.com/java-phaser\" rel=\"nofollow noreferrer\">https://www.baeldung.com/java-phaser</a> which allows to build different and complex scenarios of multi-threading executions easily.</p>\n","answer_id":65410571,"question_id":65382129,"last_edit_date":1608649600},{"owner":{"profile_image":"https://www.gravatar.com/avatar/ec430cc01ef4cf4ae63ebbe9e8596f72?s=256&d=identicon&r=PG","account_id":1547313,"user_type":"registered","user_id":1440565,"link":"https://stackoverflow.com/users/1440565/code-apprentice","reputation":82164,"display_name":"Code-Apprentice","accept_rate":59},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1608573471,"creation_date":1608569661,"body":"<p>You are correct. If two threads lock the same object, then one of the threads will block, which doesn't help with performance. If on the other hand, the two threads can run completely independently of each other, then there is a huge performance gain.</p>\n","answer_id":65396827,"question_id":65396228,"last_edit_date":1608573471},{"owner":{"profile_image":"https://i.stack.imgur.com/2VjzX.jpg?s=256&g=1","account_id":6696437,"user_type":"registered","user_id":5164318,"link":"https://stackoverflow.com/users/5164318/emandt","reputation":2557,"display_name":"emandt"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1608566738,"creation_date":1608566738,"body":"<p>You need something similar to:</p>\n<pre><code>/** Class for Synchronize two Threads */\nprivate static class SyncObj&lt;T&gt; {\n    @Nullable\n    private T mValue = null;\n    public SyncObj(@Nullable final T initValue) { this.mValue = initValue; }\n    public void set(@Nullable final T value) { this.mValue = value; }\n    @Nullable\n    public T get() { return this.mValue; }\n}\n\n/** A Thread is used instead of {@link AsyncPost} */\nprivate class AsyncPost extends Thread {\n    private Handler mAsyncPostHandler;\n    private final Handler mMainThreadHandler;\n    private boolean mOnPreExecuted = false;\n    public AsyncPost() {\n        mMainThreadHandler = new Handler(Looper.getMainLooper()) {\n            @UiThread @MainThread\n            @Override\n            public void handleMessage(@NonNull final Message message) {\n                switch (message.what) {\n                    case 111: {\n                        @Nullable\n                        final String cRequestText = (String)message.obj;\n                        if (cRequestText == null) break;\n                        dialog.setMessage(cRequestText);\n                        break;\n                    }\n                    default: { }    //all Runnables sent to &quot;mMainThreadHandler&quot; are executed &quot;here&quot;\n                }\n            }\n        };\n    }\n    @WorkerThread\n    @Override\n    public void run() {\n        Looper.prepare();\n        mAsyncPostHandler = new Handler(Looper.myLooper()) {\n            @Override\n            public void handleMessage(@NonNull final Message message) {\n                switch (message.what) {\n                    case -1: {\n                        final Looper cMyLooper = Looper.myLooper();\n                        if (cMyLooper != null) cMyLooper.quit();\n                        break;\n                    }\n                    case 555: {\n                        if (!mOnPreExecuted) {\n                                //esecuted on Main/UIThread at first API Request...\n                            OnMainThreadRun(new Runnable() {    //SAME AS &quot;onPreExecute()&quot;\n                                @Override\n                                public void run() { dialog = ProgressDialog.show(Sync_Bulk.this, &quot;&quot;, &quot;&quot;); }\n                            });\n                            mOnPreExecuted = true;\n                        }\n                        final List&lt;?&gt; cList = (List&lt;?&gt;)message.obj;\n                        if (cList == null) break;\n                        final SyncObj&lt;String&gt; cSyncObj = new SyncObj&lt;&gt;(null);\n                            //loop through the List\n                        @Nullable\n                        String cRequesteResult;\n                        for (final Object cItem : cList) {\n                                //call API Request for each item in the List...\n                            postRequest(cSyncObj, cItem);\n                            try {\n                                    //...wait until &quot;notify()&quot; is called\n                                synchronized (cSyncObj) {\n                                        //loop until &quot;SyncObj.set()&quot; was called with a valid Value\n                                    while ((cRequesteResult = cSyncObj.get()) == null) cSyncObj.wait();\n                                        //check SyncObj result\n                                    if (cRequesteResult.equals(&quot;OK&quot;)) {\n                                        Log.i(&quot;MainActivity&quot;, &quot;Request successfully&quot;);\n                                    } else {\n                                        Log.w(&quot;MainActivity&quot;, &quot;Request failed: &quot; + cRequesteResult);\n                                    }\n                                        //update the Dialog on Main/UIThread\n                                    OnProgressUpdate(cRequesteResult);\n                                }\n                            } catch (Exception e) {\n                                Log.e(&quot;MainActivity&quot;, &quot;Stopping all Request due to Exception: &quot; + e.getMessage());\n                            }\n                        }\n                            //terminate this Thread\n                        postToAsyncThread_Quit();\n                        break;\n                    }\n                }\n            }\n        };\n        Looper.loop();\n        this.OnMainThreadRun(new Runnable() {   //SAME AS &quot;OnPostExecute()&quot;\n            @Override\n            public void run() {\n                ..executed on Main/UIThread at the end of all..\n            }\n        });\n    }\n    /** Execute a {@link Runnable} on MainThread/UiThread */\n    @WorkerThread\n    private void OnMainThreadRun(@Nullable final Runnable runnable) {\n        if (runnable == null) return;\n        mMainThreadHandler.post(runnable);\n    }\n    @AnyThread\n    private void OnProgressUpdate(@Nullable final String text) { mMainThreadHandler.sendMessage(Message.obtain(mMainThreadHandler, 111, text)); }\n    /** Execute a {@link Runnable} on {@link AsyncPost} Thread */\n    @AnyThread\n    private void postToAsyncThread_DoRequests(@Nullable final List&lt;?&gt; list) { mAsyncPostHandler.sendMessage(Message.obtain(mAsyncPostHandler, 555, list)); }\n    /** Terminate {@link AsyncPost} Thread */\n    @AnyThread\n    private void postToAsyncThread_Quit() { mAsyncPostHandler.sendEmptyMessage(-1); }\n}\n\nprivate void postRequest(final SyncObj&lt;String&gt; syncObj, @NonNull final Object listItem) {\n        //execute API Request which will trigger one of Listener methods\n    doAsyncRequest(listItem, new ResponseListener() {\n        @Override\n        void onSuccess() {\n            synchronized (syncObj) {\n                syncObj.set(&quot;OK&quot;);\n                syncObj.notify();\n            }\n        }\n        @Override\n        void onFailed() {\n            synchronized (syncObj) {\n                syncObj.set(&quot;ERROR&quot;);\n                syncObj.notify();\n            }\n        }\n    });\n}\n\nprivate void doAllRequests(@Nullable final List&lt;?&gt; list) {\n    final AsyncPost cAsyncPost = new AsyncPost();\n    cAsyncPost.start();\n    cAsyncPost.postToAsyncThread_DoRequests(list);\n}\n</code></pre>\n<p>Just call &quot;doAllRequests(...)&quot; providing the appropriate List.\nA single &quot;OnPreExecute()&quot;-like will be executed at first API call and a single &quot;OnPostExecute()&quot;-like will be executed at the end of last APi call.\nAt each API Call (success or fail) &quot;case 111:&quot; will be called from the Main/UIThread.</p>\n","answer_id":65396071,"question_id":65393915},{"owner":{"profile_image":"https://i.stack.imgur.com/bh9Vd.png?s=256&g=1","account_id":16559,"user_type":"registered","user_id":36223,"link":"https://stackoverflow.com/users/36223/daveb","reputation":1856,"display_name":"DaveB"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1608564725,"creation_date":1608564725,"body":"<p>Using Platform.runLater() in a background thread is kind of a messy kludge that should probably be avoided.  JavaFX has mechanisms to handle this kind of thing which you should use.  Specifically, Task&lt;&gt; is designed to allow background threads to update data which is connected to JavaFX screen elements which need to be updated on the FXAT.</p>\n<p>You CAN do what you're trying to do with a JavaFX Task, but using  the Java Timer inside of it seems impossible, since there doesn't seem to be any way for a Java thread to wait on a Timer to complete.  So, instead I've used a &quot;for&quot; loop with a sleep to do the same thing.  It's clumsy, but it does demonstrate how to connect partial results from a Task to screen display:</p>\n<pre><code>public class Sample1 extends Application {\n\n    public static void main(String[] args) {\n        launch(args);\n    }\n\n    @Override\n    public void start(Stage primaryStage) {\n        Scene scene = new Scene(new Timer1(), 300, 200);\n        primaryStage.setScene(scene);\n        primaryStage.show();\n    }\n}\n\npublic class Timer1 extends VBox {\n\n    public Timer1() {\n        Text time = new Text();\n        Button startButton = new Button(&quot;Start&quot;);\n        Button stopButton = new Button(&quot;Stop&quot;);\n        getChildren().addAll(time, startButton, stopButton);\n        startButton.setOnAction(startEvt -&gt; {\n            Task&lt;Integer&gt; timerFxTask = new Task&lt;&gt;() {\n\n                {\n                    updateValue(0);\n                }\n\n                @Override\n                protected Integer call() throws Exception {\n                    for (int counter = 0; counter &lt;= 1000; counter++) {\n                        sleep(1000);\n                        updateValue(counter);\n                    }\n                    return 1000;\n                }\n            };\n            stopButton.setOnAction(stopEvt -&gt; timerFxTask.cancel());\n            time.textProperty().bind(Bindings.createStringBinding(() -&gt; timerFxTask.getValue().toString(),\n                    timerFxTask.valueProperty()));\n            Thread timerThread = new Thread(timerFxTask);\n            timerThread.start();\n        });\n    }\n}\n</code></pre>\n<p>But there is a better way to do what you're trying to do, which is essentially an animation - and JavaFX has a facility to do exactly this.  Usually, people use animations to morph the appearance of JavaFX screen elements, but you can also use it to animate the contents of a Text over time as well.  What I've done here is create an IntegerProperty which can be transitioned from a start value to an end value interpolated linearly over time and then bound that value to the TextProperty of a Text on the screen.  So you see it update once per second.</p>\n<pre><code>public class Sample1 extends Application {\n\n    public static void main(String[] args) {\n        launch(args);\n    }\n\n    @Override\n    public void start(Stage primaryStage) {\n        Scene scene = new Scene(new Timer2(), 300, 200);\n        primaryStage.setScene(scene);\n        primaryStage.show();\n    }\n}\n\npublic class Timer2 extends VBox {\n\n    public Timer2() {\n        Text time = new Text();\n        Button startButton = new Button(&quot;Start&quot;);\n        Button stopButton = new Button(&quot;Stop&quot;);\n        getChildren().addAll(time, startButton, stopButton);\n        startButton.setOnAction(startEvt -&gt; {\n            IntegerProperty counter = new SimpleIntegerProperty(0);\n            Timeline timeline = new Timeline(new KeyFrame(Duration.seconds(1000), new KeyValue(counter, 1000)));\n            stopButton.setOnAction(stopEvt -&gt; timeline.stop());\n            time.textProperty().bind(Bindings.createStringBinding(() -&gt; Integer.toString(counter.get()), counter));\n            timeline.play();\n        });\n    }\n}\n</code></pre>\n","answer_id":65395539,"question_id":65391501},{"owner":{"profile_image":"https://www.gravatar.com/avatar/6b2c535fac79e482b71f15de561f55ca?s=256&d=identicon&r=PG","account_id":60171,"user_type":"registered","user_id":179850,"link":"https://stackoverflow.com/users/179850/gray","reputation":115485,"display_name":"Gray","accept_rate":100},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1608555694,"creation_date":1608396600,"body":"<blockquote>\n<p>Does the value of AtomicReference will be set lazily if we assign a function to it which returns some array?</p>\n</blockquote>\n<p>First off, <code>AtomicReference.set()</code> is immediate and in no ways lazy.  If we look at your code, we see that <code>someFunc()</code> returns an <code>ArrayList</code> so this will be set immediately into <code>atomicStrings</code>.  Unfortunately, the strings are added to the list by another thread and there is no synchronization between the main thread, that is running <code>someFunc()</code> and creating the list, and the thread that is adding the strings to the list.  Anytime two different threads are accessing the same object, and especially mutating that object, you need to worry about mutex (race conditions) and memory synchronization.</p>\n<p>One thing you could use to fix your specific issue is to use a <code>BlockingQueue</code> which is a synchronized class instead of an <code>ArrayList</code>.  <code>BlockingQueue</code> take care of all of the memory synchronization and mutex locking to ensure that accesses from multiple threads are done appropriately.</p>\n<pre><code>BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;();\n</code></pre>\n<p>Then, when the inner thread calls <code>queue.add(&quot;a&quot;);</code> and then after the 10 seconds expire the main thread calls <code>queue.iterator()</code>, they will see the same collection of strings.  There is no need for the <code>AtomicReference</code> because the atomic class the main and the inner threads will be sharing is the <code>ArrayBlockingQueue </code>.</p>\n","answer_id":65372167,"question_id":65363568,"last_edit_date":1608555694},{"owner":{"profile_image":"https://www.gravatar.com/avatar/166994c436c6a1d69ee7af86f727d57f?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":14704600,"user_type":"registered","user_id":10619713,"link":"https://stackoverflow.com/users/10619713/jakob-tinhofer","reputation":345,"display_name":"Jakob Tinhofer"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1608551014,"creation_date":1608549117,"body":"<p>Ok, my comments are too long. This is how I would try to do it.</p>\n<ol>\n<li>Start the stopwatch on the application being loaded</li>\n<li>Create a new thread that launches itself every so often.</li>\n<li>Inside there, get the time from the Stopwatch in seconds (<code>sw.getTime(TimeUntis.seconds)</code>). Convert that to hours and minutes if you want <a href=\"https://stackoverflow.com/questions/6118922/convert-seconds-value-to-hours-minutes-seconds#:%7E:text=hours%20%3D%20totalSecs%20%2F%203600%3B%20minutes,%2C%20hours%2C%20minutes%2C%20seconds\">like shown in this SO post</a></li>\n<li>Then, write the time to the UI using <code>Platform.runLater(new Runnable(){ /* access ui element and write time here */ });</code></li>\n</ol>\n","answer_id":65391726,"question_id":65391501,"last_edit_date":1608551014},{"owner":{"profile_image":"https://www.gravatar.com/avatar/dd818daa34685a9be777abbadd91e4a1?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8666186,"user_type":"registered","user_id":6486622,"link":"https://stackoverflow.com/users/6486622/denis-zavedeev","reputation":7757,"display_name":"Denis Zavedeev"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1608485238,"creation_date":1608484458,"body":"<p>I guess, it is a problem from <a href=\"https://leetcode.com/problems/print-in-order/\" rel=\"nofollow noreferrer\">leetcode</a>.</p>\n<blockquote>\n<p>Currently I don't understand how to pass <code>Runnable</code> object to the synchronized methods (it's one the task conditions):</p>\n</blockquote>\n<p>The <code>runnable</code> could look like:</p>\n<pre><code>private static class PrintingRunnable implements Runnable {\n\n    private final String string;\n\n    public PrintingRunnable(String string) {\n        this.string = string;\n    }\n\n    @Override\n    public void run() {\n        System.out.print(string);\n    }\n}\n</code></pre>\n<p>and passed as:</p>\n<pre><code>foo.first(new PrintingRunnable(&quot;first&quot;));\nfoo.second(new PrintingRunnable(&quot;second&quot;));\nfoo.third(new PrintingRunnable(&quot;third&quot;));\n</code></pre>\n<hr />\n<p>Please note, that you are <strong>not required</strong> to supply your own <code>Runnable</code>s, or create <code>Thread</code>s to solve the problem, just implement the <code>first</code>, <code>second</code>, and <code>third</code> methods.</p>\n<hr />\n<p>In Java, <code>Runnable</code> is <em>nothing more</em> than some action that could be <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runnable.html#run()\" rel=\"nofollow noreferrer\"><code>run</code></a>. It may print something, or do anything else.</p>\n<p>It is possible that leetcode <strong>does not really print anything</strong>, but uses <em>something different to test submissions</em>. (And it does not matter for someone, who tries to solve the problem)</p>\n<p>But if you want to do it locally you can use the <code>PrintingRunnable</code> above:</p>\n<pre><code>public static void main(String[] args) throws InterruptedException {\n    Foo foo = new Foo();\n\n\n    new Thread(() -&gt; {\n        try {\n            foo.third(new PrintingRunnable(&quot;third&quot;));\n        } catch (InterruptedException exception) {\n            exception.printStackTrace();\n        }\n    }).start();\n    new Thread(() -&gt; {\n        try {\n            foo.first(new PrintingRunnable(&quot;first&quot;));\n        } catch (InterruptedException exception) {\n            exception.printStackTrace();\n        }\n    }).start();\n    new Thread(() -&gt; {\n        try {\n            foo.second(new PrintingRunnable(&quot;second&quot;));\n        } catch (InterruptedException exception) {\n            exception.printStackTrace();\n        }\n    }).start();\n}\n</code></pre>\n","answer_id":65382608,"question_id":65382129,"last_edit_date":1608485238},{"owner":{"profile_image":"https://i.stack.imgur.com/DLHqU.png?s=256&g=1","account_id":1223835,"user_type":"registered","user_id":1189885,"link":"https://stackoverflow.com/users/1189885/chrylis-cautiouslyoptimistic","reputation":75888,"display_name":"chrylis -cautiouslyoptimistic-","accept_rate":43},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":true,"last_activity_date":1608323859,"creation_date":1608323859,"body":"<p>You aren't &quot;assigning a function&quot; to it, you're <em>immediately evaluating</em> <code>someFunc</code> and placing the value (a reference to the list) in the <code>AtomicReference</code>.</p>\n<p>The atomic classes have special <em>happens-before</em> constraints, so anything that happens to the list in <code>someFunc</code> is guaranteed to be visible to anyone who retrieves the list from the reference, but your modifications to the list in your spawned thread have no <em>happens-before</em> relationship to the rest of your program. The behavior is undefined, up to and including <code>ConcurrentModificationException</code>.</p>\n","answer_id":65363616,"question_id":65363568},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG","account_id":2518243,"user_type":"registered","user_id":2189127,"link":"https://stackoverflow.com/users/2189127/james-d","reputation":203472,"display_name":"James_D"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1608232320,"creation_date":1608232320,"body":"<p>You can use a <a href=\"https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/CompletableFuture.html\" rel=\"nofollow noreferrer\"><code>CompletableFuture</code></a>:</p>\n<pre><code>public class USBDevice {\n    public Task&lt;Void&gt; readData() {\n        return new Task&lt;Void&gt;() {\n            @Override\n            protected Void call() throws Exception {\n\n                CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; {\n                    //read data through usb device and add it into array;\n                });\n                try {\n                    future.get(10, TimeUnit.SECONDS);\n                    // get here if read was successful\n                } catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                } catch (ExecutionException ee) {\n                    // exception was thrown by code reading usb device\n                } catch (TimeoutException te) {\n                    // timeout occurred\n                }\n                return null;\n            }\n        };\n    }\n}\n</code></pre>\n","answer_id":65346950,"question_id":65344341},{"owner":{"profile_image":"https://www.gravatar.com/avatar/2fe75f2132e516dbf8ee6de0097d765e?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":9374511,"user_type":"registered","user_id":8471807,"link":"https://stackoverflow.com/users/8471807/sachin-pete","reputation":21,"display_name":"Sachin Pete"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1603023508,"creation_date":1602962164,"body":"<pre><code>public class Print1To20 {\n\n    int couter=0;\n    static int N;\n\n    public void preven(){\n        synchronized (this) {\n            while(couter&lt;N) {\n                while(couter%2==0) {\n                    try {\n                        wait();\n                    } catch(Exception e) {\n                    }\n                    System.out.println(Thread.currentThread().getName()+&quot;:&quot;+couter);\n                }\n                couter++;\n                notify();\n            }\n        }\n    }\n    public void prodd(){\n        synchronized (this) {\n            while(couter&lt;N) {\n                while(couter%2==1) {\n                    try {\n                        wait();\n                    } catch(Exception e) {\n                    }\n                    System.out.println(Thread.currentThread().getName()+&quot;:&quot;+couter);\n                }\n                couter++;\n                notify();\n            }\n        }\n    }\n    \n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n\n        //  Thread t1= new Th;\n\n        //Thread t2= new Thread(new PrintOdd());\n\n        N=20;\n        Print1To20 pt= new Print1To20();\n        Thread t1= new Thread(new Runnable() {\n            @Override\n            public void run() {\n                // TODO Auto-generated method stub\n                pt.preven();\n            }\n        });\n\n        Thread t2= new Thread(new Runnable() {\n            @Override\n            public void run() {\n                // TODO Auto-generated method stub\n                pt.prodd();\n            }\n        });\n        t1.start();\n        t2.start();\n    }\n}\n</code></pre>\n<p>Ref: Reference taken from GeekforGeeks</p>\n","answer_id":64406380,"question_id":24720849,"last_edit_date":1603023508},{"owner":{"profile_image":"https://i.stack.imgur.com/o4wOg.jpg?s=256&g=1","account_id":3294086,"user_type":"registered","user_id":2771717,"link":"https://stackoverflow.com/users/2771717/autocrab","reputation":3607,"display_name":"Autocrab"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1602654131,"creation_date":1602654131,"body":"<p>It appears that your <code>runOnUiThread</code> code invokes after activity gets destroyed.</p>\n<p>You should check if activity is destroyed:</p>\n<pre><code>        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                final String folderSize = calculateFolderSize(); // my work\n                runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        if (!isDestroyed())\n                            textView.setText(folderSize + &quot; GB&quot;);\n                    }\n                });\n            }\n        });\n        thread.start();\n</code></pre>\n","answer_id":64347286,"question_id":64346783},{"owner":{"profile_image":"https://www.gravatar.com/avatar/54af3ad01b032767b05a7e98fede6d6e?s=256&d=identicon&r=PG","account_id":2360785,"user_type":"registered","user_id":2067492,"link":"https://stackoverflow.com/users/2067492/matt","reputation":11123,"display_name":"matt"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1601634137,"creation_date":1601630447,"body":"<p>Can we think of the arrow as a resource?</p>\n<pre><code>import java.util.concurrent.*;\n\n\npublic class Bowmen implements Runnable{\n    String name;\n    Bowmen target;\n    SynchronousQueue&lt;Object&gt; queue = new SynchronousQueue&lt;&gt;();\n    public Bowmen(String name){\n        this.name = name;\n    }\n    \n    public void shoot(String name, Object o) throws InterruptedException{\n        System.out.println(this.name + &quot; : &quot; + name + &quot; shot me.&quot;);\n        queue.put(o);\n    }\n    \n    public void run(){\n        try{\n            Object o = queue.take();\n            System.out.println(this.name + &quot; : I will shoot &quot; + target.name);\n            target.shoot(name, o);\n        } catch(InterruptedException e){\n            //just finish.\n        }\n    }\n    public void setTarget(Bowmen t){\n        target = t;\n    }\n    \n    public static void main(String[] args) throws Exception{\n        \n        Bowmen a = new Bowmen(&quot;a&quot;);\n        Bowmen b = new Bowmen(&quot;b&quot;);\n        \n        a.setTarget(b);\n        b.setTarget(a);\n        \n        for(int i = 0; i&lt;5; i++){\n            new Thread(a).start();\n            new Thread(b).start();\n        }\n        //all the threads are waiting because there is no resource to share yet.\n        a.shoot( null, new Object() );\n    }\n\n}\n</code></pre>\n<p>This will produce output</p>\n<blockquote>\n<p>a : null shot me.<br />\na : I will shoot b<br />\nb : a shot me.<br />\nb : I will shoot a<br />\n...</p>\n</blockquote>\n<p>It will end with &quot;a : b shot me.&quot; but the program will not finish because there isn't a thread taking from the queue to let the last call to shoot finish.</p>\n","answer_id":64169128,"question_id":64163535,"last_edit_date":1601634137},{"owner":{"profile_image":"https://www.gravatar.com/avatar/8a60e0393575feef649748f8f2e95c62?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6925906,"user_type":"registered","user_id":5317000,"link":"https://stackoverflow.com/users/5317000/suresh-mahalingam","reputation":95,"display_name":"Suresh Mahalingam"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1601563360,"creation_date":1600067590,"body":"<p>A round robin among N producers can be achieved using a PriorityBlockingQueue as follows.</p>\n<p>Maintain N AtomicInteger counters for each of the producers and a global counter as a tie breaker in case the producer counters are equal.</p>\n<p>When adding to the Q incement counter for the producer and also global counter and store into Q object. The comparator for Q will order based on Producer counter 1st and then the global counter value stored in the Q object.</p>\n<p>However when objects of one producer is empty for sometime in the Q the corresponding counter falls behind and it will start hogging the Q when objects start coming in.</p>\n<p>To avoid this maintain a volatile variable which is updated with the producer counter of the object when de-queued. After incrementing the producer counter during en-queue if the value is less than the last de-queued counter in volatile variable reset the counter to that value + 1.</p>\n","answer_id":63879647,"question_id":27737781,"last_edit_date":1601563360},{"owner":{"profile_image":"https://www.gravatar.com/avatar/16b7172bb346958c1b69e0229ba1ac4f?s=256&d=identicon&r=PG","account_id":1723085,"user_type":"registered","user_id":1578356,"link":"https://stackoverflow.com/users/1578356/newday","reputation":3842,"display_name":"newday","accept_rate":63},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1601527340,"creation_date":1601527340,"body":"<p>after using the get(1, TimeUnit.SECONDS); I started to see improvement on the server side as well (Reaching the threads less than 1 second) since we are not waiting more than 1 second on the client side.</p>\n<pre><code>while (true) {\n    clientMonitorServicesMap.forEach((k, v) -&gt; {\n      Future&lt;Boolean&gt; val = scheduledExecutorService.submit(new PollService(k));\n      try {\n        boolean result = val.get(1, TimeUnit.SECONDS);\n        System.out.println(&quot;service &quot; + k.getHost() + &quot;:&quot; + k.getPort() + &quot;status is &quot; + result);\n        if (result) {\n          List&lt;ClientMonitorService&gt; list = v.stream()\n                  //.filter(a -&gt; LocalDateTime.now().getSecond() % a.getServiceToMonitor().getFreqSec() == 0)\n                  .collect(Collectors.toList());\n          list.stream().forEach(a -&gt; System.out.println(a.getClientId()));\n        }\n\n      } catch (InterruptedException e) {\n       logger.log(Level.WARNING,&quot;Interrupted -&gt; &quot; + k.getHost()+&quot;:&quot;+k.getPort());\n      } catch (ExecutionException e) {\n        logger.log(Level.INFO,&quot;ExecutionException exception -&gt; &quot;+ k.getHost()+&quot;:&quot;+k.getPort());\n      } catch (TimeoutException e) {\n        logger.log(Level.INFO,&quot;TimeoutException exception -&gt; &quot;+ k.getHost()+&quot;:&quot;+k.getPort());\n      }\n\n    });\n  }\n</code></pre>\n","answer_id":64149186,"question_id":64112611},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG","account_id":401843,"user_type":"registered","user_id":768644,"link":"https://stackoverflow.com/users/768644/rzwitserloot","reputation":89863,"display_name":"rzwitserloot"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1601482101,"creation_date":1601482101,"body":"<p>The answer is non-trivial; the fact that there is a parent/child relationship between the threads is itself misleading. Threads don't as a rule care or get any special relationship with the thread that spawned it at all.</p>\n<p>Thus, the answer is a mix of: &quot;Parent/Child? I'm not sure those are appropriate terms to apply to the concept of 'a thread that is going to spawn another thread' and 'the thread that it spawned'&quot;, and &quot;the same way any two threads communicate with each other: Carefully, probably via things in the <code>java.util.concurrent</code> package, and really optimally threads should never communicate except through communication channels with built in transactional support, such as a database, or message queue libraries like rabbitMQ.</p>\n","answer_id":64141533,"question_id":64141492},{"owner":{"profile_image":"https://www.gravatar.com/avatar/8bea1f01a8f41b0714de4eddc3c93ce8?s=256&d=identicon&r=PG","account_id":11180480,"user_type":"registered","user_id":8207228,"link":"https://stackoverflow.com/users/8207228/ralf-kleberhoff","reputation":7021,"display_name":"Ralf Kleberhoff"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1601481197,"creation_date":1601481197,"body":"<p>From the code you posted, I see two places where you seem to get stuck:</p>\n<ul>\n<li>Filling out the <code>run()</code> method in the <code>ColumnCalculator</code>.</li>\n<li>Using threads with the <code>ColumnCalculator</code> to get the multiplication result.</li>\n</ul>\n<p>From the comment inside <code>ColumnCalculator</code> I deduce that its duty is to compute one specific column of the result matrix. So, for e.g. a 5-columns matrix, you need five <code>ColumnCalculator</code> instances to get the complete result.</p>\n<h2>ColumnCalculator.run()</h2>\n<p>Put in code that does the matrix multiplication, not for all columns, but only for the column <code>col_idx</code>. That means: copy the code from multiplyBy() and strip it down so that it doesn't loop over all result columns.</p>\n<h2>Matrix.multiplyByThreads()</h2>\n<p>Instead of using a fixed number of threads, I'd start with a simpler approach:</p>\n<p>For each column in the result, create one ColumnCalculator and one thread, and have that thread run that calculator.</p>\n<p>And then wait for all of them to finish.</p>\n<p>When you've mastered that approach and like to continue, then an optimization might be to limit the number of threads to e.g. 10 and have them compute result columns until they're all done, but I recommend to start with the simpler approach.</p>\n","answer_id":64141295,"question_id":64140757},{"owner":{"profile_image":"https://www.gravatar.com/avatar/cbf3044a40d8139345d51081d5fc4517?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6838496,"user_type":"registered","user_id":5259625,"link":"https://stackoverflow.com/users/5259625/gen","reputation":2450,"display_name":"Gen","accept_rate":56},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1601465970,"creation_date":1601465970,"body":"<p>if you need simultaneous execution and each time new thread you can find the solution here</p>\n<pre><code>public class SleepClass {\n    public static void main(String[] args) {\n        SleepClass s= new SleepClass();\n        s.m2(500);\n        s.m2(1000);\n    }\n    \n    public void m2(int time) {\n        SleepClass s= new SleepClass();\n        new Thread(() -&gt; {\n            s.m1(time);\n        }).start();\n    }\n    \n    public void m1(int time) {\n        \n        for(int i = 0; i&lt;= 10; i++) {\n            System.out.println(i);\n            try {\n                Thread.sleep(time);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        \n    }\n\n}\n</code></pre>\n","answer_id":64136807,"question_id":64134839},{"owner":{"profile_image":"https://www.gravatar.com/avatar/964b3f08a9f4f4b76d14b5eb33190038?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":4501201,"user_type":"registered","user_id":3659670,"link":"https://stackoverflow.com/users/3659670/conffusion","reputation":4375,"display_name":"Conffusion"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1601461731,"creation_date":1601461731,"body":"<p>You have to put your logic in a Runnable and launch it using new <code>Thread(runnable).start()</code>.\nTo pass parameters to each runnable define them as class variables so you can pass them via the constructor and use them in the <code>run</code> method:</p>\n<pre><code>public class SleepClass {\n\n    public static void main(String[] args) {\n        SleepClass s= new SleepClass();\n        s.m1(10000);\n        s.m1(20000);\n    }\n    \n    public void m1(int time) {\n        for(int i = 0; i&lt; 3; i++) {\n            new Thread(new Launcher(i,time)).start();\n        }\n    }\n\n    public class Launcher implements Runnable {\n        int i;\n        int time;\n        public Launcher(int i, int time) {\n            this.i=i;\n            this.time=time;\n        }\n        @Override\n        public void run() {\n            System.out.println(i);\n            try {\n                Thread.sleep(time);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }                   \n        }\n        \n    }\n}\n</code></pre>\n","answer_id":64135639,"question_id":64134839},{"owner":{"profile_image":"https://i.stack.imgur.com/HbwqU.jpg?s=256&g=1","account_id":4264857,"user_type":"registered","user_id":3488208,"link":"https://stackoverflow.com/users/3488208/surendar-d","reputation":5594,"display_name":"Surendar D","accept_rate":20},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1599478405,"creation_date":1563439626,"body":"<p>Please try this once.</p>\n<ol>\n<li>Create a drawable file splash_background.xml</li>\n</ol>\n\n<pre><code>&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;\n\n    &lt;item android:drawable=&quot;@color/{your color}&quot; /&gt;\n\n    &lt;item&gt;\n        &lt;bitmap\n            android:layout_width=&quot;@dimen/size_250&quot;\n            android:layout_height=&quot;@dimen/size_100&quot;\n            android:gravity=&quot;center&quot;\n            android:scaleType=&quot;fitXY&quot;\n            android:src=&quot;{your image}&quot;\n            android:tint=&quot;@color/colorPrimary&quot; /&gt;\n    &lt;/item&gt;\n\n&lt;/layer-list&gt;\n</code></pre>\n<ol start=\"2\">\n<li><p>Put this in styles.xml</p>\n<pre><code>  &lt;style name=&quot;SplashTheme&quot; parent=&quot;Theme.AppCompat.NoActionBar&quot;&gt;\n      &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/splash_background&lt;/item&gt;\n  &lt;/style&gt;\n</code></pre>\n</li>\n<li><p>In your AndroidMainfest.xml set the above theme to Launch activity.</p>\n<pre><code>    &lt;activity\n         android:name=&quot;.SplashScreenActivity&quot;\n         android:screenOrientation=&quot;portrait&quot;\n         android:theme=&quot;@style/SplashTheme&quot;\n         android:windowSoftInputMode=&quot;stateVisible|adjustResize&quot;&gt;\n         &lt;intent-filter&gt;\n             &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;\n\n             &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;\n         &lt;/intent-filter&gt;\n     &lt;/activity&gt;\n</code></pre>\n</li>\n</ol>\n","answer_id":57090517,"question_id":37437037,"last_edit_date":1599478405},{"owner":{"profile_image":"https://i.stack.imgur.com/jgnbc.jpg?s=256&g=1","account_id":2174289,"user_type":"registered","user_id":1925388,"link":"https://stackoverflow.com/users/1925388/anmol-singh-jaggi","reputation":8434,"display_name":"Anmol Singh Jaggi","accept_rate":81},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1597191007,"creation_date":1597176994,"body":"<p>We can create a DAG where each vertex of the graph is one of the tasks.<br />\nAfter that, we can compute its <a href=\"https://en.wikipedia.org/wiki/Topological_sorting#:%7E:text=In%20computer%20science%2C%20a%20topological,before%20v%20in%20the%20ordering.\" rel=\"nofollow noreferrer\">topological sorted</a> order.<br />\nWe can then decorate the Task class with a priority field and run the <code>ThreadPoolExecutor</code> with a <code>PriorityBlockingQueue</code> which compares Tasks using the priority field.</p>\n<p>The final trick is to override <code>run()</code> to first wait for all the dependent tasks to finish.</p>\n<p>Since each task waits indefinitely for its dependent tasks to finish, we cannot afford to let the thread-pool be completely occupied with tasks that are higher up in the topological sort order; the thread pool will get stuck forever.<br />\nTo avoid this, we just have to assign priorities to tasks according to the topological order.</p>\n<pre class=\"lang-java prettyprint-override\"><code>import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\nimport java.util.concurrent.PriorityBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\n\npublic class Testing {\n\n  private static Callable&lt;Void&gt; getCallable(String taskId){\n    return () -&gt; {\n      System.out.println(String.format(&quot;Task %s result&quot;, taskId));\n      Thread.sleep(100);\n      return null;\n    };\n  }\n\n  public static void main(String[] args) throws ExecutionException, InterruptedException {\n    Callable&lt;Void&gt; taskA = getCallable(&quot;A&quot;);\n    Callable&lt;Void&gt; taskB = getCallable(&quot;B&quot;);\n    Callable&lt;Void&gt; taskC = getCallable(&quot;C&quot;);\n    Callable&lt;Void&gt; taskD = getCallable(&quot;D&quot;);\n    Callable&lt;Void&gt; taskE = getCallable(&quot;E&quot;);\n    PrioritizedFutureTask&lt;Void&gt; pfTaskA = new PrioritizedFutureTask&lt;&gt;(taskA);\n    PrioritizedFutureTask&lt;Void&gt; pfTaskB = new PrioritizedFutureTask&lt;&gt;(taskB);\n    PrioritizedFutureTask&lt;Void&gt; pfTaskC = new PrioritizedFutureTask&lt;&gt;(taskC);\n    PrioritizedFutureTask&lt;Void&gt; pfTaskD = new PrioritizedFutureTask&lt;&gt;(taskD);\n    PrioritizedFutureTask&lt;Void&gt; pfTaskE = new PrioritizedFutureTask&lt;&gt;(taskE);\n    // Create a DAG graph.\n    pfTaskB.addDependency(pfTaskC).addDependency(pfTaskE);\n    pfTaskA.addDependency(pfTaskB).addDependency(pfTaskC).addDependency(pfTaskD);\n    // Now that we have a graph, we can just get its topological sorted order.\n    List&lt;PrioritizedFutureTask&lt;Void&gt;&gt; topological_sort = new ArrayList&lt;&gt;();\n    topological_sort.add(pfTaskE);\n    topological_sort.add(pfTaskC);\n    topological_sort.add(pfTaskB);\n    topological_sort.add(pfTaskD);\n    topological_sort.add(pfTaskA);\n    ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,\n        new PriorityBlockingQueue&lt;Runnable&gt;(1, new CustomRunnableComparator()));\n    // Its important to insert the tasks in the topological sorted order, otherwise its possible that the thread pool will be stuck forever.\n    for (int i = 0; i &lt; topological_sort.size(); i++) {\n      PrioritizedFutureTask&lt;Void&gt; pfTask = topological_sort.get(i);\n      pfTask.setPriority(i);\n      // The lower the priority, the sooner it will run.\n      executor.execute(pfTask);\n    }\n  }\n}\n\nclass PrioritizedFutureTask&lt;T&gt; extends FutureTask&lt;T&gt; implements Comparable&lt;PrioritizedFutureTask&lt;T&gt;&gt; {\n\n  private Integer _priority = 0;\n  private final Callable&lt;T&gt; callable;\n  private final List&lt;PrioritizedFutureTask&gt; _dependencies = new ArrayList&lt;&gt;();\n  ;\n\n  public PrioritizedFutureTask(Callable&lt;T&gt; callable) {\n    super(callable);\n    this.callable = callable;\n  }\n\n  public PrioritizedFutureTask(Callable&lt;T&gt; callable, Integer priority) {\n    this(callable);\n    _priority = priority;\n  }\n\n  public Integer getPriority() {\n    return _priority;\n  }\n\n  public PrioritizedFutureTask&lt;T&gt; setPriority(Integer priority) {\n    _priority = priority;\n    return this;\n  }\n\n  public PrioritizedFutureTask&lt;T&gt; addDependency(PrioritizedFutureTask dep) {\n    this._dependencies.add(dep);\n    return this;\n  }\n\n  @Override\n  public void run() {\n    for (PrioritizedFutureTask dep : _dependencies) {\n      try {\n        dep.get();\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n      } catch (ExecutionException e) {\n        e.printStackTrace();\n      }\n    }\n    super.run();\n  }\n\n  @Override\n  public int compareTo(PrioritizedFutureTask&lt;T&gt; other) {\n    if (other == null) {\n      throw new NullPointerException();\n    }\n    return getPriority().compareTo(other.getPriority());\n  }\n}\n\nclass CustomRunnableComparator implements Comparator&lt;Runnable&gt; {\n  @Override\n  public int compare(Runnable task1, Runnable task2) {\n    return ((PrioritizedFutureTask) task1).compareTo((PrioritizedFutureTask) task2);\n  }\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>Task E result\nTask C result\nTask B result\nTask D result\nTask A result\n</code></pre>\n<p>PS: <a href=\"https://github.com/Anmol-Singh-Jaggi/interview-notes/tree/master/notes/algo-ds-practice/problems/graph/standard/topo_sort\" rel=\"nofollow noreferrer\">Here</a> is a well-tested and simple implementation of topological sort in Python which you can easily port in Java.</p>\n","answer_id":63365785,"question_id":63354899,"last_edit_date":1597191007},{"owner":{"profile_image":"https://www.gravatar.com/avatar/901954b4bf4f56918ed39a925018c8d7?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":18497209,"user_type":"registered","user_id":13475352,"link":"https://stackoverflow.com/users/13475352/sergey-rymsha","reputation":91,"display_name":"Sergey Rymsha"},"content_license":"CC BY-SA 4.0","score":9,"is_accepted":false,"last_activity_date":1588799345,"creation_date":1588799345,"body":"<p>I run into the same issue and found the\n<a href=\"https://bugs.openjdk.java.net/browse/JDK-8241054\" rel=\"noreferrer\">bug report</a></p>\n\n<p>It is awaiting JDK 11.0.8 release.</p>\n","answer_id":61645456,"question_id":54485755},{"owner":{"profile_image":"https://www.gravatar.com/avatar/63f6b4cb480178c6809b5bbeae5a2429?s=256&d=identicon&r=PG","account_id":1242750,"user_type":"registered","user_id":1204940,"link":"https://stackoverflow.com/users/1204940/abhishek","reputation":642,"display_name":"Abhishek"},"content_license":"CC BY-SA 4.0","score":-1,"is_accepted":false,"last_activity_date":1588240348,"creation_date":1588240348,"body":"<p>I know this is very late to answer, but I think it will help many. \nYou can check for the existing socket if any by below code.</p>\n\n<pre><code>SocketAddress socketAddress = new InetSocketAddress(\"localhost\", 8091);\n    Socket socket = new Socket();\n    ServerSocket serverSocket = null;\n    try {\n        socket.connect(socketAddress);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    if(socket == null) {\n        try {\n            serverSocket = new ServerSocket(8091);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n</code></pre>\n\n<p>if not found a active socket on the same port and IP then it will start a new server socket or you can change it start socket only else you can connect to the existing socket.</p>\n","answer_id":61520614,"question_id":40197514},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c324bc64b1ba9913b27c9a89d9fc62c9?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8571883,"user_type":"registered","user_id":6422459,"link":"https://stackoverflow.com/users/6422459/digitshifter","reputation":821,"display_name":"DigitShifter"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1581801207,"creation_date":1581801207,"body":"<p><strong>Try this small example, to get a feel for ThreadLocal variable:</strong><br>\n<br></p>\n\n<pre><code>public class Book implements Runnable {\n    private static final ThreadLocal&lt;List&lt;String&gt;&gt; WORDS = ThreadLocal.withInitial(ArrayList::new);\n\n    private final String bookName; // It is also the thread's name\n    private final List&lt;String&gt; words;\n\n\n    public Book(String bookName, List&lt;String&gt; words) {\n        this.bookName = bookName;\n        this.words = Collections.unmodifiableList(words);\n    }\n\n    public void run() {\n        WORDS.get().addAll(words);\n        System.out.printf(\"Result %s: '%s'.%n\", bookName, String.join(\", \", WORDS.get()));\n    }\n\n    public static void main(String[] args) {\n        Thread t1 = new Thread(new Book(\"BookA\", Arrays.asList(\"wordA1\", \"wordA2\", \"wordA3\")));\n        Thread t2 = new Thread(new Book(\"BookB\", Arrays.asList(\"wordB1\", \"wordB2\")));\n        t1.start();\n        t2.start();\n    }\n}\n</code></pre>\n\n<p><br>\n<strong>Console output, if thread BookA is done first:</strong><br>\nResult BookA: 'wordA1, wordA2, wordA3'.<br>\nResult BookB: 'wordB1, wordB2'.<br>\n<br>\n<strong>Console output, if thread BookB is done first:</strong><br>\nResult BookB: 'wordB1, wordB2'.<br>\nResult BookA: 'wordA1, wordA2, wordA3'.<br>\n<br></p>\n","answer_id":60243198,"question_id":817856},{"owner":{"profile_image":"https://i.stack.imgur.com/X1Q3J.jpg?s=256&g=1","account_id":2593996,"user_type":"registered","user_id":2248045,"link":"https://stackoverflow.com/users/2248045/hitesh-singh","reputation":1971,"display_name":"Hitesh Singh"},"content_license":"CC BY-SA 4.0","score":126,"is_accepted":false,"last_activity_date":1575439237,"creation_date":1465455372,"body":"<p>please add this line into your app theme </p>\n\n<pre><code>&lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;\n</code></pre>\n\n<p>for more information : <a href=\"https://developer.android.com/topic/performance/vitals/launch-time#themed\" rel=\"noreferrer\">https://developer.android.com/topic/performance/vitals/launch-time#themed</a></p>\n","answer_id":37718830,"question_id":37437037,"last_edit_date":1575439237},{"owner":{"profile_image":"https://i.stack.imgur.com/K5WPD.jpg?s=256&g=1","account_id":1298254,"user_type":"registered","user_id":1248724,"link":"https://stackoverflow.com/users/1248724/zarathustra","reputation":2903,"display_name":"Zarathustra","accept_rate":67},"content_license":"CC BY-SA 4.0","score":10,"is_accepted":true,"last_activity_date":1569863738,"creation_date":1549993709,"body":"<p>As @jspcal said before disable TLS 1.3.</p>\n\n<p><strong>tl;dr</strong>: disable tlsv1.3 via extending/overwriting </p>\n\n<p><code>&lt;java_home&gt;/conf/security/java.security</code> the <code>jdk.tls.disabledAlgorithms</code> property</p>\n\n<p>Since my application is running in a docker container I changed the base image to disable tls1.3</p>\n\n<pre><code>FROM openjdk:11-jre\n...\n\nRUN sed -i \"/jdk.tls.disabledAlgorithms=/ s/=.*/=TLSv1.3, SSLv3, RC4, MD5withRSA, DH keySize &lt; 1024, EC keySize &lt; 224, DES40_CBC, RC4_40, 3DES_EDE_CBC/\" $(readlink -f /usr/bin/java | sed \"s:bin/java::\")/conf/security/java.security\n</code></pre>\n\n<p>As far as I know there is no way of setting this (security) property via a system property! See also <code>sun.security.util.DisabledAlgorithmConstraints#PROPERTY_TLS_DISABLED_ALGS</code> which actually ready the property.</p>\n\n<p><strong>Update</strong>: Bug is still present in 11.0.2</p>\n","answer_id":54655885,"question_id":54485755,"last_edit_date":1569863738},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c2aa0c3f639d473d15b08c2cafc9188c?s=256&d=identicon&r=PG","account_id":174482,"user_type":"registered","user_id":403872,"link":"https://stackoverflow.com/users/403872/abhijit-gaikwad","reputation":3102,"display_name":"Abhijit Gaikwad","accept_rate":83},"content_license":"CC BY-SA 4.0","score":15,"is_accepted":false,"last_activity_date":1557882823,"creation_date":1372659023,"body":"<ol>\n<li><p>ThreadLocal in Java had been introduced on JDK 1.2 but was later generified in JDK 1.5 to introduce type safety on ThreadLocal variable.</p></li>\n<li><p>ThreadLocal can be associated with Thread scope, all the code which is executed by Thread has access to ThreadLocal variables but two thread can not see each others ThreadLocal variable.</p></li>\n<li><p>Each thread holds an exclusive copy of ThreadLocal variable which becomes eligible to Garbage collection after thread finished or died, normally or due to any Exception, Given those ThreadLocal variable doesn't have any other live references.</p></li>\n<li><p>ThreadLocal variables in Java are generally private static fields in Classes and maintain its state inside Thread.</p></li>\n</ol>\n\n<p>Read more: <a href=\"https://javarevisited.blogspot.com/2012/05/how-to-use-threadlocal-in-java-benefits.html#ixzz2XltgbHTK\" rel=\"noreferrer\">ThreadLocal in Java - Example Program and Tutorial</a></p>\n","answer_id":17398338,"question_id":817856,"last_edit_date":1557882823},{"owner":{"profile_image":"https://www.gravatar.com/avatar/72641170cc9abff008d21ac50894803b?s=256&d=identicon&r=PG","account_id":20470,"user_type":"registered","user_id":48933,"link":"https://stackoverflow.com/users/48933/neil-coffey","reputation":21695,"display_name":"Neil Coffey","accept_rate":90},"content_license":"CC BY-SA 4.0","score":20,"is_accepted":false,"last_activity_date":1557882784,"creation_date":1241394605,"body":"<p>Essentially, when you need a <strong>variable's value to depend on the current thread</strong> and it <strong>isn't convenient for you to attach the value to the thread in some other way</strong> (for example, subclassing thread).</p>\n\n<p>A typical case is where <strong>some other framework has created the thread</strong> that your code is running in, e.g. a servlet container, or where it just makes more sense to use ThreadLocal because your variable is then \"in its logical place\" (rather than a variable hanging from a Thread subclass or in some other hash map).</p>\n\n<p>On my web site, I have some further <a href=\"https://www.javamex.com/tutorials/synchronization_concurrency_thread_local3.shtml\" rel=\"noreferrer\">discussion and examples of when to use ThreadLocal</a> that may also be of interest.</p>\n\n<p>Some people advocate using ThreadLocal as a way to attach a \"thread ID\" to each thread in certain concurrent algorithms where you need a thread number (see e.g. Herlihy &amp; Shavit). In such cases, check that you're really getting a benefit!</p>\n","answer_id":818364,"question_id":817856,"last_edit_date":1557882784},{"owner":{"profile_image":"https://www.gravatar.com/avatar/520c9c078b8d25980de17b8d4fe0ceba?s=256&d=identicon&r=PG","account_id":24436,"user_type":"registered","user_id":62130,"link":"https://stackoverflow.com/users/62130/esko-luontola","reputation":73314,"display_name":"Esko Luontola","accept_rate":39},"content_license":"CC BY-SA 4.0","score":200,"is_accepted":false,"last_activity_date":1557882754,"creation_date":1241444172,"body":"<p>Many frameworks use ThreadLocals to maintain some context related to the current thread. For example when the current transaction is stored in a ThreadLocal, you don't need to pass it as a parameter through every method call, in case someone down the stack needs access to it. Web applications might store information about the current request and session in a ThreadLocal, so that the application has easy access to them. With Guice you can use ThreadLocals when implementing <a href=\"https://github.com/google/guice/wiki/CustomScopes\" rel=\"noreferrer\">custom scopes</a> for the injected objects (Guice's default <a href=\"https://github.com/google/guice/wiki/Scopes\" rel=\"noreferrer\">servlet scopes</a> most probably use them as well).</p>\n\n<p>ThreadLocals are one sort of global variables (although slightly less evil because they are restricted to one thread), so you should be careful when using them to avoid unwanted side-effects and memory leaks. Design your APIs so that the ThreadLocal values will always be automatically cleared when they are not needed anymore and that incorrect use of the API won't be possible (for example <a href=\"https://github.com/orfjackal/dimdwarf/blob/453f7aee9efc364ebad80531c05081e255323c07/dimdwarf-core/src/main/java/net/orfjackal/dimdwarf/context/ThreadContext.java#L48-55\" rel=\"noreferrer\">like this</a>). ThreadLocals can be used to make the code cleaner, and in some rare cases they are the only way to make something work (my current project had two such cases; they are documented <a href=\"https://github.com/orfjackal/dimdwarf/wiki/Design-Guidelines\" rel=\"noreferrer\">here</a> under \"Static Fields and Global Variables\").</p>\n","answer_id":820131,"question_id":817856,"last_edit_date":1557882754},{"owner":{"profile_image":"https://www.gravatar.com/avatar/7ccd45f17734f7d050a186468bdc38eb?s=256&d=identicon&r=PG","account_id":25274,"user_type":"registered","user_id":64881,"link":"https://stackoverflow.com/users/64881/phil-m","reputation":6653,"display_name":"Phil M"},"content_license":"CC BY-SA 4.0","score":458,"is_accepted":false,"last_activity_date":1557882643,"creation_date":1241388129,"body":"<p>Since a <code>ThreadLocal</code> is a reference to data within a given <code>Thread</code>, you can end up with classloading leaks when using <code>ThreadLocal</code>s in application servers using thread pools. You need to be very careful about cleaning up any <code>ThreadLocal</code>s you <code>get()</code> or <code>set()</code> by using the <code>ThreadLocal</code>'s <code>remove()</code> method.</p>\n\n<p>If you do not clean up when you're done, any references it holds to classes loaded as part of a deployed webapp will remain in the <a href=\"https://web.archive.org/web/20070104122432/http://www.brokenbuild.com/blog/2006/08/04/java-jvm-gc-permgen-and-memory-options/\" rel=\"noreferrer\">permanent heap</a> and will never get garbage collected. Redeploying/undeploying the webapp will not clean up each <code>Thread</code>'s reference to your webapp's class(es) since the <code>Thread</code> is not something owned by your webapp. Each successive deployment will create a new instance of the class which will never be garbage collected.</p>\n\n<p>You will end up with out of memory exceptions due to <code>java.lang.OutOfMemoryError: PermGen space</code> and after some googling will probably just increase <code>-XX:MaxPermSize</code> instead of fixing the bug.</p>\n\n<p>If you do end up experiencing these problems, you can determine which thread and class is retaining these references by using <a href=\"http://www.eclipse.org/mat/\" rel=\"noreferrer\">Eclipse's Memory Analyzer</a> and/or by following <a href=\"http://frankkieviet.blogspot.com/2006/10/classloader-leaks-dreaded-permgen-space.html\" rel=\"noreferrer\">Frank Kieviet's guide</a> and <a href=\"http://frankkieviet.blogspot.com/2006/10/how-to-fix-dreaded-permgen-space.html\" rel=\"noreferrer\">followup</a>.</p>\n\n<p>Update: Re-discovered <a href=\"http://avasseur.blogspot.com/2003/11/threadlocal-and-memory-leaks.html\" rel=\"noreferrer\">Alex Vasseur's blog entry</a> that helped me track down some <code>ThreadLocal</code> issues I was having.</p>\n","answer_id":818120,"question_id":817856,"last_edit_date":1557882643},{"owner":{"profile_image":"https://i.stack.imgur.com/RDWxl.png?s=256&g=1","account_id":4342327,"user_type":"registered","user_id":3545273,"link":"https://stackoverflow.com/users/3545273/serge-ballesta","reputation":145474,"display_name":"Serge Ballesta","accept_rate":100},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1551107156,"creation_date":1405248589,"body":"<p>You are misusing <code>synchronized</code> and <code>wait</code> by calling wait on the object you used in <code>synchronized</code>, immediately, without having a check <em>inside</em> the synchronized block in a loop. <strong>NEVER DO THAT AGAIN</strong>. </p>\n\n<p>In fact here's what happen :</p>\n\n<ul>\n<li>at <code>synchronized</code> line you get a lock on <code>Constants.lock</code></li>\n<li>at <code>wait</code> line, you <strong>release</strong> the lock on <code>Constants.lock</code> and wait for a notify from another thread.</li>\n</ul>\n\n<p>So what is happening in your prog :</p>\n\n<ul>\n<li>first thread (no matter what it is) reaches <code>synchronized</code> and proceed blocking the second</li>\n<li>first thread releases the synchonizing lock and put itself in a wait state for a notify</li>\n<li>second thread goes through <code>synchronized</code> because first has released the lock</li>\n<li>both thread are now waiting for a notify that will never occur</li>\n</ul>\n","answer_id":24721873,"question_id":24720849,"last_edit_date":1551107156},{"owner":{"profile_image":"https://lh3.googleusercontent.com/-wzV0pRRmQn4/AAAAAAAAAAI/AAAAAAAAG9E/XR0AzCzVUSg/photo.jpg?sz=256","account_id":13384743,"user_type":"registered","user_id":9658981,"link":"https://stackoverflow.com/users/9658981/manav-sharma","reputation":11,"display_name":"Manav Sharma"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1551105690,"creation_date":1551105167,"body":"<p>Everyone on the Stack Overflow tried the same solution. Checkout a different implementation for the same.</p>\n\n<pre><code>public class PrintSequenceUsingTwo {\n\n    public static void main(String[] args) {\n        ThreadSequence sequence = new ThreadSequence();\n        Thread t1 = new Thread(()-&gt; {try {\n            sequence.print();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }},\"t1\");\n        Thread t2 = new Thread(()-&gt; {try {\n            sequence.print();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }},\"t2\");\n\n        t1.start();\n        t2.start();\n        try {\n            t1.join();\n            t2.join();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>\n\n<hr>\n\n<pre><code>class ThreadSequence {\n\n    private static int var = 0; \n    private int limit = 10;     //set the variable value upto which you want to print\n\n    public synchronized void print() throws InterruptedException {\n        while (var&lt;limit) {\n            notify();\n            System.out.println(\"Current Thread \"+Thread.currentThread().getName()+\" Value : \"+(++var));\n            wait();\n        }\n        notify();\n    }\n}\n</code></pre>\n","answer_id":54868462,"question_id":24720849,"last_edit_date":1551105690},{"owner":{"profile_image":"https://i.stack.imgur.com/VoV9s.jpg?s=256&g=1","account_id":485625,"user_type":"registered","user_id":902036,"link":"https://stackoverflow.com/users/902036/dz902","reputation":5104,"display_name":"dz902","accept_rate":60},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1550734743,"creation_date":1550734743,"body":"<p>This is interesting as the name \"readlock\" or \"reader-lock\" is probably a bit misleading.</p>\n\n<p>I found it easier to think it as a <strong>mode switch</strong>, you switch to <em>read-only mode</em>, or <em>write-only mode</em>. You switch mode by acquiring corresponding locks.</p>\n","answer_id":54801639,"question_id":33384822},{"owner":{"profile_image":"https://i.stack.imgur.com/vTEma.jpg?s=256&g=1","account_id":4208732,"user_type":"registered","user_id":3447032,"link":"https://stackoverflow.com/users/3447032/gokareless","reputation":1205,"display_name":"gokareless"},"content_license":"CC BY-SA 4.0","score":7,"is_accepted":false,"last_activity_date":1549897683,"creation_date":1549897683,"body":"<p>Duplicating <strong>@Solomon Slow</strong> comment here, as it helped me personally:</p>\n\n<blockquote>\n  <p>Read locks and write locks come in pairs: If thread <strong>R</strong> holds a <em>read lock</em>, it <strong>blocks</strong> thread <strong>W</strong> from obtaining the corresponding <em>write lock</em>, but it <strong>does not block</strong> thread <strong>S</strong> from getting the same <em>read lock</em>. A reader/writer lock pair allows any number of readers to \"own\" the read lock at the same time, OR it allows one writer to own the write lock, but it never allows a reader and a writer at the same time, and it never allows more than one writer at the same time.</p>\n</blockquote>\n","answer_id":54633486,"question_id":33384822},{"owner":{"profile_image":"https://www.gravatar.com/avatar/097d761861529df52a6800744f1074d2?s=256&d=identicon&r=PG","account_id":84127,"user_type":"registered","user_id":235354,"link":"https://stackoverflow.com/users/235354/jspcal","reputation":51115,"display_name":"jspcal"},"content_license":"CC BY-SA 4.0","score":9,"is_accepted":false,"last_activity_date":1549048805,"creation_date":1549048805,"body":"<p>Try disabling <code>TLSv1.3</code> or <code>SSLv3</code> to see if that helps.</p>\n\n<p>Set the system property on the command line: <code>-Djdk.tls.disabledAlgorithms=TLSv1.3</code></p>\n\n<p>Or define the property in <code>&lt;java_home&gt;/conf/security/java.security</code></p>\n\n<p>If you think it's an implementation bug, you may want to open an issue.</p>\n","answer_id":54485918,"question_id":54485755},{"owner":{"profile_image":"https://lh5.googleusercontent.com/-vTTwbpau6o4/AAAAAAAAAAI/AAAAAAAABbA/nMg4jej0wtY/photo.jpg?sz=256","account_id":8047963,"user_type":"registered","user_id":6067590,"link":"https://stackoverflow.com/users/6067590/akanshi-srivastava","reputation":1160,"display_name":"Akanshi Srivastava"},"content_license":"CC BY-SA 4.0","score":17,"is_accepted":false,"last_activity_date":1548662806,"creation_date":1548662806,"body":"<p>I added the following two lines in my theme\nunder styles.xml</p>\n\n<pre><code>    &lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;\n    &lt;item name=\"android:windowBackground\"&gt;@null&lt;/item&gt;\n</code></pre>\n\n<p>Worked like a charm</p>\n","answer_id":54397744,"question_id":37437037},{"owner":{"profile_image":"https://i.stack.imgur.com/9Q2UB.png?s=256&g=1","account_id":13184766,"user_type":"registered","user_id":9523162,"link":"https://stackoverflow.com/users/9523162/meyi","reputation":7674,"display_name":"meyi"},"content_license":"CC BY-SA 4.0","score":12,"is_accepted":false,"last_activity_date":1547777884,"creation_date":1547745165,"body":"<p>I know that I'm a few years late, but I came across this issue and took an unorthodox approach. I wanted to do it without making a new class, so this is what I came up with: </p>\n\n<pre><code>int x = 0;\nnew Thread((new Runnable() {\n     int x;\n     public void run() {\n        // stuff with x and whatever else you want\n     }\n     public Runnable pass(int x) {\n           this.x = x;\n           return this;\n     }\n}).pass(x)).start();\n</code></pre>\n","answer_id":54241038,"question_id":877096,"last_edit_date":1547777884},{"owner":{"profile_image":"https://www.gravatar.com/avatar/117cb4789d68e0d8c0ca17fd09948a1a?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":14685618,"user_type":"registered","user_id":10605704,"link":"https://stackoverflow.com/users/10605704/young","reputation":31,"display_name":"Young"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1541428261,"creation_date":1541428261,"body":"<p>[For Reference]ThreadLocal cannot solve update problems of shared object. It is recommended to use a staticThreadLocal object which is shared by all operations in the same thread.\n[Mandatory]remove() method must be implemented by ThreadLocal variables, especially when using thread pools in which threads are often reused. Otherwise, it may affect subsequent business logic and cause unexpected problems such as memory leak.</p>\n","answer_id":53156397,"question_id":817856},{"owner":{"profile_image":"https://www.gravatar.com/avatar/263ca357f9cf115f409fd3d8fe697503?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":2975624,"user_type":"registered","user_id":2526714,"link":"https://stackoverflow.com/users/2526714/v0ld3m0rt","reputation":874,"display_name":"v0ld3m0rt","accept_rate":95},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1539494359,"creation_date":1539494359,"body":"<p>You can find the explanation in the site mentioned in package declaraion:\nHere's the working code:</p>\n\n<pre><code>public class MultipleThreading {\n    int count = 1;\n    int MAX = 20;\n\n    public void printOdd() {\n    synchronized (this) {\n        while (count &lt; MAX) {\n        while (count % 2 == 0) {\n            try {\n            wait();\n            } catch (InterruptedException e) {\n            e.printStackTrace();\n            }\n        }\n        System.out.print(count + \" \");\n        count++;\n        notify();\n        }\n    }\n    }\n\n    public void printEven() {\n    synchronized (this) {\n        while (count &lt; MAX) {\n        while (count % 2 == 1) {\n            try {\n            wait();\n            } catch (InterruptedException e) {\n            e.printStackTrace();\n            }\n        }\n        System.out.print(count + \" \");\n        count++;\n        notify();\n        }\n    }\n    }\n\n    public static void main(String[] args) {\n    MultipleThreading mt = new MultipleThreading();\n    Thread t1 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n        mt.printEven();\n        }\n    });\n    Thread t2 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n        mt.printOdd();\n        }\n    });\n    t1.start();\n    t2.start();\n    }\n}\n</code></pre>\n","answer_id":52799710,"question_id":24720849},{"owner":{"profile_image":"https://i.stack.imgur.com/eNviq.png?s=256&g=1","account_id":5243963,"user_type":"registered","user_id":4190267,"link":"https://stackoverflow.com/users/4190267/indian","reputation":130,"display_name":"indian"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1538390322,"creation_date":1415353577,"body":"<p>The first difference is that <code>yield()</code> is a <code>Thread</code> method , <code>wait()</code> is at the origins <code>Object</code> method inheritid in <code>thread</code> as for all classes , that in the shape, in the background (using java doc) </p>\n\n<pre><code>wait()\n</code></pre>\n\n<p>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. In other words, this method behaves exactly as if it simply performs the call wait(0).</p>\n\n<pre><code>yield()\n</code></pre>\n\n<p>A hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint.</p>\n\n<p>and here you can see the <a href=\"http://javarevisited.blogspot.fr/2011/12/difference-between-wait-sleep-yield.html\" rel=\"nofollow noreferrer\">difference</a> between <a href=\"http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#yield()\" rel=\"nofollow noreferrer\">yield()</a> and <a href=\"http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#wait()\" rel=\"nofollow noreferrer\">wait()</a></p>\n","answer_id":26798351,"question_id":26798073,"last_edit_date":1538390322},{"owner":{"profile_image":"https://i.stack.imgur.com/QN0a6.jpg?s=256&g=1","account_id":6198641,"user_type":"registered","user_id":4829218,"link":"https://stackoverflow.com/users/4829218/calvin-k","reputation":114,"display_name":"Calvin K"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1537363352,"creation_date":1537363352,"body":"<p>Create a local variable in your class that <code>extends Thread</code> or <code>implements Runnable</code>.</p>\n\n<pre><code>public class Extractor extends Thread {\n    public String webpage = \"\";\n    public Extractor(String w){\n        webpage = w;\n    }\n    public void setWebpage(String l){\n        webpage = l;\n    }\n\n    @Override\n    public void run() {// l is link\n        System.out.println(webpage);\n    }\n    public String toString(){\n        return \"Page: \"+webpage;\n    }}\n</code></pre>\n\n<p>This way, you can pass a variable when you run it.</p>\n\n<pre><code>Extractor e = new Extractor(\"www.google.com\");\ne.start();\n</code></pre>\n\n<p>The output:</p>\n\n<pre><code>\"www.google.com\"\n</code></pre>\n","answer_id":52406906,"question_id":877096},{"owner":{"profile_image":"https://i.stack.imgur.com/63g7E.jpg?s=256&g=1","account_id":1252022,"user_type":"registered","user_id":6730571,"link":"https://stackoverflow.com/users/6730571/hugues-m","reputation":19996,"display_name":"Hugues M."},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1531412347,"creation_date":1531412347,"body":"<p>I've had the same issue on Ubuntu, with <code>openjdk-9-jdk-headless</code> installed, <code>jstack</code> alone would work fine but <code>jstack -m</code> would fail with same error as you.</p>\n\n<p>Installing <code>openjdk-9-dbg</code> (package that brings debug symbols) solved it.</p>\n","answer_id":51310395,"question_id":49516601},{"owner":{"profile_image":"https://i.stack.imgur.com/wOpca.jpg?s=256&g=1","account_id":1901420,"user_type":"registered","user_id":1717210,"link":"https://stackoverflow.com/users/1717210/tachedechoco","reputation":3763,"display_name":"TacheDeChoco"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1531397535,"creation_date":1531397535,"body":"<p>The same user is fine, but make also sure you are using the jstack that is bundled the <strong>exact same</strong> JVM as the one that is running the process 7219.</p>\n","answer_id":51305417,"question_id":49516601},{"owner":{"profile_image":"https://i.stack.imgur.com/SoIAb.jpg?s=256&g=1","account_id":8324600,"user_type":"registered","user_id":6255036,"link":"https://stackoverflow.com/users/6255036/krishna","reputation":1566,"display_name":"Krishna"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1530860546,"creation_date":1530860546,"body":"<pre><code>Style :- \n&lt;style name=\"SplashViewTheme\" parent=\"Theme.AppCompat.NoActionBar\"&gt;\n    &lt;item name=\"android:windowBackground\"&gt;@drawable/splash&lt;/item&gt;\n    &lt;item name=\"windowActionBar\"&gt;false&lt;/item&gt;\n    &lt;item name=\"windowNoTitle\"&gt;true&lt;/item&gt;\n&lt;/style&gt;\n\nIn Manifest :- \n&lt;activity android:name=\".SplashActivity\"\n        android:theme=\"@style/SplashViewTheme\"&gt;\n        &lt;intent-filter&gt;\n            &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n\n            &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n        &lt;/intent-filter&gt;\n    &lt;/activity&gt;\n</code></pre>\n","answer_id":51204730,"question_id":37437037},{"owner":{"profile_image":"https://i.stack.imgur.com/f4hTe.jpg?s=256&g=1","account_id":13723126,"user_type":"registered","user_id":9902575,"link":"https://stackoverflow.com/users/9902575/david-studer","reputation":105,"display_name":"David Studer"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1530190098,"creation_date":1530190098,"body":"<p>The issue is indeed not caused by the multithreading logic itself, it is caused by <strong>Eclipse</strong> and the respective <strong>JVM</strong>. Running the exact same code in <strong>Netbeans</strong> or on an <strong>Tomcat 8 Server</strong> did not lead to any problems. A reinstallation of Eclipse did not solve the malfunction within the Eclipse framework, but having the certainty that the issue does not cause any trouble on a server is sufficient for me to close the case. </p>\n\n<p>Thanks to <a href=\"https://stackoverflow.com/users/2563754/seelenvirtuose\">Seelenvirtuose</a> for the hints and his effort.</p>\n","answer_id":51083358,"question_id":51055780},{"owner":{"profile_image":"https://www.gravatar.com/avatar/7d4357beb6de2712b6b2171ebe4c499b?s=256&d=identicon&r=PG","account_id":3023214,"user_type":"registered","user_id":2563754,"link":"https://stackoverflow.com/users/2563754/seelenvirtuose","reputation":20361,"display_name":"Seelenvirtuose"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1530081892,"creation_date":1530081892,"body":"<blockquote>\n  <p>But every time I start running my own thread class as a new thread, the main class thread does not terminate anymore by itself.</p>\n</blockquote>\n\n<p>This is somewhat wrong. Your program does not terminate because there exists at least one non-daemon thread that still is running. The rule is: A Java program is terminated if all non-daemon threads are terminated.</p>\n\n<p>I modified your program to make this behavior clear:</p>\n\n<pre><code>public class OwnThread implements Runnable {\n    @Override\n    public void run() {\n        runForever();\n    }\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(new OwnThread());\n        thread.start();\n        runForever();\n    }\n\n    private static void runForever() {\n        while (true) {}\n    }\n}\n</code></pre>\n\n<p>Running that will create two threads that will run forever. One is the main thread which is started by running the program, and the other is the thread started inside the main method:</p>\n\n<p><a href=\"https://i.stack.imgur.com/kc9Qy.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/kc9Qy.png\" alt=\"enter image description here\"></a></p>\n\n<p>Modifying the above code by removing the call to <em>runForever</em> in the main method ...</p>\n\n<pre><code>public static void main(String[] args) {\n    Thread thread = new Thread(new OwnThread());\n    thread.start();\n}\n</code></pre>\n\n<p>... will result in a different thread picture:</p>\n\n<p><a href=\"https://i.stack.imgur.com/d86FX.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/d86FX.png\" alt=\"enter image description here\"></a></p>\n\n<p>Here the main thread is gone because it is terminated. But the other started thread is still running.</p>\n\n<p>Side note: Suddenly another thread appears - <code>DestroyJavaVM</code>. Have a look at the post <a href=\"https://stackoverflow.com/questions/34433267/destroyjavavm-thread-always-running\">DestroyJavaVM thread ALWAYS running</a> for more information.</p>\n","answer_id":51056168,"question_id":51055780},{"owner":{"profile_image":"https://i.stack.imgur.com/MUmw0.jpg?s=256&g=1","account_id":2629067,"user_type":"registered","user_id":2275474,"link":"https://stackoverflow.com/users/2275474/pritesh-patel","reputation":688,"display_name":"Pritesh Patel","accept_rate":100},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1528118288,"creation_date":1528118288,"body":"<p>The <strong>ThreadLocal</strong> class in Java enables you to create variables that can only be read and written by the same thread. Thus, even if two threads are executing the same code, and the code has a reference to a ThreadLocal variable, then the two threads cannot see each other's ThreadLocal variables.</p>\n\n<p><a href=\"http://tutorials.jenkov.com/java-concurrency/threadlocal.html\" rel=\"nofollow noreferrer\">Read more</a></p>\n","answer_id":50681599,"question_id":817856},{"owner":{"profile_image":"https://www.gravatar.com/avatar/4c1cbfeb8f960be43b662f976c47ca6b?s=256&d=identicon&r=PG","account_id":26685,"user_type":"registered","user_id":69689,"link":"https://stackoverflow.com/users/69689/overthink","reputation":24085,"display_name":"overthink","accept_rate":85},"content_license":"CC BY-SA 3.0","score":916,"is_accepted":true,"last_activity_date":1524678699,"creation_date":1241382377,"body":"<p>One possible (and common) use is when you have some object that is not thread-safe, but you want to avoid <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html\" rel=\"noreferrer\">synchronizing</a> access to that object (I'm looking at you, <a href=\"https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html\" rel=\"noreferrer\">SimpleDateFormat</a>).  Instead, give each thread its own instance of the object.</p>\n\n<p>For example:</p>\n\n<pre><code>public class Foo\n{\n    // SimpleDateFormat is not thread-safe, so give one to each thread\n    private static final ThreadLocal&lt;SimpleDateFormat&gt; formatter = new ThreadLocal&lt;SimpleDateFormat&gt;(){\n        @Override\n        protected SimpleDateFormat initialValue()\n        {\n            return new SimpleDateFormat(\"yyyyMMdd HHmm\");\n        }\n    };\n\n    public String formatIt(Date date)\n    {\n        return formatter.get().format(date);\n    }\n}\n</code></pre>\n\n<p><a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html\" rel=\"noreferrer\">Documentation</a>.</p>\n","answer_id":817926,"question_id":817856,"last_edit_date":1524678699},{"owner":{"profile_image":"https://www.gravatar.com/avatar/8ef359acdee98b1513720480264b6eac?s=256&d=identicon&r=PG","account_id":2849643,"user_type":"registered","user_id":2447120,"link":"https://stackoverflow.com/users/2447120/rakesh-chauhan","reputation":423,"display_name":"Rakesh Chauhan"},"content_license":"CC BY-SA 4.0","score":32,"is_accepted":false,"last_activity_date":1522247318,"creation_date":1443950915,"body":"<p>There is very good example in book <strong>Java Concurrency in Practice</strong>. Where author (<a href=\"https://en.wikipedia.org/wiki/Joshua_Bloch\" rel=\"noreferrer\">Joshua Bloch</a>) explains how Thread confinement is one of the simplest ways to achieve thread safety and <strong>ThreadLocal</strong> is more formal means of maintaining thread confinement. In the end he also explain how people can abuse it by using it as global variables.</p>\n<p>I have copied the text from the mentioned book but code 3.10 is missing as it is not much important to understand where ThreadLocal should be use.</p>\n<blockquote>\n<p>Thread-local variables are often used to prevent sharing in designs based on mutable Singletons or global variables. For example, a single-threaded application might maintain a global database connection that is initialized at startup to avoid having to pass a Connection to every method. Since JDBC connections may not be thread-safe, a multithreaded application that uses a global connection without additional coordination is not thread-safe either. By using a ThreadLocal to store the JDBC connection, as in ConnectionHolder in Listing 3.10, each thread will have its own connection.<br/></p>\n<p>ThreadLocal is widely used in implementing application frameworks. For example, J2EE containers associate a transaction context with an executing thread for the duration of an EJB call. This is easily implemented using a static Thread-Local holding the transaction context: when framework code needs to determine what transaction is currently running, it fetches the transaction context from this ThreadLocal. This is convenient in that it reduces the need to pass execution context information into every method, but couples any code that uses this mechanism to the framework.</p>\n<p>It is easy to abuse ThreadLocal by treating its thread confinement property as a license to use global variables or as a means of creating “hidden” method arguments. Like global variables, thread-local variables can detract from reusability and introduce hidden couplings among classes, and should therefore be used with care.</p>\n</blockquote>\n","answer_id":32931978,"question_id":817856,"last_edit_date":1592644375},{"owner":{"profile_image":"https://lh5.googleusercontent.com/-yRGGcWHl23g/AAAAAAAAAAI/AAAAAAAAAE8/rs-zYQv-l9I/photo.jpg?sz=256","account_id":9240608,"user_type":"registered","user_id":6864013,"link":"https://stackoverflow.com/users/6864013/prasad-reddy","reputation":399,"display_name":"prasad reddy"},"content_license":"CC BY-SA 3.0","score":38,"is_accepted":false,"last_activity_date":1521183452,"creation_date":1521183452,"body":"<p>Please copy and paste these two lines in your manifest app theme i.e res/styles/AppTheme. then it will work like charm..</p>\n\n<pre><code>&lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;\n&lt;item name=\"android:windowIsTranslucent\"&gt;true&lt;/item&gt;\n</code></pre>\n","answer_id":49314844,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b7e983bc66ab99bac7d0891527628145?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":3244300,"user_type":"registered","user_id":2736367,"link":"https://stackoverflow.com/users/2736367/sam","reputation":2975,"display_name":"Sam","accept_rate":75},"content_license":"CC BY-SA 3.0","score":40,"is_accepted":false,"last_activity_date":1520938475,"creation_date":1520938475,"body":"<p>Recommended way of solving this problem is missing in the answers. So I am adding my answer here. The white-screen-at-startup problem occurs because of the initial blank screen that the system process draws when launching the app. A common way to solve this is by turning off this initial screen by adding this to your <code>styles.xml</code> file.</p>\n\n<pre><code>&lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;\n</code></pre>\n\n<p>But according to android documentation this can result in longer startup time. Recommended way of avoiding this initial white screen according to google is to use activity's <code>windowBackground</code> theme attribute and provide a simple custom drawable for the starting activity.  </p>\n\n<p>Like this:</p>\n\n<p>Drawable Layout file, <code>my_drawable.xml</code></p>\n\n<pre><code>&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:opacity=\"opaque\"&gt;\n  &lt;!-- The background color, preferably the same as your normal theme --&gt;\n  &lt;item android:drawable=\"@android:color/white\"/&gt;\n  &lt;!-- Your product logo - 144dp color version of your app icon --&gt;\n  &lt;item&gt;\n    &lt;bitmap\n      android:src=\"@drawable/product_logo_144dp\"\n      android:gravity=\"center\"/&gt;\n  &lt;/item&gt;\n&lt;/layer-list&gt;\n</code></pre>\n\n<p>Create a new style in your <code>styles.xml</code></p>\n\n<pre><code>&lt;!-- Base application theme. --&gt;\n&lt;style name=\"AppTheme\"&gt;\n    &lt;!-- Customize your theme here. --&gt;               \n&lt;/style&gt;\n\n&lt;!-- Starting activity theme --&gt;\n&lt;style name=\"AppTheme.Launcher\"&gt;\n    &lt;item name=\"android:windowBackground\"&gt;@drawable/my_drawable&lt;/item&gt;\n&lt;/style&gt;\n</code></pre>\n\n<p>Add this theme to your starting activity in the Manifest file </p>\n\n<pre><code>&lt;activity ...\nandroid:theme=\"@style/AppTheme.Launcher\" /&gt;\n</code></pre>\n\n<p>And when you want to transition back to your normal theme call <code>setTheme(R.style.Apptheme)</code> before calling <code>super.onCreate()</code> and <code>setContentView()</code> </p>\n\n<pre><code>public class MainActivity extends AppCompatActivity {\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    // Make sure this is before calling super.onCreate\n    setTheme(R.style.Theme_MyApp);\n    super.onCreate(savedInstanceState);\n    // ...\n  }\n}\n</code></pre>\n\n<p>This is the recommended way to solve the problem and this is from google <a href=\"https://material.io/guidelines/patterns/launch-screens.html#\" rel=\"noreferrer\">Material Design</a> patterns.</p>\n","answer_id":49254344,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/dc8c4ddd99b446c28d2e1546c457e508?s=256&d=identicon&r=PG","account_id":4495,"user_type":"registered","user_id":6782,"link":"https://stackoverflow.com/users/6782/alnitak","reputation":335863,"display_name":"Alnitak","accept_rate":78},"content_license":"CC BY-SA 3.0","score":421,"is_accepted":true,"last_activity_date":1518710716,"creation_date":1242643303,"body":"<p>You need to pass the parameter in the constructor to the Runnable object:</p>\n\n<pre><code>public class MyRunnable implements Runnable {\n\n   public MyRunnable(Object parameter) {\n       // store parameter for later user\n   }\n\n   public void run() {\n   }\n}\n</code></pre>\n\n<p>and invoke it thus:</p>\n\n<pre><code>Runnable r = new MyRunnable(param_value);\nnew Thread(r).start();\n</code></pre>\n","answer_id":877113,"question_id":877096,"last_edit_date":1518710716},{"owner":{"profile_image":"https://www.gravatar.com/avatar/92649572223f7fa0485d3e87805159b4?s=256&d=identicon&r=PG","account_id":267334,"user_type":"registered","user_id":555451,"link":"https://stackoverflow.com/users/555451/stuart-cardall","reputation":2179,"display_name":"Stuart Cardall"},"content_license":"CC BY-SA 3.0","score":7,"is_accepted":false,"last_activity_date":1514541231,"creation_date":1514541231,"body":"<p>In Java 8 you can use <code>lambda</code> expressions with the <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html\" rel=\"noreferrer\">Concurrency API</a> &amp; the <code>ExecutorService</code> as a higher level replacement for working with threads directly:</p>\n\n<blockquote>\n  <p><code>newCachedThreadPool()</code> Creates a thread pool that creates new threads\n  as needed, but will reuse previously constructed threads when they are\n  available. These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks.</p>\n</blockquote>\n\n<pre><code>    private static final ExecutorService executor = Executors.newCachedThreadPool();\n\n    executor.submit(() -&gt; {\n        myFunction(myParam1, myParam2);\n    });\n</code></pre>\n\n<p>See also <code>executors</code> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html\" rel=\"noreferrer\">javadocs</a>.</p>\n","answer_id":48020642,"question_id":877096},{"owner":{"profile_image":"https://www.gravatar.com/avatar/3f3a232ec46927a08f59d4d4e59c6802?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":3401111,"user_type":"registered","user_id":2853221,"link":"https://stackoverflow.com/users/2853221/dev-amitabh","reputation":185,"display_name":"Dev Amitabh"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1513047641,"creation_date":1513047641,"body":"<p>Threadlocal provides a very easy way to achieve objects reusability with zero cost.</p>\n\n<p>I had a situation where multiple threads were creating an image of mutable cache, on each update notification.</p>\n\n<p>I used a Threadlocal on each thread, and then each thread would just need to reset old image and then update it again from the cache on each update notification.</p>\n\n<p>Usual reusable objects from object pools have thread safety cost associated with them, while this approach has none. </p>\n","answer_id":47764719,"question_id":817856},{"owner":{"profile_image":"https://www.gravatar.com/avatar/ddb4a32b3d7306760349340e46fd078d?s=256&d=identicon&r=PG","account_id":3750936,"user_type":"registered","user_id":3148734,"link":"https://stackoverflow.com/users/3148734/bpjoshi","reputation":1111,"display_name":"bpjoshi","accept_rate":75},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1512028724,"creation_date":1511992191,"body":"<p>Thread-local variables are often used to prevent sharing in designs based on\nmutable Singletons or global variables. </p>\n\n<p>It can be used in scenarios like making seperate JDBC connection for each thread when you are not using a Connection Pool.</p>\n\n<pre><code>private static ThreadLocal&lt;Connection&gt; connectionHolder\n           = new ThreadLocal&lt;Connection&gt;() {\n      public Connection initialValue() {\n           return DriverManager.getConnection(DB_URL);\n          }\n     };\n\npublic static Connection getConnection() {\n      return connectionHolder.get();\n} \n</code></pre>\n\n<p>When you call getConnection, it will return a connection associated with that thread.The same can be done with other properties like dateformat, transaction context that you don't want to share between threads. </p>\n\n<p>You could have also used local variables for the same, but these resource usually take up time in creation,so you don't want to create them again and again whenever you perform some business logic with them. However, ThreadLocal values are stored in the thread object itself and as soon as the thread is garbage collected, these values are gone too.</p>\n\n<p>This <a href=\"https://howtodoinjava.com/core-java/multi-threading/when-and-how-to-use-thread-local-variables/\" rel=\"nofollow noreferrer\">link</a> explains use of ThreadLocal very well.</p>\n","answer_id":47562423,"question_id":817856,"last_edit_date":1512028724},{"owner":{"profile_image":"https://i.stack.imgur.com/miNqr.jpg?s=256&g=1","account_id":4324639,"user_type":"registered","user_id":3531794,"link":"https://stackoverflow.com/users/3531794/dimos","reputation":8470,"display_name":"Dimos"},"content_license":"CC BY-SA 3.0","score":5,"is_accepted":false,"last_activity_date":1505561291,"creation_date":1505561291,"body":"<p><code>ThreadLocal</code> is useful, when you want to have some state that should not be shared amongst different threads, but it should be accessible from each thread during its whole lifetime.</p>\n\n<p>As an example, imagine a web application, where each request is served by a different thread. Imagine that for each request you need a piece of data multiple times, which is quite expensive to compute. However, that data might have changed for each incoming request, which means that you can't use a plain cache. A simple, quick solution to this problem would be to have a <code>ThreadLocal</code> variable holding access to this data, so that you have to calculate it only once for each request. Of course, this problem can also be solved without the use of <code>ThreadLocal</code>, but I devised it for illustration purposes. </p>\n\n<p>That said, have in mind that <code>ThreadLocal</code>s are essentially a form of global state. As a result, it has many other implications and should be used only after considering all the other possible solutions. </p>\n","answer_id":46253405,"question_id":817856},{"owner":{"profile_image":"https://i.stack.imgur.com/Auh5P.png?s=256&g=1","account_id":2075948,"user_type":"registered","user_id":4233197,"link":"https://stackoverflow.com/users/4233197/hiren-patel","reputation":52334,"display_name":"Hiren Patel","accept_rate":55},"content_license":"CC BY-SA 3.0","score":11,"is_accepted":false,"last_activity_date":1496909476,"creation_date":1496909476,"body":"<p>I had same issue, you have to update your style.</p>\n\n<p><strong>style.xml</strong></p>\n\n<pre><code>&lt;!-- Base application theme. --&gt;\n &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt;\n\n        &lt;!-- Customize your theme here. --&gt;\n        &lt;item name=\"drawerArrowStyle\"&gt;@style/DrawerArrowStyle&lt;/item&gt;\n        &lt;item name=\"android:windowNoTitle\"&gt;true&lt;/item&gt;\n        &lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;\n        &lt;item name=\"android:windowBackground\"&gt;@null&lt;/item&gt;\n        &lt;item name=\"android:windowIsTranslucent\"&gt;true&lt;/item&gt;\n\n &lt;/style&gt;\n</code></pre>\n\n<p>Your manifest file should looks like below.</p>\n\n<pre><code>&lt;application\n        android:name=\".MyApplication\"\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:theme=\"@style/AppTheme\"&gt;\n     // Other stuff\n&lt;/application&gt;\n</code></pre>\n\n<p><strong>Outout:</strong></p>\n\n<p><a href=\"https://i.stack.imgur.com/78a5r.gif\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/78a5r.gif\" alt=\"enter image description here\"></a></p>\n\n<p>Hope this would help you.</p>\n","answer_id":44430166,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/52f323891e5e487c80d4034887c31f1b?s=256&d=identicon&r=PG","account_id":3178228,"user_type":"registered","user_id":2685581,"link":"https://stackoverflow.com/users/2685581/ajay-kumar","reputation":4984,"display_name":"Ajay Kumar"},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1496153397,"creation_date":1496139866,"body":"<p>ThreadLocal is a specially provisioned functionality by JVM to provide an isolated storage space for threads only. like the value of instance scoped variable are bound to a given instance of a class only. each object has its only values and they can not see each other value. so is the concept of ThreadLocal variables, they are local to the thread in the sense of object instances other thread except for the one which created it, can not see it. <a href=\"https://itexpertsconsultant.wordpress.com/2017/05/29/threadlocal-example-with-java-8/\" rel=\"nofollow noreferrer\">See Here</a></p>\n\n<pre><code>import java.util.concurrent.atomic.AtomicInteger;\nimport java.util.stream.IntStream;\n\n\npublic class ThreadId {\nprivate static final AtomicInteger nextId = new AtomicInteger(1000);\n\n// Thread local variable containing each thread's ID\nprivate static final ThreadLocal&lt;Integer&gt; threadId = ThreadLocal.withInitial(() -&gt; nextId.getAndIncrement());\n\n\n// Returns the current thread's unique ID, assigning it if necessary\npublic static int get() {\n    return threadId.get();\n}\n\npublic static void main(String[] args) {\n\n    new Thread(() -&gt; IntStream.range(1, 3).forEach(i -&gt; {\n        System.out.println(Thread.currentThread().getName() + \" &gt;&gt; \" + new ThreadId().get());\n    })).start();\n\n    new Thread(() -&gt; IntStream.range(1, 3).forEach(i -&gt; {\n        System.out.println(Thread.currentThread().getName() + \" &gt;&gt; \" + new ThreadId().get());\n    })).start();\n\n    new Thread(() -&gt; IntStream.range(1, 3).forEach(i -&gt; {\n        System.out.println(Thread.currentThread().getName() + \" &gt;&gt; \" + new ThreadId().get());\n    })).start();\n\n}\n}\n</code></pre>\n","answer_id":44259643,"question_id":817856,"last_edit_date":1496153397},{"owner":{"profile_image":"https://i.stack.imgur.com/zw18i.png?s=256&g=1","account_id":1663234,"user_type":"registered","user_id":1531124,"link":"https://stackoverflow.com/users/1531124/ghostcat","reputation":138406,"display_name":"GhostCat","accept_rate":96},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":true,"last_activity_date":1493199636,"creation_date":1493199636,"body":"<p>What can be said so far: you use the ExecutorService to pass in tasks:</p>\n\n<pre><code>new StatusMultiThreading(id, username, psLog, connSTORY, connCF, mongoDatabase)\n</code></pre>\n\n<p>Later on, when you call <code>get()</code> the corresponding task is triggered. So that exception takes place inside that class of yours. </p>\n","answer_id":43630459,"question_id":43630406},{"owner":{"profile_image":"https://lh5.googleusercontent.com/-zJQot7cFQ8g/AAAAAAAAAAI/AAAAAAAAC8w/mLSR34VdUxk/photo.jpg?sz=256","account_id":9419272,"user_type":"registered","user_id":7803889,"link":"https://stackoverflow.com/users/7803889/javier-reinoso","reputation":11,"display_name":"Javier Reinoso"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1491120410,"creation_date":1491118425,"body":"<p>Just write the item in values/styles.xml:</p>\n\n<pre><code>&lt;item name=\"android:windowBackground\"&gt;@android:color/black&lt;/item&gt;\n</code></pre>\n\n<p>For example, in the AppTheme:</p>\n\n<pre><code>&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"&gt;\n    &lt;item name=\"windowNoTitle\"&gt;true&lt;/item&gt;\n    &lt;item name=\"windowActionBar\"&gt;false&lt;/item&gt;\n    &lt;item name=\"android:windowFullscreen\"&gt;true&lt;/item&gt;\n    &lt;item name=\"android:windowContentOverlay\"&gt;@null&lt;/item&gt;\n\n    &lt;item name=\"android:windowBackground\"&gt;@android:color/black&lt;/item&gt;\n\n    &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt;\n    &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt;\n    &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt;\n&lt;/style&gt;\n</code></pre>\n","answer_id":43165801,"question_id":37437037,"last_edit_date":1491120410},{"owner":{"profile_image":"https://i.stack.imgur.com/GGyFL.jpg?s=256&g=1","account_id":7201903,"user_type":"registered","user_id":5498855,"link":"https://stackoverflow.com/users/5498855/ivan-milisavljevic","reputation":2058,"display_name":"Ivan Milisavljevic"},"content_license":"CC BY-SA 3.0","score":102,"is_accepted":true,"last_activity_date":1490998158,"creation_date":1465301471,"body":"<p>The problem with white background is caused because of android's cold start while the app loads to memory, and it can be avoided with this:</p>\n\n<pre><code>public class OnboardingWithCenterAnimationActivity extends AppCompatActivity {\npublic static final int STARTUP_DELAY = 300;\npublic static final int ANIM_ITEM_DURATION = 1000;\npublic static final int ITEM_DELAY = 300;\n\nprivate boolean animationStarted = false;\n\n@Override\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    setTheme(R.style.AppTheme);\n    getWindow().getDecorView().setSystemUiVisibility(\n            View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_onboarding_center);\n}\n\n@Override\npublic void onWindowFocusChanged(boolean hasFocus) {\n\n    if (!hasFocus || animationStarted) {\n        return;\n    }\n\n    animate();\n\n    super.onWindowFocusChanged(hasFocus);\n}\n\nprivate void animate() {\n    ImageView logoImageView = (ImageView) findViewById(R.id.img_logo);\n    ViewGroup container = (ViewGroup) findViewById(R.id.container);\n\n    ViewCompat.animate(logoImageView)\n        .translationY(-250)\n        .setStartDelay(STARTUP_DELAY)\n        .setDuration(ANIM_ITEM_DURATION).setInterpolator(\n            new DecelerateInterpolator(1.2f)).start();\n\n    for (int i = 0; i &lt; container.getChildCount(); i++) {\n        View v = container.getChildAt(i);\n        ViewPropertyAnimatorCompat viewAnimator;\n\n        if (!(v instanceof Button)) {\n            viewAnimator = ViewCompat.animate(v)\n                    .translationY(50).alpha(1)\n                    .setStartDelay((ITEM_DELAY * i) + 500)\n                    .setDuration(1000);\n        } else {\n            viewAnimator = ViewCompat.animate(v)\n                    .scaleY(1).scaleX(1)\n                    .setStartDelay((ITEM_DELAY * i) + 500)\n                    .setDuration(500);\n        }\n\n        viewAnimator.setInterpolator(new DecelerateInterpolator()).start();\n    }\n}\n}\n</code></pre>\n\n<p>layout</p>\n\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;FrameLayout\nxmlns:android=\"http://schemas.android.com/apk/res/android\"\nxmlns:tools=\"http://schemas.android.com/tools\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\"\nandroid:background=\"?colorPrimary\"\nandroid:orientation=\"vertical\"\n&gt;\n\n&lt;LinearLayout\n    android:id=\"@+id/container\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:layout_gravity=\"center\"\n    android:gravity=\"center\"\n    android:orientation=\"vertical\"\n    android:paddingTop=\"144dp\"\n    tools:ignore=\"HardcodedText\"\n    &gt;\n\n    &lt;TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center_horizontal\"\n        android:layout_marginTop=\"16dp\"\n        android:alpha=\"0\"\n        android:text=\"Hello world\"         android:textAppearance=\"@style/TextAppearance.AppCompat.Widget.ActionBar.Title.Inverse\"\n        android:textColor=\"@android:color/white\"\n        android:textSize=\"22sp\"\n        tools:alpha=\"1\"\n        /&gt;\n\n    &lt;TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center_horizontal\"\n        android:layout_marginTop=\"8dp\"\n        android:alpha=\"0\"\n        android:gravity=\"center\"\n        android:text=\"This a nice text\"\n      android:textAppearance=\"@style/TextAppearance.AppCompat.Widget.ActionBar.Subtitle.Inverse\"\n        android:textSize=\"20sp\"\n        tools:alpha=\"1\"\n        /&gt;\n\n    &lt;Button\n        android:id=\"@+id/btn_choice1\"\n        android:layout_width=\"200dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginTop=\"48dp\"\n        android:scaleX=\"0\"\n        android:scaleY=\"0\"\n        android:text=\"A nice choice\"\n        android:theme=\"@style/Button\"\n        /&gt;\n\n    &lt;Button\n        android:id=\"@+id/btn_choice2\"\n        android:layout_width=\"200dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginTop=\"4dp\"\n        android:scaleX=\"0\"\n        android:scaleY=\"0\"\n        android:text=\"Far better!\"\n        android:theme=\"@style/Button\"\n        /&gt;\n\n&lt;/LinearLayout&gt;\n\n&lt;ImageView\n    android:id=\"@+id/img_logo\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:layout_gravity=\"center\"\n    android:src=\"@drawable/img_face\"\n    tools:visibility=\"gone\"\n    /&gt;\n&lt;/FrameLayout&gt;\n</code></pre>\n\n<p>img face</p>\n\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:opacity=\"opaque\"&gt;\n\n&lt;item android:drawable=\"?colorPrimary\"/&gt;\n&lt;item&gt;\n    &lt;bitmap\n        android:gravity=\"center\"\n        android:src=\"@drawable/img_face\"/&gt;\n&lt;/item&gt;\n</code></pre>\n\n<p></p>\n\n<p>Add this theme to your splashscreen in the manifest</p>\n\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;resources&gt;\n&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt;\n    &lt;!-- Customize your theme here. --&gt;\n    &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt;\n    &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt;\n    &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt;\n    &lt;item name=\"android:windowBackground\"&gt;@null&lt;/item&gt;\n&lt;/style&gt;\n\n&lt;style name=\"AppTheme.CenterAnimation\"&gt;\n    &lt;item name=\"android:windowBackground\"&gt;@drawable/ll_face_logo&lt;/item&gt;\n&lt;/style&gt;\n</code></pre>\n\n<p></p>\n\n<p>which will produce efect like this</p>\n\n<p><img src=\"https://raw.githubusercontent.com/saulmm/onboarding-examples-android/master/art/center.gif\" alt=\"a busy cat\"></p>\n\n<p>for more details and more solutions you can check this\n<a href=\"http://saulmm.github.io/avoding-android-cold-starts\" rel=\"noreferrer\">BlogPost</a></p>\n","answer_id":37679026,"question_id":37437037,"last_edit_date":1490998158},{"owner":{"profile_image":"https://i.stack.imgur.com/oZ1UM.gif?s=256&g=1","account_id":930090,"user_type":"registered","user_id":960115,"link":"https://stackoverflow.com/users/960115/jeff-g","reputation":4490,"display_name":"Jeff G","accept_rate":92},"content_license":"CC BY-SA 3.0","score":7,"is_accepted":false,"last_activity_date":1489186173,"creation_date":1489186173,"body":"<p>As of Java 8, you can use a lambda to capture parameters that are <a href=\"https://stackoverflow.com/a/20938132/960115\">effectively final</a>.  For example:</p>\n\n<pre><code>final String param1 = \"First param\";\nfinal int param2 = 2;\nnew Thread(() -&gt; {\n    // Do whatever you want here: param1 and param2 are in-scope!\n    System.out.println(param1);\n    System.out.println(param2);\n}).start();\n</code></pre>\n","answer_id":42729024,"question_id":877096,"last_edit_date":1495540988},{"owner":{"profile_image":"https://www.gravatar.com/avatar/6e4992cc0a3d78db161a3a1170148520?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6236104,"user_type":"registered","user_id":4851359,"link":"https://stackoverflow.com/users/4851359/infoj","reputation":681,"display_name":"infoj"},"content_license":"CC BY-SA 3.0","score":8,"is_accepted":false,"last_activity_date":1485703285,"creation_date":1440086295,"body":"<p>Two use cases where threadlocal variable can be used - <br/>\n1- When we have a requirement to associate state with a thread (e.g., a user ID or Transaction ID). That usually happens with a web application that every request going to a servlet has a unique transactionID associated with it.</p>\n\n<pre><code>// This class will provide a thread local variable which\n// will provide a unique ID for each thread\nclass ThreadId {\n    // Atomic integer containing the next thread ID to be assigned\n    private static final AtomicInteger nextId = new AtomicInteger(0);\n\n    // Thread local variable containing each thread's ID\n    private static final ThreadLocal&lt;Integer&gt; threadId =\n        ThreadLocal.&lt;Integer&gt;withInitial(()-&gt; {return nextId.getAndIncrement();});\n\n    // Returns the current thread's unique ID, assigning it if necessary\n    public static int get() {\n        return threadId.get();\n    }\n}\n</code></pre>\n\n<p>Note that here the method withInitial is implemented using lambda expression.<br/>\n2- Another use case is when we want to have a thread safe instance and we don't want to use synchronization as the performance cost with synchronization is more. One such case is when SimpleDateFormat is used. Since SimpleDateFormat is not thread safe so we have to provide mechanism to make it thread safe. </p>\n\n<pre><code>public class ThreadLocalDemo1 implements Runnable {\n    // threadlocal variable is created\n    private static final ThreadLocal&lt;SimpleDateFormat&gt; dateFormat = new ThreadLocal&lt;SimpleDateFormat&gt;(){\n        @Override\n        protected SimpleDateFormat initialValue(){\n            System.out.println(\"Initializing SimpleDateFormat for - \" + Thread.currentThread().getName() );\n            return new SimpleDateFormat(\"dd/MM/yyyy\");\n        }\n    };\n\n    public static void main(String[] args) {\n        ThreadLocalDemo1 td = new ThreadLocalDemo1();\n        // Two threads are created\n        Thread t1 = new Thread(td, \"Thread-1\");\n        Thread t2 = new Thread(td, \"Thread-2\");\n        t1.start();\n        t2.start();\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"Thread run execution started for \" + Thread.currentThread().getName());\n        System.out.println(\"Date formatter pattern is  \" + dateFormat.get().toPattern());\n        System.out.println(\"Formatted date is \" + dateFormat.get().format(new Date()));\n    } \n\n}\n</code></pre>\n","answer_id":32122972,"question_id":817856,"last_edit_date":1485703285},{"owner":{"profile_image":"https://www.gravatar.com/avatar/ee889ac6797f1f23ebb955164162bd39?s=256&d=identicon&r=PG","account_id":2019478,"user_type":"registered","user_id":1806005,"link":"https://stackoverflow.com/users/1806005/hi-my-name-is","reputation":4894,"display_name":"hi_my_name_is","accept_rate":56},"content_license":"CC BY-SA 3.0","score":5,"is_accepted":true,"last_activity_date":1483083594,"creation_date":1483083594,"body":"<p>you may want to play with <code>isolation</code> parameter of<code>@Transactional</code> annotation. Spring by default uses.. hm.. <code>DEFAULT</code> which is set by database, so may be different. You can try to use: <code>READ_UNCOMMITTED</code>. More info: <a href=\"http://www.byteslounge.com/tutorials/spring-transaction-isolation-tutorial\" rel=\"noreferrer\">http://www.byteslounge.com/tutorials/spring-transaction-isolation-tutorial</a></p>\n","answer_id":41392530,"question_id":41391209},{"owner":{"profile_image":"https://www.gravatar.com/avatar/7dfb3c6fe5d0c1f5121d7d6d311fa8ff?s=256&d=identicon&r=PG","account_id":1056981,"user_type":"registered","user_id":1059465,"link":"https://stackoverflow.com/users/1059465/znlyj","reputation":1109,"display_name":"znlyj","accept_rate":43},"content_license":"CC BY-SA 3.0","score":10,"is_accepted":false,"last_activity_date":1480420693,"creation_date":1367162549,"body":"<p>Webapp server may keep a thread pool, and a <code>ThreadLocal</code> var should be removed before response to the client, thus current thread may be reused by next request.</p>\n","answer_id":16264385,"question_id":817856,"last_edit_date":1480420693},{"owner":{"profile_image":"https://www.gravatar.com/avatar/4301e2847b861058706df775f913e02d?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8829249,"user_type":"registered","user_id":6596346,"link":"https://stackoverflow.com/users/6596346/paul","reputation":96,"display_name":"paul","accept_rate":40},"content_license":"CC BY-SA 3.0","score":-1,"is_accepted":false,"last_activity_date":1477174238,"creation_date":1477174238,"body":"<p>Instead of while true in you waitForClient method try this</p>\n\n<pre><code>private final int allowedClients = 10;\nprivate int connectedClients = 0;\npublic void waitForClient () {\n\nboolean isLogPrinted = false;\n\nwhile (connectedClients &lt;= allowedClients){\n    try {\n       if (clientCount &lt; serverThread.length){\n           System.out.println (\"Waiting for connection...\");\n           isLogPrinted = false;\n           addThread (serverSocket.accept());\n           connectedClients++;\n           System.out.println(\"Client count: \" + clientCount);\n       }\n       else {\n           if (!isLogPrinted){\n                System.out.println(\"MAXIMUM NUMBER OF CLIENTS REACHED! (\" + clientCount + \").\");\n                isLogPrinted = true;\n           }\n       }\n   } catch (IOException e) {\n       System.out.println(\"Error while waiting for new clients to connect: \" + e.getMessage());\n        }\n</code></pre>\n\n<p>}\n}</p>\n","answer_id":40197569,"question_id":40197514},{"owner":{"profile_image":"https://i.stack.imgur.com/oJtcB.jpg?s=256&g=1","account_id":6080415,"user_type":"registered","user_id":4746376,"link":"https://stackoverflow.com/users/4746376/sohail-zahid","reputation":8109,"display_name":"Sohail Zahid","accept_rate":73},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1471511197,"creation_date":1471511197,"body":"<p>Both properties works</p>\n\n<pre><code>    &lt;style name=\"AppBaseThemeDark\" parent=\"@style/Theme.AppCompat\"&gt;\n            &lt;!--your other properties --&gt;\n            &lt;!--&lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;--&gt;\n            &lt;item name=\"android:windowBackground\"&gt;@null&lt;/item&gt;\n            &lt;!--your other properties --&gt;\n    &lt;/style&gt;\n</code></pre>\n","answer_id":39014103,"question_id":37437037},{"owner":{"profile_image":"https://i.stack.imgur.com/XiFZh.jpg?s=256&g=1","account_id":1542133,"user_type":"registered","user_id":1955871,"link":"https://stackoverflow.com/users/1955871/rob","reputation":6317,"display_name":"Rob","accept_rate":75},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1469460315,"creation_date":1469460315,"body":"<p>While I am not familiar with Eclipse MAT and what it is showing you, it is proper behavior for some objects to go through the Finalizer queue.</p>\n\n<p>Under normal circumstances, any object that overrides the <code>finalize</code> method will be queued for finalization (which consists of calling the <code>finalize</code> method). The general idea is that when the garbage collector identifies an object as unreachable, it looks to see if the <code>finalize</code> method is overridden and has not yet been called. If <code>finalize</code> is defined and has not yet been called, then the object is queued for finalization, otherwise the memory is collected.</p>\n\n<p>The finalizer appears to be implemented as a queue that is serviced by a single thread. The thread processes each object in the queue by calling <code>finalize</code>. After the call to <code>finalize</code> completes, the object is removed from the queue.</p>\n\n<p>Subsequently, when the garbage collector again determines that the object is unreachable, it will find that <code>finalize</code> is overridden, but has already been called. The member is collected.</p>\n\n<p>Note that using this feature delays collection of garbage. And while it is a convenient way to clean up an object, the JVM does not guarantee when or even if the <code>finalize</code> method will be called.</p>\n\n<p>One related risk is \"finalizer starvation.\" You mention \"growing\" so perhaps this is an issue you are facing. If you create enough garbage that requires finalization and if that finalization takes too long, you can actually run out of memory because the single finalizer queue cannot keep up. There are a number of ways to deal with this situation:</p>\n\n<ul>\n<li>Make execution of <code>finalize</code> complete (infinite loops are bad) and quickly.</li>\n<li>Avoid synchronization in <code>finalize</code>.</li>\n<li>Make the Finalizer thread have the highest execution priority. This can be accomplished by creating a garbage instance that changes the thread priority in the finalizer - create one of these during app initialization.</li>\n</ul>\n\n<p>If you are seeing starvation, use a thread dump to see what the Finalizer thread is working on.</p>\n","answer_id":38571742,"question_id":38570732},{"owner":{"profile_image":"https://www.gravatar.com/avatar/4656523cbdc8a8a57fd218f93f035418?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6441501,"user_type":"registered","user_id":4991382,"link":"https://stackoverflow.com/users/4991382/mihir-patel","reputation":402,"display_name":"Mihir Patel"},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1468411201,"creation_date":1468409804,"body":"<p>No you can't pass parameters to the <code>run()</code> method. The signature tells you that (it has no parameters). Probably the easiest way to do this would be to use a purpose-built object that takes a parameter in the constructor and stores it in a final variable: </p>\n\n<pre><code>public class WorkingTask implements Runnable\n{\n    private final Object toWorkWith;\n\n    public WorkingTask(Object workOnMe)\n    {\n        toWorkWith = workOnMe;\n    }\n\n    public void run()\n    {\n        //do work\n    }\n}\n\n//...\nThread t = new Thread(new WorkingTask(theData));\nt.start();\n</code></pre>\n\n<p>Once you do that - you have to be careful of the data integrity of the object you pass into the 'WorkingTask'. The data will now exist in two different threads so you have to make sure it is Thread Safe.</p>\n","answer_id":38350646,"question_id":877096,"last_edit_date":1468411201},{"owner":{"profile_image":"https://www.gravatar.com/avatar/0d2acc7b8704bde598db2397d141d88f?s=256&d=identicon&r=PG","account_id":139857,"user_type":"registered","user_id":345718,"link":"https://stackoverflow.com/users/345718/patrick","reputation":799,"display_name":"Patrick"},"content_license":"CC BY-SA 3.0","score":8,"is_accepted":false,"last_activity_date":1468386642,"creation_date":1468386642,"body":"<p>Since this issue is still open at the time of writing (version 3.0.X) <a href=\"https://issues.jboss.org/browse/RESTEASY-1357\" rel=\"noreferrer\">RESTEASY: deprecated Apache classes cleanup</a></p>\n\n<p>You can go deeper to use the newer, non-deprecated classes instead to create you resteasy client. You will also have more control over how you want the pool to be etc.</p>\n\n<p>Here is what I did:</p>\n\n<pre><code>// This will create a threadsafe JAX-RS client using pooled connections.\n// Per default this implementation will create no more than than 2\n// concurrent connections per given route and no more 20 connections in\n// total. (see javadoc of PoolingHttpClientConnectionManager)\nPoolingHttpClientConnectionManager cm =\n        new PoolingHttpClientConnectionManager();\n\nCloseableHttpClient closeableHttpClient =\n        HttpClientBuilder.create().setConnectionManager(cm).build();\nApacheHttpClient4Engine engine =\n        new ApacheHttpClient4Engine(closeableHttpClient);\nreturn new ResteasyClientBuilder().httpEngine(engine).build();\n</code></pre>\n\n<p>Also <strong>make sure you release the connection</strong> after making a call. Calling response.close() will do that for you so probably put that in a finally block.</p>\n","answer_id":38343094,"question_id":33097230},{"owner":{"profile_image":"https://www.gravatar.com/avatar/bffea7de598020c514bdca3b0239d865?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8509289,"user_type":"registered","user_id":6379785,"link":"https://stackoverflow.com/users/6379785/gmetal","reputation":2918,"display_name":"gmetal"},"content_license":"CC BY-SA 3.0","score":21,"is_accepted":false,"last_activity_date":1465307102,"creation_date":1465307102,"body":"<p>Have you tried setting the<code>android:windowBackground</code> attribute in the theme of your launcher activity, to either a color or a drawable?</p>\n\n<p>For example this: </p>\n\n<pre><code>&lt;item name=\"android:windowBackground\"&gt;@android:color/black&lt;/item&gt;\n</code></pre>\n\n<p>when added to the Launcher activity theme will show a black color (rather than the white color) on startup. This is an easy trick to hide long initialisation, while showing your users something, <strong>and it works fine</strong> even if you subclass the Application object.</p>\n\n<p>Avoid using other constructs (even Threads) for doing long initialisation tasks, because you may end up not being able to control the lifecycle of such constructs. The Application object is the correct place for doing exactly this type of actions. </p>\n","answer_id":37681189,"question_id":37437037},{"owner":{"profile_image":"https://i.stack.imgur.com/eCkiz.jpg?s=256&g=1","account_id":3251487,"user_type":"registered","user_id":2741598,"link":"https://stackoverflow.com/users/2741598/vickyexpert","reputation":3147,"display_name":"Vickyexpert","accept_rate":50},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1464861962,"creation_date":1464861962,"body":"<p>As you are already aware why this white screen is there, as due to background processes or application initialization or large files, so just check below idea for overcome from this.</p>\n\n<p>To prevent this white screen on beginning of the app, one way is splash screen, this is just a way not final and you must have to use.</p>\n\n<p>When you will show splash screen from your splash.xml file, then also this issue will be remain same,</p>\n\n<p>So you have to create ont style in style.xml file for splash screen and there you have to set window background as your splash image and then apply that theme to your splash activity from manifest file. So now when you will run app, first it will set theme and by this way user will be able to see directly splash image instead of white screen.</p>\n","answer_id":37588748,"question_id":37437037},{"owner":{"profile_image":"https://i.stack.imgur.com/Q57nx.jpg?s=256&g=1","account_id":3016236,"user_type":"registered","user_id":4969827,"link":"https://stackoverflow.com/users/4969827/sergey-shustikov","reputation":15507,"display_name":"Sergey Shustikov"},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1464861958,"creation_date":1464861958,"body":"<p>Did you try to put initialization to <code>onActivityCreated</code>?</p>\n\n<p>Inside <code>Application</code> class :</p>\n\n<pre><code> registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() {\n            @Override\n            public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n                if(activity.getClass().equals(FirstActivity.class) {\n                    // try without runOnUiThread if it will not help\n                    activity.runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            new InitializatioTask().execute();\n                        }\n                    });\n                }\n            }\n\n            @Override\n            public void onActivityStarted(Activity activity) {\n\n            }\n\n            @Override\n            public void onActivityResumed(Activity activity) {\n\n            }\n\n            @Override\n            public void onActivityPaused(Activity activity) {\n\n            }\n\n            @Override\n            public void onActivityStopped(Activity activity) {\n\n            }\n\n            @Override\n            public void onActivitySaveInstanceState(Activity activity, Bundle outState) {\n\n            }\n\n            @Override\n            public void onActivityDestroyed(Activity activity) {\n\n            }\n        });\n</code></pre>\n","answer_id":37588747,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c039fcc583a7df47d9b415dcccd343a4?s=256&d=identicon&r=PG","account_id":1963159,"user_type":"registered","user_id":1764080,"link":"https://stackoverflow.com/users/1764080/shmuel","reputation":3916,"display_name":"Shmuel","accept_rate":65},"content_license":"CC BY-SA 3.0","score":21,"is_accepted":false,"last_activity_date":1464179937,"creation_date":1464179937,"body":"<p>First of all, to remove the white screen read this - <a href=\"https://www.bignerdranch.com/blog/splash-screens-the-right-way/\" rel=\"noreferrer\">https://www.bignerdranch.com/blog/splash-screens-the-right-way/</a></p>\n\n<p>But more importantly, optimize your initial load and defer any heavy work to when you have time to run it. Post your application class here if you want us to take a look at it.</p>\n","answer_id":37437432,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/7ca54b3b9ddb5fa296fa19ac520294ae?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":7265641,"user_type":"registered","user_id":6259238,"link":"https://stackoverflow.com/users/6259238/limestone","reputation":51,"display_name":"Limestone"},"content_license":"CC BY-SA 3.0","score":5,"is_accepted":false,"last_activity_date":1461726649,"creation_date":1461726649,"body":"<p>when?</p>\n\n<p>When an object is not thread-safe, instead of synchronization which hampers the scalability, give one object to every thread and keep it thread scope, which is ThreadLocal. One of most often used but not thread-safe objects are database Connection and JMSConnection. </p>\n\n<p>How ?</p>\n\n<p>One example is Spring framework uses ThreadLocal heavily for managing transactions behind the scenes by keeping these connection objects in ThreadLocal variables. At high level, when a transaction is started it gets the connection ( and disables the auto commit ) and keeps it in ThreadLocal. on further db calls it uses same connection to communicate with db. At the end, it takes the connection from ThreadLocal and commits ( or rollback ) the transaction and releases the connection. </p>\n\n<p>I think log4j also uses ThreadLocal for maintaining MDC.</p>\n","answer_id":36879565,"question_id":817856},{"owner":{"profile_image":"https://www.gravatar.com/avatar/077e85b58e7d2f715ce377c558d3b4ec?s=256&d=identicon&r=PG","account_id":179293,"user_type":"registered","user_id":411846,"link":"https://stackoverflow.com/users/411846/centic","reputation":15713,"display_name":"centic","accept_rate":80},"content_license":"CC BY-SA 3.0","score":13,"is_accepted":false,"last_activity_date":1459849119,"creation_date":1459846446,"body":"<p>Be aware: Apache POI explicitly does not support multi-threading access to the same workbook-object! This is because there are structures that are handled on a workbook-level, e.g. Styles, Comments, ...</p>\n\n<p>You will run into obscure errors and corrupted documents if you try to do this naively. </p>\n\n<p>The only guarantee that it makes is that separate workbooks in different threads will work fine, i.e. there is no thread-unsafe global state kept anywhere.</p>\n\n<p>The only way that should work would be to synchronize every access to the workbook via a synchronized block:</p>\n\n<pre><code>synchronized (workbook) {\n    ... access the sheet and the contents\n}\n</code></pre>\n\n<p>Read-only access might work, but again Apache POI does not make guarantees that concurrent read-access to the same workbook will work.</p>\n\n<p>Update: There is now a corresponding <a href=\"http://poi.apache.org/faq.html#faq-N101BC\" rel=\"noreferrer\">FAQ entry</a> stating this as well.</p>\n","answer_id":36421529,"question_id":28626848,"last_edit_date":1459849119},{"owner":{"profile_image":"https://www.gravatar.com/avatar/99266f63196c82aaeb18e36727424c07?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":3869264,"user_type":"registered","user_id":3204950,"link":"https://stackoverflow.com/users/3204950/rameshvanka","reputation":51,"display_name":"rameshvanka"},"content_license":"CC BY-SA 3.0","score":-1,"is_accepted":false,"last_activity_date":1459845993,"creation_date":1459844383,"body":"<p>Inside the main thread create the workbook, workbook create the sheets and distribute the sheets to worker thread. main thread should wait until all the worker thread completes. main thread workbook the flush the data into stream. then stream into file.</p>\n\n<p>If you want source code with example, send a mail to me. I will share ramesh.niwas@gmail.com</p>\n","answer_id":36420786,"question_id":28626848,"last_edit_date":1459845993},{"owner":{"profile_image":"https://www.gravatar.com/avatar/07a4fda1c1cd6f2a3168d7fbb72dcc16?s=256&d=identicon&r=PG","account_id":7882823,"user_type":"registered","user_id":5956116,"link":"https://stackoverflow.com/users/5956116/pavel-pscheidl","reputation":344,"display_name":"Pavel Pscheidl"},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1458491585,"creation_date":1458491585,"body":"<p>First, do not reuse WebTarget. For simplicity, you can always create new WebTarget.</p>\n\n<p>Second, if you're using Resteasy, you can add provided dependency for Resteasy client to your project. Example in Gradle:</p>\n\n<pre><code>    provided 'org.jboss.resteasy:resteasy-client:3.0.14.Final'\n</code></pre>\n\n<p>Then, you can create your connection like this:</p>\n\n<pre><code>        ResteasyClientBuilder builder = new ResteasyClientBuilder();\n        builder.connectionPoolSize(200);\n</code></pre>\n\n<p>There is no need to set maxPooledPerRoute, this is set automatically by RestEasy (can be found in RestEasyClientBuilder class source code).</p>\n\n<p>When you set connectionPoolSize, you will no longer get error when Client is reused and you can happily re-use them all across the application. I've tried this solution on many projects and it actually works well. But when you deploy your application to a non-resteasy container (like Glassfish), your code won't work and you will have to use ClientBuilder class again.</p>\n","answer_id":36116402,"question_id":33097230},{"owner":{"profile_image":"https://i.stack.imgur.com/xpNqK.jpg?s=256&g=1","account_id":426109,"user_type":"registered","user_id":807126,"link":"https://stackoverflow.com/users/807126/doug-stevenson","reputation":302042,"display_name":"Doug Stevenson"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":true,"last_activity_date":1457491340,"creation_date":1457491340,"body":"<p>You can remove previously posted Runnables using the <a href=\"http://developer.android.com/reference/android/os/Handler.html#removeCallbacks(java.lang.Runnable)\" rel=\"nofollow\">removeCallbacks()</a> method on the Handler used to post them.  You will need to have the <em>exact</em> reference to the Runnable posted.</p>\n\n<p>In your code, you post a Runnable while declaring it anonymously inline.  If you do that, won't retain a reference to that Runnable.  Instead, you can store the reference to that new Runnable in a member variable or something that won't be forgotten by the time you want to remove it.</p>\n\n<pre><code>private Runnable r;  // assign before use\nprivate Handler h;   // assign before use\n\nprivate void schedule() {\n    h.postDelayed(r, 99999);\n}\n\nprivate void cancel() {\n    h.removeCallbacks(r);\n}\n</code></pre>\n","answer_id":35881920,"question_id":35881814},{"owner":{"profile_image":"https://i.stack.imgur.com/7H9TF.png?s=256&g=1","account_id":2994830,"user_type":"registered","user_id":2541560,"link":"https://stackoverflow.com/users/2541560/kayaman","reputation":1,"display_name":"Kayaman"},"content_license":"CC BY-SA 3.0","score":3,"is_accepted":false,"last_activity_date":1456390979,"creation_date":1456390979,"body":"<p>Unless you call <code>p.waitFor();</code> your process will happily run concurrently alongside the process that it spawned (<code>p</code>).</p>\n","answer_id":35622631,"question_id":35622593},{"owner":{"profile_image":"https://www.gravatar.com/avatar/bb15dcf43c8fe4a01b9d16e93690e118?s=256&d=identicon&r=PG","account_id":543250,"user_type":"registered","user_id":912319,"link":"https://stackoverflow.com/users/912319/kanagavelu-sugumar","reputation":18874,"display_name":"Kanagavelu Sugumar","accept_rate":62},"content_license":"CC BY-SA 3.0","score":5,"is_accepted":false,"last_activity_date":1452144546,"creation_date":1449058064,"body":"<blockquote>\n  <p>ThreadLocal will ensure accessing the mutable object by the multiple\n  threads in the non synchronized method is synchronized, means making\n  the mutable object to be immutable within the method. <BR> <BR> This\n  is achieved by giving new instance of mutable object for each thread\n  try accessing it. So It is local copy to the each thread. This is some\n  hack on making instance variable in a method to be accessed like a\n  local variable. As you aware method local variable is only available\n  to the thread, one difference is; method local variables will not\n  available to the thread once method execution is over where as mutable\n  object shared with threadlocal will be available across multiple\n  methods till we clean it up.</p>\n</blockquote>\n\n<p><strong>By Definition:</strong></p>\n\n<blockquote>\n  <p>The ThreadLocal class in Java enables you to create variables that can\n  only be read and written by the same thread. Thus, even if two threads\n  are executing the same code, and the code has a reference to a\n  ThreadLocal variable, then the two threads cannot see each other's\n  ThreadLocal variables.</p>\n</blockquote>\n\n<p>Each <code>Thread</code> in java contains <code>ThreadLocalMap</code> in it. <BR>\nWhere <BR></p>\n\n<pre><code>Key = One ThreadLocal object shared across threads.\nvalue = Mutable object which has to be used synchronously, this will be instantiated for each thread.\n</code></pre>\n\n<p><strong>Achieving the ThreadLocal:</strong> </p>\n\n<p>Now create a wrapper class for ThreadLocal which is going to hold the mutable object like below (with or without <code>initialValue()</code>). <BR> Now getter and setter of this wrapper will work on threadlocal instance instead of mutable object.</p>\n\n<p>If getter() of threadlocal didn't find any value with in the threadlocalmap of the <code>Thread</code>; then it will invoke the initialValue() to get its private copy with respect to the thread.</p>\n\n<pre><code>class SimpleDateFormatInstancePerThread {\n\n    private static final ThreadLocal&lt;SimpleDateFormat&gt; dateFormatHolder = new ThreadLocal&lt;SimpleDateFormat&gt;() {\n\n        @Override\n        protected SimpleDateFormat initialValue() {\n            SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\") {\n                UUID id = UUID.randomUUID();\n                @Override\n                public String toString() {\n                    return id.toString();\n                };\n            };\n            System.out.println(\"Creating SimpleDateFormat instance \" + dateFormat +\" for Thread : \" + Thread.currentThread().getName());\n            return dateFormat;\n        }\n    };\n\n    /*\n     * Every time there is a call for DateFormat, ThreadLocal will return calling\n     * Thread's copy of SimpleDateFormat\n     */\n    public static DateFormat getDateFormatter() {\n        return dateFormatHolder.get();\n    }\n\n    public static void cleanup() {\n        dateFormatHolder.remove();\n    }\n}\n</code></pre>\n\n<p>Now <code>wrapper.getDateFormatter()</code> will call <code>threadlocal.get()</code> and that will check the <code>currentThread.threadLocalMap</code> contains <strong>this</strong> (threadlocal) instance.<BR>\nIf yes return the value (SimpleDateFormat) for corresponding threadlocal instance <BR>\nelse add the map with this threadlocal instance, initialValue(). <BR></p>\n\n<p>Herewith thread safety achieved on this mutable class; by each thread is working with its own mutable instance but with same ThreadLocal instance. Means All the thread will share the same ThreadLocal instance as key, but different SimpleDateFormat instance as value.</p>\n\n<p><a href=\"https://github.com/skanagavelu/yt.tech/blob/master/src/ThreadLocalTest.java\" rel=\"noreferrer\">https://github.com/skanagavelu/yt.tech/blob/master/src/ThreadLocalTest.java</a></p>\n","answer_id":34042362,"question_id":817856,"last_edit_date":1452144546},{"owner":{"profile_image":"https://i.stack.imgur.com/lwpFY.png?s=256&g=1","account_id":6764092,"user_type":"registered","user_id":5264490,"link":"https://stackoverflow.com/users/5264490/chromium","reputation":517,"display_name":"Chromium","accept_rate":100},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1452136702,"creation_date":1452136702,"body":"<p>There is a simple way of passing parameters into runnables.\nCode:</p>\n\n<pre><code>public void Function(final type variable) {\n    Runnable runnable = new Runnable() {\n        public void run() {\n            //Code adding here...\n        }\n    };\n    new Thread(runnable).start();\n}\n</code></pre>\n","answer_id":34646813,"question_id":877096},{"owner":{"profile_image":"https://www.gravatar.com/avatar/3e83e511e401770207ffbb0d31b8ffb4?s=256&d=identicon&r=PG","account_id":916980,"user_type":"registered","user_id":2580516,"link":"https://stackoverflow.com/users/2580516/warren-dew","reputation":8820,"display_name":"Warren Dew"},"content_license":"CC BY-SA 3.0","score":8,"is_accepted":false,"last_activity_date":1446016175,"creation_date":1446016175,"body":"<p>In the case of multithreaded code with both reads and writes, if a thread neglects to obtain a lock while reading, it risks reading inconsistent or garbage data due to a simultaneous write.  For example, it could read a long variable just as that long variable was being written, and it could read the high half of the old value and the low half of the new value, which means the value it read would be complete garbage, something that was never actually written.</p>\n\n<p>If a thread with a read lock writes without the write lock, it could cause other reading threads to read garbage data in a similar manner.</p>\n","answer_id":33384952,"question_id":33384822},{"owner":{"profile_image":"https://i.stack.imgur.com/XpMUU.jpg?s=256&g=1","account_id":1431364,"user_type":"registered","user_id":1353722,"link":"https://stackoverflow.com/users/1353722/lefloh","reputation":10713,"display_name":"lefloh","accept_rate":81},"content_license":"CC BY-SA 3.0","score":9,"is_accepted":false,"last_activity_date":1444797794,"creation_date":1444797794,"body":"<p>Your implementation is not thread-safe. When two threads access <code>someMethod</code> at the same time they are sharing the same <code>Client</code> and one will try to make a second request while the first one is not finished. </p>\n\n<p>You have two choices:</p>\n\n<ul>\n<li>Synchronize the access to the <code>Client</code> and <code>WebTarget</code> manually.</li>\n<li>Let the container manage concurrency by annotating the enclosing type with <code>@javax.ejb.Singleton</code> which guarantees thread safety. (see chapter 4.8.5 of the <a href=\"http://download.oracle.com/otn-pub/jcp/ejb-3.1-pfd-oth-JSpec/ejb-3_1-pfd-spec.pdf\" rel=\"noreferrer\">EJB specification</a>)</li>\n</ul>\n\n<p>If <code>someMethod</code> in a container managed environment I would use the second approach.</p>\n","answer_id":33116773,"question_id":33097230},{"owner":{"profile_image":"https://i.stack.imgur.com/rHVf5.jpg?s=256&g=1","account_id":2353205,"user_type":"registered","user_id":2061604,"link":"https://stackoverflow.com/users/2061604/andrei","reputation":43254,"display_name":"Andrei","accept_rate":73},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1441713166,"creation_date":1441712019,"body":"<h2>Specially for Android</h2>\n\n<p>For callback purposes I usually implement my own generic <code>Runnable</code> with input parameter(s):</p>\n\n<pre><code>public interface Runnable&lt;TResult&gt; {\n    void run(TResult result);\n}\n</code></pre>\n\n<p>Usage is simple:</p>\n\n<pre><code>myManager.doCallbackOperation(new Runnable&lt;MyResult&gt;() {\n    @Override\n    public void run(MyResult result) {\n        // do something with the result\n    }\n});\n</code></pre>\n\n<p>In manager:</p>\n\n<pre><code>public void doCallbackOperation(Runnable&lt;MyResult&gt; runnable) {\n    new AsyncTask&lt;Void, Void, MyResult&gt;() {\n        @Override\n        protected MyResult doInBackground(Void... params) {\n            // do background operation\n            return new MyResult(); // return resulting object\n        }\n\n        @Override\n        protected void onPostExecute(MyResult result) {\n            // execute runnable passing the result when operation has finished\n            runnable.run(result);\n        }\n    }.execute();\n}\n</code></pre>\n","answer_id":32456728,"question_id":877096,"last_edit_date":1441713166},{"owner":{"profile_image":"https://www.gravatar.com/avatar/1768cce8ccf2dffe3483b0ab5d7cfd74?s=256&d=identicon&r=PG","account_id":10987,"user_type":"registered","user_id":21005,"link":"https://stackoverflow.com/users/21005/mnementh","reputation":50685,"display_name":"Mnementh","accept_rate":78},"content_license":"CC BY-SA 3.0","score":9,"is_accepted":false,"last_activity_date":1440141330,"creation_date":1242643320,"body":"<p>To create a thread you normally create your own implementation of Runnable. Pass the parameters to the thread in the constructor of this class.</p>\n\n<pre><code>class MyThread implements Runnable{\n   private int a;\n   private String b;\n   private double c;\n\n   public MyThread(int a, String b, double c){\n      this.a = a;\n      this.b = b;\n      this.c = c;\n   }\n\n   public void run(){\n      doSomething(a, b, c);\n   }\n}\n</code></pre>\n","answer_id":877116,"question_id":877096,"last_edit_date":1440141330},{"owner":{"profile_image":"https://www.gravatar.com/avatar/699a9b2caefb52530d1c872bb2932d21?s=256&d=identicon&r=PG","account_id":22965,"user_type":"registered","user_id":57159,"link":"https://stackoverflow.com/users/57159/ian-ringrose","reputation":51428,"display_name":"Ian Ringrose","accept_rate":89},"content_license":"CC BY-SA 3.0","score":3,"is_accepted":false,"last_activity_date":1434388741,"creation_date":1434388741,"body":"<p>Caching, sometime you have to calculate the same value lots of time so by storing the last set of inputs to a method and the result you can speed the code up.    By using Thread Local Storage you avoid having to think about locking.</p>\n","answer_id":30851175,"question_id":817856},{"owner":{"profile_image":"https://i.stack.imgur.com/vpL92.jpg?s=256&g=1","account_id":1487826,"user_type":"registered","user_id":1404798,"link":"https://stackoverflow.com/users/1404798/thirumalvalavan","reputation":2690,"display_name":"Thirumalvalavan"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1426175165,"creation_date":1426175165,"body":"<p>Below code will help to someone,</p>\n\n<pre><code>public class MyClass {\n\nprivate static Object lock = new Object();\n\npublic static void main(String args[]){\n\n    Runnable runnable1 = new Runnable() {\n        @Override\n        public void run() {\n            for(int i=1; i&lt;20; i=i+2){\n                synchronized (lock) {\n                    System.out.println(\"Thread 1: \"+i);\n                    try {\n                        lock.notifyAll();\n                        lock.wait();\n                    } catch (InterruptedException e) {\n                        System.out.println(\"Error in Thread 1: \"+e.getMessage());\n                    }\n                }\n            }\n        }\n    };\n\n\n    Runnable runnable2 = new Runnable() {\n        @Override\n        public void run() {\n            for(int i=2; i&lt;=20; i=i+2){\n                synchronized (lock) {\n                    System.out.println(\"Thread 2: \"+i);\n                    try {\n                        lock.notifyAll();\n                        lock.wait();\n                    } catch (InterruptedException e) {\n                        System.out.println(\"Error in Thread 2: \"+e.getMessage());\n                    }\n                }\n            }\n        }\n    };\n\n    Thread thread1 = new Thread(runnable1);\n    Thread thread2 = new Thread(runnable2);\n\n    System.out.println(\"Thread Start: \");\n    thread1.start();\n    thread2.start();               \n}\n\n}\n</code></pre>\n","answer_id":29014237,"question_id":24720849},{"owner":{"profile_image":"https://www.gravatar.com/avatar/6196764c912dbcdd37f80cccf20d73b0?s=256&d=identicon&r=PG","account_id":5733087,"user_type":"registered","user_id":4528039,"link":"https://stackoverflow.com/users/4528039/t-gounelle","reputation":6013,"display_name":"T.Gounelle"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1424432344,"creation_date":1424432344,"body":"<p>You create a <code>XSSFWorkbook</code> by reading the file <code>C:/Test.xlsx</code> ; the constructor called is <a href=\"http://poi.apache.org/apidocs/org/apache/poi/xssf/usermodel/XSSFWorkbook.html#XSSFWorkbook(java.io.InputStream)\" rel=\"nofollow\"><code>XSSFWorkbook(InputStream)</code></a>, which constructs a <code>OPCPackage</code>. \nThis <code>C:/Test.xlsx</code> file has to be valid, i.e. not corrupted, not empty.</p>\n\n<p>If you want to create a <em>new</em> workbook, you should not read an empty file, but rather use the appropriate constructor.</p>\n\n<p>Regarding multi-threading, I haven't tested it but there are constraints on what the different threads can do (e.g. one per <code>XSSheet</code>). Look at this <a href=\"https://mail-archives.apache.org/mod_mbox/poi-user/201109.mbox/%3C1314859350817-4757295.post@n5.nabble.com%3E\" rel=\"nofollow\">mail archive</a>.</p>\n","answer_id":28628085,"question_id":28626848},{"owner":{"profile_image":"https://www.gravatar.com/avatar/0f72a37ab8103ebfa12561218367ec3a?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":395357,"user_type":"registered","user_id":758280,"link":"https://stackoverflow.com/users/758280/jeffrey","reputation":44547,"display_name":"Jeffrey","accept_rate":100},"content_license":"CC BY-SA 3.0","score":3,"is_accepted":true,"last_activity_date":1420236923,"creation_date":1420179624,"body":"<p>I feel like it's more straightforward to implement this with one <code>Queue</code> for each producer. One thread can't wait on multiple <code>Queue</code>s, but you could combine all of the <code>Queue</code>s into one helper class so that it doesn't need to.</p>\n\n<pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Queue;\nimport java.util.concurrent.PriorityBlockingQueue;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nimport javax.annotation.concurrent.GuardedBy;\n\npublic class RoundRobin&lt;P, E&gt; {\n    private final Lock lock = new ReentrantLock();\n    private final Condition added = lock.newCondition();\n\n    @GuardedBy(\"lock\") private final Map&lt;P, Queue&lt;E&gt;&gt; queues = new LinkedHashMap&lt;&gt;();\n\n    public boolean add(P producer, E item) {\n        lock.lock();\n        try {\n            if (!queues.containsKey(producer)) {\n                queues.put(producer, new PriorityBlockingQueue&lt;&gt;());\n            }\n\n            added.signalAll();\n            return queues.get(producer).add(item);\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public Iterator&lt;E&gt; roundRobinIterator() {\n        return new Iterator&lt;E&gt;() {\n            private Iterator&lt;? extends Queue&lt;E&gt;&gt; i = null;\n            private boolean singlePass = true;\n\n            @Override\n            public boolean hasNext() {\n                return true;\n            }\n\n            @Override\n            public E next() {\n                lock.lock();\n                try {\n                    while (true) {\n                        if (i == null || !i.hasNext()) {\n                            i = queues.values().iterator();\n                            singlePass = true;\n                        }\n\n                        while (i.hasNext()) {\n                            Queue&lt;E&gt; q = i.next();\n                            if (!q.isEmpty()) {\n                                if (singlePass) {\n                                    // copy the iterator to prevent\n                                    // ConcurrentModificationExceptions\n                                    singlePass = false;\n                                    i = copy(i);\n                                }\n                                return q.poll();\n                            }\n                        }\n\n                        if (singlePass) {\n                            // If singlePass is true then we just checked every\n                            // queue and they were all empty.\n                            // Wait for another element to be added.\n                            added.await();\n                        }\n                    }\n                } catch (InterruptedException e) {\n                    throw new NoSuchElementException(e.getMessage());\n                } finally {\n                    lock.unlock();\n                }\n            }\n\n            private &lt;T&gt; Iterator&lt;? extends T&gt; copy(Iterator&lt;? extends T&gt; i) {\n                List&lt;T&gt; copy = new ArrayList&lt;&gt;();\n                while (i.hasNext()) {\n                    copy.add(i.next());\n                }\n                return copy.iterator();\n            }\n        };\n    }\n}\n</code></pre>\n","answer_id":27738182,"question_id":27737781,"last_edit_date":1420236923},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b5daee5ebc4e63ae694a4a68c902c2e8?s=256&d=identicon&r=PG","account_id":27505,"user_type":"registered","user_id":72673,"link":"https://stackoverflow.com/users/72673/maurice-perry","reputation":32693,"display_name":"Maurice Perry","accept_rate":72},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1420186136,"creation_date":1420186136,"body":"<p>I think I would do something like that:</p>\n\n<pre><code>import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class RRQueue&lt;M&gt; {\n    private final ThreadLocal&lt;Queue&lt;M&gt;&gt; threadQueue = new ThreadLocal&lt;&gt;();\n    private final List&lt;Queue&lt;M&gt;&gt; queues;\n    private int current = 0;\n\n    public RRQueue() {\n        this.queues = new ArrayList&lt;&gt;();\n    }\n\n    public synchronized void add(M msg) {\n        Queue&lt;M&gt; queue = threadQueue.get();\n        if (queue == null) {\n            queue = new LinkedList&lt;&gt;(); // or whatever\n            queues.add(queue);\n            threadQueue.set(queue);\n        }\n        queue.add(msg);\n        notify();\n    }\n\n    public synchronized M get() throws InterruptedException {\n        while (true) {\n            for (int i = 0; i &lt; queues.size(); ++i) {\n                Queue&lt;M&gt; queue = queues.get(current);\n                current = (current+1)%queues.size();\n                if (!queue.isEmpty()) {\n                    return queue.remove();\n                }\n            }\n            wait();\n        }\n    }\n}\n</code></pre>\n","answer_id":27739235,"question_id":27737781},{"owner":{"profile_image":"https://www.gravatar.com/avatar/5cfe5f7d64f44be04f147295f5c7b88e?s=256&d=identicon&r=PG","account_id":71739,"user_type":"registered","user_id":207421,"link":"https://stackoverflow.com/users/207421/user207421","reputation":307163,"display_name":"user207421","accept_rate":82},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1420181770,"creation_date":1420181770,"body":"<p>It's all in how you allocate the IDs. Allocate them <em>N</em> apart, where <em>N</em> is the number of producers, and add each producer's index to that. Then reading them sequentially will yield a round-robin order. You'll have a tiny bit of bookkeeping to do to know when to increment the underlying ID, which will happen when you reach <em>Nx-1</em> for any <em>x</em>.</p>\n","answer_id":27738534,"question_id":27737781},{"owner":{"profile_image":"https://www.gravatar.com/avatar/d3c9a4e663c77df1fe4888da3ba85bcc?s=256&d=identicon&r=PG","account_id":37853,"user_type":"registered","user_id":108350,"link":"https://stackoverflow.com/users/108350/will","reputation":4899,"display_name":"will","accept_rate":32},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1419286796,"creation_date":1419286796,"body":"<p>One further option; this approach lets you use the Runnable item like an asynchronous function call.  If your task does not need to return a result, e.g. it just performs some action you don't need to worry about how you pass back an \"outcome\".</p>\n\n<p>This pattern lets you reuse an item, where you need some kind of internal state.  When not passing  parameter(s) in the constructor care is needed to mediate the programs access to parameters.  You may need more checks if your use-case involves different callers, etc.</p>\n\n<pre><code>public class MyRunnable implements Runnable \n{\n  private final Boolean PARAMETER_LOCK  = false;\n  private X parameter;\n\n  public MyRunnable(X parameter) {\n     this.parameter = parameter;\n  }\n\n  public void setParameter( final X newParameter ){\n\n      boolean done = false;\n      synchronize( PARAMETER_LOCK )\n      {\n          if( null == parameter )\n          {\n              parameter = newParameter;\n              done = true;\n          }\n      }\n      if( ! done )\n      {\n          throw new RuntimeException(\"MyRunnable - Parameter not cleared.\" );\n      }\n  }\n\n\n  public void clearParameter(){\n\n      synchronize( PARAMETER_LOCK )\n      {\n          parameter = null;\n      }\n  }\n\n\n  public void run() {\n\n      X localParameter;\n\n      synchronize( PARAMETER_LOCK )\n      {\n          localParameter = parameter;\n      }\n\n      if( null != localParameter )\n      {\n         clearParameter();   //-- could clear now, or later, or not at all ...\n         doSomeStuff( localParameter );\n      }\n\n  }\n</code></pre>\n\n<p>}</p>\n\n<p>Thread t = new Thread(new MyRunnable(parameter));\n   t.start();</p>\n\n<p>If you need a result of processing, you will also need to coordinate completion of MyRunnable when the sub-task finishes.  You could pass a call back or just wait on the Thread 't', etc.</p>\n","answer_id":27611318,"question_id":877096},{"owner":{"profile_image":"https://www.gravatar.com/avatar/293f86043bc0fb6dba1190ad388c9d27?s=256&d=identicon&r=PG","account_id":279913,"user_type":"registered","user_id":575338,"link":"https://stackoverflow.com/users/575338/mavarazy","reputation":7622,"display_name":"mavarazy","accept_rate":59},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1416477893,"creation_date":1416472636,"body":"<p>Why not just use await with timeout?</p>\n\n<pre><code>boolean await(long timeout, TimeUnit unit);\n</code></pre>\n\n<p>If the specified waiting time elapses then the value false is returned, otherwise true is returned on await completion.</p>\n\n<p><a href=\"https://stackoverflow.com/questions/15245629/abort-countdownlatch-await-after-time-out\">Abort countDownLatch.await() after time out</a></p>\n\n<p>If you want to stop execution of other threads, if any thread fails - you'll need some additional communication layer.</p>\n\n<p>For example:</p>\n\n<pre><code>AtomicBoolean kill = new AtomicBoolean(false);\nCountDownLatch latch = new CountDownLatch(SOME_NUM);\n\nclass Task extends Runnable {\n     public void run() {\n         try {\n              ....\n              if (kill.get())\n                  throw new Exception();\n              ....\n         } catch (Throwable throwable) {\n            kill.set(true);\n         } finally {\n            countDownLatch.countDown();\n         }\n     }\n}\n</code></pre>\n\n<p>If you just want to release count down on Throwable, regardless of other processes, you can do countDown in loop on Exception</p>\n\n<pre><code>class Task extends Runnable {\n     public void run() {\n         try {\n              ....\n         } catch (Throwable throwable) {\n            while(countDownLatch.getCount() != 0)\n               countDownLatch.countDown();\n         } finally {\n            countDownLatch.countDown();\n         }\n     }\n}\n</code></pre>\n\n<p>You can combine 2 countDown tasks</p>\n\n<pre><code>CountDownLatch A = new CountDownLatch(1);\nCountDownLatch B = new CountDownLatch(1);\n\nclass CountDownTracker extend Runnable {\n     public void run() {\n         B.await();\n         A.countDown();\n     }\n}\n\nclass Task extends Runnable {\n     public void run() {\n         try {\n              ....\n         } catch (Throwable throwable) {\n            A.countDown();\n         } finally {\n            B.countDown();\n         }\n     }\n}\n</code></pre>\n\n<p>in this case A will finish after completion, or any Task failure.</p>\n\n<p>And so on...</p>\n","answer_id":27035047,"question_id":27034958,"last_edit_date":1495542446},{"owner":{"profile_image":"https://i.stack.imgur.com/KQO5i.png?s=256&g=1","account_id":3359040,"user_type":"registered","user_id":2821298,"link":"https://stackoverflow.com/users/2821298/andreas-aumayr","reputation":1006,"display_name":"Andreas Aumayr"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1416474230,"creation_date":1416474230,"body":"<p>In addition to the other answers:</p>\n\n<p>it depends on what \"but if something fails\" means, but if failing means you catch an Exception in a worker thread, you may count down the latch within the catch clause as well. This of course changes the meaning of countDown from \"Successfully processed\" to \"processing complete\" - so your code has to handle this..</p>\n","answer_id":27035517,"question_id":27034958},{"owner":{"profile_image":"https://www.gravatar.com/avatar/f61fbcc7c59e134d888f2e34cd216658?s=256&d=identicon&r=PG","account_id":1390639,"user_type":"registered","user_id":1321564,"link":"https://stackoverflow.com/users/1321564/benjamin-m","reputation":23879,"display_name":"Benjamin M","accept_rate":71},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1416472443,"creation_date":1416472443,"body":"<p>You could use a <code>Semaphore</code>, which is close to a <code>CountDownLatch</code> and it's impl has methods for manipulating it: <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html\" rel=\"nofollow\">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html</a></p>\n","answer_id":27034992,"question_id":27034958},{"owner":{"profile_image":"https://i.stack.imgur.com/tr7wR.jpg?s=256&g=1","account_id":2524075,"user_type":"registered","user_id":2193767,"link":"https://stackoverflow.com/users/2193767/thelostmind","reputation":36076,"display_name":"TheLostMind","accept_rate":78},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1416472433,"creation_date":1416472433,"body":"<p>The <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html\" rel=\"nofollow\">CountDownLatch</a> has an overloaded <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html#await(long,%20java.util.concurrent.TimeUnit)\" rel=\"nofollow\">await()</a> method which takes <em>time</em> and <em>time unit</em> as inputs and releases the lock once the given time elapses</p>\n","answer_id":27034988,"question_id":27034958},{"owner":{"profile_image":"https://www.gravatar.com/avatar/67f2ccd17aa6fd622152ad88fc2ae784?s=256&d=identicon&r=PG","account_id":422870,"user_type":"registered","user_id":801894,"link":"https://stackoverflow.com/users/801894/solomon-slow","reputation":25925,"display_name":"Solomon Slow"},"content_license":"CC BY-SA 3.0","score":31,"is_accepted":true,"last_activity_date":1415369583,"creation_date":1415369124,"body":"<blockquote>\n  <p>aren't they both doing the same task - waiting so that other threads can execute?</p>\n</blockquote>\n\n<p>Not even close, because <code>yield()</code> does not <em>wait</em> for anything.</p>\n\n<p>Every thread can be in one of a number of different states:  <em>Running</em> means that the thread is actually running on a CPU, <em>Runnable</em> means that nothing is preventing the thread from running except, maybe the availability of a CPU for it to run on.  All of the other states can be lumped into a category called <em>blocked</em>.  A blocked thread is a thread that is waiting for something to happen before it can become runnable.</p>\n\n<p>The operating system <em>preempts</em> running threads on a regular basis:  Every so often (between 10 times per second and 100 times per second on most operating systems) the OS tags each running thread and says, \"your turn is up, go to the back of the run queue' (i.e., change state from running to runnable).  Then it lets whatever thread is at the head of the run queue use that CPU (i.e., become running again).</p>\n\n<p>When your program calls <code>Thread.yield()</code>, it's saying to the operating system, \"I still have work to do, but it might not be as important as the work that some other thread is doing.  Please send me to the back of the run queue right now.\"  If there is an available CPU for the thread to run on though, then it effectively will just keep running (i.e., the yield() call will immediately return).</p>\n\n<p>When your program calls <code>foobar.wait()</code> on the other hand, it's saying to the operating system, \"Block me until some other thread calls <code>foobar.notify()</code>.</p>\n\n<p>Yielding was first implemented on non-preemptive operating systems and, in non-preemptive threading libraries.  On a computer with only one CPU, the <em>only</em> way that more than one thread ever got to run was when the threads explicitly yielded to one another.</p>\n\n<p>Yielding also was useful for <em>busy waiting</em>.  That's where a thread waits for something to happen by sitting in a tight loop, testing the same condition over and over again.  If the condition depended on some other thread to do some work, the waiting thread would yield() each time around the loop in order to let the other thread do its work.</p>\n\n<p>Now that we have preemption and multiprocessor systems and libraries that provide us with higher-level synchronization objects, there is basically no reason why an application programs would need to call <code>yield()</code> anymore.</p>\n","answer_id":26803040,"question_id":26798073,"last_edit_date":1415369583},{"owner":{"profile_image":"https://i.stack.imgur.com/t2hoD.jpg?s=256&g=1","account_id":3211603,"user_type":"registered","user_id":2711488,"link":"https://stackoverflow.com/users/2711488/holger","reputation":289317,"display_name":"Holger"},"content_license":"CC BY-SA 3.0","score":8,"is_accepted":false,"last_activity_date":1415354856,"creation_date":1415354856,"body":"<p><code>wait</code> is for <em>waiting</em> on a condition. This might not jump into the eye when looking at the method as it is entirely up to you to define what kind of condition it is. But the API tries to force you to use it correctly by requiring that you own the monitor of the object on which you are waiting, which is necessary for a correct condition check in a multi-threaded environment.</p>\n\n<p>So a correct use of <code>wait</code> looks like:</p>\n\n<pre><code>synchronized(object) {\n  while( ! /* your defined condition */)\n    object.wait();\n  /* execute other critical actions if needed */\n}\n</code></pre>\n\n<p>And it must be paired with another thread executing code like:</p>\n\n<pre><code>synchronized(object) {\n  /* make your defined condition true */)\n  object.notify();\n}\n</code></pre>\n\n<hr>\n\n<p>In contrast <code>Thread.yield()</code> is just a <em>hint</em> that your thread might release the CPU at this point of time. It’s not specified whether it actually does anything and, regardless of whether the CPU has been released or not, it has no impact on the semantics in respect to the memory model. In other words, it does not create any relationship to other threads which would be required for accessing shared variables correctly.</p>\n\n<p>For example the following loop accessing <code>sharedVariable</code> (which is not declared <code>volatile</code>) might run forever without ever noticing updates made by other threads:</p>\n\n<pre><code>while(sharedVariable != expectedValue) Thread.yield();\n</code></pre>\n\n<p>While <code>Thread.yield</code> might help other threads to run (they will run anyway on most systems), it does <em>not</em> enforce re-reading the value of <code>sharedVariable</code> from the shared memory. Thus, without other constructs enforcing memory visibility, e.g. decaring <code>sharedVariable</code> as <code>volatile</code>, this loop is broken.</p>\n","answer_id":26798737,"question_id":26798073},{"owner":{"profile_image":"https://www.gravatar.com/avatar/38750c50c11e6054c2123073b17b18fc?s=256&d=identicon&r=PG","account_id":11369,"user_type":"registered","user_id":21886,"link":"https://stackoverflow.com/users/21886/richiehindle","reputation":274348,"display_name":"RichieHindle","accept_rate":88},"content_license":"CC BY-SA 3.0","score":11,"is_accepted":false,"last_activity_date":1393507894,"creation_date":1241381121,"body":"<p><a href=\"http://docs.oracle.com/javase/7/docs/api/java/lang/ThreadLocal.html\" rel=\"noreferrer\">The documentation</a> says it very well: \"each thread that accesses [a thread-local variable] (via its get or set method) has its own, independently initialized copy of the variable\".</p>\n\n<p>You use one when each thread must have its own copy of something.  By default, data is shared between threads.</p>\n","answer_id":817864,"question_id":817856,"last_edit_date":1393507894},{"owner":{"profile_image":"https://www.gravatar.com/avatar/33feea54e02fb1147b41d2edb88659dd?s=256&d=identicon&r=PG","account_id":3684,"user_type":"registered","user_id":5346,"link":"https://stackoverflow.com/users/5346/nick-fortescue","reputation":43315,"display_name":"Nick Fortescue","accept_rate":84},"content_license":"CC BY-SA 3.0","score":128,"is_accepted":false,"last_activity_date":1371901005,"creation_date":1242643307,"body":"<h3>For Anonymous classes:</h3>\n\n<p>In response to question edits here is how it works for Anonymous classes</p>\n\n<pre><code>   final X parameter = ...; // the final is important\n   Thread t = new Thread(new Runnable() {\n       p = parameter;\n       public void run() { \n         ...\n       };\n   t.start();\n</code></pre>\n\n<hr>\n\n<h3>Named classes:</h3>\n\n<p>You have a class that extends Thread (or implements Runnable) and a constructor with the parameters you'd like to pass. Then, when you create the new thread, you have to pass in the arguments, and then start the thread, something like this:</p>\n\n<pre><code>Thread t = new MyThread(args...);\nt.start();\n</code></pre>\n\n<p>Runnable is a much better solution than Thread BTW. So I'd prefer:</p>\n\n<pre><code>   public class MyRunnable implements Runnable {\n      private X parameter;\n      public MyRunnable(X parameter) {\n         this.parameter = parameter;\n      }\n\n      public void run() {\n      }\n   }\n   Thread t = new Thread(new MyRunnable(parameter));\n   t.start();\n</code></pre>\n\n<p>This answer is basically the same as this similar question: <a href=\"https://stackoverflow.com/questions/705037/how-to-pass-parameters-to-a-thread-object\">How to pass parameters to a Thread object</a></p>\n","answer_id":877115,"question_id":877096,"last_edit_date":1495542393},{"owner":{"profile_image":"https://www.gravatar.com/avatar/8be4691d697474170946184567d36814?s=256&d=identicon&r=PG","account_id":11385,"user_type":"registered","user_id":21925,"link":"https://stackoverflow.com/users/21925/robin","reputation":24062,"display_name":"Robin","accept_rate":62},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1367050373,"creation_date":1241442624,"body":"<p>As was mentioned by @unknown (google), it's usage is to define a global variable in which the value referenced can be unique in each thread.  It's usages typically entails storing some sort of contextual information that is linked to the current thread of execution.  </p>\n\n<p>We use it in a Java EE environment to pass user identity to classes that are not Java EE aware (don't have access to HttpSession, or the EJB SessionContext).  This way the code, which makes usage of identity for security based operations, can access the identity from anywhere, without having to explicitly pass it in every method call.</p>\n\n<p>The request/response cycle of operations in most Java EE calls makes this type of usage easy since it gives well defined entry and exit points to set and unset the ThreadLocal.</p>\n","answer_id":820028,"question_id":817856,"last_edit_date":1367050373},{"owner":{"profile_image":"https://i.stack.imgur.com/Y985l.jpg?s=256&g=1","account_id":259304,"user_type":"registered","user_id":542091,"link":"https://stackoverflow.com/users/542091/ovidiu-latcu","reputation":71887,"display_name":"Ovidiu Latcu","accept_rate":92},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1364282279,"creation_date":1364282279,"body":"<p>Actually the best way would be to use <a href=\"http://developer.android.com/guide/components/loaders.html\" rel=\"nofollow\"><code>Loaders</code></a>. More specific a <a href=\"http://developer.android.com/reference/android/content/CursorLoader.html\" rel=\"nofollow\"><code>CursorLoader</code></a>. The advantage of the <code>Loaders</code> compared to <code>AsyncTasks</code> and <code>Threads</code> is that the <code>Cursors</code> will be tied to your <code>Activity</code> or <code>Fragment</code> lifecycle. So you will not end up in trobule if your <code>AsyncTask</code> or <code>Thread</code> finishes after your <code>Activity</code> or <code>Fragment</code> are stopped, and try to notify a component that is no longer present.</p>\n\n<p>You can find some examples for <code>Loaders</code> here <a href=\"http://www.grokkingandroid.com/using-loaders-in-android/\" rel=\"nofollow\">How to Use Loaders</a>, and here <a href=\"http://www.androiddesignpatterns.com/2012/07/loaders-and-loadermanager-background.html\" rel=\"nofollow\">Life Before Loaders</a>.</p>\n","answer_id":15631449,"question_id":15631304},{"owner":{"profile_image":"https://www.gravatar.com/avatar/f214a9dce3ad4cadfcb376e7c7528b02?s=256&d=identicon&r=PG","account_id":1548782,"user_type":"registered","user_id":1441666,"link":"https://stackoverflow.com/users/1441666/nirali","reputation":13681,"display_name":"Nirali","accept_rate":100},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1364282075,"creation_date":1364282075,"body":"<p>AsyncTask is better compared to Thread</p>\n\n<p><strong>AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers.</strong></p>\n\n<p>And go through this <a href=\"https://stackoverflow.com/questions/6964011/handler-vs-asynctask-vs-thread?rq=1\"><strong>Handler vs AsyncTask vs Thread</strong></a></p>\n","answer_id":15631381,"question_id":15631304,"last_edit_date":1495535524},{"owner":{"profile_image":"https://www.gravatar.com/avatar/74674ffbf8adf72c0398a64d0615f128?s=256&d=identicon&r=PG","account_id":872021,"user_type":"registered","user_id":922653,"link":"https://stackoverflow.com/users/922653/colselaw","reputation":1069,"display_name":"Colselaw","accept_rate":60},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1359596255,"creation_date":1359596255,"body":"<p>Nothing really new here, but I discovered today that <code>ThreadLocal</code> is very useful when using Bean Validation in a web application. Validation messages are localized, but by default use <code>Locale.getDefault()</code>. You can configure the <code>Validator</code> with a different <code>MessageInterpolator</code>, but there's no way to specify the <code>Locale</code> when you call <code>validate</code>. So you could create a static <code>ThreadLocal&lt;Locale&gt;</code> (or better yet, a general container with other things you might need to be <code>ThreadLocal</code> and then have your custom <code>MessageInterpolator</code> pick the <code>Locale</code> from that. Next step is to write a <code>ServletFilter</code> which uses a session value or <code>request.getLocale()</code> to pick the locale and store it in your <code>ThreadLocal</code> reference.</p>\n","answer_id":14617072,"question_id":817856},{"owner":{"profile_image":"https://i.stack.imgur.com/hlWHy.jpg?s=256&g=1","account_id":1151383,"user_type":"registered","user_id":1133011,"link":"https://stackoverflow.com/users/1133011/david-kroukamp","reputation":36217,"display_name":"David Kroukamp","accept_rate":96},"content_license":"CC BY-SA 3.0","score":13,"is_accepted":true,"last_activity_date":1356721293,"creation_date":1356714034,"body":"<p>Its hard to tell what you are doing,</p>\n\n<p>but seems like you are trying to override <code>paint()</code> of a <code>Runnable</code> from within its <code>run()</code> method.</p>\n\n<p>This can surely not be done.</p>\n\n<p>The logic is </p>\n\n<ul>\n<li>Take a component</li>\n<li>Override its paint method to draw what we need</li>\n<li>Call method to update co-ordinates of rectangle (or in this case timer will do that)</li>\n<li>Than call <code>repaint()</code> on the component so paint method may be called again and redraw the rectangle with its new co-ordinates (Timer would also take care of repainting after changing co-ordinates of Rectangle)</li>\n<li>repeat last 2 steps as many times as needed/wanted</li>\n</ul>\n\n<p>(when I say <em>component</em> I actually mean <code>JPanel</code>, <em>paint method</em> refers to overridden <code>paintComponent(..)</code> of <code>JPanel</code> as this is best practice.)</p>\n\n<p><strong>Some suggestions:</strong></p>\n\n<p>1) Dont override <code>paint</code> rather use <code>JPanel</code> and override <code>paintComponent</code>. </p>\n\n<p>2) Dont forget to honor the <em>paint chain</em> and call <code>super.XXX</code> implementation of overridden <code>paintComponent(Graphics g)</code> (or any overridden method for that fact) unless purposefully leaving it out. i.e</p>\n\n<pre><code>class MyPanel extends JPanel {\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n\n         //do drawings here\n    }\n}\n</code></pre>\n\n<p>3) If drawing in <code>paintComponent</code> it is usually needed to override <code>getPreferredSize()</code> and return <code>Dimension</code>s which fit the contents/drawings of <code>JPanel</code>, i.e:</p>\n\n<pre><code>class MyPanel extends JPanel {\n    @Override\n    public Dimension getPreferredSize() {\n         return new Dimension(300,300);\n    }\n}\n</code></pre>\n\n<p>3) Look at <a href=\"http://docs.oracle.com/javase/tutorial/uiswing/misc/timer.html\"><code>Swing Timer</code></a> instead of <code>Thread.sleep(..)</code> as <code>sleep</code> will block GUI thread and make it seem to be frozen. i.e</p>\n\n<pre><code>Timer t = new Timer(10, new AbstractAction() {\n    int count = 20;\n    @Override\n    public void actionPerformed(ActionEvent ae) {\n        if (count &lt; 1000) {\n            //increment rectangles y position\n            //now repaint container so we can see changes in co-ordinates (unless you have a timer which repaints for you too)\n            count++;\n        } else {//counter is at 1000 stop the timer\n            ((Timer) ae.getSource()).stop();\n        }\n    }\n});\nt.start();\n</code></pre>\n\n<p>4) An alternative (because I see for now you are only moving a <code>Rectangle</code> which is not a Swing component) to Swing timer is <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/TimerTask.html\"><code>TimerTask</code></a>, and this can be used as long as no Swing components will be created/manipulated from within its <code>run()</code> method (as <code>TimerTask</code> does not run on EDT like Swing Timer). Note <code>revalidate()</code> and <code>repaint()</code> are <em>Thread-safe</em> so it can be used within <code>TimerTask</code>.</p>\n\n<p>The advantage of the above is unnecessary code is kept of EDT (i.e moving AWT rectangle by changing co-ords) i.e</p>\n\n<pre><code>    final TimerTask tt = new TimerTask() {\n        @Override\n        public void run() {\n            if (count &lt; 1000) {\n               //increment rectangles y position\n                //now repaint container so we can see changes in co-ordinates (unless you have a timer which repaints for you too)\n            count++;\n            } else {//counter is at 1000 stop the timer\n                cancel();\n            }\n        }\n    };\n\n    new Timer().scheduleAtFixedRate(tt, 0, 10);//start in 0milis and call run every 10 milis\n</code></pre>\n","answer_id":14072987,"question_id":14072940,"last_edit_date":1356721293},{"owner":{"profile_image":"https://www.gravatar.com/avatar/72fd1ca57aa0094fd5b9d0430f95c98e?s=256&d=identicon&r=PG","account_id":1640346,"user_type":"registered","user_id":1512926,"link":"https://stackoverflow.com/users/1512926/jeff-richley","reputation":1,"display_name":"Jeff Richley"},"content_license":"CC BY-SA 3.0","score":5,"is_accepted":false,"last_activity_date":1351018209,"creation_date":1351018209,"body":"<p>You have to be very careful with the ThreadLocal pattern.  There are some major down sides like Phil mentioned, but one that wasn't mentioned is to make sure that the code that sets up the ThreadLocal context isn't \"re-entrant.\"</p>\n\n<p>Bad things can happen when the code that sets the information gets run a second or third time because information on your thread can start to mutate when you didn't expect it.  So take care to make sure the ThreadLocal information hasn't been set before you set it again.</p>\n","answer_id":13037170,"question_id":817856},{"owner":{"profile_image":"https://i.stack.imgur.com/7auRa.png?s=256&g=1","account_id":1300215,"user_type":"registered","user_id":1250303,"link":"https://stackoverflow.com/users/1250303/java42","reputation":7638,"display_name":"Java42"},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1331499712,"creation_date":1330967720,"body":"<p>Parameter passing via the start() and run() methods:</p>\n\n<pre><code>// Tester\npublic static void main(String... args) throws Exception {\n    ThreadType2 t = new ThreadType2(new RunnableType2(){\n        public void run(Object object) {\n            System.out.println(\"Parameter=\"+object);\n        }});\n    t.start(\"the parameter\");\n}\n\n// New class 1 of 2\npublic class ThreadType2 {\n    final private Thread thread;\n    private Object objectIn = null;\n    ThreadType2(final RunnableType2 runnableType2) {\n        thread = new Thread(new Runnable() {\n            public void run() {\n                runnableType2.run(objectIn);\n            }});\n    }\n    public void start(final Object object) {\n        this.objectIn = object;\n        thread.start();\n    }\n    // If you want to do things like setDaemon(true); \n    public Thread getThread() {\n        return thread;\n    }\n}\n\n// New class 2 of 2\npublic interface RunnableType2 {\n    public void run(Object object);\n}\n</code></pre>\n","answer_id":9570940,"question_id":877096,"last_edit_date":1331499712},{"owner":{"profile_image":"https://www.gravatar.com/avatar/1738dc801b47a9191702b57447f3392c?s=256&d=identicon&r=PG","account_id":95724,"user_type":"registered","user_id":260541,"link":"https://stackoverflow.com/users/260541/rhu","reputation":963,"display_name":"rhu"},"content_license":"CC BY-SA 2.5","score":4,"is_accepted":true,"last_activity_date":1301871559,"creation_date":1301871559,"body":"<p>If you use Log4j, there is a specific mechanism for handling this type of logging pattern, split between two classes <a href=\"http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/NDC.html\" rel=\"nofollow\">org.apache.log4j.NDC</a> and <a href=\"http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/NDC.html\" rel=\"nofollow\">org.apache.log4j.MDC</a> ('Nested and Mapped Diagnostic Contexts').</p>\n\n<p>Have a browse at <a href=\"http://wiki.apache.org/logging-log4j/NDCvsMDC\" rel=\"nofollow\">NDC vs MDC - Which one should I use?</a> to see which is the best to use for your particular situation.</p>\n\n<p>Here's another link which describes MDC use in a bit more practical detail: <a href=\"http://onjava.com/pub/a/onjava/2002/08/07/log4j.html?page=3\" rel=\"nofollow\">Build Flexible Logs With log4j - O'Reilly Media</a></p>\n\n<p>Note that underlying storage mechanism MDC/NDC uses (I believe) is ThreadLocal anyway.</p>\n","answer_id":5533107,"question_id":5532864},{"owner":{"profile_image":"https://www.gravatar.com/avatar/087489aab3f24970d7a04fa604455df6?s=256&d=identicon&r=PG","account_id":289607,"user_type":"registered","user_id":590689,"link":"https://stackoverflow.com/users/590689/m-genova","reputation":377,"display_name":"m.genova"},"content_license":"CC BY-SA 2.5","score":1,"is_accepted":false,"last_activity_date":1301869686,"creation_date":1301869686,"body":"<p>I use your second approach in developed software (printserver), but threads have a long run so \"setName()\" don't add latency in processing.\nThe logging phase is very good showing thread name.</p>\n\n<p>I think \"setName()\" is a problema in two case:</p>\n\n<ol>\n<li>very short run;</li>\n<li>thread used by more actors with different id (but this is not your context, or not?).</li>\n</ol>\n\n<p>bye.</p>\n","answer_id":5532975,"question_id":5532864},{"owner":{"profile_image":"https://www.gravatar.com/avatar/48c0da7b99e8558e7180f5621573eac2?s=256&d=identicon&r=PG","account_id":37202,"user_type":"registered","user_id":106315,"link":"https://stackoverflow.com/users/106315/jwoolard","reputation":6114,"display_name":"jwoolard","accept_rate":93},"content_license":"CC BY-SA 2.5","score":18,"is_accepted":false,"last_activity_date":1242643876,"creation_date":1242643393,"body":"<p>When you create a thread, you need an instance of <code>Runnable</code>. The easiest way to pass in a parameter would be to pass it in as an argument to the constructor:</p>\n\n<pre><code>public class MyRunnable implements Runnable {\n\n    private volatile String myParam;\n\n    public MyRunnable(String myParam){\n        this.myParam = myParam;\n        ...\n    }\n\n    public void run(){\n        // do something with myParam here\n        ...\n    }\n\n}\n\nMyRunnable myRunnable = new myRunnable(\"Hello World\");\nnew Thread(myRunnable).start();\n</code></pre>\n\n<p>If you then want to change the parameter while the thread is running, you can simply add a setter method to your runnable class:</p>\n\n<pre><code>public void setMyParam(String value){\n    this.myParam = value;\n}\n</code></pre>\n\n<p>Once you have this, you can change the value of the parameter by calling like this:</p>\n\n<pre><code>myRunnable.setMyParam(\"Goodbye World\");\n</code></pre>\n\n<p>Of course, if you want to trigger an action when the parameter is changed, you will have to use locks, which makes things considerably more complex.</p>\n","answer_id":877118,"question_id":877096,"last_edit_date":1242643876},{"owner":{"profile_image":"https://i.stack.imgur.com/DVUwx.jpg?s=256&g=1","account_id":32251,"user_type":"registered","user_id":89266,"link":"https://stackoverflow.com/users/89266/dfa","reputation":114942,"display_name":"dfa","accept_rate":91},"content_license":"CC BY-SA 2.5","score":57,"is_accepted":false,"last_activity_date":1242643645,"creation_date":1242643248,"body":"<p>via constructor of a Runnable or Thread class</p>\n\n<pre><code>class MyThread extends Thread {\n\n    private String to;\n\n    public MyThread(String to) {\n        this.to = to;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"hello \" + to);\n    }\n}\n\npublic static void main(String[] args) {\n    new MyThread(\"world!\").start();\n}\n</code></pre>\n","answer_id":877104,"question_id":877096,"last_edit_date":1242643645},{"owner":{"profile_image":"https://www.gravatar.com/avatar/2c4d219e169610bd0ab7a4bcf5762e3a?s=256&d=identicon&r=PG","account_id":14954,"user_type":"registered","user_id":31136,"link":"https://stackoverflow.com/users/31136/bruno-conde","reputation":47917,"display_name":"bruno conde","accept_rate":50},"content_license":"CC BY-SA 2.5","score":10,"is_accepted":false,"last_activity_date":1242643598,"creation_date":1242643598,"body":"<p>You can either extend the <a href=\"http://java.sun.com/javase/6/docs/api/java/lang/Thread.html?is-external=true\" rel=\"noreferrer\"><code>Thread</code></a> <code>class</code> or the <a href=\"http://java.sun.com/javase/6/docs/api/java/lang/Runnable.html\" rel=\"noreferrer\"><code>Runnable</code></a> <code>class</code> and provide parameters as you want. There are simple examples in the <a href=\"http://java.sun.com/javase/6/docs/api/java/lang/Thread.html?is-external=true\" rel=\"noreferrer\">docs</a>. I'll port them here:</p>\n\n<pre><code> class PrimeThread extends Thread {\n     long minPrime;\n     PrimeThread(long minPrime) {\n         this.minPrime = minPrime;\n     }\n\n     public void run() {\n         // compute primes larger than minPrime\n          . . .\n     }\n }\n\n PrimeThread p = new PrimeThread(143);\n p.start();\n\n class PrimeRun implements Runnable {\n     long minPrime;\n     PrimeRun(long minPrime) {\n         this.minPrime = minPrime;\n     }\n\n     public void run() {\n         // compute primes larger than minPrime\n          . . .\n     }\n }\n\n\n PrimeRun p = new PrimeRun(143);\n new Thread(p).start();\n</code></pre>\n","answer_id":877132,"question_id":877096},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c53d539b59c19087182f0b1c53bb52de?s=256&d=identicon&r=PG","account_id":7450,"user_type":"registered","user_id":12960,"link":"https://stackoverflow.com/users/12960/brian-agnew","reputation":269220,"display_name":"Brian Agnew"},"content_license":"CC BY-SA 2.5","score":3,"is_accepted":false,"last_activity_date":1242643301,"creation_date":1242643301,"body":"<p>You can derive a class from Runnable, and during the construction (say) pass the parameter in.</p>\n\n<p>Then launch it using Thread.start(Runnable r);</p>\n\n<p>If you mean <em>whilst</em> the thread is running, then simply hold a reference to your derived object in the calling thread, and call the appropriate setter methods (synchronising where appropriate)</p>\n","answer_id":877112,"question_id":877096},{"owner":{"profile_image":"https://www.gravatar.com/avatar/1bf160a6e7f3d51d74f4f3d25982b75b?s=256&d=identicon&r=PG","account_id":27166,"user_type":"registered","user_id":71399,"link":"https://stackoverflow.com/users/71399/pauljwilliams","reputation":19089,"display_name":"pauljwilliams","accept_rate":65},"content_license":"CC BY-SA 2.5","score":7,"is_accepted":false,"last_activity_date":1242643262,"creation_date":1242643262,"body":"<p>Either write a class that implements Runnable, and pass whatever you need in a suitably defined constructor, or write a class that extends Thread with a suitably defined constructor that calls super() with appropriate parameters.</p>\n","answer_id":877106,"question_id":877096},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e9f9bb459497b506ded2b14cf67ba30d?s=256&d=identicon&r=PG","account_id":35470,"user_type":"registered","user_id":100464,"link":"https://stackoverflow.com/users/100464/user100464","reputation":17531,"display_name":"user100464","accept_rate":91},"content_license":"CC BY-SA 2.5","score":55,"is_accepted":false,"last_activity_date":1241382039,"creation_date":1241382039,"body":"<p>In Java, if you have a datum that can vary per-thread, your choices are to pass that datum around to every method that needs (or may need) it, or to associate the datum with the thread.  Passing the datum around everywhere may be workable if all your methods already need to pass around a common \"context\" variable.  </p>\n\n<p>If that's not the case, you may not want to clutter up your method signatures with an additional parameter.  In a non-threaded world, you could solve the problem with the Java equivalent of a global variable.  In a threaded word, the equivalent of a global variable is a thread-local variable.</p>\n","answer_id":817911,"question_id":817856},{"owner":{"profile_image":"https://www.gravatar.com/avatar/50f62e826c15e759df9aa32986f08773?s=256&d=identicon&r=PG","account_id":918256,"user_type":"registered","user_id":950558,"link":"https://stackoverflow.com/users/950558/bastien-aracil","reputation":1641,"display_name":"Bastien Aracil"},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1632661726,"creation_date":1632652821,"body":"<p>Regarding your implementation,</p>\n<p>I would have use a Set instead of a List to hold your values (I assume the values have proper equals/hashcode for this to make sense): the List#contains method is in O(n) which might be expensive if you have a lot of IBAN used at the same time.</p>\n<p>Also, you should avoid using <a href=\"https://stackoverflow.com/questions/442564/avoid-synchronizedthis-in-java\">synchronize(this)</a> (which is the same as the synchronized keyword on method).</p>\n<p>To solve your problem, I use something like this:</p>\n<pre><code>import java.lang.ref.Reference;\nimport java.lang.ref.ReferenceQueue;\nimport java.lang.ref.SoftReference;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Locks&lt;T&gt; {\n\n    private final Lock lock = new ReentrantLock();\n\n    //a Bimap from guava might be better here if you have the dependency\n    //in your project\n    private final Map&lt;Reference&lt;?&gt;, T&gt; valuePerReference = new HashMap&lt;&gt;();\n    private final Map&lt;T, Reference&lt;Lock&gt;&gt; locks = new HashMap&lt;&gt;();\n\n    private final ReferenceQueue&lt;Lock&gt; lockReferenceQueue = new ReferenceQueue&lt;&gt;();\n\n    public Locks() {\n        final Thread cleanerThread = new Thread(new Cleaner());\n        cleanerThread.setDaemon(true);\n        cleanerThread.start();\n    }\n\n    /**\n     * @param value the value the synchronization must be made on\n     * @return a lock that can be used to synchronize block of code.\n     */\n    public Lock getLock(T value) {\n        lock.lock();\n        try {\n            return getExistingLock(value).orElseGet(() -&gt; createNewLock(value));\n        } finally {\n            lock.unlock();\n        }\n    }\n\n\n    private Optional&lt;Lock&gt; getExistingLock(T value) {\n        return Optional.ofNullable(locks.get(value)).map(Reference::get);\n    }\n\n    private Lock createNewLock(T value) {\n        //I create ReentrantLock here but a Supplier&lt;Lock&gt; could be a parameter of this\n        //class to make it more generic. Same remark for SoftReference below.\n        final Lock lock = new ReentrantLock();\n        final Reference&lt;Lock&gt; reference = new SoftReference&lt;&gt;(lock, lockReferenceQueue);\n        this.locks.put(value,reference);\n        this.valuePerReference.put(reference,value);\n        return lock;\n    }\n\n\n    private void removeLock(Reference&lt;?&gt; reference) {\n        lock.lock();\n        try {\n            final T value = valuePerReference.remove(reference);\n            locks.remove(value);\n        } finally {\n            lock.unlock();\n        }\n    }\n\n\n    private class Cleaner implements Runnable {\n        @Override\n        public void run() {\n            while (!Thread.currentThread().isInterrupted()) {\n                try {\n                    final Reference&lt;? extends Lock&gt; garbaged = lockReferenceQueue.remove();\n                    removeLock(garbaged);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n            }\n        }\n    }\n\n}\n</code></pre>\n<p>I then use this like this:</p>\n<pre><code>import java.util.concurrent.locks.Lock;\n\npublic class Usage {\n\n    private final Locks&lt;String&gt; locks = new Locks&lt;&gt;();\n\n\n    public void doSomethind(String iban) {\n        final Lock lock = locks.getLock(iban);\n        lock.lock();\n        try {\n            //.. do something with your iban\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n</code></pre>\n<p>Although it uses ReentrantLock, the code can be easily modified for ReadWriteLock for instance.</p>\n","answer_id":69334079,"question_id":69333175,"last_edit_date":1632661726},{"owner":{"profile_image":"https://www.gravatar.com/avatar/0e88940e0fe1efbb23af2620864f0a7c?s=256&d=identicon&r=PG","account_id":2676306,"user_type":"registered","user_id":2312654,"link":"https://stackoverflow.com/users/2312654/maciej-waku%c5%82a","reputation":125,"display_name":"Maciej Wakuła"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1632592684,"creation_date":1632592684,"body":"<p>Common scenario might be that you have documents sent in some way (ex. kafka) and wish to ensure there are no duplicates. As far as I know there is no such a way in ElasticSearch though you might try a trick here:</p>\n<ul>\n<li>ElasticSearch allows custom document ID to be given</li>\n<li>Document ID is restricted to 512 bytes length and cannot be used for normal &quot;processing&quot;</li>\n</ul>\n<p>You might wish to create an ID based on your fields (like primary key in a database). If using _create then your document would be created only if it doesn't exist yet.</p>\n<p>Some problems are still to be solved though:\nHow to generate the ID? Simple concatenation would work but only if you are sure the total length won't exceed 512B. Otherwise a checksum can be used - but there is a small chance of collision.\nWhat to do if almost the same document is received (your keys are the same but some other difference exists). Elastic would allow only &quot;replace&quot; or &quot;do not replace&quot;. You need to handle other scenarios.</p>\n","answer_id":69328750,"question_id":58551226},{"owner":{"profile_image":"https://www.gravatar.com/avatar/146f628dfd30b3b623c6444798b60e98?s=256&d=identicon&r=PG","account_id":203002,"user_type":"registered","user_id":450398,"link":"https://stackoverflow.com/users/450398/grodriguez","reputation":21637,"display_name":"Grodriguez","accept_rate":85},"content_license":"CC BY-SA 4.0","score":5,"is_accepted":false,"last_activity_date":1632590227,"creation_date":1286780580,"body":"<p>Before you call <code>wait</code> on an object, you must acquire that object's lock:</p>\n<pre><code>synchronized(obj)\n{\n    obj.wait();\n}\n</code></pre>\n<p>Your code is calling <code>wait</code> on a <code>Thread</code> object without acquiring the lock first.</p>\n<p>I assume this is just a simplified test case to show your problem, but note that you probably want to be calling <code>wait</code> on an object that is accessible from all threads, not on the <code>Thread</code> objects themselves.</p>\n","answer_id":3904078,"question_id":3903039,"last_edit_date":1632590227},{"owner":{"profile_image":"https://www.gravatar.com/avatar/1902715058d9327c2bb4f5216d113cf3?s=256&d=identicon&r=PG","account_id":22855965,"user_type":"unregistered","user_id":17000834,"link":"https://stackoverflow.com/users/17000834/user17000834","reputation":26,"display_name":"user17000834"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1632566221,"creation_date":1632566221,"body":"<p>If there are one consumer and one producer, then this <code>RingBuffer</code> is thread-safe.</p>\n<p>Happens-before is provided by <code>AtomicInteger size</code>: it is read at the start and is written at the end of both <code>poll()</code> and <code>offer()</code>.</p>\n<p>For example, let's look at <code>poll()</code>.<br />\nNotice that:</p>\n<ol>\n<li>in <code>poll()</code> we read <code>buffer[index]</code> only if we've read <code>size.get()!=0</code></li>\n<li><code>size.get()!=0</code> can only happen after <code>size.getAndIncrement()</code> in <code>offer()</code></li>\n<li><code>size</code> is <code>AtomicInteger</code>, which means it provides <em>happens-before</em> and makes all modifications in <code>offer()</code> visible in <code>poll()</code></li>\n</ol>\n<p>In other words:</p>\n<ul>\n<li><code>buffer[writeIndex]=value</code> in <code>offer()</code></li>\n<li>-(happens-before)-&gt; <code>size.getAndIncrement()</code> in <code>offer()</code></li>\n<li>-(happens-before)-&gt; <code>size.get()!=0</code> in <code>poll()</code></li>\n<li>-(happens-before)-&gt; <code>T x = buffer[index]</code> in <code>poll()</code></li>\n</ul>\n","answer_id":69325327,"question_id":69323845},{"owner":{"profile_image":"https://i.stack.imgur.com/Klcqr.gif?s=256&g=1","account_id":292208,"user_type":"registered","user_id":2245707,"link":"https://stackoverflow.com/users/2245707/pveentjer","reputation":10665,"display_name":"pveentjer","accept_rate":17},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1632554358,"creation_date":1632553709,"body":"<p>There is no happens before edge between a write to an array at some position and a read from the same position. So if you don't have any ordering guarantee in place, your code is suffering from  a data race.</p>\n<p>If you also allow for concurrent offers and concurrent polls, then you also have race conditions on your hands.</p>\n<p>It has been quite some time I played with ringbuffers. But normally you make use of a tail and head sequence (e.g. a long). If you make the ringbuffer a power of 2, you can do a cheap mod on the conversion of the sequences to indices. And the head and tail sequence could be relatively expensive volatiles (I really would start with that) and later on you could play with relaxed memory order modes. The head and tail will give you the appropriate happens before edges so don't need to do anything special to the array. With this approach you can also get rid of the 'size'; you can calculate the size as the difference between tail and thehead; the problem with size is that it will cause contention between a thread read/writing to the ringbuffer. Also you need to properly pad the the head/tail fields to prevent false sharing.</p>\n","answer_id":69323901,"question_id":69323845,"last_edit_date":1632554358},{"owner":{"profile_image":"https://i.stack.imgur.com/Cf2VX.jpg?s=256&g=1","account_id":10716734,"user_type":"registered","user_id":7887075,"link":"https://stackoverflow.com/users/7887075/amol-kshirsagar","reputation":243,"display_name":"Amol Kshirsagar"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1632531457,"creation_date":1632530279,"body":"<p>As I mentioned earlier I tried multiple options like below:</p>\n<p>A) <strong>ConcurrentHashMap</strong>: But it does guarantee prevention of ConcurrentModificationException but does not guarantee that elements are inserted correctly.I have tested and concurrenthashmap does not populate all the elements all the time correctly</p>\n<p>B) <strong>Synchronised</strong> :Used synchronised on the uploadFiles map above but that defeats the purpose of using spring webflux</p>\n<p>C) <strong>Deep Cloned</strong> the HashMap and made sure I am GETTING only on the cloned map and PUTTING only to the original map but then I faced race condition</p>\n<p>Since I was using <strong>Spring webflux</strong>, the approach which finally worked for me was to aggregate the threads using <strong>collectList()</strong> after the call to the DocumentStorage and then group them based on the attribute which was going to be used as the key in the final hashmap in question. <strong>I did this so that I dont have to iterate over the hashmap and insert at the same time. All I did was just PUT making sure that there are NO multiple PUTS for the same key</strong></p>\n<p>Code to aggregate the threads returning from the DocumentStorage.Please read the comments as well :)</p>\n<pre><code>Flux.fromIterable(entryValue)\n                  .flatMap(\n                      fileUploadLodgeReturnDetailsDTO -&gt; {\n//call to the documentStorage happens at per document level\n                        return callToDocumentStorage(fileUploadLodgeReturnDetailsDTO);\n                      })\n                  .collectList()\n                  .flatMapMany(\n                      fileUploadLodgeReturnDetailsDTOS -&gt; {\n                      //final grouping by key happens here\n                        groupByKeyAndInsertToMap(\n                            fileUploadLodgeReturnDetailsDTOS);\n                        return Flux.fromIterable(fileUploadLodgeReturnDetailsDTOS);\n                      });\n</code></pre>\n<p>The groupingBy and insert code in above function groupByKeyAndInsertToMap() goes like this:</p>\n<pre><code> Map&lt;String, List&lt;FileUploadLodgeReturnDetailsDTO&gt;&gt; groupedByDocumentType =\n        fileUploadLodgeReturnDetailsDTOs.stream()\n            .collect(\n                Collectors.groupingBy(\n                    fileUploadLodgeReturnDetailsDTO -&gt; {\n                      return fileUploadLodgeReturnDetailsDTO.getDocumentType().name();\n                    }));\n  //the final PUT into the MAP at unique Keys Always to avoid ConcurrentModificationException\n    groupedByDocumentType.entrySet().stream()\n        .forEach(\n            stringListEntry -&gt; {\n              uploadFileList.put(\n                  LandDocumentType.make(stringListEntry.getKey()),\n                  new ArrayList&lt;&gt;(stringListEntry.getValue()));\n            });\n</code></pre>\n<p>This solution can be helpful for non spring webflux applications as well where you just collect the objects into a List and group them by the parameter which is going to be the key in your final HashMap</p>\n","answer_id":69322267,"question_id":69202716,"last_edit_date":1632531457},{"owner":{"profile_image":"https://lh3.googleusercontent.com/-XdUIqdMkCWA/AAAAAAAAAAI/AAAAAAAAAAA/4252rscbv5M/photo.jpg?sz=256","account_id":13597557,"user_type":"registered","user_id":9809131,"link":"https://stackoverflow.com/users/9809131/timur-efimov","reputation":358,"display_name":"Timur Efimov"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1632530345,"creation_date":1632527029,"body":"<p>I think the only way to do it faster is through pre-calculation.</p>\n<p>So, <code>String[][] arr;</code> and <code>for (String a : arr[5]) {/* thread creation etc */}</code> should be used.</p>\n<p>Where '5' it is '00101'.</p>\n<p>Also might helps: <code>Integer.toBinaryString(5)</code> and <code>(int) Long.parseLong(&quot;00101&quot;, 2)</code>.</p>\n","answer_id":69322046,"question_id":69321964,"last_edit_date":1632530345},{"owner":{"profile_image":"https://www.gravatar.com/avatar/243020408204ff6b968ab7aef703d7eb?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":9195024,"user_type":"registered","user_id":6834039,"link":"https://stackoverflow.com/users/6834039/areeha","reputation":823,"display_name":"Areeha"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1632502261,"creation_date":1593453832,"body":"<p>Although all the above answers are correct, I want to suggest this one as I came across this situation myself:\nYou can use a flag say:</p>\n<pre><code>isRunning=true;\nwhile(isRunning){\n   //do Something\n}\n</code></pre>\n<p>Later, make sure that isRunning is set to false after you are done reading from the buffer or data file.</p>\n","answer_id":62644141,"question_id":3367192,"last_edit_date":1632502261},{"owner":{"profile_image":"https://lh3.googleusercontent.com/a-/AOh14GjZ8dyFtSTWI17iL3UaLdUN81kzoivMM7z6o7SZ=k-s256","account_id":22763977,"user_type":"registered","user_id":16922342,"link":"https://stackoverflow.com/users/16922342/ismael-clemente-aguirre","reputation":681,"display_name":"Ismael Clemente Aguirre"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1632435354,"creation_date":1632435354,"body":"<p>As is mentioned in <a href=\"https://medium.com/google-cloud/things-i-wish-i-knew-about-google-cloud-pub-sub-part-2-b037f1f08318\" rel=\"nofollow noreferrer\">this article</a>, maybe you need to modify the acknowledgement deadline in order to give more time the client to acking</p>\n<blockquote>\n<p>“A predetermined amount of time (this defaults to 10 seconds) is\nallocated for the client to acknowledge (ack) this message before the\nserver redelivers it. This is known as the acknowledgement deadline.\nIf the client holds the message beyond the agreed deadline without\nacking, or if the client sends a Nack (negative acknowledged) request,\nthe message will be redelivered (potentially to a different subscriber\nif you have multiple set up).</p>\n</blockquote>\n<blockquote>\n<p>Sometimes, the acknowledgement deadline\nis not enough time for a message to be ack’ed by the client, so a\nModifyAckDeadline request is used to extend the deadline.”</p>\n</blockquote>\n<p>In that case you need to apply concurrency control, concurrency control allows you to configure how many threads or streams are used by the client library to pull messages. Increasing the number of threads or streams allows your client to pull messages from the Pub/Sub server more rapidly. The C++, Go, Java, Ruby clients let you configure how many threads are used for callbacks, though some clients, like Node, don’t support this. Increasing the number of callback threads allows you to process more messages concurrently.</p>\n<p>In <a href=\"https://cloud.google.com/pubsub/docs/samples/pubsub-publisher-concurrency-control#pubsub_publisher_concurrency_control-java\" rel=\"nofollow noreferrer\">this Link</a> you will find a code sample to configure a publisher to have different numbers of threads for publishing messages and processing message futures.</p>\n<p>If you want to know more about <a href=\"https://cloud.google.com/pubsub/docs/ordering\" rel=\"nofollow noreferrer\">Ordering Messages</a> or have <a href=\"https://cloud.google.com/pubsub/docs/subscriber\" rel=\"nofollow noreferrer\">Subscribe Overview</a>.</p>\n","answer_id":69307461,"question_id":69257436},{"owner":{"profile_image":"https://lh6.googleusercontent.com/-8RmyDafK12A/AAAAAAAAAAI/AAAAAAAALwY/Sbb2T_q0I6M/photo.jpg?sz=256","account_id":9054065,"user_type":"registered","user_id":9016322,"link":"https://stackoverflow.com/users/9016322/kris","reputation":1,"display_name":"Kris"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1632418458,"creation_date":1632418458,"body":"<p>Doing something like below should hopefully help you:</p>\n<pre><code>&lt;job id=&quot;job&quot;&gt;\n    &lt;step id=&quot;step_0&quot; next=&quot;split_1&quot;&gt;\n        &lt;tasklet ref=&quot;taskletStep_4&quot;/&gt;\n    &lt;/step&gt;\n    &lt;split id=&quot;split_1&quot; next=&quot;step_5&quot; task-executor=&quot;taskExecutor&quot;&gt; \n        &lt;flow&gt;\n            &lt;step id=&quot;step_1&quot; next=&quot;step_2&quot;&gt;\n                &lt;tasklet ref=&quot;taskletStep_1&quot;/&gt;\n            &lt;/step&gt;\n            &lt;step id=&quot;step_2&quot; next=&quot;step_3&quot;&gt;\n                &lt;tasklet ref=&quot;taskletStep_2&quot;/&gt;\n            &lt;/step&gt;\n            &lt;step id=&quot;step_3&quot;&gt;\n                &lt;tasklet ref=&quot;taskletStep_3&quot;/&gt;\n            &lt;/step&gt;\n        &lt;/flow&gt;\n        &lt;flow&gt;\n            &lt;step id=&quot;step_4&quot;&gt;\n                &lt;tasklet ref=&quot;taskletStep_4&quot;/&gt;\n            &lt;/step&gt;\n        &lt;/flow&gt;\n    &lt;/split&gt;\n    &lt;step id=&quot;step_5&quot;&gt;\n        &lt;tasklet ref=&quot;taskletStep_5&quot;/&gt;\n    &lt;/step&gt;\n&lt;/job&gt;\n\n&lt;beans:bean id=&quot;taskletStep_1&quot; class=&quot;com.test.batch.parallelstep.step.SimpleStep1&quot; /&gt;\n&lt;beans:bean id=&quot;taskletStep_2&quot; class=&quot;com.test.batch.parallelstep.step.SimpleStep2&quot; /&gt;\n&lt;beans:bean id=&quot;taskletStep_3&quot; class=&quot;com.test.batch.parallelstep.step.SimpleStep3&quot; /&gt;\n&lt;beans:bean id=&quot;taskletStep_4&quot; class=&quot;com.test.batch.parallelstep.step.SimpleStep4&quot; /&gt;\n&lt;beans:bean id=&quot;taskletStep_5&quot; class=&quot;com.test.batch.parallelstep.step.SimpleStep5&quot; /&gt;\n\n&lt;beans:bean id=&quot;taskExecutor&quot; class=&quot;org.springframework.core.task.SimpleAsyncTaskExecutor&quot; /&gt;\n</code></pre>\n","answer_id":69304578,"question_id":20269091},{"owner":{"profile_image":"https://www.gravatar.com/avatar/dd818daa34685a9be777abbadd91e4a1?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8666186,"user_type":"registered","user_id":6486622,"link":"https://stackoverflow.com/users/6486622/denis-zavedeev","reputation":7757,"display_name":"Denis Zavedeev"},"content_license":"CC BY-SA 4.0","score":4,"is_accepted":true,"last_activity_date":1632415878,"creation_date":1607969653,"body":"<p>This has been fixed in Java 14.</p>\n<p><code>Thread.isInterrupted</code> returns <code>true</code> if the thread was interrupted, even if the thread is not alive. See Oracle's <a href=\"https://www.oracle.com/java/technologies/javase/14-relnote-issues.html#JDK-8229516\" rel=\"nofollow noreferrer\">release notes</a> and <a href=\"https://bugs.openjdk.java.net/browse/JDK-8229516\" rel=\"nofollow noreferrer\">JDK-8229516</a>.</p>\n<blockquote>\n<p>The specification for <code>java.lang.Thread::interrupt</code> allows for an implementation to only <em>track the interrupt state for live threads</em>, and previously this is what occurred. <strong>As of this release, the interrupt state of a <code>Thread</code> is <em>always</em> available</strong>, and if you interrupt a thread <code>t</code> before it is started, or after it has terminated, the query <code>t.isInterrupted()</code> will return true.</p>\n</blockquote>\n<p>The following paragraph has been added to the javadoc of <a href=\"https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Thread.html#interrupt()\" rel=\"nofollow noreferrer\"><code>Thread#interrupt</code></a>:</p>\n<blockquote>\n<p>In the JDK Reference Implementation, interruption of a thread that is not alive still records that the interrupt request was made and will report it via <code>interrupted</code> and <code>isInterrupted()</code>.</p>\n</blockquote>\n<p>So the test in the question runs successfully on:</p>\n<pre><code>openjdk version &quot;14.0.2&quot; 2020-07-14\nOpenJDK Runtime Environment (build 14.0.2+12)\nOpenJDK 64-Bit Server VM (build 14.0.2+12, mixed mode)\n</code></pre>\n<hr />\n<p>The interruption flag is stored as a field in the <code>Thread</code> class:</p>\n<pre class=\"lang-java prettyprint-override\"><code>/* Interrupt state of the thread - read/written directly by JVM */\nprivate volatile boolean interrupted;\n</code></pre>\n<p>and <code>isInterrupted</code> method simply returns the flag:</p>\n<pre><code>public boolean isInterrupted() {\n    return interrupted;\n}\n</code></pre>\n<p>previously it delegated to a <code>native</code> <code>isInterrupted(boolean)</code> method</p>\n","answer_id":65294303,"question_id":20969486,"last_edit_date":1632415878},{"owner":{"profile_image":"https://www.gravatar.com/avatar/a983ccf67fa7942199386a01feeb43f7?s=256&d=identicon&r=PG","account_id":312321,"user_type":"registered","user_id":626318,"link":"https://stackoverflow.com/users/626318/blackcompe","reputation":3200,"display_name":"blackcompe"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1604850971,"creation_date":1320021406,"body":"<p><a href=\"http://www.ece.sunysb.edu/%7Eyang/333slides-2010/MOS-3e-02-2010.pdf\" rel=\"nofollow noreferrer\">This</a> (page 87) goes over the Dining Philosophers problem taken from Tanenbaum's <em>Modern Operating Systems 3e</em>. The problem is solved with sempahores in the C programming language.</p>\n","answer_id":7948954,"question_id":7948815,"last_edit_date":1604850971},{"owner":{"profile_image":"https://www.gravatar.com/avatar/597c4ac7a49f5c45722d971691b9d626?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":4217515,"user_type":"registered","user_id":3453226,"link":"https://stackoverflow.com/users/3453226/spongebob","reputation":8460,"display_name":"spongebob","accept_rate":77},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1604599058,"creation_date":1604599058,"body":"<p>Use two locks:</p>\n<pre><code>private boolean immortal;\nprivate final Object killMonitor = new Object();\nprivate final Object flagMonitor = new Object();\n\npublic void set(boolean immortal) {\n    synchronized (flagMonitor) {\n        this.immortal = immortal;\n    }\n}\n\npublic void kill() {\n    // ...\n    synchronized (flagMonitor) {\n        if (!immortal) {\n            synchronized (killMonitor) {\n                runnableList.addAll(Collections.nCopies(numThreads, POISON_PILL));\n            }\n        }\n    }\n}\n</code></pre>\n","answer_id":64702781,"question_id":64676963},{"owner":{"profile_image":"https://i.stack.imgur.com/upuLe.jpg?s=256&g=1","account_id":277279,"user_type":"registered","user_id":571189,"link":"https://stackoverflow.com/users/571189/prince-john-wesley","reputation":62850,"display_name":"Prince John Wesley"},"content_license":"CC BY-SA 4.0","score":16,"is_accepted":true,"last_activity_date":1604597705,"creation_date":1336631602,"body":"<blockquote>\n<p>the half-constructed-object is not visible to other threads</p>\n</blockquote>\n<p>It is not true. The object is visible to other threads at the time of construction if it has any <strong>non final/volatile</strong> fields. Therefore, other threads might see a default value for <code>permits</code> i.e <code>0</code> which might not be consistent with the current thread.</p>\n<p>The Java memory model offers a special guarantee of <strong>initialization safety</strong> for immutable objects (object with only final fields). An object reference visible to another thread does not necessarily mean that the state of that object is visible to the consuming thread - <code>JCP $3.5.2</code></p>\n<p>From  Listing 3.15 of Java Concurrency in Practice:</p>\n<blockquote>\n<p>While it may seem that field values set in a constructor are the\nfirst values written to those fields and therefore that there are no\n&quot;older&quot; values to see as stale values, the <strong>Object</strong> constructor first\nwrites the default values to all fields before subclass constructors\nrun. It is therefore possible to see the <strong>default</strong> value for a field as\na <strong>stale</strong> value.</p>\n</blockquote>\n","answer_id":10528614,"question_id":10528572,"last_edit_date":1604597705},{"owner":{"profile_image":"https://www.gravatar.com/avatar/caa09b52f2616de4fd1a6ffcc65a5859?s=256&d=identicon&r=PG","account_id":65386,"user_type":"registered","user_id":192444,"link":"https://stackoverflow.com/users/192444/john-vint","reputation":39895,"display_name":"John Vint","accept_rate":100},"content_license":"CC BY-SA 4.0","score":17,"is_accepted":true,"last_activity_date":1604596854,"creation_date":1366386526,"body":"<p>You can imagine creation of an object has a number of non-atomic functions.  First you want to initialize and publish Holder.  But you also need to initialize all the private member fields and publish them.</p>\n<p>Well, the JMM has no rules for the write and publication of the <code>holder</code>'s member fields to happen before the write of the <code>holder</code> field as occurring in <code>initialize()</code>. What that means is that even though <code>holder</code> is not null, it is legal for the member fields to not yet be visible to other threads.</p>\n<p>You may end up seeing something like</p>\n<pre><code>public class Holder {\n    String someString = &quot;foo&quot;;\n    int someInt = 10;\n}\n</code></pre>\n<p><code>holder</code> may not be null but <code>someString</code> could be null and <code>someInt</code> could be 0.</p>\n<p>Under an x86 architecture this is, from what I know, impossible to happen but may not be the case in others.</p>\n<p>So next question may be &quot;<em>Why does volatile fix this?</em>&quot; The JMM says that all writes that happen prior to the volatile store are visible to all subsequent threads of the volatile field.</p>\n<p>So if <code>holder</code> is volatile and you see <code>holder</code> is not null, based on volatile rules, all of the fields would be initialized.</p>\n<blockquote>\n<p>To safely publish this object, do we have to make holder\ninitialization static and declare it as volatile</p>\n</blockquote>\n<p>Yes, because as I mentioned if the <code>holder</code> variable is not null then all writes would be visible.</p>\n<blockquote>\n<p>How can the <code>AssertionError</code> be thrown?</p>\n</blockquote>\n<p>If a thread notices <code>holder</code> not to be null, and invokes <code>AssertionError</code> upon entering the method and reading <code>n</code> the first time may be <code>0</code> (the default value), the second read of <code>n</code> may now see the write from the first thread.</p>\n","answer_id":16108538,"question_id":16107683,"last_edit_date":1604596854},{"owner":{"profile_image":"https://lh3.googleusercontent.com/a-/AOh14GjcYA0G52MP6Dhj_QCJ8QyVvVU2hU32k4fjtpLF=k-s256","account_id":18858438,"user_type":"registered","user_id":13755857,"link":"https://stackoverflow.com/users/13755857/shawrup","reputation":2538,"display_name":"Shawrup"},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1604505026,"creation_date":1604315811,"body":"<p>I am assuming you are using Heroku Dynos, so there are 4 separate instances of your app running in production. Since there are 4 separate instances, your use of <code>synchronized</code> will be of little use here. All 4 of your instances are getting invoked at the same time, so there is a chance that, all of them will get the value of <code>redisTemplate.getValue(&quot;DATE&quot;)</code> as not null. You need an atomic operation with an centralized entity. Redis does serve as an centralized entity, but <code>redisTemplate.getValue(&quot;DATE&quot;)</code> and then <code>redisTemplate.putValue(&quot;DATE&quot;, LocalDate.now())</code> is not an atomic operation. So it is very possible that 4 instances call <code>redisTemplate.getValue(&quot;DATE&quot;)</code> and get the real date. Since all 4 of them are not null, they will all update the value and then process your operation.</p>\n<p>You should try using <code>redisTemplate.delete(key)</code>. It is an atomic operation which returns true if the key is deleted else returns false. So your code may look like this.</p>\n<pre><code>@Scheduled(zone = &quot;${scheduler.zone}&quot;, cron = &quot;${scheduler.cron.job}&quot;)\npublic  void processScheduled() {\n  \n      boolean isDeleted= redisTemplate.delete(&quot;DATE&quot;); // only one will get true, other will get false.\n\n      if (isDeleted) {\n        log.info(&quot;Entered process in SchedulerConfig&quot;);\n      \n        schedulerService.processScheduled();\n\n        // sleep for some time and then update the date value\n        redisTemplate.putValue(&quot;DATE&quot;, LocalDate.now());\n\n      }\n    \n  }\n</code></pre>\n<p>Or you can update the Date value after some time of the invocation with @Scheduled</p>\n<pre><code>@Scheduled(zone = &quot;${scheduler.zone}&quot;, cron = &quot;${scheduler.flag.update.job}&quot;)\npublic  void updateDateFlag() {\n    redisTemplate.putValue(&quot;DATE&quot;, LocalDate.now());\n}\n</code></pre>\n","answer_id":64644503,"question_id":64642918,"last_edit_date":1604505026},{"owner":{"profile_image":"https://www.gravatar.com/avatar/44c841338e1646af9a977f1fa0e23948?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":162699,"user_type":"registered","user_id":3788176,"link":"https://stackoverflow.com/users/3788176/andy-turner","reputation":138060,"display_name":"Andy Turner","accept_rate":54},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1604483692,"creation_date":1604481909,"body":"<p>A neat way to do this could be to declare your <code>runnableList</code> as a synchronized list:</p>\n<pre><code>// where T is whatever type it needs to be\nList&lt;T&gt; runnableList = Collections.synchronizedList(new ArrayList&lt;&gt;());\n</code></pre>\n<p>Then you could add to it without explicit synchronization:</p>\n<pre><code>if (!immortal) {\n  runnableList.addAll(Collections.nCopies(numThreads, POISON_PILL));\n}\n</code></pre>\n<p>This works because a single call to <code>addAll</code> is atomic.</p>\n<p>This isn't doing it <em>without</em> synchronization, though, it's just internal to the list.</p>\n<hr />\n<p>With this said, it's hard to recommend a &quot;better&quot; solution because it's not clear what the requirements are. Synchronization (etc) is used to preserve the invariants of your object when operated on by multiple threads.</p>\n<p>For example, <em>why</em> do you need <code>immortal</code> to remain unchanged while you add things to <code>runnableList</code>? How else do you access <code>immortal</code> and <code>runnableList</code>? etc</p>\n","answer_id":64677300,"question_id":64676963,"last_edit_date":1604483692},{"owner":{"profile_image":"https://www.gravatar.com/avatar/d8e15a80252f8580b1bbf9879a040546?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":19878493,"user_type":"registered","user_id":14562993,"link":"https://stackoverflow.com/users/14562993/mr-black","reputation":21,"display_name":"Mr.black"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1604395800,"creation_date":1604395800,"body":"<p>Maybe it's a good idea to use AtomicBoolean implement it.\nIf it's not, please let me know.</p>\n<pre><code>import java.util.concurrent.atomic.AtomicBoolean;\n\npublic class BinarySemaphore {\n    \n    private final AtomicBoolean permit;\n    \n    public BinarySemaphore() {\n        this(true);\n    }\n    \n    /**\n     * Creates a binary semaphore with a specified initial state\n     */\n    public BinarySemaphore(boolean permit) {\n        this.permit = new AtomicBoolean(permit);\n    }\n\n    public void acquire() {\n        boolean prev;\n        do {\n            prev = tryAcquire();\n        } while (!prev);\n    }\n\n    public boolean tryAcquire() {\n        return permit.compareAndSet(true, false);\n    }\n\n    /**\n     * In any case, the permit was released\n     */\n    public void release() {\n        permit.set(true);\n    }\n\n    public boolean available(){\n        return permit.get();\n    }\n}\n</code></pre>\n","answer_id":64660076,"question_id":8286472},{"owner":{"profile_image":"https://lh3.googleusercontent.com/a-/AAuE7mAOothLOP4GljRNL3sAyDfb4N6AeHrvVJsvApFE=k-s256","account_id":15494779,"user_type":"registered","user_id":12824504,"link":"https://stackoverflow.com/users/12824504/haoyu-wang","reputation":1291,"display_name":"haoyu wang"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1604386436,"creation_date":1604386436,"body":"<p>I assume what you expected is when you call <code>A.method1</code>, <code>someObj.getAttribute()</code> will return <code>true</code> in <code>B.callMethod</code>, when you call <code>A.method2</code>, <code>someObj.getAttribute()</code> will return <code>false</code> in <code>B.callMethod</code>.</p>\n<p>Unfortunately,this will not work. Because between the line <code>setSomeAttribute</code> and <code>callMethod</code>,other thread may have change the value of the attribute.</p>\n<p>If you are only use the attribute in <code>callMethod</code>,why not just pass the attribute instead of the <code>Foo</code> object. Code as follow:</p>\n<pre><code>class A{\n  void method1(){\n    someOtherObj.callMethod(true);\n  }\n}\nclass B{\n  void callMethod(boolean flag){\n    if(flag){\n        //do one thing\n    } else{\n        //so another thing\n    }\n  }\n}\n</code></pre>\n<p>If you must use <code>Foo</code> as the parameter, what you can do is to make <code>setAttribute</code> and <code>callMethod</code> atomic.<br />\nThe easiest way to achieve it is to make it synchronized.Code as follow:</p>\n<pre><code>  synchronized void method1(){\n    someObj.setSomeAttribute(true);\n    someOtherObj.callMethod(someObj);\n  }\n  synchronized void method2(){\n    someObj.setSomeAttribute(false);\n    someOtherObj.callMethod(someObj);\n  }\n</code></pre>\n<p>But this may have bad performance, you can achieve it with some more fine-grained lock.</p>\n","answer_id":64658013,"question_id":64654918},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG","account_id":401843,"user_type":"registered","user_id":768644,"link":"https://stackoverflow.com/users/768644/rzwitserloot","reputation":89863,"display_name":"rzwitserloot"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1604362379,"creation_date":1604362026,"body":"<p>Will there be unexpected results? Yes, guaranteed, in that if you modify things you wouldn't want to have an impact on your app (such as the phase of the moon, the current song playing in your winamp, whether your dog is cuddling near the CPU, if it's the 5th tuesday of the month, and other such things), that may have an effect on behaviour. Which you don't want.</p>\n<p>What you've described is a so-called violation of the java memory model: The end result is that any java implementation is free to return any of multiple values and nevertheless, that VM is operating properly according to the java specification. Even if it does so seemingly arbitrarily.</p>\n<p>As a general rule, each thread gets an unfair coin. Unfair, in that it will try to mess with you: It'll flip correctly every time when you test it out, and then in production, and only when you're giving a demo to that crucial customer, it'll get ya.</p>\n<p>Every time it reads to or writes from any field, it will flip this mean coin. On heads, it will use the actual field. On tails, it will use a local copy it made.</p>\n<p>That's oversimplifying the model quite a bit, but it's a good start to try to get your head around how this works.</p>\n<p>The way out is to force so-called 'comes before' relationships: What java will do, is ensure that what you can observe matches these relationships: If event A is defined as having a comes-before relationship vs. event B, then anything A did will be observed, exactly as is, by B, guaranteed. No more coin flips.</p>\n<p>Examples of establishing comes-before relationships involve using <code>volatile</code>, <code>synchronized</code>, and any methods that use these things internally.</p>\n<p>NB: Of course. if your <code>setSomeAttribute</code> method, which you did not paste, includes some comes-before-establishing act, then there's no problem here, but as a rule a method called <code>setX</code> will not be doing that.</p>\n<p>An example of one that doesn't:</p>\n<pre><code>class Example {\n  private String attr;\n\n  public void setAttr(String attr) {\n    this.attr = attr;\n  }\n}\n</code></pre>\n<p>some examples of ones that do:</p>\n<ul>\n<li><p>Let's say method <code>B.callMethod</code> is executed in the same thread as <code>method1</code> - then you are guaranteed to at least observe the change method1 made, though it's still a coin flip (whether you actually see what method2 did or not). What would not be possible is seeing the value of that attribute before either method1 or method2 runs, because code running in a single thread has comes-before across the entire run (any line that is executed before another in the same thread has a comes-before relationship).</p>\n</li>\n<li><p>The set method looks like:</p>\n</li>\n</ul>\n<pre><code>class Example {\n  private String attr;\n  private final Object lock = new Object();\n\n  public void setAttr(String attr) {\n    synchronized (lock) {\n      this.attr = attr;\n    }\n  }\n\n  public String getAttr() {\n    synchronized (lock) {\n      return this.attr;\n    }\n  }\n}\n</code></pre>\n<p>Now the get and set ops lock on the same object, that's one of the ways to establish comes-before. Which thread got to a lock first is observable behaviour; if method1's set got there before B's get, then you are guaranteed to observe method1's set.</p>\n<p>More generally, sharing state between threads is extremely tricky and you should endeavour not do so. The alternatives are:</p>\n<ul>\n<li>Initialize all state before starting a thread, then do the job, and only when it is finished, relay all results back. Fork/join does this.</li>\n<li>Use a messaging system that has great concurrency fundamentals, such as a database, which has transactions, or message queue libraries.</li>\n<li>If you must share state, try to write things in terms of the nice classes in j.u.concurrent.</li>\n</ul>\n","answer_id":64655013,"question_id":64654918,"last_edit_date":1604362379},{"owner":{"profile_image":"https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG","account_id":47283,"user_type":"registered","user_id":139985,"link":"https://stackoverflow.com/users/139985/stephen-c","reputation":703927,"display_name":"Stephen C","accept_rate":69},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1585578536,"creation_date":1585493353,"body":"<p>Let assume that threads <code>A</code> and <code>B</code> have a reference to a <code>Container</code> instance.</p>\n\n<p>(Since <code>Container.map</code> is declared as <code>final</code>, its value will be safely published.  Furthermore, since it refers to a <code>ConcurrentHashMap</code>, no synchronization is required to maintain thread-safety.)</p>\n\n<p>Now suppose thread <code>A</code> calls <code>Longholder holder = container.createValue(x)</code> and somehow passes <code>holder</code> to thread <code>B</code>.  Your question is, if <code>B</code> calls <code>doSmth</code> passing that holder, will the <code>map.get(holder)</code> call see it in the map?</p>\n\n<p>The answer is Yes, it will.</p>\n\n<p>The specification for <code>ConcurrentHashMap</code> says this:</p>\n\n<blockquote>\n  <p><em>\"Retrievals reflect the results of the most recently completed update operations holding upon their onset. (More formally, an update operation for a given key bears a happens-before relation with any (non-null) retrieval for that key reporting the updated value.)\"</em>.</p>\n</blockquote>\n\n<p>That means there is a <em>happens before</em> from the <code>put</code> call that thread <code>A</code> made and the subsequent <code>get</code> call in thread <code>B</code>.  That in turn means that:</p>\n\n<ul>\n<li>the <code>get</code> <em>will</em> find the <code>LongHolder</code> key, and</li>\n<li>the <code>get</code> <em>will</em> return the correct value.</li>\n</ul>\n\n<p>The value of the <code>LongHolder</code> object's <code>i</code> field will also be as expected, and it would be even if <code>LongHolder</code> was a <em>mutable</em> holder.</p>\n\n<p>(Note that there is not much point declaring an immutable <code>LongHolder</code> here.  It is equivalent to a <code>java.lang.Long</code> ... albeit with a simpler API.)</p>\n\n<hr>\n\n<blockquote>\n  <p>Can operations be reordered in a such manner that the reference to <code>LongHolder</code> from <code>createValue</code> escapes the method and thus becomes available for other threads before putting it into the map?</p>\n</blockquote>\n\n<p>Basically, no.  The relevant operations are this:</p>\n\n<pre><code>      LongHolder v = new LongHolder(i);\n      map.put(v, 1)\n      return v;    // corrected typo\n</code></pre>\n\n<ol>\n<li>There is no reordering of the source code that makes any sense.  </li>\n<li>If you are talking about reordering by compiler with respect to the thread that is running <code>createValue</code>, the JLS does not permit it.   Any reordering that alters intra-thread visibility is forbidden. </li>\n<li><p>The publication of <code>v</code> via the map is a safe publication, due to the properties of <code>get</code> and <code>put</code>.  (At the implementation, there are memory barriers that forbid the harmful reorderings around the <code>get</code> and <code>put</code> calls.)</p></li>\n<li><p>and 3. are a <em>consequence</em> of the <em>happens before</em> relationships.</p></li>\n</ol>\n\n<p>Now, if the code was to change to this:</p>\n\n<pre><code>      LongHolder v = new LongHolder(i);\n      map.put(v, 1)\n      // Somehow modify v.i\n      return v;\n</code></pre>\n\n<p>then <em>that</em> would be a form of unsafe publication.  Since the change to <code>v.i</code> by <code>A</code> happens after the <code>put</code>, the <em>happens before</em> relation between the <code>put</code> and the <code>get</code> in <code>B</code> is no sufficient to guarantee to make the new value of <code>v.i</code> visible in thread <code>B</code>.   That is because the <em>chaining</em> doesn't work anymore.</p>\n\n<p>Now, I suppose that if the result of the <code>createValue</code> call in thread <code>A</code> was passed to another thread (<code>B</code> or <code>C</code>) in an unsafe way, then the latter is not guaranteed to see the correct value for <code>v.i</code> ... if <code>LongHolder</code> is mutable.  But that is not a problem with the <code>createValue</code> / <code>doSmth</code> code.  And the publication of the value of <code>v</code> via the map is safe.</p>\n\n<p>But I reckon that this discussion of reorderings is missing the point.  Any reordering that violates the visibility semantics guaranteed by the memory model is forbidden.  The JIT compiler is not allowed to do it.  So you just need to do the <em>happens before</em> analysis.</p>\n","answer_id":60915932,"question_id":60914276,"last_edit_date":1585578536},{"owner":{"profile_image":"https://i.stack.imgur.com/54njx.png?s=256&g=1","account_id":4210603,"user_type":"registered","user_id":3448419,"link":"https://stackoverflow.com/users/3448419/apangin","reputation":94386,"display_name":"apangin"},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":true,"last_activity_date":1585482514,"creation_date":1585481524,"body":"<p>This is not related to Tiered Compilation. The problem also happens without it. Let JVM compile just one method <code>check</code> and see how it looks in C2-compiled code:</p>\n\n<pre><code>java -XX:-TieredCompilation \\\n     -XX:CompileCommand=compileonly,Shared::check \\\n     -XX:CompileCommand=print,Shared::check \\\n     Shared\n</code></pre>\n\n<p>The output is</p>\n\n<pre><code>    0x00000000031a4160: mov     dword ptr [rsp+0ffffffffffffa000h],eax\n    0x00000000031a4167: push    rbp\n    0x00000000031a4168: sub     rsp,20h           ;*synchronization entry\n                                                  ; - Shared::check@-1 (line 11)\n\n(1) 0x00000000031a416c: mov     r10d,dword ptr [rdx+0ch]\n                                                  ;*getfield x\n                                                  ; - Shared::check@5 (line 11)\n\n(2) 0x00000000031a4170: mov     r8d,dword ptr [rdx+10h]  ;*getfield y\n                                                  ; - Shared::check@1 (line 11)\n\n    0x00000000031a4174: cmp     r8d,r10d\n    0x00000000031a4177: jnle    31a4185h          ;*if_icmple\n                                                  ; - Shared::check@8 (line 11)\n\n    0x00000000031a4179: add     rsp,20h\n    0x00000000031a417d: pop     rbp\n    0x00000000031a417e: test    dword ptr [1020000h],eax\n                                                  ;   {poll_return}\n    0x00000000031a4184: ret\n</code></pre>\n\n<p>As you can see, <code>x</code> is loaded first (line 1), and <code>y</code> is loaded after (line 2). Between these lines another thread may increase <code>y</code> an aribrary number of times, thus making <code>y</code> seem greater than <code>x</code>.</p>\n\n<p>In this particular case you've guessed about reordering of loads with respect to the original program order (in the bytecode <code>getfield y</code> goes before <code>getfield x</code>). However, as @Andreas mentioned, this is not the only reason why the program may break. Even if JIT compiler emits <code>load(y)</code> before <code>load(x)</code>, depending on the CPU architecture, it may happen that the first load gets a newer value, while the second load gets an older one, and this will be absolutely correct from JMM perspective.</p>\n","answer_id":60913568,"question_id":60912357,"last_edit_date":1585482514},{"owner":{"profile_image":"https://i.stack.imgur.com/qDozH.jpg?s=256&g=1","account_id":5126886,"user_type":"registered","user_id":4108590,"link":"https://stackoverflow.com/users/4108590/ravindra-ranwala","reputation":20904,"display_name":"Ravindra Ranwala","accept_rate":57},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":true,"last_activity_date":1585476595,"creation_date":1585476595,"body":"<p>You are calling wait and notify on explicit lock objects and that is not legal. If you are using explicit lock objects, you have to use Condition object associated with it. Then you should call <code>condition.awai</code>t and <code>condition.signalAll</code> methods instead of <code>wait</code> and <code>notify</code>. Here's the idiom for using explicit locks in your particular scenario.</p>\n\n<pre><code>final Condition setA = lock.newCondition();\npublic void threadA() {\n    lock.lock();\n    try {\n        while (a == 5)\n            setA.await();\n        System.out.println(\"A = \" + a);\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n    } finally {\n        lock.unlock();\n    }\n}\n\npublic void threadB() {\n    lock.lock();\n    try {\n        this.a = 11;\n        System.out.println(\"B = \" + a);\n        setA.signalAll();\n    } finally {\n        lock.unlock();\n    }\n}\n</code></pre>\n\n<p>And this program produces the following output:</p>\n\n<pre><code>B = 11\nA = 11\n</code></pre>\n","answer_id":60912705,"question_id":60912120},{"owner":{"profile_image":"https://i.stack.imgur.com/IHDzC.jpg?s=256&g=1","account_id":10712815,"user_type":"registered","user_id":7884542,"link":"https://stackoverflow.com/users/7884542/nyarian","reputation":4135,"display_name":"nyarian"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1585391758,"creation_date":1585391758,"body":"<p>Aforementioned behavior is not guaranteed. The guarantee of such a \"visibility\" is actually a subject of <strong>happens-before relationship</strong>:</p>\n\n<blockquote>\n  <p>The key to avoiding memory consistency errors is understanding the <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/memconsist.html\" rel=\"nofollow noreferrer\">happens-before relationship</a>. This relationship is simply a guarantee that memory writes by one specific statement are visible to another specific statement.</p>\n</blockquote>\n\n<p>Happens-before relationship (<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#MemoryVisibility\" rel=\"nofollow noreferrer\">according to JLS</a>) can be achieved as such:</p>\n\n<ol>\n<li>Each action in a thread happens-before every action in that thread that comes later in the program's order.</li>\n<li>An unlock (synchronized block or method exit) of a monitor happens-before every subsequent lock (synchronized block or method entry) of that same monitor. And because the happens-before relation is transitive, all actions of a thread prior to unlocking happen-before all actions subsequent to any thread locking that monitor.</li>\n<li>A write to a volatile field happens-before every subsequent read of that same field. Writes and reads of volatile fields have similar memory consistency effects as entering and exiting monitors, but do not entail mutual exclusion locking.</li>\n<li>A call to start on a thread happens-before any action in the started thread.</li>\n<li>All actions in a thread happen-before any other thread successfully returns from a join on that thread.</li>\n</ol>\n\n<p>So, in your particular case, you actually need either synchronization using a shared monitor or <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicIntegerArray.html\" rel=\"nofollow noreferrer\">AtomicIntegerArray</a> in order to make access to the array thread-safe; <code>volatile</code> modifier won't help as is, because it only affects the variable pointing to the array, not the array's elements (<a href=\"https://stackoverflow.com/a/5173642/7884542\">more detailed explanation</a>).</p>\n","answer_id":60900005,"question_id":60895586},{"owner":{"profile_image":"https://i.stack.imgur.com/MWKel.jpg?s=256&g=1","account_id":2179728,"user_type":"registered","user_id":10819573,"link":"https://stackoverflow.com/users/10819573/arvind-kumar-avinash","reputation":73077,"display_name":"Arvind Kumar Avinash"},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1585353599,"creation_date":1585353599,"body":"<blockquote>\n  <p>If the first thread first performs values[i]= 58, is it guaranteed\n  that if the second threads executes slightly later, that the if of the\n  second thread reads 58 even though the second thread reads values[i]\n  outside a synchronized block?</p>\n</blockquote>\n\n<p>No</p>\n\n<p>Synchronising this way does not stop other threads to perform any operation on the array simultaneously. However, other threads will be prevented to grab a lock on the array.</p>\n","answer_id":60895713,"question_id":60895586},{"owner":{"profile_image":"https://www.gravatar.com/avatar/956003d5607ba6be2dd3f37427980e2c?s=256&d=identicon&r=PG","account_id":435105,"user_type":"registered","user_id":821497,"link":"https://stackoverflow.com/users/821497/ciamej","reputation":6948,"display_name":"ciamej","accept_rate":60},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":true,"last_activity_date":1585302515,"creation_date":1585299116,"body":"<p>All actions of the same thread are ordered by the happens-before relation.</p>\n\n<p>JLS 17.4.5:</p>\n\n<blockquote>\n  <p>If x and y are actions of the same thread and x comes before y in program order, then hb(x, y).</p>\n</blockquote>\n\n<p>Also note, that happens-before is transitive, thus if the write within the synchronized block happens before unlock, and unlock happens before a lock on another thread, then the write happens before any action in the synchronized block in the other thread.</p>\n","answer_id":60882674,"question_id":60882316,"last_edit_date":1585302515},{"owner":{"profile_image":"https://i.stack.imgur.com/ilGFE.jpg?s=256&g=1","account_id":7292048,"user_type":"registered","user_id":5558122,"link":"https://stackoverflow.com/users/5558122/vladimir-pligin","reputation":1570,"display_name":"Vladimir Pligin"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1585299276,"creation_date":1585299276,"body":"<p>The best explanation here is that unlock action has a happens-before edge with the last action in the thread. It's called program order.\nIt's described in the <a href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.3\" rel=\"nofollow noreferrer\">documentation</a></p>\n\n<p><code>Among all the inter-thread actions performed by each thread t, the program order of t is a total order that reflects the order in which these actions would be performed according to the intra-thread semantics of t.</code></p>\n","answer_id":60882716,"question_id":60882316},{"owner":{"profile_image":"https://www.gravatar.com/avatar/67f2ccd17aa6fd622152ad88fc2ae784?s=256&d=identicon&r=PG","account_id":422870,"user_type":"registered","user_id":801894,"link":"https://stackoverflow.com/users/801894/solomon-slow","reputation":25925,"display_name":"Solomon Slow"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1585245501,"creation_date":1585245149,"body":"<p>I would not normally write code in which different threads meet up with each other, but since this appears to be a homework assignment...</p>\n\n<p>In my solution there would be a single, blocking queue. When a \"teller\" thread starts up, and each time it finishes \"interacting\" with a customer, it would put its <em>self</em> into the queue, and then wait for a new customer to start an interaction. The customers all would wait to <code>take()</code> a teller from the queue, and when they get one,... \"interact\" with it.</p>\n\n<hr>\n\n<p>If it was not homework I would do something entirely different. I don't know why \"customer\" threads are a thing, but I don't see any use for \"teller\" threads at all. There might be some kind of limited-availability <code>Teller</code> <em>objects</em>, but they would not be threads. The customer threads could \"interact\" by simply calling <code>Teller</code> methods or, if necessary, by submitting <em>tasks</em> that call <code>Teller</code> methods to a generic <em>thread pool</em>.</p>\n","answer_id":60873302,"question_id":60871531,"last_edit_date":1585245501},{"owner":{"profile_image":"https://lh6.googleusercontent.com/-1o6naSHtMCw/AAAAAAAAAAI/AAAAAAAAADU/na4_vOaI0N8/photo.jpg?sz=256","account_id":6518336,"user_type":"registered","user_id":5043325,"link":"https://stackoverflow.com/users/5043325/wu-lihu","reputation":54,"display_name":"wu lihu"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1585147074,"creation_date":1585147074,"body":"<p>I assume you mean the callback of the CompletableStage? \nSomething like \n CompletableFuture r =  CompletableFuture.supplyAsync(()a -> new Hello()).thenAccept(s -> s + World());</p>\n","answer_id":60851079,"question_id":60850133},{"owner":{"profile_image":"https://www.gravatar.com/avatar/ada69b2a87f0732a5b051e769d07b13d?s=256&d=identicon&r=PG","account_id":1628551,"user_type":"registered","user_id":1503554,"link":"https://stackoverflow.com/users/1503554/thisisnozaku","reputation":2314,"display_name":"ThisIsNoZaku","accept_rate":43},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1585146575,"creation_date":1585146575,"body":"<p>If you want to supply (calculate/generate/retrieve/etc.) some value then do something with that value asynchronously, you can create a <code>CompletableFuture</code> via a method such as <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html#supplyAsync-java.util.function.Supplier-\" rel=\"nofollow noreferrer\">CompletableFuture.supplyAsync</a>. This will return an instance of <code>CompletableFuture</code>.</p>\n\n<p>With that instance, you can call the method <code>thenAccept</code>, which will call the given <code>Consumer</code> method, with the value supplied by the previous step as the argument.</p>\n\n<p>So something kind of like this:</p>\n\n<pre><code>CompletableFuture.supplyAsync(aMethodThatWillReturnAString, yourExecutor).thenAccept((string theString) -&gt; {\n    System.out.println(theString);\n});\n</code></pre>\n","answer_id":60850923,"question_id":60850133},{"owner":{"profile_image":"https://i.stack.imgur.com/t2hoD.jpg?s=256&g=1","account_id":3211603,"user_type":"registered","user_id":2711488,"link":"https://stackoverflow.com/users/2711488/holger","reputation":289317,"display_name":"Holger"},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1585125989,"creation_date":1585125989,"body":"<p>There is no actual problem, as your proposition, “<em>I cant use CompletableFuture.allOf() because it stop on first fail</em>” is wrong. The future returned by <code>allOf</code> will be completed exceptionally if at least one of the input futures has been completed exceptionally, but it still will only be completed when all futures have been completed.<br>\nAs can easily be demonstrated:</p>\n\n<pre><code>CompletableFuture&lt;?&gt; f1 = new CompletableFuture&lt;&gt;();\nf1.completeExceptionally(new Throwable(\"fail immediately\"));\nCompletableFuture&lt;?&gt; f2\n  = CompletableFuture.runAsync(() -&gt; LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(2)));\nCompletableFuture&lt;?&gt; all = CompletableFuture.allOf(f1, f2);\n\nlong t0 = System.nanoTime();\ntry {\n    all.join();\n} finally {\n    System.err.println(\"Completed: \"+f1.isDone()+\", \"+f2.isDone());\n    System.err.printf(\"%.2fs%n\", (System.nanoTime()-t0)*1e-9);\n}\n</code></pre>\n\n<pre class=\"lang-none prettyprint-override\"><code>Completed: true, true\n2,00s\nException in thread \"main\" java.util.concurrent.CompletionException: java.lang.Throwable: fail immediately\n    at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:292)\n    at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:308)\n    at java.util.concurrent.CompletableFuture.biRelay(CompletableFuture.java:1284)\n    at java.util.concurrent.CompletableFuture$BiRelay.tryFire(CompletableFuture.java:1270)\n    at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:474)\n    at java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1632)\n    at java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1618)\n    at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n    at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n    at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n    at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)\nCaused by: java.lang.Throwable: fail immediately\n    at Demo.main(Demo.java:16)\n</code></pre>\n\n<p>So you can use <code>allOf</code> to check the completion state of all jobs, even when some fail:</p>\n\n<pre><code>ExecutorService e = Executors.newFixedThreadPool(20);\nRandom r = ThreadLocalRandom.current();\nCompletableFuture&lt;?&gt;[] workerJobs = IntStream.range(0, 20)\n    .mapToObj(i -&gt; {\n      long time = TimeUnit.MILLISECONDS.toNanos(r.nextInt(4000));\n      boolean fail = r.nextBoolean();\n      return CompletableFuture.runAsync(() -&gt; {\n        LockSupport.parkNanos(time);\n        if(fail) throw new RuntimeException();\n      }, e);\n    })\n    .toArray(CompletableFuture&lt;?&gt;[]::new);\ne.shutdown();\n\ntry {\n  CompletableFuture.allOf(workerJobs).get(2, TimeUnit.SECONDS);\n  System.out.println(\"All completed within 2 seconds or less without failures\");\n}\ncatch(InterruptedException ex) {\n  throw new AssertionError(ex);\n}\ncatch(ExecutionException ex) {\n  System.out.println(\"All completed within 2 seconds or less, at least one failed\");\n}\ncatch(TimeoutException ex) {\n  System.out.println(\"At least one did not complete within 2 seconds\");\n}\nfor(CompletableFuture&lt;?&gt; f: workerJobs) {\n  System.out.println(f.isDone()? \"completed\"\n    +(f.isCompletedExceptionally()? \" exceptionally\": \"\"): \"not completed\");\n}\n</code></pre>\n","answer_id":60845412,"question_id":60838503},{"owner":{"profile_image":"https://www.gravatar.com/avatar/5e9b86bbe0805dfaf5d07146d2a69956?s=256&d=identicon&r=PG","account_id":2242,"user_type":"registered","user_id":3095,"link":"https://stackoverflow.com/users/3095/dave","reputation":13698,"display_name":"Dave","accept_rate":89},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1585085190,"creation_date":1585085190,"body":"<p>Java doesn't have a great way to wait for a bunch of Completable Futures with a timeout (that I know of):</p>\n\n<pre><code>public class TryWaitForCF {\n\nprivate void run() throws Exception {\n\n    List&lt;Worker&gt; workers = new ArrayList&lt;&gt;();\n    for( int i=0; i&lt;10; i++){\n        workers.add(new Worker(\"Worker=\"+i));\n    }\n\n    List&lt;CompletableFuture&lt;Worker&gt;&gt; waitList = new ArrayList&lt;&gt;();\n    workers.forEach(worker -&gt; waitList.add(worker.stop()));\n\n    long endTime = System.currentTimeMillis() + 2000;\n    for( CompletableFuture&lt;Worker&gt; cf : waitList ){\n        long timeout = endTime - System.currentTimeMillis();\n        if( timeout &lt; 0 ){\n            timeout = 0;\n        }\n        System.out.println(\"Get result waiting at most: \" + timeout + \" ms\");\n        try {\n            Worker result = cf.get(timeout, TimeUnit.MILLISECONDS);\n            System.out.println(result.name  + \": finished\" );\n        }\n        catch( Exception e ){\n            System.out.println(\"Failed to get result: \" + e.getMessage());\n        }\n    }\n\n}\n\npublic static void main(String[] args) throws Exception {\n    new TryWaitForCF().run();\n}\n\nstatic class Worker {\n    private String name;\n    private long timeToComplete;\n\n    public Worker(String name){\n        this.name = name;\n        this.timeToComplete = (long) (Math.random() * (3000 - 1000 + 1) + 1000);\n        System.out.println(name  + \": timeToComplete=\" + timeToComplete);\n    }\n\n    public CompletableFuture&lt;Worker&gt; stop() {\n        return CompletableFuture.supplyAsync(() -&gt; {\n            try {\n                Thread.sleep(timeToComplete);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            return this;\n        });\n    }\n}\n</code></pre>\n\n<p>}</p>\n\n<p>results:</p>\n\n<pre><code>Worker=0: timeToComplete=1018\nWorker=1: timeToComplete=1866\nWorker=2: timeToComplete=1894\nWorker=3: timeToComplete=2041\nWorker=4: timeToComplete=1124\nWorker=5: timeToComplete=1613\nWorker=6: timeToComplete=2445\nWorker=7: timeToComplete=2188\nWorker=8: timeToComplete=2129\nWorker=9: timeToComplete=2174\nGet result waiting at most: 2000 ms\nWorker=0: finished\nGet result waiting at most: 980 ms\nWorker=1: finished\nGet result waiting at most: 130 ms\nWorker=2: finished\nGet result waiting at most: 100 ms\nFailed to get result: null\nGet result waiting at most: 0 ms\nWorker=4: finished\nGet result waiting at most: 0 ms\nWorker=5: finished\nGet result waiting at most: 0 ms\nFailed to get result: null\nGet result waiting at most: 0 ms\nFailed to get result: null\nGet result waiting at most: 0 ms\nFailed to get result: null\nGet result waiting at most: 0 ms\nFailed to get result: null\n</code></pre>\n\n<p>You might want to change your design, though. </p>\n","answer_id":60839598,"question_id":60838503},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c8af77fbf1b7c58c923d1c80fce2097a?s=256&d=identicon&r=PG","account_id":2031013,"user_type":"registered","user_id":2908793,"link":"https://stackoverflow.com/users/2908793/etki","reputation":2094,"display_name":"Etki","accept_rate":58},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1571989969,"creation_date":1571989477,"body":"<p>There is no way to guarantee there isn't such document just by properties in index in any way. Even if you check it's presence in index and don't see it, there is some time between response for that operation was issued and your indexing request accepted by ES. </p>\n\n<p>So basically you have only two ways:</p>\n\n<ul>\n<li>Guarantee single execution of indexing operation (long and not-so-easy way because we don't have exactly-once systems) </li>\n<li>Convert document unique properties into document ID, so even if your indexing operations overlap, they will just write same values into same document (or the second one and following will fail, depending on request options).</li>\n</ul>\n\n<p>The latter one is quite easy, you have some options out of the box:</p>\n\n<ul>\n<li>Take all unique properties in determined order and concatenate their string representations (ugly)</li>\n<li>Take all unique properties in determined order, concatenate their byte values and encode using Base64 (less ugly)</li>\n<li>Take all unique properties in determined order, pass them through hashing function (md5, sha-X families, whatever you like) and use string representation of result.</li>\n</ul>\n","answer_id":58554266,"question_id":58551226,"last_edit_date":1571989969},{"owner":{"profile_image":"https://lh6.googleusercontent.com/-nDnnU9jHyO8/AAAAAAAAAAI/AAAAAAAAAAA/z6hynXfhs0g/photo.jpg?sz=256","account_id":13759339,"user_type":"registered","user_id":9929449,"link":"https://stackoverflow.com/users/9929449/lebigcat","reputation":1737,"display_name":"LeBigCat"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1571988831,"creation_date":1571988831,"body":"<p>If you detect an insert why not once insertion done (and index refresh...) check if you have no duplicate. A second solution would be to write every Xs using a bulk insert-update pack of data (= store new documents in a list in a share area, so you could check if your document arenot already present in, and write this list every 10s for example).</p>\n","answer_id":58554122,"question_id":58551226},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b4c3acc21c6d768e3875ebac67b53bdf?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8086222,"user_type":"registered","user_id":6093696,"link":"https://stackoverflow.com/users/6093696/eric","reputation":906,"display_name":"Eric"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1562402046,"creation_date":1562402046,"body":"<p>The <code>volatile</code> keyword in this case is enough because it establishes a happens-before relation for the reads and writes, guaranteeing that the write in one thread will be observed by a subsequent read in another thread.</p>\n\n<p>The <code>synchronized</code> block is not incorrect but it is redundant. Also, if you do use <code>synchronized</code>, you can mark your message variable as non-volatile. But be careful and make sure the read is also in a <code>synchronized</code> block, otherwise you have a data race. Non-volatile writes made by one thread in a <code>synchronized</code> block are guaranteed to be visible for threads subsequently entering a <code>synchronized</code> block on the same monitor. </p>\n\n<p>As a final note, the <code>synchronized</code> block has different progress conditions than <code>volatile</code> reads and writes. The former is blocking (mutual exclusion) while the latter is wait-free.</p>\n","answer_id":56912472,"question_id":56904832},{"owner":{"profile_image":"https://i.stack.imgur.com/W6OMC.png?s=256&g=1","account_id":1056871,"user_type":"registered","user_id":1059372,"link":"https://stackoverflow.com/users/1059372/eugene","reputation":117749,"display_name":"Eugene","accept_rate":97},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1562321986,"creation_date":1562321631,"body":"<p>IMO you are slightly confusing a few things here. Making an Object <em>immutable</em> will inherently make it thread-safe : no state, no synchronization required. Making <em>all</em> fields final will ensure that the Object is <em>safely published</em>; i.e.: a thread reading/observing a reference to the newly created instance, will see all the variables set via its constructor <em>and</em> being final, as set.   </p>\n\n<p>Making \"some\" instance fields <code>final</code> gives you nothing w.r.t. the guarantees that JLS offers about safely publishing an instance.</p>\n\n<p>You can still have a thread safe object that has fields being updated via <code>setters/getters</code>, but these would be protected by some locks for example. </p>\n\n<p><code>@Value</code> and/or <code>@PostConstruct</code> methods are supposed to be called only once - and Spring controls that no other business logic methods are called (the context is not even fully created) into that instance (though if you really wanted to you could hack into this). But think about it from a different angle too : usually spring returns singleton beans (you are using <code>@Value</code> after all), so having <em>any</em> state in those instances would still require careful reasoning and most probably thread-safe access anyway.</p>\n\n<p>Or the fact that <em>usually</em> you add some kind of services via <code>@PostConstruct</code> (that have dependencies on those set in the constructor) - that are supposed to be stateless; while fields that have <code>@Value</code> annotation are <code>private</code> - thus not exposed at all(no setters for them), thus <em>not</em> an invariant to reason about when thinking about it's thread safety. </p>\n","answer_id":56901054,"question_id":56897420,"last_edit_date":1562321986},{"owner":{"profile_image":"https://www.gravatar.com/avatar/00d71e011fc61cad60c5ffc9bf48c5ef?s=256&d=identicon&r=PG","account_id":1000314,"user_type":"registered","user_id":1015327,"link":"https://stackoverflow.com/users/1015327/jimmyb","reputation":12261,"display_name":"JimmyB"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1562076926,"creation_date":1561988366,"body":"<blockquote>\n  <p>Further i am thinking to use a boolean flag e.g. canReadContinue</p>\n</blockquote>\n\n<p>You're on the right track. But remember that <em>any number</em> of threads could concurrently perform their <em>read</em> accesses and that the write access can only be done if <em>no</em> other thread is currently reading or writing.</p>\n\n<p>So you need to keep track of how many readers are currently holding the lock, and every reader must make sure to release the lock when it's done. Only if &amp; when 0 readers (and 0 writers) hold the lock, a writer may proceed; and only if &amp; when 0 writers hold the lock, any reader may proceed.</p>\n","answer_id":56836721,"question_id":56836221,"last_edit_date":1562076926},{"owner":{"profile_image":"https://www.gravatar.com/avatar/00d71e011fc61cad60c5ffc9bf48c5ef?s=256&d=identicon&r=PG","account_id":1000314,"user_type":"registered","user_id":1015327,"link":"https://stackoverflow.com/users/1015327/jimmyb","reputation":12261,"display_name":"JimmyB"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1562076665,"creation_date":1562075266,"body":"<p>Answering on your updated code here is some skeleton for you to complete:</p>\n\n<pre><code>public class SharedResource {\n\n  private final Object signal = new Object();\n  private boolean writeLocked;\n  private int readerCount;\n\n  public void write(final Object newState) throws InterruptedException {\n\n    this.acquireWriteLock();\n\n    try {\n\n      // Now we know that no read and no other write is going on.\n      System.out.println(\"Write thread has the lock.\");\n      this.doWrite(newState);\n\n    } finally {\n      // make sure we release the lock in any case.\n      this.realeaseWriteLock();\n    }\n\n  }\n\n  private void acquireWriteLock() throws InterruptedException {\n    synchronized (this.signal) {\n\n      // Wait until no more readers *and* no writer holds the lock.\n\n      // To do: Insert the condition we need to wait for:\n\n      while (/* condition here! */ ) {\n        // To do: Wait for the lock-holding thread(s) to signal that they released their lock(s).\n      }\n\n      this.writeLocked = true; // Let others know that the write lock has been taken.\n\n    }\n  }\n\n  private void realeaseWriteLock() {\n    synchronized (this.signal) {\n\n      this.writeLocked = false;\n\n      // To do: Notify any and all other waiting threads that we released the lock!\n\n    }\n  }\n\n  public Object read() {\n\n    // To be done...\n\n  }\n\n  private void acquireReadLock() throws InterruptedException {\n    synchronized (this.signal) {\n\n      // Wait until no *writer* holds the lock.\n      // To do: Insert condition we need to wait for:\n\n      while (/* condition here! */ ) {\n         // To do: Wait for the lock-holding thread(s) to signal that they released their lock(s).\n\n      }\n\n      // Now we know that no writer holds the lock. Acquire (another) read lock:\n\n      this.readerCount++;\n\n    }\n  }\n\n  private void releaseReadLock() throws InterruptedException {\n    synchronized (this.signal) {\n\n      this.readerCount--;\n\n      // To do: Notify any threads waiting (i.e. writer threads).\n\n      // (In fact only *required* if there are *no* more readers now because that's the only condition any thread will wait on.)\n\n    }\n  }\n\n  private void doWrite(final Object newState) {\n    // do stuff\n  }\n\n  private Object doRead() {\n    return \"\";\n  }\n\n}\n</code></pre>\n\n<p>The main point to understand may be that <em>every</em> attempt to take a lock may have to <code>wait</code>, and that every release of a lock should <code>notify</code> any (potential) waiting threads.</p>\n","answer_id":56853979,"question_id":56836221,"last_edit_date":1562076665},{"owner":{"profile_image":"https://www.gravatar.com/avatar/68339d6cdb18de89897c8b8bd5b6e44a?s=256&d=identicon&r=PG","account_id":2844499,"user_type":"registered","user_id":2443288,"link":"https://stackoverflow.com/users/2443288/david","reputation":599,"display_name":"David","accept_rate":100},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1562063561,"creation_date":1562063561,"body":"<p>You don't have to expose the locking to the user of the resource, however if you start implementing that pattern you soon discover that you may as well use a ConcurrentHashMap which is actually optimized well for synchronized access</p>\n\n<pre><code>class Resource {\n  private Cache&lt;Key, Value&gt; yourcache;\n  private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n  private final Lock rlock = lock.readLock();\n  private final Lock wlock = lock.writeLock();\n\n  Value read(Key key) { try {\nrlock.lock();\nreturn yourcache.get(key)\n} finally {\nrlock.unlock();\n}\n}\n  void write(Key key) { ... /* similar pattern to above */ ... }\n\n  Lock readLock() { return rlock; } //don't expose these at all!\n  Lock writeLock() { return wlock; }//don't expose these at all!\n}\n</code></pre>\n","answer_id":56850504,"question_id":56847027},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b27d1b2fdf565f8c6bc2abb6ff6d212f?s=256&d=identicon&r=PG","account_id":52242,"user_type":"registered","user_id":156063,"link":"https://stackoverflow.com/users/156063/filip-navara","reputation":4828,"display_name":"Filip Navara","accept_rate":75},"content_license":"CC BY-SA 4.0","score":4,"is_accepted":true,"last_activity_date":1562007037,"creation_date":1327283797,"body":"<p>The general concepts are the same. The differences between the Java and .NET memory model need to be taken into account though. This usually involves using the <a href=\"http://msdn.microsoft.com/en-us/library/system.threading.interlocked.aspx\" rel=\"nofollow noreferrer\">Interlocked</a> functions (in <a href=\"http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/atomic/package-summary.html\" rel=\"nofollow noreferrer\">Java</a>), <a href=\"http://msdn.microsoft.com/en-us/library/system.threading.thread.volatileread.aspx\" rel=\"nofollow noreferrer\">VolatileRead</a> / <a href=\"http://msdn.microsoft.com/en-us/library/system.threading.thread.volatilewrite.aspx\" rel=\"nofollow noreferrer\">VolatileWrite</a> or <a href=\"http://msdn.microsoft.com/en-us/library/system.threading.thread.memorybarrier.aspx\" rel=\"nofollow noreferrer\">explicit memory barrier</a>.</p>\n\n<p>There are two memory models specified for .NET. A weak memory model specified in Section 12, Partition I of the .NET Framework ECMA standard. <a href=\"https://web.archive.org/web/20120310104629/http://msdn.microsoft.com/en-us/magazine/cc163715.aspx\" rel=\"nofollow noreferrer\">Stronger memory model</a> is actually implemented by the .NET Framework runtime. An alternative definition is described by <a href=\"https://web.archive.org/web/20071208141010/http://www.bluebytesoftware.com/blog/2007/11/10/CLR20MemoryModel.aspx\" rel=\"nofollow noreferrer\">Joe Duffy</a>. One practical case where the .NET memory model makes difference to Java one is described on the <a href=\"http://weblog.ikvm.net/PermaLink.aspx?guid=ea28365e-947e-4e00-a969-d8c8a29b3a42\" rel=\"nofollow noreferrer\">IKVM.NET blog</a>.</p>\n\n<p>Regarding your points:</p>\n\n<ol>\n<li><p>Locking works the same way as in Java.</p></li>\n<li><p>Safe publication - The first two scenarios (locks and <a href=\"http://msdn.microsoft.com/en-us/library/x13ttww7%28v=vs.71%29.aspx\" rel=\"nofollow noreferrer\">volatile</a>) work identical to the Java counterparts.</p>\n\n<p>Synchronized collections in .NET are deprecated, but they internally use a lock, so they work exactly the same way as if the accesses were locked.</p>\n\n<p><a href=\"http://msdn.microsoft.com/en-us/library/system.collections.concurrent.aspx\" rel=\"nofollow noreferrer\">Concurrent collections</a> added as part of .NET 3.5 internally use lock-free techniques, so they should be memory coherent between different threads. I'm not sure if they are memory consistent though.</p></li>\n<li>Immutable object are thread-safe by definition. Once you construct an immutable object it can no longer be modified. The thread that created it is the only thread that can have its copy in the cache. Once you publish it, all the other threads will get an up-to-date copy and this copy is guaranteed not to change. Thus, the only sore point is the publishing itself. You still need to care about Safe publication in order not to create two instances of the immutable object, but each of these instances would be thread-safe when accessed from any thread.</li>\n</ol>\n","answer_id":8966482,"question_id":8707215,"last_edit_date":1562007037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG","account_id":47283,"user_type":"registered","user_id":139985,"link":"https://stackoverflow.com/users/139985/stephen-c","reputation":703927,"display_name":"Stephen C","accept_rate":69},"content_license":"CC BY-SA 4.0","score":5,"is_accepted":false,"last_activity_date":1561990636,"creation_date":1561989209,"body":"<p>Hints:</p>\n\n<ul>\n<li>You need a mutex; e.g. a primitive object lock.</li>\n<li>You need a counter of the number of readers <em>currently</em> holding a logical read lock.</li>\n<li>You need a flag to say if a writer is holding a logical write lock.</li>\n<li>You hold the mutex if and only you are acquiring or releasing a logical lock.  Once you have acquired it, you release the mutex.</li>\n<li>You will need to use <code>wait</code> and <code>notify</code>.</li>\n</ul>\n\n<p>Effectively you need to<sup>1</sup> implement a simplified version <code>ReadWriteLock</code>.</p>\n\n<hr>\n\n<p><sup>1 - ... for the purposes of your homework assignment.  In a real world program, you should simply <em>use</em> the existing <code>ReadWriteLock</code> class.</sup></p>\n","answer_id":56836919,"question_id":56836221,"last_edit_date":1561990636},{"owner":{"profile_image":"https://i.stack.imgur.com/5qiMO.jpg?s=256&g=1","account_id":1376679,"user_type":"registered","user_id":1310566,"link":"https://stackoverflow.com/users/1310566/simon-forsberg","reputation":13172,"display_name":"Simon Forsberg","accept_rate":94},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1561901033,"creation_date":1561901033,"body":"<p>The <code>createExpensiveGraph</code> is just a placeholder for whatever function you would like to cache. It could be to retrieve a value from a database, make a HTTP call, or compute a computationally expensive value. Depending on what you would like to cache, you have to implement - and name appropriately - this function yourself.</p>\n","answer_id":56825179,"question_id":56706833},{"owner":{"profile_image":"https://www.gravatar.com/avatar/28df8a966ae08848f42afff541d0af6a?s=256&d=identicon&r=PG","account_id":1200477,"user_type":"registered","user_id":1175053,"link":"https://stackoverflow.com/users/1175053/c-s","reputation":1427,"display_name":"C S"},"content_license":"CC BY-SA 4.0","score":13,"is_accepted":false,"last_activity_date":1561844773,"creation_date":1545979865,"body":"<p>In Python, due to the Global Interpreter Lock (GIL), a process can only execute one python bytecode at a time, regardless of how many threads it has.  This means inserting/updating/reading a key to a dictionary is thread-safe, which is what people usually mean by saying a dictionary's get/put are \"atomic\".<sup>&dagger;</sup></p>\n\n<p>But this means that, exactly as you suspected, multiple threads trying to update different keys to the same dictionary will not be concurrent.  Java, of course, doesn't have the GIL issue so multiple threads can update different keys in the ConcurrentHashMap at the same time.  This doesn't always happen; it's just possible. The ConcurrentHashMap implementation shards the set of keys and locks each shard.  Each shard can be read concurrently but only one thread can write at a time.</p>\n\n<hr>\n\n<p>&dagger;: Sometimes it's pointed out objects with a <code>__hash__</code> method written in Python will require multiple Python bytecodes, so then puts and gets are not atomic per se; however simple puts and gets will still be thread-safe in the sense that they will not cause crashes or garbage values, although you can still have race-conditions.</p>\n","answer_id":53954750,"question_id":48124257,"last_edit_date":1561844773},{"owner":{"profile_image":"https://www.gravatar.com/avatar/106fb294399b9dcf137df54499d91d42?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":14774354,"user_type":"registered","user_id":10669776,"link":"https://stackoverflow.com/users/10669776/przemek-krysztofiak","reputation":914,"display_name":"Przemek Krysztofiak"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1542536981,"creation_date":1542536981,"body":"<p>In my opinion the better way is RxJavaFx\n<br>This sample: <a href=\"https://github.com/pkrysztofiak/rxjavafx-demo\" rel=\"nofollow noreferrer\">https://github.com/pkrysztofiak/rxjavafx-demo</a>\n<br>RxJavaFx tutorial <a href=\"https://github.com/ReactiveX/RxJavaFX\" rel=\"nofollow noreferrer\">https://github.com/ReactiveX/RxJavaFX</a></p>\n\n<pre><code>package com.github.pkrysztofiak.rxjavafx.rxjavafxdemo.concurrency;\n\nimport java.util.Random;\n\nimport io.reactivex.Observable;\nimport io.reactivex.rxjavafx.observables.JavaFxObservable;\nimport io.reactivex.rxjavafx.schedulers.JavaFxScheduler;\nimport io.reactivex.schedulers.Schedulers;\nimport javafx.application.Application;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Button;\nimport javafx.scene.control.Label;\nimport javafx.scene.layout.HBox;\nimport javafx.stage.Stage;\n\npublic class ParallelTasksApp extends Application {\n\n    public static void main(String[] args) {\n        launch(args);\n    }\n\n    @Override\n    public void start(Stage stage) throws Exception {\n        Button button = new Button(\"Start\");\n        Label label = new Label();\n        HBox hBox = new HBox(button, label);\n        stage.setScene(new Scene(hBox));\n        stage.show();\n\n        JavaFxObservable.actionEventsOf(button)\n        .flatMap(actionEvent -&gt; Observable.range(1, 4))\n        .flatMap(i -&gt; Observable.just(i)\n                .subscribeOn(Schedulers.newThread())\n                .map(this::runLongProcess))\n        .observeOn(JavaFxScheduler.platform())\n        .scan(0, (aggregator, next) -&gt; ++aggregator)\n        .map(String::valueOf)\n        .subscribe(label::setText);\n    }\n\n    private int runLongProcess(int i) {\n        try {\n            Thread.sleep(new Random().nextInt(10000));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \" i=\" + i);\n        return i;\n    }\n}\n</code></pre>\n","answer_id":53359883,"question_id":53357250},{"owner":{"profile_image":"https://i.stack.imgur.com/NMBDq.jpg?s=256&g=1","account_id":1244574,"user_type":"registered","user_id":1206301,"link":"https://stackoverflow.com/users/1206301/alexei-kaigorodov","reputation":13277,"display_name":"Alexei Kaigorodov","accept_rate":10},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":true,"last_activity_date":1542514780,"creation_date":1542514780,"body":"<p>Since you extend class Task, you can also overwrite method <code>succeeded()</code> and remove invocation of <code>task.setOnSucceeded()</code> on the main thread:</p>\n\n<pre><code>for (int i = 0; i &lt; n; ++i) {\n  CalcTask task = new CalcTask(i);\n  new Thread(task).start();\n}\n\npublic class CalcTask extends Task&lt;Integer&gt; {\n    protected int id;\n\n    public CalcTask (int id) {\n        this.id = id;\n    }\n\n    public void succeeded() {\n       process(this.getValue());\n    }\n\n    @Override\n    public Integer call() {\n        return CALCULATION_RESULT;\n    }\n}\n</code></pre>\n\n<p>or even use plain <code>Runnable</code> instead of <code>Task</code>:</p>\n\n<pre><code>public class CalcTask implements Runnable {\n    protected int id;\n\n    public CalcTask (int id) {\n        this.id = id;\n    }\n\n    @Override\n    public void run() {\n       CALCULATION_RESULT = calculate();\n       process(CALCULATION_RESULT);\n    }\n}\n</code></pre>\n","answer_id":53357850,"question_id":53357250},{"owner":{"profile_image":"https://i.stack.imgur.com/Wf4sI.jpg?s=256&g=1","account_id":3079737,"user_type":"registered","user_id":2608245,"link":"https://stackoverflow.com/users/2608245/sawan","reputation":246,"display_name":"Sawan","accept_rate":40},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1542369380,"creation_date":1542369380,"body":"<p>It's not wrong but just a safety in case of accidental modification. You could check for equality with <code>concurrentLinkedQueue.size() == maxSize</code> in a conditional statement.</p>\n","answer_id":53337419,"question_id":30129960},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e91ac3a5d330ba7da39c92d8fb60dd3e?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":5982719,"user_type":"registered","user_id":4701158,"link":"https://stackoverflow.com/users/4701158/john-kim","reputation":1091,"display_name":"John Kim","accept_rate":50},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1542349649,"creation_date":1542349649,"body":"<p>It's difficult to say exactly what is causing your error without seeing code and the full error. </p>\n\n<p>However here is perhaps a relevant thread : <a href=\"https://stackoverflow.com/questions/826319/classcastexception-when-casting-to-the-same-class\">ClassCastException when casting to the same class</a></p>\n\n<p>As said in this thread, maybe you have loaded the class with one classloader then tried to cast it to the same class loaded by another classloader? </p>\n","answer_id":53332550,"question_id":53332447},{"owner":{"profile_image":"https://www.gravatar.com/avatar/00f847716086188f2a13a91d508d938b?s=256&d=identicon&r=PG","account_id":5037493,"user_type":"registered","user_id":4045880,"link":"https://stackoverflow.com/users/4045880/michal","reputation":2383,"display_name":"Michal"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1542299877,"creation_date":1542299877,"body":"<p>With naked JDBC, a new Connection as mentioned by Martin Schapendonk is the way to go. </p>\n\n<p>With Spring the <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Propagation.html#REQUIRES_NEW\" rel=\"nofollow noreferrer\">Propagation#REQUIRES_NEW</a> on the <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html\" rel=\"nofollow noreferrer\">Transactional annotation</a> would be available. Similarly, with EJB one could use <a href=\"https://docs.oracle.com/javaee/6/api/javax/ejb/TransactionAttributeType.html#REQUIRES_NEW\" rel=\"nofollow noreferrer\">TransactionAttributeType#REQUIRES_NEW</a>.</p>\n","answer_id":53324031,"question_id":53319482},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c4e0f173f249564a165ec4e60574bdca?s=256&d=identicon&r=PG","account_id":236811,"user_type":"registered","user_id":504547,"link":"https://stackoverflow.com/users/504547/martin-schapendonk","reputation":13011,"display_name":"Martin Schapendonk"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1542289599,"creation_date":1542289599,"body":"<p>Autonomous transactions are good advice. However, you could also open a second connection in your Java program. Handle the updates/commits in one connection and the main transaction in the other.</p>\n","answer_id":53320871,"question_id":53319482},{"owner":{"profile_image":"https://www.gravatar.com/avatar/ab28e5358f7959b75d8649c7e1759874?s=256&d=identicon&r=PG","account_id":1635690,"user_type":"registered","user_id":1509264,"link":"https://stackoverflow.com/users/1509264/mt0","reputation":150157,"display_name":"MT0","accept_rate":58},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":true,"last_activity_date":1542286023,"creation_date":1542286023,"body":"<blockquote>\n  <p>I need to update a column,say Y of some table say X, and that this should be committed but not the whole transaction.</p>\n</blockquote>\n\n<p>You can perform the update of X in an <a href=\"https://docs.oracle.com/cd/B19306_01/appdev.102/b14261/sqloperations.htm#i36056\" rel=\"nofollow noreferrer\">autonomous transaction</a>.</p>\n\n<pre><code>CREATE PROCEDURE updateXofY(\n  in_id IN X.ID%TYPE,\n  in_y  IN X.Y%TYPE\n)\nAS\n  PRAGMA AUTONOMOUS_TRANSACTION;\nBEGIN\n  UPDATE X\n  SET   Y  = in_y\n  WHERE id = in_id;\n  COMMIT;\nEND updateXofY;\n/\n</code></pre>\n\n<p>Once you call the procedure it will update column Y of table X and <code>COMMIT</code> the autonomous transaction without committing the calling transaction.</p>\n\n<p>The drawback of this is that the autonomous transaction is <code>COMMIT</code>ted so that if you <code>ROLLBACK</code> the main transaction then this will not <code>ROLLBACK</code> the autonomous transaction (since it is autonomous).</p>\n","answer_id":53319823,"question_id":53319482},{"owner":{"profile_image":"https://www.gravatar.com/avatar/826b0d5f2ae42a48261b1bfe780596d6?s=256&d=identicon&r=PG","account_id":40662,"user_type":"registered","user_id":117839,"link":"https://stackoverflow.com/users/117839/michael-wiles","reputation":20954,"display_name":"Michael Wiles","accept_rate":74},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1542284955,"creation_date":1542284955,"body":"<p>Why can't you just start another transaction to do the \"inner\" work. Keep the current transaction running and use the new transaction to do the extra piece of work.</p>\n\n<p>Unless if the outer transaction fails you want to roll back the inner transaction as well. In which case I think you need nested transactions.</p>\n","answer_id":53319550,"question_id":53319482},{"owner":{"profile_image":"https://www.gravatar.com/avatar/228e002fe5d793c790597502a4bd9255?s=256&d=identicon&r=PG","account_id":134781,"user_type":"registered","user_id":337156,"link":"https://stackoverflow.com/users/337156/comrad","reputation":105,"display_name":"comrad"},"content_license":"CC BY-SA 4.0","score":-1,"is_accepted":false,"last_activity_date":1542284883,"creation_date":1542284883,"body":"<p>The reason behind an transaction is too be atomic. Therefore there is no general way to do this but save the value and update in another transaction.</p>\n","answer_id":53319527,"question_id":53319482},{"owner":{"profile_image":"https://www.gravatar.com/avatar/d6d2d77ac6734d63354d84a5e44f6906?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":4576229,"user_type":"registered","user_id":3714601,"link":"https://stackoverflow.com/users/3714601/user3714601","reputation":1231,"display_name":"user3714601","accept_rate":43},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":true,"last_activity_date":1542277257,"creation_date":1542277257,"body":"<p>No, it won't try to get write lock. </p>\n\n<p>Container job is done within interceptors, wrapping EJB method calls. For example, when stateless BeanA calls your singleton - it does so through proxy, which makes possible the guarantees given by container (retrieving lock, etc.).  </p>\n\n<p>But in this case, it's just a normal method call (stopWaiting), not wrapped by proxy, so no place for magic.</p>\n","answer_id":53317217,"question_id":53316923},{"owner":{"profile_image":"https://i.stack.imgur.com/NMBDq.jpg?s=256&g=1","account_id":1244574,"user_type":"registered","user_id":1206301,"link":"https://stackoverflow.com/users/1206301/alexei-kaigorodov","reputation":13277,"display_name":"Alexei Kaigorodov","accept_rate":10},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1542173582,"creation_date":1542173582,"body":"<p>Point 2: if the thread is a boat, it should take cars on one bank of the river and unload them on the other bank. Looks like most natural representation of cars on a bank is a BlockingQueue and ArrayList for cars on the boat. Generally, always consider BlockingQueue first.</p>\n\n<p>Point 3: this is usually done by synchronized methods, or <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantLock.html\" rel=\"nofollow noreferrer\">ReentrantLocks</a>.</p>\n","answer_id":53293752,"question_id":53290957},{"owner":{"profile_image":"https://i.stack.imgur.com/lhqqt.png?s=256&g=1","account_id":14692591,"user_type":"registered","user_id":10610826,"link":"https://stackoverflow.com/users/10610826/mykhailo-moskura","reputation":2143,"display_name":"Mykhailo Moskura"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1542154062,"creation_date":1542151918,"body":"<p>Atomic Variables</p>\n\n<p>Atomic Variables are proceed with CAS algorithm and they have can be consumed by multiple threads safely :</p>\n\n<p>CAS :</p>\n\n<p>A typical CAS operation works on three operands:\nThe memory location on which to operate (M) The existing expected\nvalue (A) of the variable The new value (B) which needs to be set The\nCAS operation updates atomically the value in M to B, but only if the\nexisting value in M matches A, otherwise no action is taken.</p>\n\n<p>You can use Exchanger which could be used to swap , exchange some \n   information between two threads</p>\n\n<p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Exchanger.html\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Exchanger.html</a></p>\n\n<p>Blocking queue is consumer producer model a you mentioned , So for \nusing it you need to create two threads one will be Producer it will\nput to the Blocking queue , consumer will consume (read) from it .\nThere are many implementations of BlockingQueue<br>\nHere is more\n   detailed information:</p>\n\n<p><a href=\"http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html\" rel=\"nofollow noreferrer\">http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html</a></p>\n\n<p>So from you list is all on their places.</p>\n\n<p>Also you can reed something here about java.util.concurrent \nI think this will be helpful :</p>\n\n<p><a href=\"http://tutorials.jenkov.com/java-util-concurrent/index.html\" rel=\"nofollow noreferrer\">http://tutorials.jenkov.com/java-util-concurrent/index.html</a></p>\n","answer_id":53291030,"question_id":53290957,"last_edit_date":1542154062},{"owner":{"profile_image":"https://www.gravatar.com/avatar/6b2c535fac79e482b71f15de561f55ca?s=256&d=identicon&r=PG","account_id":60171,"user_type":"registered","user_id":179850,"link":"https://stackoverflow.com/users/179850/gray","reputation":115485,"display_name":"Gray","accept_rate":100},"content_license":"CC BY-SA 4.0","score":53,"is_accepted":true,"last_activity_date":1542149261,"creation_date":1373897871,"body":"<blockquote>\n  <p>Why there is the non-concurrent TreeMap on one side and the ConcurrentSkipListMap on one other?</p>\n</blockquote>\n\n<p>I suspect this was done because making a tree structure concurrent was too difficult or suffered from locking performance problems.   In terms of ordered collections, SkipLists are very simple data structures and provide similar behavior and performance to trees so the <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentSkipListMap.html\" rel=\"noreferrer\"><code>ConcurrentSkipListMap</code></a> (and <code>Set</code>) might have been easier to make concurrent.</p>\n\n<p>I'm actually more disappointed that there isn't a non-concurrent SkipList collection myself.</p>\n\n<blockquote>\n  <p>Is it safe to say that a SkipListMap included a TreeMap?</p>\n</blockquote>\n\n<p>No.  It <em>is</em> safe to say that a SkipList gives similar features in terms of an ordered collection of items that gives <code>O(logN)</code> performance for lookup, insert, delete, etc..  At least it gives a probabilistic approximation of that performance.</p>\n\n<p>Here's a <a href=\"http://igoro.com/archive/skip-lists-are-fascinating/\" rel=\"noreferrer\">good page about skiplists</a>.  They are extremely cool data structures.  I can only hope the are taught in modern programming data structures classes.</p>\n","answer_id":17656453,"question_id":17656373,"last_edit_date":1542149261},{"owner":{"profile_image":"https://www.gravatar.com/avatar/6b2c535fac79e482b71f15de561f55ca?s=256&d=identicon&r=PG","account_id":60171,"user_type":"registered","user_id":179850,"link":"https://stackoverflow.com/users/179850/gray","reputation":115485,"display_name":"Gray","accept_rate":100},"content_license":"CC BY-SA 4.0","score":6,"is_accepted":false,"last_activity_date":1542149121,"creation_date":1289279439,"body":"<blockquote>\n  <p>Why does marking a Java variable volatile make things less synchronized?</p>\n</blockquote>\n\n<p>The question \"why does the code run worse\" with the <code>volatile</code> keyword is not a valid question.  It is behaving <em>differently</em> because of the different memory model that is used for volatile fields.  The fact that your program's output tended towards 0 without the keyword cannot be relied upon and if you moved to a different architecture with differing CPU threading or number of CPUs, vastly different results would not be uncommon.</p>\n\n<p>Also, it is important to remember that although <code>x++</code> seems atomic, it is actually a read/modify/write operation. If you run your test program on a number of different architectures, you will find different results because how the JVM implements <code>volatile</code> is very hardware dependent.  Accessing <code>volatile</code> fields can also be significantly slower than accessing cached fields -- sometimes by 1 or 2 orders of magnitude which will change the timing of your program.</p>\n\n<p>Use of the <code>volatile</code> keyword does erect a memory barrier for the specific field and (as of Java 5) this memory barrier is extended to all other shared variables.  This means that the value of the variables will be copied in/out of central storage when accessed.  However, there are subtle differences between <code>volatile</code> and the <code>synchronized</code> keyword in Java.  For example, there is no locking happening with <code>volatile</code> so if multiple threads are updating a volatile variable, race conditions will exist around non-atomic operations.  That's why we use <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html\" rel=\"nofollow noreferrer\"><code>AtomicInteger</code></a> and friends which take care of increment functions appropriately without synchronization.</p>\n\n<p>Here's some good reading on the subject:</p>\n\n<ul>\n<li><a href=\"http://www.ibm.com/developerworks/java/library/j-jtp06197.html#1.0\" rel=\"nofollow noreferrer\">Java theory and practice: Managing volatility</a></li>\n<li><a href=\"http://www.javamex.com/tutorials/synchronization_volatile.shtml\" rel=\"nofollow noreferrer\">The volatile keyword in Java</a></li>\n</ul>\n\n<p>Hope this helps.</p>\n","answer_id":4130708,"question_id":4130625,"last_edit_date":1542149121},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b17015101f2649d332c389337897816b?s=256&d=identicon&r=PG","account_id":173621,"user_type":"registered","user_id":402428,"link":"https://stackoverflow.com/users/402428/michid","reputation":10596,"display_name":"michid"},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1542145910,"creation_date":1542145910,"body":"<p><code>return value</code> does <em>not</em> need to be synchronized:</p>\n\n<ul>\n<li>reads of references is atomic according to the <a href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7\" rel=\"nofollow noreferrer\">JLS</a>: \"Writes to and reads of references are always atomic, ...\"</li>\n<li>each thread reading <code>value</code> is guaranteed to so see its latest value as according to the <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5\" rel=\"nofollow noreferrer\">Java Memory Model</a> <code>value = newValue</code> <em>happens-before</em> <code>done.countDown()</code>, which <em>happens-before</em> <code>done.await()</code>, which <em>happens-before</em> <code>return value</code>. By transitivity <code>value = newValue</code> thus <em>happens-before</em> <code>return value</code>.</li>\n</ul>\n","answer_id":53290056,"question_id":53284720},{"owner":{"profile_image":"https://www.gravatar.com/avatar/780a651189f64a2cbf4b7f62cf852005?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":7178634,"user_type":"registered","user_id":5483526,"link":"https://stackoverflow.com/users/5483526/matt-timmermans","reputation":55168,"display_name":"Matt Timmermans"},"content_license":"CC BY-SA 4.0","score":8,"is_accepted":true,"last_activity_date":1542133768,"creation_date":1542133332,"body":"<p>The return does not need to be synchronized.  Since <code>CountDownLatch.countDown()</code> is not called until after the value is set for the last time, <code>CountDownLatch.await()</code> ensures that value is stable before it is read and returned.</p>\n\n<p>The developer who wrote this was probably not quite sure of what he was doing (concurrency is difficult and dangerous) or, more likely, his use of the <code>GuardedBy</code> annotation on <code>value</code> caused his build system to emit a warning on the <code>return</code>, and some other developer synchronized it unnecessarily just to make the warning go away.</p>\n\n<p>I say 'some other developer', because this class otherwise seems to be specifically designed to allow <code>getValue()</code> to proceed without locking once the value has been set.</p>\n","answer_id":53287297,"question_id":53284720,"last_edit_date":1542133768},{"owner":{"profile_image":"https://i.stack.imgur.com/XeRXX.png?s=256&g=1","account_id":3598473,"user_type":"registered","user_id":3002418,"link":"https://stackoverflow.com/users/3002418/ricol070","reputation":492,"display_name":"ricol070"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1542130067,"creation_date":1542130067,"body":"<p>The return statement needs to perform a read operation over <em>value</em>.</p>\n\n<p>The read operation is atomic for <em>most</em> primitives, but you're dealing with a generic, meaning you won't know <em>value</em>'s type.</p>\n\n<p>For that reason, the return should be synchronized.</p>\n","answer_id":53286518,"question_id":53284720},{"owner":{"profile_image":"https://www.gravatar.com/avatar/dfce05e7f8fa35ad2f043eaa00c2e83b?s=256&d=identicon&r=PG","account_id":2771244,"user_type":"registered","user_id":2385808,"link":"https://stackoverflow.com/users/2385808/fritz-duchardt","reputation":11224,"display_name":"Fritz Duchardt","accept_rate":62},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1537697179,"creation_date":1537696493,"body":"<p>First up, the straight answer to this problem by Dough Lea:</p>\n\n<blockquote>\n  <p>It is almost never a good idea to use bare spins waiting for values of variables. Use Thread.onSpinWait, Thread.yield, and/or blocking synchronization to better cope with the fact that \"eventually\" can be a long time, especially when there are more threads than cores on a system. </p>\n</blockquote>\n\n<p><a href=\"http://gee.cs.oswego.edu/dl/html/j9mm.html\" rel=\"nofollow noreferrer\">http://gee.cs.oswego.edu/dl/html/j9mm.html</a></p>\n\n<p><strong>Thead.onSpinWait was introduced with Java 9.</strong> It could look like this.</p>\n\n<pre><code>while (true) {\n    while (messageQueue.peek() == null) {\n       Thread.onSpinWait();\n    }\n    // do something with the message\n}\n</code></pre>\n\n<blockquote>\n  <p>By invoking this method within each iteration of a spin-wait loop construct, the calling thread indicates to the runtime that it is busy-waiting. The runtime may take action to improve the performance of invoking spin-wait loop constructions. </p>\n</blockquote>\n\n<p><a href=\"https://docs.oracle.com/javase/9/docs/api/java/lang/Thread.html#onSpinWait--\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/9/docs/api/java/lang/Thread.html#onSpinWait--</a></p>\n","answer_id":52464972,"question_id":3367192,"last_edit_date":1537697179},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b14ba28202572d07a9c99c30103657bb?s=256&d=identicon&r=PG","account_id":1619432,"user_type":"registered","user_id":1496335,"link":"https://stackoverflow.com/users/1496335/urag","reputation":1228,"display_name":"urag","accept_rate":0},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1523542863,"creation_date":1523542863,"body":"<p>After looking in changes in your question I wanted to suggest a different approach using BlockingQueue in such case the producer logic completely separated from the consumer so you could do something like this</p>\n\n<pre><code>public class MyClass {\n\nprivate static BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(10);\n\nprivate static Map&lt;String, String&gt; dataComputed = new ConcurrentHashMap&lt;&gt;();\n\npublic static void writeValues(String key) {\n    Random r = new Random();\n    try {\n        // Simulate working for long time\n        TimeUnit.SECONDS.sleep(r.nextInt(11));\n        String value = \"Hello there fdfsd\" + Math.random();\n        queue.offer(value);\n        dataComputed.putIfAbsent(key, value);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n\n}\n\nprivate static String getValueOrTimeout(String key) throws InterruptedException {\n    String result = dataComputed.get(key);\n    if (result == null) {\n        result = queue.poll(10, TimeUnit.SECONDS);\n    }\n    return result;\n}\n\n\npublic static void main(String... args) throws InterruptedException, ExecutionException {\n    String key = \"TheKey\";\n\n    Thread producer = new Thread(() -&gt; {\n        writeValues(key);\n    });\n\n    Thread consumer = new Thread(() -&gt; {\n        try {\n            String message = getValueOrTimeout(key);\n            if (message == null) {\n                System.out.println(\"No message in 10 seconds\");\n            } else {\n                System.out.println(\"The message:\" + message);\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    });\n\n    consumer.start();\n    producer.start();\n\n}\n</code></pre>\n\n<p>}</p>\n\n<p>With that said I have to agree with @earned that making the client thread to wait is not a good approach instead I would suggest using a WebSocket which gives you an ability to push data to the client when it is ready you can find lots of tutorials on WebSocket here is one for example <a href=\"http://www.baeldung.com/java-websockets\" rel=\"nofollow noreferrer\">ws tutorial</a></p>\n","answer_id":49799035,"question_id":49794862},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b14ba28202572d07a9c99c30103657bb?s=256&d=identicon&r=PG","account_id":1619432,"user_type":"registered","user_id":1496335,"link":"https://stackoverflow.com/users/1496335/urag","reputation":1228,"display_name":"urag","accept_rate":0},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1523536019,"creation_date":1523535266,"body":"<p>I think you should use a Future it gives an ability to compute data in a separate thread and block for the requested time period while waiting for an answer. Notice how it throws an exception if more then 3 seconds passed</p>\n\n<pre><code>public class MyClass {\n\n// Simulates havy work that takes 10 seconds\nprivate static int getValueOrTimeout() throws InterruptedException {\n    TimeUnit.SECONDS.sleep(10);\n    return 123;\n}\n\n\npublic static void main(String... args) throws InterruptedException, ExecutionException {\n    Callable&lt;Integer&gt; task = () -&gt; {\n        Integer val = null;\n        try {\n            val = getValueOrTimeout();\n        } catch (InterruptedException e) {\n            throw new IllegalStateException(\"task interrupted\", e);\n        }\n\n        return val;\n    };\n\n    ExecutorService executor = Executors.newFixedThreadPool(1);\n    Future&lt;Integer&gt; future = executor.submit(task);\n\n    System.out.println(\"future done? \" + future.isDone());\n\n    try {\n        Integer result = future.get(3, TimeUnit.SECONDS);\n        System.out.print(\"Value was computed and was : \" + result);\n    } catch (TimeoutException ex) {\n        System.out.println(\"Not computed within 10 Seconds\");\n    }\n}\n</code></pre>\n\n<p>}</p>\n","answer_id":49796266,"question_id":49794862,"last_edit_date":1523536019},{"owner":{"profile_image":"https://www.gravatar.com/avatar/af9689064b2f7b82d2147bbf7f10d4d7?s=256&d=identicon&r=PG","account_id":2016713,"user_type":"registered","user_id":1803853,"link":"https://stackoverflow.com/users/1803853/davide-lorenzo-marino","reputation":26480,"display_name":"Davide Lorenzo MARINO","accept_rate":71},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1523524660,"creation_date":1523524359,"body":"<p>Here is a possible scenario, where:</p>\n\n<ul>\n<li>Column a is the value of a.</li>\n<li>Thread 1 is the action of thread 1</li>\n<li>The first current is the value of current for the thread 1</li>\n<li>Thread 2 is the action of thread 2</li>\n<li>The second current is the value of current for the thread 2</li>\n</ul>\n\n<p>Here the steps:</p>\n\n<pre><code>a        Thread 1     current     Thread 2    current\n----------------------------------------------------------\n0        current = 0     0 \n0                                 current = 0    0\n0        current = a     0\n0                                 current = a    0\n0        print curr      0                                // Prints 0\n2        a = current+2   0\n2        current = a     2\n2        print current   2                                // Prints 0, 2\n4        a = current+2   2\n4        current = a     4\n4        print current   4                                // Prints 0, 2, 4\n4                                 print current  0        // Prints 0, 2, 4, 0\n2                                 a = current+2  0\n2                                 current = a    2\n2                                 print current  2        // Prints 0, 2, 4, 0, 2\n4                                 a = current+2  2\n4                                 current = a    4\n4                                 print current  4        // Prints 0, 2, 4, 0, 2, 4\n6                                 a = current+2  4 \n6        a = current+2    4\n6                                 current = a    6\n6        current = a      6\n6        print current                                     // Prints 0, 2, 4, 0, 2, 4, 6\n6                                 print current            // Prints 0, 2, 4, 0, 2, 4, 6, 6\n</code></pre>\n\n<p>Note that this is not the only possible scenario because some operations can be inverted between thread 1 and thread 2 (for example the last two couples)   </p>\n","answer_id":49792555,"question_id":49791645,"last_edit_date":1523524660},{"owner":{"profile_image":"https://www.gravatar.com/avatar/729e4caaf411e97d790069c67a9c9cff?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8972075,"user_type":"registered","user_id":6690200,"link":"https://stackoverflow.com/users/6690200/xingbin","reputation":27597,"display_name":"xingbin","accept_rate":100},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1523524369,"creation_date":1523524369,"body":"<blockquote>\n  <p>I mean if first thread enter it's run method, it will change the value\n  of a</p>\n</blockquote>\n\n<p>yes</p>\n\n<blockquote>\n  <p>and if in between second thread comes it will get the changed value of\n  a</p>\n</blockquote>\n\n<p>not so certain, the updated value may not be visible to the second thread. See <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/memconsist.html\" rel=\"nofollow noreferrer\">Memory Consistency</a>:</p>\n\n<blockquote>\n  <p>Suppose a simple int field is defined and initialized:</p>\n  \n  <p><code>int counter = 0;</code></p>\n  \n  <p>The counter field is shared between two threads, A\n  and B. </p>\n  \n  <p>Suppose thread A increments counter:</p>\n  \n  <p><code>counter++;</code></p>\n  \n  <p>Then, shortly afterwards, thread B prints out counter:</p>\n  \n  <p><code>System.out.println(counter);</code></p>\n  \n  <p>If the two statements had been executed\n  in the same thread, it would be safe to assume that the value printed\n  out would be \"1\". But if the two statements are executed in separate\n  threads, the value printed out might well be \"0\", because <strong>there's no\n  guarantee that thread A's change to counter will be visible to thread\n  B — unless the programmer has established a happens-before\n  relationship between these two statements</strong>.</p>\n</blockquote>\n","answer_id":49792560,"question_id":49791645},{"owner":{"profile_image":"https://www.gravatar.com/avatar/ac3d067c37ac7b414d7a4fdffa646594?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6094808,"user_type":"registered","user_id":4755974,"link":"https://stackoverflow.com/users/4755974/veselin-davidov","reputation":7041,"display_name":"Veselin Davidov"},"content_license":"CC BY-SA 3.0","score":-2,"is_accepted":true,"last_activity_date":1523522992,"creation_date":1523522440,"body":"<p>IF there were no racing conditions the answer would be always B) because you increment the same variable. But this is not the case because in this code:</p>\n\n<pre><code> current = a;\n System.out.print(current + \", \");\n a= current + 2;\n</code></pre>\n\n<p>You set current=a (which has some value), use it for printing but during that time another thread may have modified a. And then when you set a=current+2 you override that other threads change.</p>\n\n<p>For example if the steps are:\nInitially a=0;</p>\n\n<ol>\n<li>Thread 1 current=a; (T1 current = 0)</li>\n<li>Thread 2 current=a; (t2 current also = 0)</li>\n<li>Thread 1 prints current -> 0 </li>\n<li>Thread 1 sets a=current+2 -> a=2;</li>\n<li>Thread 2 prints its own current which is still 0 set in step 2</li>\n<li>Thread 2 sets a=current+2 -> a=2 basically overriding step 4 which occurred in the other thread</li>\n</ol>\n\n<p>So you can get other possible answers too like:</p>\n\n<p>0, 0, 2, 4, 6, 2, 4, 6, </p>\n\n<p>0, 2, 4, 6, 0, 2, 4, 6,</p>\n\n<p>0, 2, 4, 0, 2, 4, 6, 6,\netc.</p>\n\n<p>It depends on the way the threads are executed and what has happened between when we set current to something and then set a back to current+2</p>\n","answer_id":49791824,"question_id":49791645,"last_edit_date":1523522992},{"owner":{"profile_image":"https://i.stack.imgur.com/s4qlq.png?s=256&g=1","account_id":6780825,"user_type":"registered","user_id":5221149,"link":"https://stackoverflow.com/users/5221149/andreas","reputation":155680,"display_name":"Andreas"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1523475691,"creation_date":1523475691,"body":"<p>The data with the reference value, and the data for the object, is stored in two different places in memory.</p>\n\n<p>The data for the object is likely stored in multiple places in memory, e.g. if the object has a <code>String</code> field, the <code>String</code> object is itself two objects (the <code>String</code> object and the <code>char[]</code> with the text), so that means your object might be in 3 different places in memory.</p>\n\n<p>With your reference to your object, that means a total of 4 different memory locations, just for a simple object with a <code>String</code> field.</p>\n\n<p>Those 4 locations are <strong>independently cached</strong> by the CPU, as needed.</p>\n\n<p>For example, if you write <code>o.getName().length()</code>, it requires the CPU to:</p>\n\n<ul>\n<li>Read the reference</li>\n<li>Read the <code>name</code> field of <code>Myobject</code> (a <code>String</code> reference)</li>\n<li>Read the <code>value</code> field of <code>String</code> (a <code>char[]</code> reference)</li>\n<li>Read the <code>length</code> of <code>char[]</code></li>\n</ul>\n\n<p>All 4 memory locations will be loaded into the CPU cache.</p>\n\n<p>Some of the memory locations may be very close to each other and reside in the same memory block, e.g. the <code>String</code> object and the <code>char[]</code> may be next to each other, so only 3 memory loads are needed, but above operation will likely access 4 different memory blocks.</p>\n\n<p>Note that it doesn't matter whether your reference is on the stack (local variable or parameter) or on the heap (field of another object), it's still just data in memory.</p>\n","answer_id":49783253,"question_id":49782916},{"owner":{"profile_image":"https://www.gravatar.com/avatar/ca03242df77ec2d8f70f2cea0d6209be?s=256&d=identicon&r=PG","account_id":61566,"user_type":"registered","user_id":183406,"link":"https://stackoverflow.com/users/183406/meriton","reputation":68934,"display_name":"meriton","accept_rate":74},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1523475599,"creation_date":1523475128,"body":"<p>The content of CPU caches is controlled by the CPU, i.e. the actual hardware. It caches arbitrary memory contents and does not distinguish between references or objects.</p>\n\n<p>Therefore, visibility problems are possible whenever mutable memory is accessed by several threads.</p>\n\n<p>Java guarantees that local variables in a method are only accessed by a single thread. That is, if you do </p>\n\n<pre><code>void someMethod() {\n   final Myobject o = new Myobject();\n   // do something with o\n}\n</code></pre>\n\n<p>the reference will not be shared, but the object might (if the constructor stores a reference to the object where another thread might see it).</p>\n","answer_id":49783115,"question_id":49782916,"last_edit_date":1523475599},{"owner":{"profile_image":"https://www.gravatar.com/avatar/de6eafe28472ceb9522fd3f609afed53?s=256&d=identicon&r=PG","account_id":4358,"user_type":"registered","user_id":6509,"link":"https://stackoverflow.com/users/6509/tim-yates","reputation":168420,"display_name":"tim_yates"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1523466283,"creation_date":1523466283,"body":"<p>You can't just stick lambdas into Groovy (until Groovy 3)</p>\n\n<p>You'll need to translate them to Closures, so for example:</p>\n\n<pre><code>() -&gt; validate(clientId, file)\n</code></pre>\n\n<p>becomes:</p>\n\n<pre><code>{ -&gt; validate(clientId, file) }\n</code></pre>\n\n<p>And</p>\n\n<pre><code>(result, throwable) -&gt;\n{                    \n    deferredResult.setResult(result);\n} \n</code></pre>\n\n<p>would be:</p>\n\n<pre><code>{ result, throwable -&gt; deferredResult.setResult(result) } \n</code></pre>\n","answer_id":49780816,"question_id":49780277},{"owner":{"profile_image":"https://lh3.googleusercontent.com/-XdUIqdMkCWA/AAAAAAAAAAI/AAAAAAAAAAA/4252rscbv5M/photo.jpg?sz=256","account_id":13081129,"user_type":"registered","user_id":9451651,"link":"https://stackoverflow.com/users/9451651/guts","reputation":758,"display_name":"Guts"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1523444260,"creation_date":1523431470,"body":"<p>I think that your conditions in while loop are wrong.\nIt should be like this:</p>\n\n<pre><code>while(adminUsing || (u.isAdmin() &amp;&amp; userCount &gt; 0) || (!u.isAdmin() &amp;&amp; adminsWaiting &gt; 0))\n</code></pre>\n","answer_id":49768930,"question_id":49764014,"last_edit_date":1523444260},{"owner":{"profile_image":"https://lh4.googleusercontent.com/-QUM0SNPJsXo/AAAAAAAAAAI/AAAAAAAAABU/3rAlBsd0Qlg/photo.jpg?sz=256","account_id":11583471,"user_type":"registered","user_id":8486518,"link":"https://stackoverflow.com/users/8486518/m%e1%ba%a1nh-quy%e1%ba%bft-nguy%e1%bb%85n","reputation":17797,"display_name":"Mạnh Quyết Nguyễn"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1523418776,"creation_date":1523418776,"body":"<p>I think you can use <code>flatMap()</code>.\nDeclare enum: <code>Availability {TITLE, DETAIL}</code>\nThen mapping:</p>\n\n<pre><code>x.entrySet().parallelStream()\n.map(entry -&gt; {\n    // Construct mapping between y and Boolean here\n    return Map&lt;Y, EnumMap&lt;Availability, Boolean&gt;&gt;;\n})\n.flatMap(v -&gt; v.entrySet().stream())\n.collect(v -&gt; toMap(v.getKey(), v.getValue(), (v1, v2) -&gt; YOUR_DEFINE_MAPPER, ConcurrentHashMap::new));\n</code></pre>\n\n<p>Hope this help</p>\n","answer_id":49766226,"question_id":49763724},{"owner":{"profile_image":"https://i.stack.imgur.com/Mn4kq.png?s=256&g=1","account_id":2147129,"user_type":"registered","user_id":1904517,"link":"https://stackoverflow.com/users/1904517/iagreen","reputation":31578,"display_name":"iagreen"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":true,"last_activity_date":1523418032,"creation_date":1523418032,"body":"<p>I am not sure exactly what you are looking for by a \"message passing construct\".  <code>cache</code> will work for you example above, but you mention you don't want to use that.  </p>\n\n<p>Another option that might fit your use case is using <a href=\"https://github.com/ReactiveX/RxJava/wiki/Connectable-Observable-Operators\" rel=\"nofollow noreferrer\"><code>ConnectableObservable</code></a>. It only starts emitting items when you call <code>connect</code> on it, not when it is subscribed to.  Convert your <code>observableOne</code> to a <code>ConnectableObservable</code> by calling <code>publish</code>.  Then set up all your subscribers.  Then call <code>connect</code> on <code>observableOne</code>.</p>\n\n<pre><code>ConnectableObservable&lt;String&gt; observableOne = Observable\n        .just(\"{1}\")\n        .map(v -&gt; {\n          System.out.println(\"Executing Observable 1\");\n          return v;\n        }).publish();\n\n    Observable&lt;String&gt; observableTwo = observableOne\n        .map(observableOneValue -&gt; {\n          System.out.println(\"Executing Observable 2\");\n          return \"{2\"+observableOneValue+\"}\";\n        });\n\n    Observable.zip(\n        observableOne,\n        observableTwo,\n        (observableOneValue, observableTwoValue) -&gt;\n        {\n          System.out.println(\"Executing Observable 3\");\n          return \"{3\"+observableOneValue+observableTwoValue+\"}\";\n        }\n    ).subscribe(System.out::println);\n\n    // Call when all the subscribers are ready --\n    observableOne.connect();\n</code></pre>\n\n<p>Notes  </p>\n\n<ul>\n<li><code>observableOne</code> is now a <code>ConnectableObservable</code></li>\n<li>need to use <code>subscribe</code> instead of <code>blockingSubscribe</code> so the code will execute the <code>connect</code> call.</li>\n</ul>\n","answer_id":49766141,"question_id":49765151},{"owner":{"profile_image":"https://i.stack.imgur.com/cNxVX.jpg?s=256&g=1","account_id":5412293,"user_type":"registered","user_id":4308639,"link":"https://stackoverflow.com/users/4308639/ruslan-akhundov","reputation":2188,"display_name":"Ruslan Akhundov","accept_rate":73},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1523352519,"creation_date":1523352519,"body":"<p>Of course when you call <code>readLock()/writeLock()</code> on <code>Lock</code> object there would be some overhead on this locking, at least some <code>cas</code> operations, in worst case thread blocking.</p>\n\n<p>There is no much CPU impact because in case of <code>Lock</code>(<code>ReentrantReadWriteLock</code> in your case) it's implemented based on <code>AbstractQueuedSynchronizer</code> and uses <code>cas</code> operations inside. </p>\n\n<p>To eliminate overhead on storing multiple <code>ReentrantReadWriteLock</code> you can either just use <code>synchronized</code> on particular <code>pair</code>(of course then you would be unavailable to use read/write lock optimization, but since each bucket is just a <code>Pair</code>, not a collection, I think there shouldn't be much to lose here, also jvm can optimize <code>synchronized</code> sections in various ways).</p>\n","answer_id":49750078,"question_id":49747795},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b22c1842c6e8f7f2b9b3ed8c0d4efb4d?s=256&d=identicon&r=PG","account_id":2524916,"user_type":"registered","user_id":2194470,"link":"https://stackoverflow.com/users/2194470/szymon-stepniak","reputation":40776,"display_name":"Szymon Stepniak","accept_rate":100},"content_license":"CC BY-SA 3.0","score":7,"is_accepted":true,"last_activity_date":1523344691,"creation_date":1523343282,"body":"<p>You can use <code>.map()</code> instead of <code>.forEach()</code> and return a map created with <code>Collectors.toMap()</code> terminating function instead of modifying external map in parallel. Consider following example:</p>\n\n<pre><code>Map result = x.keySet()\n  .parallelStream()\n  .map(req -&gt; {\n    try {\n      Response response = getResponseForRequest(req);\n      return new AbstractMap.SimpleEntry&lt;&gt;(req, response.getTitle());\n    } catch (TimeoutException e) {\n      return new AbstractMap.SimpleEntry&lt;&gt;(req, null);\n    }\n  })\n  .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey, AbstractMap.SimpleEntry::getValue));\n</code></pre>\n\n<p>In this example you return a <code>SimpleEntry</code> object that represents a key and value for each element and when all entries are processed you collect them to a single map.</p>\n\n<h3>Simplification</h3>\n\n<p><a href=\"https://stackoverflow.com/users/2711488/holger\">Holger</a> suggested even more simplified solution by getting rid of <code>AbstractMap.SimpleEntry</code> at all:</p>\n\n<pre><code>Map result = x.keySet()\n  .parallelStream()\n  .collect(Collectors.toMap(Function.identity(), req -&gt; {\n    try {\n      Response response = getResponseForRequest(req);\n      return response.getTitle()\n    } catch (TimeoutException e) {\n      return null\n    }\n  }));\n</code></pre>\n\n<p>Pick whatever works better for you.</p>\n","answer_id":49747220,"question_id":49747070,"last_edit_date":1523344691},{"owner":{"user_type":"does_not_exist","display_name":"user502187"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1516374518,"creation_date":1516374518,"body":"<p>An easy implementation of an LRU cache does the following, a while loop is only need when the max size is adjusted, but not for the primitive operations:</p>\n\n<ul>\n<li>During put, remove superflous element.  </li>\n<li>During get, move element to top.</li>\n</ul>\n\n<p>The primitive operations will be one shot. You can then use either ordinary synchronized or read write lock around this data structure.</p>\n\n<p>When using read write locks the fairness on who comes first is then rather an issue of the used read write locks than of the LRU cache itself.</p>\n\n<p><a href=\"https://github.com/jburse/jekejeke-devel/blob/master/utils/headless/matula/util/system/CacheBounded.java\" rel=\"nofollow noreferrer\">Here</a> is a sample implementation.  </p>\n","answer_id":48344062,"question_id":30129960},{"owner":{"profile_image":"https://i.stack.imgur.com/ygjaF.png?s=256&g=1","account_id":559545,"user_type":"registered","user_id":921834,"link":"https://stackoverflow.com/users/921834/andrei-zaitcev","reputation":1388,"display_name":"andrei_zaitcev"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":true,"last_activity_date":1506675664,"creation_date":1506675664,"body":"<p>Please correct me if I'm wrong, but I don't see a reason to waste CPU time infinity iterating. Of course, I don't see the entire code and your API may not allow you to do something, but I would implement the data processing in following way:</p>\n\n<pre><code>final class Observation {\n    private float gsr;\n    private float ibi;\n\n    public Observation(float gsr, float ibi) {\n        this.gsr = gsr;\n        this.ibi = ibi;\n    }\n\n    // getters &amp; setters\n\n}\n\npublic final class Observations {\n    private final ConcurrentHashMap&lt;Long, Observation&gt; observations = new ConcurrentHashMap&lt;&gt;();\n\n    public void insertGsrValue(long timestamp, float gsr) {\n        for (;;) {\n            Observation observation = observations.get(timestamp);\n            if (observation == null) {\n                observation = observations.putIfAbsent(timestamp, new Observation(gsr, 0.0f));\n                if (observation == null) {\n                    return;\n                }\n            }\n            if (observations.replace(timestamp, observation, new Observation(gsr, observation.getIbi()))) {\n                return;\n            }\n        }\n    }\n\n    public void insertIbiValue(long timestamp, float ibi) {\n        for (;;) {\n            Observation observation = observations.get(timestamp);\n            if (observation == null) {\n                observation = observations.putIfAbsent(timestamp, new Observation(0.0f, ibi));\n                if (observation == null) {\n                    return;\n                }\n            }\n            if (observations.replace(timestamp, observation, new Observation(observation.getGsr(), ibi))) {\n                return;\n            }\n        }\n    }\n\n    public List&lt;Observation&gt; getObservations() {\n        return new ArrayList&lt;&gt;(observations.values());\n    }\n\n    public void clear() {\n        observations.clear();\n    }\n\n}\n\npublic final class ObservationService extends Service {\n    private final Observations observations = new Observations();\n    private volatile long currentMillis;\n    private HandlerThread handlerThread;\n    private Handler handler;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        handlerThread = new HandlerThread(\"observations_sender_thread\");\n        handlerThread.start();\n        handler = new Handler(handlerThread.getLooper());\n        handler.postDelayed(new Runnable() {\n            @Override\n            public void run() {\n                sendData();\n                handler.postDelayed(this, TimeUnit.SECONDS.toMillis(60));\n            }\n        }, TimeUnit.SECONDS.toMillis(60));\n    }\n\n    @Override\n    public void onDestroy() {\n        handlerThread.quit();\n    }\n\n    private void sendData() {\n        List&lt;Observation&gt; observationList = observations.getObservations();\n        observations.clear();\n        // send observation list somehow\n    }\n\n    public void didReceiveGSR(float gsr, double timestamp) {\n        // assuming this is called on a worker thread\n        long t = System.currentTimeMillis() / 1000;\n        observations.insertGsrValue(t, gsr);\n        currentMillis = t;\n    }\n\n    public void didReceiveIBI(float ibi, double timestamp) {\n        // assuming this is called on a worker thread\n        observations.insertIbiValue(currentMillis, ibi);\n    }\n\n    @Nullable\n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n}\n</code></pre>\n\n<p>So what this code does is insert new values from sensors into a hash map and send it somewhere every 60 seconds. This code is still not perfect as there is a problem with concurrency. For example, if 2 gsr values come first and then one ibi value, then we will lose the first gsr value. </p>\n\n<p>Anyway, this code should give an idea how you can avoid blocking the thread and store the data concurrency.</p>\n\n<p>Please do let me know if you have any questions regarding the code.</p>\n","answer_id":46485364,"question_id":46484053},{"owner":{"profile_image":"https://www.gravatar.com/avatar/eb882db87b8f8087cddca0156f743bf0?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":11875089,"user_type":"registered","user_id":8690351,"link":"https://stackoverflow.com/users/8690351/stone-wu","reputation":1,"display_name":"Stone Wu"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1506611464,"creation_date":1506611464,"body":"<p>you can try to use current system milliseconds &amp; random num<br>\nlike this:\nSystem.currentTimeMillis() + String.format(\"%05d\", random.nextInt(99999))</p>\n","answer_id":46472604,"question_id":46472265},{"owner":{"profile_image":"https://www.gravatar.com/avatar/53ee9941b3fefef67175daf212e62d41?s=256&d=identicon&r=PG","account_id":23121,"user_type":"registered","user_id":57695,"link":"https://stackoverflow.com/users/57695/peter-lawrey","reputation":527376,"display_name":"Peter Lawrey","accept_rate":75},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1506610778,"creation_date":1506610778,"body":"<p>To ensure uniqueness you need to either</p>\n\n<ul>\n<li>use a shared resource, such as a shared directory, or messaging or data grid.</li>\n<li>make it highly unlikely, e.g. use a UUID.</li>\n<li>give each worker a unique id and use this in the file name.</li>\n</ul>\n","answer_id":46472364,"question_id":46472265},{"owner":{"profile_image":"https://www.gravatar.com/avatar/0a56e8febf5fa464d98b39b6a395528c?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":4066516,"user_type":"registered","user_id":3341238,"link":"https://stackoverflow.com/users/3341238/kingamer","reputation":491,"display_name":"KinGamer"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1506560308,"creation_date":1506559618,"body":"<p>A simple approach would be to just use a <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReadWriteLock.html\" rel=\"nofollow noreferrer\">read-write lock</a> (<code>[Reentrant]ReadWriteLock</code>), so many threads could read concurrently, but once someone gets the write lock, nobody else can access the list.</p>\n\n<p>Or you could do something somewhat similar to your idea: one read-write lock for each slot + a global (\"structural\") read-write lock + a variable to keep track of the <code>j &gt;= i</code> cases. So:</p>\n\n<ul>\n<li>To access (read or write) anything, a thread needs at least the global read lock.</li>\n<li>Only threads trying to make structural changes (the ones that change the size) get the global write lock, but only to set an <code>int modifyingFrom</code> variable indicating all positions from there on are \"locked\" (the <code>j &gt;= i</code> cases). After setting <code>modifyingFrom</code>, you downgrade (see <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html\" rel=\"nofollow noreferrer\">docs</a>) from write to read lock, letting others access the list.</li>\n<li>Any thread trying to do anything that isn't a structural change, once holding the global read lock, checks if what it wants to do conflicts with the current value of <code>modifyingFrom</code>. If there's a conflict, sleep until the thread who has set <code>modifyingFrom</code> finishes and notifies everybody who is waiting. This check must be synchronized (just use <code>synchronized (obj)</code> on some object) so the structure-changing thread doesn't happen to <code>obj.notify()</code> before the conflicting thread calls <code>obj.wait()</code> and sleeps forever (holding the global read lock!). :(</li>\n<li>You should either have a <code>boolean structuralChangeHappening = false</code> or set <code>modifyingFrom</code> to some <code>x &gt; &lt;list size&gt;</code> when no structural changes are happening (then you can just check that <code>i &lt; modifyingFrom</code> to <code>get()</code> or <code>update()</code>). A thread finishing a structural change sets <code>modifyingFrom</code> back to this value and here's where it has to synchronize to notify waiting threads.</li>\n<li>A thread wanting to make a structural change when one is already happening will wait because it needs the global write lock and at least one thread has the global read lock. In fact, it will wait until nobody is accessing the list at all.</li>\n<li>A thread allocating a new (bigger... or smaller, if you had a <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#trimToSize--\" rel=\"nofollow noreferrer\"><code>trimToSize()</code></a> or something) array would hold the global <em>write</em> lock <em>during the entire operation</em>.</li>\n</ul>\n\n<p>I was tempted to think the global read-write lock wasn't really necessary, but the last two points justify it.</p>\n\n<p>Some example cases:</p>\n\n<ul>\n<li><em>Some threads trying to <code>get(i)</code> (each with it's <code>i</code>, unique or not):</em> each one would get the global read lock, then the <code>i</code>th read lock, then read the position, and nobody would wait at all.</li>\n<li><em>The same case with additional threads trying to <code>update([index =] i, element)</code>:</em> if there are no equal <code>i</code>s, nobody will wait. Otherwise, only the thread writing or the threads reading the conflicting position will wait.</li>\n<li><em>A thread <code>t</code> starts an <code>insert([index =] 5, element)</code>, and other threads try to <code>get(i)</code>:</em> Once <code>t</code> has set <code>modifyingFrom = 5</code> and released the global write lock, all threads reading get the global read lock, then check <code>modifyingFrom</code>. Those with <code>i &lt; modifyingFrom</code> just get the (read) lock of the slot; the others wait until the <code>insert(5)</code> finishes and notifies, then get the lock of the slot.</li>\n<li><em>A thread starts an <code>add()</code> and needs to allocate a new array:</em> Once it gets the global write lock, nobody else can do anything until it has finished.</li>\n<li><em>The size of the list is 7, a thread <code>t_a</code> calls <code>add(element)</code> and another thread <code>t_g</code> calls <code>get([index =] 7)</code>:</em>\n\n<ul>\n<li>If <code>t_a</code> happens to get the global write lock first, it sets <code>modifyingFrom = 7</code>, and once it has released the lock, <code>t_g</code> gets the global read lock, sees that <code>index (= 7) &gt;= modifyingFrom</code> and sleeps until <code>t_a</code> finishes and notifies it.</li>\n<li>If <code>t_g</code> gets the global read lock first, it checks that <code>7 &lt; modifyingFrom</code> (<code>modifyingFrom &gt; &lt;list size&gt; (== 7)</code>, 4th point before the examples), then throws an exception because <code>7 &gt;= &lt;list size&gt;</code> <strong>after releasing the lock!</strong> Then <code>t_a</code> is able to get the global write lock and proceeds normally.</li>\n</ul></li>\n</ul>\n\n<p>Remembering that accesses to <code>modifyingFrom</code> must be synchronized.</p>\n\n<p>You said you want only that five operations, but if you wanted an iterator, it could check if something changed by other means (not the iterator itself), like standard classes do.</p>\n\n<p>Now, I don't know under which conditions exactly this would be better than other approaches. Also, consider that you may need more restrictions in a real application, because this should ensure only consistency: if you try to read and write the same position, the read can happen before or after the write. Maybe it would make sense to have methods like <code>tryUpdate(int, E)</code>, that only does something if no conflicting structural changes are happening when the method is called, or <code>tryUpdate(int, E, Predicate&lt;ArrayList&gt;)</code>, which only does its work if the list is in a state that satisfies the predicate (which should be defined carefully not to cause deadlocks).</p>\n\n<p>Please let me know if I missed something. There may be lots of corner cases. :)</p>\n","answer_id":46459245,"question_id":46436946,"last_edit_date":1506560308},{"owner":{"profile_image":"https://www.gravatar.com/avatar/f8c60eb5f46783d753e86238a9c18cd9?s=256&d=identicon&r=PG","account_id":265649,"user_type":"registered","user_id":552759,"link":"https://stackoverflow.com/users/552759/jtahlborn","reputation":53086,"display_name":"jtahlborn"},"content_license":"CC BY-SA 3.0","score":5,"is_accepted":false,"last_activity_date":1506531275,"creation_date":1336412383,"body":"<p>Your code will throw an NPE if the key was not previously in the map.</p>\n\n<p>Other than that, although this is a reasonable idea, it will not work in a \"<em>concurrent</em>\" environment. The reason the <code>putIfAbsent()</code> method was added was so that the map could manage the atomicity of the operation using whatever underlying support it is using to make the operations thread-safe. In your implementation, 2 different callers could end of stepping on each other (the first replaces an expired value with a new one, and the second immediately replaces the first new one with a second new one).</p>\n","answer_id":10486523,"question_id":10486413,"last_edit_date":1506531275},{"owner":{"profile_image":"https://www.gravatar.com/avatar/260eb56b4eeadb6e121c1a9d251e2c99?s=256&d=identicon&r=PG","account_id":529422,"user_type":"registered","user_id":2087280,"link":"https://stackoverflow.com/users/2087280/tasgall","reputation":334,"display_name":"Tasgall"},"content_license":"CC BY-SA 3.0","score":-1,"is_accepted":true,"last_activity_date":1506482934,"creation_date":1506482934,"body":"<p>This is not something done on the Java level, it's just inherent in how the OS or CPU itself manage RAM usage. If you're using Java, it's not really something you should worry about (in part because Java should try to keep things cache-coherent (I think it does so based on object type?), but also because there's not a lot of control for it given to you).</p>\n\n<p>When you ask for memory, the OS will find some unused RAM to give you, and load the page it's in to the cache (pages are usually 4KB). If you perform any write operations anywhere in the page, it will get flagged as \"<a href=\"https://en.wikipedia.org/wiki/Dirty_bit\" rel=\"nofollow noreferrer\">dirty</a>\". Anything you do to objects in that page can be done at the cache level, and will be pretty fast. If another core wants to touch data in that page, it will check its cache and - if the cache isn't shared - cause a cache-miss when it doesn't find it, making it try to load from RAM where it will see the \"dirty\" bit set, and cause the cached page to save to RAM before loading for the new core to read.</p>\n","answer_id":46439019,"question_id":46438859},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c422b640dd62b019c125836b1059e231?s=256&d=identicon&r=PG","account_id":169237,"user_type":"registered","user_id":395202,"link":"https://stackoverflow.com/users/395202/adrian-shum","reputation":39170,"display_name":"Adrian Shum","accept_rate":59},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":true,"last_activity_date":1506305045,"creation_date":1463625397,"body":"<p>In your specific example, you don't need that extra synchronized.  Given that you have already mentioned memory visibility (aka happens-before), I won't go deeper to explain this.</p>\n\n<p>However, it does not apply generally.  There are several assumptions in your example making it enough to simply use <code>volatile</code></p>\n\n<ol>\n<li><p>Type of <code>value</code></p>\n\n<p><del>Although you are simply doing a simple retrieval/assignment of <code>value</code>, it is not always guaranteed to be atomic for all data type.  Iirc, Java only guarantee that such operation is atomic for <code>int</code> and types smaller that <code>int</code>.  Which means, for example, if <code>value</code> is of type <code>long</code>, even you have declared it with <code>volatile</code>, you may still corrupt <code>value</code> with your above example</del></p></li>\n<li><p>Operations on <code>value</code></p>\n\n<p>Ok, let's assume it is an <code>int</code>.  In your example, you are simply getting and assigning an <code>int</code> for which the operation is atomic, hence simply using <code>volatile</code> is enough.  However if you have another method doing something like <code>value++</code>, using <code>volatile</code> is not sufficient.  In such case, you may either consider using <code>Atomic*</code> or use <code>synchronized</code></p></li>\n</ol>\n\n<hr>\n\n<p>Update: I later found that JLS <a href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a> mentioned that using volatile would enforce atomic read/write on double/long.  So my original point 1 was actually wrong</p>\n","answer_id":37313034,"question_id":37312655,"last_edit_date":1506305045},{"owner":{"profile_image":"https://www.gravatar.com/avatar/79f682361ccbe900f8846a1098d13921?s=256&d=identicon&r=PG","account_id":279365,"user_type":"registered","user_id":574479,"link":"https://stackoverflow.com/users/574479/biziclop","reputation":49126,"display_name":"biziclop","accept_rate":87},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1506277354,"creation_date":1503568101,"body":"<p>Instruction reordering alone can not lead to another thread seeing a partially constructed object. By definition, the JVM is only allowed to reorder things if they don't affect a <strong>correctly synchronized</strong> program's behaviour.</p>\n\n<p>It's unsafe publishing of the object reference that enables bad things to happen. Here's a particularly poor attempt at a singleton for example:</p>\n\n<pre><code>public class BadSingleton {\n   public static BadSingleton theInstance;\n\n   private int foo;\n\n   public BadSingleton() {\n      this.foo = 42;\n      if (theInstance == null) {\n         theInstance = this;\n      }\n   }\n}\n</code></pre>\n\n<p>Here you accidentally publish the reference to the object being constructed in a <code>static</code> field. This would not necessarily be a problem until the JVM decides to reorder things and places <code>this.foo = 42</code> after the assignment to <code>theInstance</code>. So the two things together conspire to break your invariants and allow another thread to see a <code>BadSingleton.theInstance</code> with its <code>foo</code> field uninitialised.</p>\n\n<p><em>Another frequent source of accidental publication is <strong>calling overrideable methods from the constructor</strong>. This does not always lead to accidental publication, but the potential is there, hence it should be avoided.</em></p>\n\n<blockquote>\n  <blockquote>\n    <p>only the thread that creates an object should have access to it while it is being constructed  </p>\n  </blockquote>\n  \n  <p>And does that mean that the statement from the Java Tutorials is\n  simply not true?</p>\n</blockquote>\n\n<p>Yes and no. It depends on how we interpret the word <code>should</code>. There is no guarantee that in every possible case another thread won't see a partially constructed object. But it's true in the sense that you <strong>should</strong> write code that doesn't allow it to happen.</p>\n","answer_id":45858345,"question_id":45857765,"last_edit_date":1506277354},{"owner":{"profile_image":"https://www.gravatar.com/avatar/f30a1570b27c1389f4decdd649ebe9d9?s=256&d=identicon&r=PG","account_id":1491409,"user_type":"registered","user_id":1398418,"link":"https://stackoverflow.com/users/1398418/oleg","reputation":6134,"display_name":"Oleg"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":true,"last_activity_date":1506151722,"creation_date":1506151722,"body":"<p>As you can see in the <code>ThreadPoolExecutor</code> Constructor you can supply it with any <code>BlockingQueue</code></p>\n\n<pre><code>public ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue&lt;Runnable&gt; workQueue)\n</code></pre>\n\n<p>It can be your own implementation which doesn't have to be weakly consistent and though it doesn't have to throw <code>ConcurrentModificationException</code> either this is the usual exception that is thrown so that's some defensive programming by Java developers.</p>\n","answer_id":46377168,"question_id":46377086},{"owner":{"profile_image":"https://i.stack.imgur.com/Fp4Pm.jpg?s=256&g=1","account_id":1085259,"user_type":"registered","user_id":1081110,"link":"https://stackoverflow.com/users/1081110/dawood-ibn-kareem","reputation":78314,"display_name":"Dawood ibn Kareem"},"content_license":"CC BY-SA 3.0","score":8,"is_accepted":false,"last_activity_date":1503567398,"creation_date":1503567398,"body":"<p>That article is saying  that if  you have code like</p>\n\n<pre><code>foo = new MyInt(7);\n</code></pre>\n\n<p>in a class that has a field</p>\n\n<pre><code>MyInt foo;\n</code></pre>\n\n<p>then the instructions that amount to</p>\n\n<pre><code>(reference to new object).x = 7;\nfoo = (reference to new object);\n</code></pre>\n\n<p>could be swapped over as some kind of optimisation.  This will never change the behaviour of the thread that's running this code, but it's possible that some other thread will be able to read <code>foo</code> after the line</p>\n\n<pre><code>foo = (reference to new object);\n</code></pre>\n\n<p>but before the line</p>\n\n<pre><code>(reference to new object).x = 7;\n</code></pre>\n\n<p>in which case it would see <code>foo.x</code> as <code>0</code>, not <code>7</code>.  That is to say, that other thread could run</p>\n\n<pre><code>int bar = someObject.getFoo().getValue();\n</code></pre>\n\n<p>and end up with <code>bar</code> equal to <code>0</code>.</p>\n\n<p>I've never seen anything like this happen in the wild, but the author seems to know what he's talking about.</p>\n","answer_id":45858064,"question_id":45857765},{"owner":{"profile_image":"https://lh6.googleusercontent.com/-uiCYgyMfGFg/AAAAAAAAAAI/AAAAAAAACAY/Ie4gH-XMM-Q/photo.jpg?sz=256","account_id":10878617,"user_type":"registered","user_id":7998319,"link":"https://stackoverflow.com/users/7998319/gati-sahu","reputation":2606,"display_name":"gati sahu"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1498411928,"creation_date":1498411928,"body":"<p>In your case queue in between not solving any purpose.Before jump into coding analyze the real bottleneck  in processing large files.</p>\n\n<p>Processing a file involves reading from the disk, processing (e.g. parsing an XML and transforming), and writing back to the disk.So  it is a trade off in terms of  better I/O, better CPU usage, and better memory usage. To know It is important to conduct profiling to monitor CPU usage, memory usage, and I/O efficiency.</p>\n\n<ul>\n<li>Reading the data from the disk can be I/O-heavy.</li>\n<li>Storing the read data in the Java heap memory to process them can be memory-\nheavy.</li>\n<li>Parsing &amp; transforming the data can be CPU-heavy.</li>\n<li>Writing the processed data back to the disk can be I/O-heavy.</li>\n</ul>\n","answer_id":44748851,"question_id":44746219},{"owner":{"profile_image":"https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG","account_id":47283,"user_type":"registered","user_id":139985,"link":"https://stackoverflow.com/users/139985/stephen-c","reputation":703927,"display_name":"Stephen C","accept_rate":69},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1498399560,"creation_date":1498399560,"body":"<p>An ExecutorService with a fixed sized thread pool is a good choice.  However, I think you should make the pool size a tuning parameter.</p>\n\n<p>The problem is that we don't know if <code>migrateFile</code> is CPU intensive, I/O intensive, memory (heap <em>size</em>) intensive or some combination.  The optimal thread could will depend on this.  The best strategy is to do some experiments.</p>\n","answer_id":44747149,"question_id":44746219},{"owner":{"profile_image":"https://i.stack.imgur.com/zw18i.png?s=256&g=1","account_id":1663234,"user_type":"registered","user_id":1531124,"link":"https://stackoverflow.com/users/1531124/ghostcat","reputation":138406,"display_name":"GhostCat","accept_rate":96},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":true,"last_activity_date":1498396527,"creation_date":1498393078,"body":"<p>Given the fact that the numper is fixed, that queue does not provide any benefit. You don't need it. You would need it if new files kept coming in. </p>\n\n<p>The number of threads looks valid, too. But it really depends on OS and JVM version to get the best number. You might rather do some experiments to be sure. </p>\n","answer_id":44746294,"question_id":44746219,"last_edit_date":1498396527},{"owner":{"profile_image":"https://www.gravatar.com/avatar/d16713045b2c53f8716538d847cd59db?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6763529,"user_type":"registered","user_id":5209273,"link":"https://stackoverflow.com/users/5209273/uoyilmaz","reputation":3055,"display_name":"uoyilmaz"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":true,"last_activity_date":1489406434,"creation_date":1489406434,"body":"<p>Read how synchronized keyword works: <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html</a></p>\n\n<p>The relevant part:</p>\n\n<blockquote>\n  <p>it is not possible for two invocations of synchronized methods on the\n  same object to interleave. When one thread is executing a synchronized\n  method for an object, all other threads that invoke synchronized\n  methods for the same object block (suspend execution) until the first\n  thread is done with the object.</p>\n</blockquote>\n","answer_id":42763148,"question_id":42762987},{"owner":{"profile_image":"https://www.gravatar.com/avatar/2f0d9dec16bae1e06552af55ddefc11f?s=256&d=identicon&r=PG","account_id":277416,"user_type":"registered","user_id":571407,"link":"https://stackoverflow.com/users/571407/jb-nizet","reputation":681878,"display_name":"JB Nizet","accept_rate":100},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1489406273,"creation_date":1489406273,"body":"<p>Your <code>put()</code> and <code>get()</code> methods are synchronized. So if the producer enters the <code>put()</code> method, tries to acquire the <code>notFull</code> semaphore, but can't because the buffer is full, it blocks forever, keeping the lock it acquired when entering the synchronized method. So the consumer can't enter the get() method, and can't remove elements from the buffer.</p>\n","answer_id":42763095,"question_id":42762987},{"owner":{"profile_image":"https://www.gravatar.com/avatar/5e29d2624e7e9a02320b3055a1d62193?s=256&d=identicon&r=PG","account_id":2415386,"user_type":"registered","user_id":2109526,"link":"https://stackoverflow.com/users/2109526/alex-suo","reputation":2987,"display_name":"Alex Suo","accept_rate":43},"content_license":"CC BY-SA 3.0","score":3,"is_accepted":true,"last_activity_date":1489382848,"creation_date":1489382848,"body":"<p>1) The <code>synchronized</code> in the writing side only guarantees that </p>\n\n<p>1.1 When entering the code block, all the previous operations before the <code>synchronized</code> are done and written to main memory.</p>\n\n<p>1.2 All the variables operated in the block have their value directly from main memory (i.e. all cache lines are refreshed).</p>\n\n<p>1.3 At the end of the block, the altered variables are written into the main memory before quitting the block.</p>\n\n<p>So when you read from another thread, you need <code>synchronized</code> to make sure it reads the latest value from the main memory, not from the thread cached value (i.e. the CPU cache line are successfully refreshed before used).</p>\n\n<p>2) I don't know what's factors but I guess it's a shared object. If so and assignment operator in Java is just pointer assignment i.e. you still pointing to the same factors object; thus operating on it (read and write) still need synchronization.</p>\n","answer_id":42757138,"question_id":42757087},{"owner":{"profile_image":"https://www.gravatar.com/avatar/3f80897d57525afe9eac4fb8c8318052?s=256&d=identicon&r=PG","account_id":2734060,"user_type":"registered","user_id":2357112,"link":"https://stackoverflow.com/users/2357112/user2357112","reputation":263892,"display_name":"user2357112","accept_rate":26},"content_license":"CC BY-SA 3.0","score":6,"is_accepted":true,"last_activity_date":1489379836,"creation_date":1489379119,"body":"<blockquote>\n  <p>Ideally, I could use ConcurrentMap's putIfAbsent(key, new SomeObject(key)), but that means that I create a new SomeObject(key) each time, which seems very wasteful.</p>\n</blockquote>\n\n<p>Then use <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html#computeIfAbsent-K-java.util.function.Function-\" rel=\"nofollow noreferrer\"><code>computeIfAbsent</code></a>:</p>\n\n<pre><code>concurrentMap.computeIfAbsent(key, SomeObject::new);\n</code></pre>\n\n<p>Using <code>synchronized</code> with a ConcurrentMap doesn't prevent other threads from performing operations on the map in the middle of the <code>synchronized</code> block. ConcurrentMap doesn't promise to use the map's monitor for synchronization, and neither ConcurrentHashMap nor ConcurrentSkipListMap synchronize on the map object.</p>\n\n<p>Note that the ConcurrentMap interface doesn't promise that the value will only be computed once, or that the value won't be computed if the key is already present. ConcurrentHashMap makes these promises, but ConcurrentSkipListMap doesn't.</p>\n","answer_id":42756605,"question_id":42756419,"last_edit_date":1489379836},{"owner":{"profile_image":"https://www.gravatar.com/avatar/576123e76ce4e0e40dd090ea8bc61258?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8398242,"user_type":"registered","user_id":6304521,"link":"https://stackoverflow.com/users/6304521/ebret","reputation":63,"display_name":"ebret"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1489174187,"creation_date":1489173245,"body":"<p>see : \n<a href=\"https://stackoverflow.com/questions/7457190/how-are-threads-allocated-to-handle-servlet-request\">How are Threads allocated to handle Servlet request?</a></p>\n\n<p>It is not specify in Servlet JSR, but usually a J2EE web server use one thread to handle a user request.</p>\n\n<p>So many request are using one instance of your Servlet => many thread are using one instance of your Servlet.</p>\n\n<p>To avoid deadlock or performance issue don't synchronized Servlet code, make them threadsafe and stateless:</p>\n\n<p>See: \n<a href=\"https://stackoverflow.com/questions/3106452/how-do-servlets-work-instantiation-sessions-shared-variables-and-multithreadi\">How do servlets work? Instantiation, sessions, shared variables and multithreading</a></p>\n\n<p>JSR Servlet spec 3.0\n<a href=\"http://download.oracle.com/otndocs/jcp/servlet-3.0-fr-eval-oth-JSpec/\" rel=\"nofollow noreferrer\">http://download.oracle.com/otndocs/jcp/servlet-3.0-fr-eval-oth-JSpec/</a></p>\n\n<blockquote>\n  <p><strong>Request Handling Methods</strong>\n  The basic Servlet interface defines a service method for handling client requests.\n  This method is called for each request that the servlet container routes to an instance\n  of a servlet.\n  The handling of concurrent requests to a Web application generally requires that the\n  Web Developer design servlets that can deal with multiple threads executing within\n  the service method at a particular time.\n  Generally the Web container handles concurrent requests to the same servlet by\n  concurrent execution of the service method on different threads. </p>\n</blockquote>\n","answer_id":42726073,"question_id":42725923,"last_edit_date":1495541369},{"owner":{"profile_image":"https://www.gravatar.com/avatar/eeec80237213c91e5bab56b77ac5b8ca?s=256&d=identicon&r=PG","account_id":16878,"user_type":"registered","user_id":37213,"link":"https://stackoverflow.com/users/37213/duffymo","reputation":306143,"display_name":"duffymo","accept_rate":81},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":true,"last_activity_date":1489172807,"creation_date":1489172807,"body":"<p>Servlets should be written as if they were single threaded.  Each HTTP request coming in will be handled in a separate thread.</p>\n\n<p>This means <em>no</em> shared mutable state in servlet classes.</p>\n\n<p>If your servlet has no private data members and all operations are performed on parameters that are passed in or local objects, you're thread safe.  No synchronization needed.</p>\n\n<p>Shared state has to be thread safe.</p>\n","answer_id":42725963,"question_id":42725923},{"owner":{"profile_image":"https://www.gravatar.com/avatar/6b2c535fac79e482b71f15de561f55ca?s=256&d=identicon&r=PG","account_id":60171,"user_type":"registered","user_id":179850,"link":"https://stackoverflow.com/users/179850/gray","reputation":115485,"display_name":"Gray","accept_rate":100},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1489121260,"creation_date":1489121260,"body":"<p>[[ @biziclop's answer is right albeit long and confusing. ]]</p>\n\n<blockquote>\n  <p>Is it theoretically possible that one task will be wedged to another and we will see output like this:</p>\n</blockquote>\n\n<p>Not in the code that you posted.  You are submitting 2 jobs to a single threaded executor:</p>\n\n<pre><code>ExecutorService executorService = Executors.newSingleThreadExecutor();\n</code></pre>\n\n<p>This means that only 1 thread will be executing your 2 <code>Runnable</code>s.  When that 1st thread blocks the other <code>Runnable</code> is not executing so the output won't interleave.  The 1st <code>Runnable</code> will need to complete <em>before</em> the 2nd <code>Runnable</code> is executed.</p>\n\n<p>If you use the <code>Executors.newCachedThreadExecutor();</code>, then the 2 <code>Runnable</code>s can be run concurrently and their output could interleave.  In that case, the first <code>Runnable</code> might print out <code>runnable_1_1</code> and then be time sliced so the the other thread can execute and display it's <code>runnable_2_1</code>, etc..  This is a race condition however and may be unlikely, but it's possible.</p>\n\n<blockquote>\n  <p>Single thread executor is not mandatory for this example. Mandatory that we have only one CPU core</p>\n</blockquote>\n\n<p>As @biziclop mentions, the number of CPUs on your hardware does not matter.  What matters is how many threads are in the run queue at any one point in time.</p>\n","answer_id":42710447,"question_id":42531716},{"owner":{"profile_image":"https://i.stack.imgur.com/ojvZh.jpg?s=256&g=1","account_id":1316033,"user_type":"registered","user_id":1262865,"link":"https://stackoverflow.com/users/1262865/john16384","reputation":7855,"display_name":"john16384","accept_rate":50},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":true,"last_activity_date":1488967029,"creation_date":1488966375,"body":"<p>I suspect the reason that it doesn't scale well is in Apache's code.</p>\n\n<p>I found that <code>RandomStringUtils</code> uses the standard <code>java.util.Random</code> which is known to not scale well with multiple threads, because of this kind of code:</p>\n\n<pre><code>protected int next(int bits) {\n    long oldseed, nextseed;\n    AtomicLong seed = this.seed;\n    do {\n        oldseed = seed.get();\n        nextseed = (oldseed * multiplier + addend) &amp; mask;\n    } while (!seed.compareAndSet(oldseed, nextseed));\n    return (int)(nextseed &gt;&gt;&gt; (48 - bits));\n}\n</code></pre>\n\n<p>This uses an <code>AtomicLong</code> for the <code>seed</code>.  In other words, all the threads use the same <code>Random</code> instance which use the same <code>AtomicLong</code>.  This will cause contention between the threads (especially since you are generating such long random strings) and they will waste of lot cycles doing needless synchronisation.</p>\n\n<p>When I tested it with a different kind of CPU consuming function (a loop that sums), the scaling with multiple threads worked as expected.</p>\n","answer_id":42667885,"question_id":42667412,"last_edit_date":1488967029},{"owner":{"profile_image":"https://www.gravatar.com/avatar/79f682361ccbe900f8846a1098d13921?s=256&d=identicon&r=PG","account_id":279365,"user_type":"registered","user_id":574479,"link":"https://stackoverflow.com/users/574479/biziclop","reputation":49126,"display_name":"biziclop","accept_rate":87},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1488450997,"creation_date":1488372348,"body":"<p>The number of CPUs doesn't matter when you're trying to reason about code on this level. In theory you could run the JVM on an OS that forces a context switch after every single program instruction. It would be mad and no OS does that, but how would you know just by looking at the Java code?</p>\n\n<p>If it's a single thread executor, the answer is there will be no overlapping, and if it isn't a single thread executor, you can't prove there will be no overlapping.</p>\n\n<p>To find the reason, we need to look at Chapter 17 of the JLS:</p>\n\n<blockquote>\n  <p>Two actions can be ordered by a happens-before relationship. If one\n  action happens-before another, then the first is visible to and\n  ordered before the second.</p>\n  \n  <p>If we have two actions x and y, we write hb(x, y) to indicate that x\n  happens-before y.</p>\n  \n  <p><strong>If x and y are actions of the same thread and x comes before y in\n  program order, then hb(x, y).</strong></p>\n  \n  <p>There is a happens-before edge from the end of a constructor of an\n  object to the start of a finalizer (§12.6) for that object.</p>\n  \n  <p>If an action x synchronizes-with a following action y, then we also\n  have hb(x, y).</p>\n  \n  <p>If hb(x, y) and hb(y, z), then hb(x, z).</p>\n  \n  <p>The wait methods of class Object (§17.2.1) have lock and unlock\n  actions associated with them; their happens-before relationships are\n  defined by these associated actions.</p>\n  \n  <p>It should be noted that the presence of a happens-before relationship\n  between two actions does not necessarily imply that they have to take\n  place in that order in an implementation. If the reordering produces\n  results consistent with a legal execution, it is not illegal.</p>\n</blockquote>\n\n<p>In the single thread executor case this is exactly what we get: the two runnables are actions of the same thread and one will be ahead of the other in program order. And though the last paragraph would allow reordering, reordering can't lead to visible differences in correctly synchronised code.</p>\n\n<p>With multiple threads it's anybody's guess. There are only two things that are guaranteed:</p>\n\n<ol>\n<li>The first message from a thread will be printed before the second. (See above)</li>\n<li>And each line of the output will contain a full message from one of the threads, i.e. you'll never see a line of jumbled output. This is simply because <code>PrintStream.println()</code> is synchronised.</li>\n</ol>\n\n<hr>\n\n<p>So that's the theory.</p>\n\n<p>In practice, with most JVM implementations and operating systems, you'll probably never see an overlap with this exact code for the simple reason that the tasks you execute would take too little time to be interrupted. Make them run for minutes or hours though and you'll definitely see context switching between the two.</p>\n","answer_id":42532119,"question_id":42531716,"last_edit_date":1488450997},{"owner":{"profile_image":"https://i.stack.imgur.com/gNHmR.jpg?s=256&g=1","account_id":167824,"user_type":"registered","user_id":1439305,"link":"https://stackoverflow.com/users/1439305/audrius-me%c5%a1kauskas","reputation":21098,"display_name":"Audrius Meškauskas","accept_rate":81},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1488394103,"creation_date":1488372202,"body":"<p>This cannot be cleanly done on Java level for an arbitrary thread, as there are no non-<a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#suspend()\" rel=\"nofollow noreferrer\">deprecated methods</a> to suspend it. All valid methods of control include the thread actively yielding.</p>\n\n<p>However operating system itself normally has a scheduler that periodically suspends  and resumes all running processes, allowing to have much more of them than the number of CPU cores available. Also, Java virtual machine normally does not run just as a single process (<a href=\"https://stackoverflow.com/questions/5713142/green-threads-vs-non-green-threads\">green threads</a> belong to the past), there is one process per thread.</p>\n\n<p>As a result, the operating system may suspend one thread for a short time, allowing to run another thread, or some other process outside Java virtual machine. The general answer is likely yes.</p>\n","answer_id":42532076,"question_id":42531716,"last_edit_date":1495540437},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e4bac7ebd5f5a06c716f508af656e24b?s=256&d=identicon&r=PG","account_id":235018,"user_type":"registered","user_id":501557,"link":"https://stackoverflow.com/users/501557/templatetypedef","reputation":364854,"display_name":"templatetypedef","accept_rate":90},"content_license":"CC BY-SA 3.0","score":6,"is_accepted":true,"last_activity_date":1479934790,"creation_date":1479934790,"body":"<p>The atomicity of a write means that <em>at the time you have the value ready to store</em>, the write will be done in a way such that every thread either (1) reads the previous value or (2) reads the new value, but never something corrupted. In your case, the logic to execute the statement</p>\n\n<pre><code>emp = calcluate();\n</code></pre>\n\n<p>can be broken down into two steps:</p>\n\n<ol>\n<li>Call the <code>calcluate</code> method and obtain a value; let's call it <code>val</code>.</li>\n<li>Atomically write <code>val</code> into <code>emp</code>.</li>\n</ol>\n\n<p>This means that if you try to read <code>emp</code> while the <code>calculate</code> function is still going (or, in the narrow time band between when it returns and the value hasn't been written yet), you will just get whatever value happens to already be in <code>emp</code>. The other threads will not be blocked from reading it. If you want to do that, you'll need to use some explicit synchronization.</p>\n\n<p>(As a note - atomicity does not mean \"all other threads will be blocked until the value is ready.\" It means \"all other threads will either see the state purely before the operation is done or purely after the operation is done, but nothing else.\")</p>\n","answer_id":40774070,"question_id":40774010},{"owner":{"profile_image":"https://www.gravatar.com/avatar/1566b5918e4380e51e7617d852ae791b?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":3319174,"user_type":"registered","user_id":2790759,"link":"https://stackoverflow.com/users/2790759/tom","reputation":181,"display_name":"Tom"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1473775162,"creation_date":1473775162,"body":"<p>The problem which you ask about is caused by JVM optimizations and the fact that simple object creation:</p>\n\n<pre><code>MyClass obj = new MyClass()\n</code></pre>\n\n<p>isn't always done by steps:</p>\n\n<ol>\n<li>Reserve memory for new instance of MyClass on the Heap</li>\n<li>Execute constructor to set internal properties values</li>\n<li>Set 'obj' reference to address on the Heap</li>\n</ol>\n\n<p>For some optimization purposes JVM can do it by steps:</p>\n\n<ol>\n<li>Reserve memory for new instance of MyClass on the Heap</li>\n<li>Set 'obj' reference to address on the Heap</li>\n<li>Execute constructor to set internal properties values</li>\n</ol>\n\n<p>So, imagine if two threads want to access MyClass object. First one creates it but due to JVM it executes 'optimized' set of steps. If it will execute only step 1 and 2 (but wont do 3) than we can have a serious problem. If second thread uses this object (it wont be null because it already points to reserved part of memory on the Heap) than it's properties will be incorrect which can lead to nasty things. </p>\n\n<p>This optimization wont happen if reference will be volatile.</p>\n","answer_id":39471963,"question_id":16107683},{"owner":{"profile_image":"https://i.stack.imgur.com/ek7RV.png?s=256&g=1","account_id":911472,"user_type":"registered","user_id":945226,"link":"https://stackoverflow.com/users/945226/g-blake-meike","reputation":6655,"display_name":"G. Blake Meike","accept_rate":70},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1472334950,"creation_date":1472334950,"body":"<p>I think it is ok.</p>\n\n<p>The array <code>pixels</code> (probably aliased as <code>mPixels</code>) is accessed from more than one thread.  That would make it incorrect.</p>\n\n<p>It appears, though, that you are chunking access to the array so that each thread accesses only its own chunk.  As long as multiple threads never access the same spot in the array, the code is correct.</p>\n\n<p>I gotta say, though, that it is wildly confusing.  I would say that the variable <code>len</code> is misnamed.  Certainly, the concurrency correctness is really hard to determine.  I believe that it could be written more clearly and that, with something so error-prone, it would be well worth doing so.</p>\n","answer_id":39186100,"question_id":39185681},{"owner":{"profile_image":"https://i.stack.imgur.com/49VtI.jpg?s=256&g=1","account_id":7926575,"user_type":"registered","user_id":5985853,"link":"https://stackoverflow.com/users/5985853/alexey-soshin","reputation":16936,"display_name":"Alexey Soshin"},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1472281016,"creation_date":1472205153,"body":"<p>I think you're looking for WorkStealingPool:</p>\n\n<pre><code>static ExecutorService executor = Executors.newWorkStealingPool(4);\nprivate static Map&lt;Integer, AtomicInteger&gt; map = new ConcurrentHashMap&lt;&gt;();\n\npublic static void main(String[] args) throws InterruptedException {\n\n\n    for (int i = 0; i &lt; 10; i++) {\n        executor.submit(new Worker(i))  ;\n    }\n\n    Thread.sleep(10000);\n    System.out.println(map);\n}\n\nprivate static class Worker implements Runnable {\n    private final int k;\n\n    public Worker(int k) {\n        this.k = k;\n    }\n\n    @Override\n    public void run() {\n        map.putIfAbsent(k, new AtomicInteger(0));\n        map.get(k).getAndIncrement();\n        executor.submit(new Worker(this.k));\n\n       // Also possible to resubmit current job\n       //executor.submit(this);\n    }\n}\n</code></pre>\n","answer_id":39163456,"question_id":39162994,"last_edit_date":1472281016},{"owner":{"profile_image":"https://i.stack.imgur.com/3AtSv.png?s=256&g=1","account_id":2269593,"user_type":"registered","user_id":1997376,"link":"https://stackoverflow.com/users/1997376/nicolas-filotto","reputation":43917,"display_name":"Nicolas Filotto","accept_rate":100},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1472234872,"creation_date":1472233704,"body":"<p>You miss an important point:</p>\n\n<blockquote>\n  <p><code>ImprovedList</code> assumes that once a list is passed to its constructor, the client will not use the underlying list directly again, accessing it only through the <code>ImprovedList</code>.</p>\n</blockquote>\n\n<p>So the use case that your raise is not applicable here. <code>ImprovedList</code> is just similar to <code>Collections.synchronizedList(List)</code>, it is only a wrapper class that prevents any concurrent modifications on the underlying list using intrinsic locks nothing more so if the list provided to constructor is not accessed directly but through <code>ImprovedList</code>, it is thread-safe it is what you are supposed to understand in this case.</p>\n\n<p>But generally speaking indeed, if you share the (non thread-safe) <code>List</code> provided to the constructor and you don't make a safe copy of it first (knowing that creating a safe copy of a non thread-safe List is not a thread-safe operation), it won't be thread-safe any more. However please note that sharing a non thread-safe <code>List</code> is a mistake so it is not really a real life use case.</p>\n","answer_id":39172035,"question_id":39171534,"last_edit_date":1472234872},{"owner":{"profile_image":"https://www.gravatar.com/avatar/f53318df972a9be25d0cebf34d0420b6?s=256&d=identicon&r=PG","account_id":879004,"user_type":"registered","user_id":225703,"link":"https://stackoverflow.com/users/225703/andrew-lygin","reputation":6117,"display_name":"Andrew Lygin"},"content_license":"CC BY-SA 3.0","score":3,"is_accepted":true,"last_activity_date":1472233975,"creation_date":1472233557,"body":"<p>A citation from the book:</p>\n\n<blockquote>\n  <p>this is guaranteed to provide thread safety so long as our class\n  holds the only outstanding reference to the underlying <code>List</code>.</p>\n</blockquote>\n\n<p>So, you're right that the class cannot be called thread-safe if someone holds a reference to the same list. But you're wrong in not reading the book attentively.</p>\n","answer_id":39171999,"question_id":39171534,"last_edit_date":1472233975},{"owner":{"profile_image":"https://i.stack.imgur.com/zw18i.png?s=256&g=1","account_id":1663234,"user_type":"registered","user_id":1531124,"link":"https://stackoverflow.com/users/1531124/ghostcat","reputation":138406,"display_name":"GhostCat","accept_rate":96},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1472232251,"creation_date":1472231969,"body":"<p>You are correct. If you want to make such a list really \"thread safe\", then the fact that the \"incoming\" list is just used directly (and not copied for example) allows for changes in the context of any other object that holds a reference to that initial \"incoming\" list.</p>\n\n<p>And beyond that; this implementation even allows for doing \"hard modifications\" to the list that are <strong>not</strong> synchronized; like</p>\n\n<pre><code>public T remove(int index) {\n</code></pre>\n\n<p>So - I agree with your assessment; this doesn't look exactly thread-safe. To a certain degree it is; but well, \"being 90% thread safe\", that is about as good as a project \"being 90% done\", right?!</p>\n","answer_id":39171608,"question_id":39171534,"last_edit_date":1472232251},{"owner":{"profile_image":"https://lh4.googleusercontent.com/-yL5fXt26_tY/AAAAAAAAAAI/AAAAAAAAA8A/6RD1pmObT5s/photo.jpg?sz=256","account_id":7950684,"user_type":"registered","user_id":6001605,"link":"https://stackoverflow.com/users/6001605/neha-vari","reputation":492,"display_name":"Neha Vari"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1472228846,"creation_date":1467882954,"body":"<p>In your class <code>Hello</code> there is only one field <code>int value</code>. Synchronized  locks whole object and thus heavy operation, Instead you can use AtomicInteger. Since Atomic* variables are faster. Volatile just satisfies \"happens before\" you cannot achieve atomicity for operations like \"check then act\" with volatiles.</p>\n\n<p>To make <code>Hello</code> class thread-safe, the best way </p>\n\n<pre><code>import java.util.concurrent.atomic.AtomicInteger;\n\npublic class Hello {\n    private AtomicInteger value;\n\n    public int get() {\n        return this.value.get();\n    }\n\n    public synchronized void set(int value) {\n        this.value.set(value);\n    }\n}\n</code></pre>\n\n<p>As  mentioned in <a href=\"http://nvcv22blog.wordpress.com/2016/04/16/thread-safety-with-locking/\" rel=\"nofollow\">this post</a>     </p>\n\n<blockquote>\n  <p>If some object has only one field or its critical updates are\n  limited to only one field of object so instead of using\n  synchronization or other thread safe collections , Atomic variables\n  (AtlomicInteger, AtomicReference etc.) can be utilized.</p>\n</blockquote>\n","answer_id":38241672,"question_id":37312655,"last_edit_date":1472228846},{"owner":{"profile_image":"https://www.gravatar.com/avatar/f53318df972a9be25d0cebf34d0420b6?s=256&d=identicon&r=PG","account_id":879004,"user_type":"registered","user_id":225703,"link":"https://stackoverflow.com/users/225703/andrew-lygin","reputation":6117,"display_name":"Andrew Lygin"},"content_license":"CC BY-SA 3.0","score":7,"is_accepted":true,"last_activity_date":1472222579,"creation_date":1472222579,"body":"<p>The task of distributing ten jobs between four threads and the task of utilizing only four CPUs (I use CPU here as a synonym of <em>core</em> for simplicity) by your ten jobs are a bit different.</p>\n\n<p><strong>Four threads</strong></p>\n\n<p>Limiting the threads number to four will not guarantee that they will stick to four CPUs and won't use the others. OS is allowed to shuffle your threads between all available CPUs as it likes. The only thing you can guarantee, is that your program won't be able to utilize more than 50% of all the CPU resources (given the fact that you have eight CPUs).</p>\n\n<p>But it's unlikely that you'll manage to utilize those 50%. Despite the fact that your jobs are primarily CPU-oriented, chances are that they still need read from and write to memory from time to time. When a thread misses cache on such readings/writings and waits for data to be delivered to the processor, this processor put the thread on hold and can do some work in another thread. In your case, it will have nothing to do and just sit idle until the data arrives. So, it's likely that your CPUs will be underutilized.</p>\n\n<p>If you decide to go with this approach, you need to break your jobs into small tasks and feed them to the executors, as @James Large said. You can either use <code>WorkStealingPool</code> with four threads (as @Alexey Soshin proposed), or create a pool with ten threads and use a <code>Semaphore</code> with four permits and fairness set to <code>true</code>. In the latter case, your threads must use loops, acquire permits at the beginning of every iteration and release them at the end. Each iteration will represent a small chunk of work.</p>\n\n<p><strong>Four CPUs</strong></p>\n\n<p>There're mechanisms to designate particular CPUs to work on your tasks.</p>\n\n<p>On the process level in Linux you can use <a href=\"http://linux.die.net/man/1/taskset\">special commands</a> to bind your process to particular CPUs. That will allow you to create ten threads and let the OS do all the balancing on four CPUs.</p>\n\n<p>On the threads level, you can try <a href=\"https://github.com/OpenHFT/Java-Thread-Affinity\">Java Affinity library</a> from OpenHFT. It allows to bind threads to CPUs right in your Java code. The problem is that ten threads cannot be devided between four CPUs without reminder, so it will be hard to balance them.</p>\n","answer_id":39168958,"question_id":39162994},{"owner":{"profile_image":"https://www.gravatar.com/avatar/67f2ccd17aa6fd622152ad88fc2ae784?s=256&d=identicon&r=PG","account_id":422870,"user_type":"registered","user_id":801894,"link":"https://stackoverflow.com/users/801894/solomon-slow","reputation":25925,"display_name":"Solomon Slow"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1472216397,"creation_date":1472216397,"body":"<p>I am somewhat bothered by the idea of a \"Job that never finishes.\"  I would call it something else, like \"long-running computation\" or,...</p>\n\n<p>If you've got ten of them, and you can only afford four threads to work on them, then your only choice is to break them into finite \"sub-jobs\" that <em>do</em> finish, and then write a scheduler that keeps feeding sub-jobs to the four available threads.</p>\n\n<p>But that would be replicating most of what the threading system is supposed to do for you.</p>\n\n<p>I would just make ten threads.  If you're running on a machine that only has four available cores to run the ten threads, the OS will automatically break your long running jobs into \"sub-jobs\" (i.e., time slices), and schedule them fairly on the four cores.</p>\n","answer_id":39166952,"question_id":39162994},{"owner":{"profile_image":"https://i.stack.imgur.com/lrdeC.jpg?s=256&g=1","account_id":5139201,"user_type":"registered","user_id":4117097,"link":"https://stackoverflow.com/users/4117097/anton-malyshev","reputation":8756,"display_name":"Anton Malyshev"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1472203989,"creation_date":1472203989,"body":"<p>If you need to execute 10 jobs in parallel - simply run 10 threads.</p>\n\n<p>Change <code>Executors.newFixedThreadPool(4)</code> to <code>Executors.newFixedThreadPool(10)</code>.</p>\n","answer_id":39163067,"question_id":39162994},{"owner":{"profile_image":"https://i.stack.imgur.com/7H9TF.png?s=256&g=1","account_id":2994830,"user_type":"registered","user_id":2541560,"link":"https://stackoverflow.com/users/2541560/kayaman","reputation":1,"display_name":"Kayaman"},"content_license":"CC BY-SA 3.0","score":3,"is_accepted":true,"last_activity_date":1472197434,"creation_date":1472196990,"body":"<p>According to the javadoc for <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html\" rel=\"nofollow\">Future</a>:</p>\n\n<blockquote>\n  <p>Memory consistency effects: Actions taken by the asynchronous\n  computation happen-before actions following the corresponding\n  Future.get() in another thread.</p>\n</blockquote>\n\n<p>Meaning that after looping all the <code>Futures</code> and invoking <code>get()</code> it's guaranteed that the actions have happened and the array of integers contains the results.</p>\n\n<p>Afterwards you're free to reuse the pool without it affecting the calculated array in any way.</p>\n","answer_id":39160860,"question_id":39160706,"last_edit_date":1472197434},{"owner":{"profile_image":"https://www.gravatar.com/avatar/f53318df972a9be25d0cebf34d0420b6?s=256&d=identicon&r=PG","account_id":879004,"user_type":"registered","user_id":225703,"link":"https://stackoverflow.com/users/225703/andrew-lygin","reputation":6117,"display_name":"Andrew Lygin"},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":true,"last_activity_date":1472195728,"creation_date":1472194766,"body":"<p>There's no way you can guarantee programmatically that your thread stays on the processor until it finished its work. Thread scheduling is an OS prerogative and it follows rules of fairness when distributes quanta of time between threads. </p>\n\n<p>If we look deeper, the processor itself is allowed to decide on what thread could wait for a while (for instance, if it's asking for a memory part that is not cached yet and it will take long to deliver those data to the cache), but these  delays are minor.</p>\n\n<p>Overall, your task looks like an overengineering. Unless your maze is immensely huge that marking the golden path takes so long time that it really matters (it usually takes microseconds at worst on modern computers to change the state of rather large chunks of memory, even in multithreaded environment), and you really count micro- and nanoseconds, all you need is to develop a good maze-walking algorithm, optimise it, find what number of threads works best for you and let the JVM, OS and CPU do the rest. They are good enough at doing their job even without so deep tuning.</p>\n\n<p>If even after that you still want to do something about it (maybe just out of curiosity), you could use the following strategy: Create a special thread with the highest possible priority and keep it ready. When one of your working threads finds the golden path, delegate the task of marking it to that high-priority thread. Though it won't guarantee you that the thread cannot be got kicked out of the processor, the quanta of its time will be larger.</p>\n\n<p>In Java, you can do it by means of <code>ExecutorService</code>:</p>\n\n<pre><code>private final ExecutorService executor =\n        Executors.newFixedThreadPool(1, r -&gt; {\n            Thread thread = new Thread(r, \"golden-path-marker\");\n            thread.setPriority(Thread.MAX_PRIORITY);\n            return thread;\n        });\nexecutor.prestartCoreThread();\n</code></pre>\n\n<p>And later, when you find the path:</p>\n\n<pre><code>executor.submit(() -&gt; {\n    // Mark the golden path here\n});\n</code></pre>\n\n<p>But be aware that switching between threads is time consuming, so your maze must be really big and marking the path must be really time-consuming for you to gain something from this approach.</p>\n","answer_id":39160181,"question_id":39159040,"last_edit_date":1472195728},{"owner":{"profile_image":"https://www.gravatar.com/avatar/16b6783e9b99b1199c75761eaf5c0685?s=256&d=identicon&r=PG","account_id":247613,"user_type":"registered","user_id":522444,"link":"https://stackoverflow.com/users/522444/hovercraft-full-of-eels","reputation":284089,"display_name":"Hovercraft Full Of Eels","accept_rate":100},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":true,"last_activity_date":1472149799,"creation_date":1472066043,"body":"<p>You need to get your input and error streams, and read from them each in its own thread. Right now your error stream never has a chance because of the blocking while loop ahead of it.</p>\n<p>I've used the following code (although it is years old...):</p>\n<p>Enum: GobblerType.java</p>\n<pre><code>enum GobblerType {\n   ERROR, OUTPUT\n}\n</code></pre>\n<p>Class StreamGobbler.java</p>\n<pre><code>import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\n\npublic class StreamGobbler implements Runnable {\n\n   private InputStream is;\n   private GobblerType type;\n   private OutputStream os;\n\n   public StreamGobbler(InputStream is, GobblerType type) {\n      this(is, type, null);\n   }\n\n   public StreamGobbler(InputStream is, GobblerType type, OutputStream redirect) {\n      this.is = is;\n      this.type = type;\n      this.os = redirect;\n   }\n\n   public void run() {\n      try {\n         PrintWriter pw = null;\n         if (os != null) {\n            pw = new PrintWriter(os, true);\n         }\n         InputStreamReader isr = new InputStreamReader(is);\n         BufferedReader br = new BufferedReader(isr);\n         String line = null;\n         while ((line = br.readLine()) != null) {\n            if (pw != null) {\n               pw.println(line);\n            }\n         }\n      } catch (IOException ioe) {\n         ioe.printStackTrace();\n      }\n   }\n}\n</code></pre>\n<p>And then have used it like so:</p>\n<pre><code>Process proc = Runtime.getRuntime().exec(.....);  // TODO: Fix!\n\nStreamGobbler errorGobbler = new StreamGobbler(proc.getErrorStream(), GobblerType.ERROR);\nStreamGobbler outputGobbler = new StreamGobbler(proc.getInputStream(), GobblerType.OUTPUT);\n\nnew Thread(errorGobbler).start();\nnew Thread(outputGobbler).start();\n\nint exitVal = proc.waitFor();\nproc.destroy();    \n</code></pre>\n<hr />\n<hr />\n<p>OK, I created some code as a proof of concept program. I've modified my Gobbler a bit so that it doesn't require an OutputStream but rather uses a PropertyChangeListener to notify listeners of any text coming from the InputStream. For this to work, all my code is in the same package, and note that package names are key, and you would likely need to change yours. Running this code does behave as expected. It is a bit overly simplistic and probably should use some type of blocking queue for passing information between classes.</p>\n<hr />\n<h2>GobblerType.java</h2>\n<p>An enum to distinguish the two type of stream gobblers in use</p>\n<pre><code>package pkg2;\n\npublic enum GobblerType {\n    ERROR, OUTPUT\n}\n</code></pre>\n<hr />\n<h2>StreamGobbler2.java</h2>\n<p>The stream gobbler that uses an input stream reader to get text from the input stream, puts the text into a <code>text</code> field, and notifies listeners of new text. It uses a PropertyChangeListener for the notification. This is a crude way to producer-consumer, and risks not capturing all passed information. Better would be to use a blocking queue of some sort.</p>\n<pre><code>package pkg2;\n\nimport java.beans.PropertyChangeListener;\nimport java.beans.PropertyChangeSupport;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.Callable;\n\npublic class StreamGobbler2 implements Callable&lt;Void&gt; {\n    private PropertyChangeSupport support = new PropertyChangeSupport(this);\n    private InputStream is;\n    private GobblerType type;\n    private String text;\n\n    public StreamGobbler2(InputStream is, GobblerType type) {\n        this.is = is;\n        this.type = type;\n    }\n\n    @Override\n    public Void call() throws Exception {\n        InputStreamReader isr = new InputStreamReader(is);\n        BufferedReader br = new BufferedReader(isr);\n        String line = null;\n        while ((line = br.readLine()) != null) {\n            setText(line);\n        }\n        return null;\n    }\n\n    public GobblerType getType() {\n        return type;\n    }\n    \n    public void addPropertyChangeListener(PropertyChangeListener listener) {\n        support.addPropertyChangeListener(listener);\n    }\n\n    public void addPropertyChangeListener(String propertyName, PropertyChangeListener listener) {\n        support.addPropertyChangeListener(propertyName, listener);\n    }\n    \n    public void setText(String text) {\n        String oldValue = null;\n        String newValue = text;\n        this.text = text;\n        support.firePropertyChange(type.toString(), oldValue, newValue);\n    }\n    \n    public String getText() {\n        return text;\n    }\n\n}\n</code></pre>\n<hr />\n<h2>ProcessLauncher.java</h2>\n<p>This is a non-Swing class that captures the information from the two gobblers. Again, better would be to use blocking queues (next iteration)</p>\n<pre><code>package pkg2;\n\nimport java.beans.PropertyChangeListener;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\n\npublic class ProcessLauncher implements Callable&lt;Integer&gt; {\n    private ExecutorService execService = Executors.newFixedThreadPool(2);\n    private List&lt;String&gt; commands;\n    private List&lt;PropertyChangeListener&gt; listeners = new ArrayList&lt;&gt;();\n\n    public ProcessLauncher(List&lt;String&gt; commands) {\n        this.commands = commands;\n    }\n    \n    public void addPropertyChangeListener(PropertyChangeListener listener) {\n        listeners.add(listener);\n    }\n\n    @Override\n    public Integer call() throws Exception {\n        ProcessBuilder pb = new ProcessBuilder(commands);\n        Process p = pb.start();\n        int exitValue = 0;\n\n        try (InputStream inputStream = p.getInputStream();\n             InputStream errorStream = p.getErrorStream()) {\n\n            StreamGobbler2 errorGobbler = new StreamGobbler2(inputStream, GobblerType.OUTPUT);\n            StreamGobbler2 outputGobbler = new StreamGobbler2(errorStream, GobblerType.ERROR);\n            \n            for (PropertyChangeListener listener : listeners) {\n                errorGobbler.addPropertyChangeListener(listener);\n                outputGobbler.addPropertyChangeListener(listener);                \n            }\n\n            List&lt;Future&lt;Void&gt;&gt; futures = new ArrayList&lt;&gt;();\n            futures.add(execService.submit(errorGobbler));\n            futures.add(execService.submit(outputGobbler));\n            execService.shutdown();\n\n            exitValue = p.waitFor();\n            for (Future&lt;Void&gt; future : futures) {\n                future.get();\n            }\n        }\n\n        return exitValue;\n    }\n}\n</code></pre>\n<hr />\n<h2>SwingWorkerWrapper.java</h2>\n<p>Wrapper to use the above class in a Swing fashion</p>\n<pre><code>package pkg2;\n\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.util.List;\n\nimport javax.swing.SwingWorker;\n\npublic class SwingWorkerWrapper extends SwingWorker&lt;Integer, Void&gt; {\n    private ProcessLauncher processLauncher;\n    \n    public SwingWorkerWrapper(List&lt;String&gt; commands) {\n        processLauncher = new ProcessLauncher(commands);\n        processLauncher.addPropertyChangeListener(new LauncherListener());\n    }\n    \n    @Override\n    protected Integer doInBackground() throws Exception {        \n        return processLauncher.call();\n    }\n    \n    private class LauncherListener implements PropertyChangeListener {\n        @Override\n        public void propertyChange(PropertyChangeEvent evt) {\n            firePropertyChange(evt.getPropertyName(), evt.getOldValue(), evt.getNewValue());\n        }\n    }\n}\n</code></pre>\n<hr />\n<h2>MainGui.java</h2>\n<p>GUI class that uses the above SwingWorker. Run this class to get the whole show on the road. Once running, press the &quot;Launch Process&quot; button for this program to run the TestProgram in a separate JVM.</p>\n<pre><code>package pkg2;\n\nimport java.awt.BorderLayout;\nimport java.awt.GridLayout;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.KeyEvent;\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;\n\nimport javax.swing.*;\nimport javax.swing.border.Border;\n\n@SuppressWarnings(&quot;serial&quot;)\npublic class MainGui extends JPanel {\n    private static final String[] CMD_TEXT = {&quot;java&quot;, &quot;-cp&quot;}; \n    private static final String TEST_PROGRAM = &quot;pkg2.TestProgram&quot;;\n    private JTextArea inputTextArea = new JTextArea(15, 30);\n    private JTextArea errorTextArea = new JTextArea(15, 30);\n    private List&lt;String&gt; commands = new ArrayList&lt;&gt;();\n    \n    public MainGui() {\n        for (String cmd : CMD_TEXT) {\n            commands.add(cmd);\n        }\n        String classpath = System.getProperty(&quot;java.class.path&quot;);\n        commands.add(classpath);\n        commands.add(TEST_PROGRAM);\n        \n        inputTextArea.setFocusable(false);\n        JScrollPane inputScrollPane = new JScrollPane(inputTextArea);\n        inputScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);\n        Border outsideBorder = BorderFactory.createTitledBorder(&quot;Input Messages&quot;);\n        Border border = BorderFactory.createCompoundBorder(outsideBorder, inputScrollPane.getBorder());\n        inputScrollPane.setBorder(border);\n        \n        errorTextArea.setFocusable(false);\n        JScrollPane errorScrollPane = new JScrollPane(errorTextArea);\n        errorScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);\n        outsideBorder = BorderFactory.createTitledBorder(&quot;Error Messages&quot;);\n        border = BorderFactory.createCompoundBorder(outsideBorder, errorScrollPane.getBorder());\n        errorScrollPane.setBorder(border);\n        \n        JPanel twoAreasPanel = new JPanel(new GridLayout(1, 0, 3, 3));\n        twoAreasPanel.add(inputScrollPane);\n        twoAreasPanel.add(errorScrollPane);\n        \n        JPanel btnPanel = new JPanel(new GridLayout(1, 0, 3, 3));\n        btnPanel.add(new JButton(new LaunchProcessAction()));\n        btnPanel.add(new JButton(new ExitAction()));\n        \n        setBorder(BorderFactory.createEmptyBorder(3, 3, 3, 3));\n        setLayout(new BorderLayout(3, 3));\n        add(twoAreasPanel, BorderLayout.CENTER);\n        add(btnPanel, BorderLayout.PAGE_END);        \n    }\n    \n    private class SwWrapperListener implements PropertyChangeListener {\n        @Override\n        public void propertyChange(PropertyChangeEvent evt) {\n            if (evt.getNewValue() == SwingWorker.StateValue.DONE) {\n                SwingWorkerWrapper swW = (SwingWorkerWrapper) evt.getSource();\n                try {\n                    int exitCode = swW.get();\n                    inputTextArea.append(&quot;Exit Code: &quot; + exitCode + &quot;\\n&quot;);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    inputTextArea.append(e.getLocalizedMessage());\n                    inputTextArea.append(&quot;\\n&quot;);\n                } catch (ExecutionException e) {\n                    e.printStackTrace();\n                    inputTextArea.append(e.getLocalizedMessage());\n                    inputTextArea.append(&quot;\\n&quot;);\n                }\n            } else if (GobblerType.OUTPUT.toString().equals(evt.getPropertyName())) {\n                inputTextArea.append(evt.getNewValue() + &quot;\\n&quot;);\n            } else if (GobblerType.ERROR.toString().equals(evt.getPropertyName())) {\n                errorTextArea.append(evt.getNewValue() + &quot;\\n&quot;);\n            }\n            \n        }\n    }\n    \n    private class LaunchProcessAction extends MyAction {\n        public LaunchProcessAction() {\n            super(&quot;Launch Process&quot;, KeyEvent.VK_L);\n        }\n        \n        @Override\n        public void actionPerformed(ActionEvent e) {\n            SwingWorkerWrapper swWrapper = new SwingWorkerWrapper(commands);\n            swWrapper.addPropertyChangeListener(new SwWrapperListener());\n            swWrapper.execute();\n        }\n    }\n    \n    private class ExitAction extends MyAction {\n        public ExitAction() {\n            super(&quot;Exit&quot;, KeyEvent.VK_X);\n        }\n        \n        @Override\n        public void actionPerformed(ActionEvent e) {\n            System.exit(0);\n        }\n    }\n    \n    private static abstract class MyAction extends AbstractAction {\n        public MyAction(String name, int mnemonic) {\n            super(name);\n            putValue(MNEMONIC_KEY, mnemonic);\n        }\n    }\n\n    private static void createAndShowGui() {\n        MainGui mainPanel = new MainGui();\n\n        JFrame frame = new JFrame(&quot;Main GUI&quot;);\n        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        frame.getContentPane().add(mainPanel);\n        frame.pack();\n        frame.setLocationRelativeTo(null);\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -&gt; createAndShowGui());\n    }\n}\n</code></pre>\n<hr />\n<h2>TestProgram.java</h2>\n<p>Don't run this program directly, but rather have the Main GUI run this. Be sure that this code and all the code is compiled however</p>\n<pre><code>package pkg2;\n\nimport java.awt.event.ActionEvent;\nimport java.awt.event.KeyEvent;\n\nimport javax.swing.*;\n\n@SuppressWarnings(&quot;serial&quot;)\npublic class TestProgram extends JPanel {\n    private JTextField textField = new JTextField(20);\n    private JSpinner exitCodeSpinner = new JSpinner(new SpinnerNumberModel(0, -10, 10, 1));\n    \n    public TestProgram() {        \n        SendTextAction sendTextAxn = new SendTextAction();\n        textField.setAction(sendTextAxn);\n\n        JPanel panel1 = new JPanel();\n        panel1.add(textField);\n        panel1.add(new JButton(sendTextAxn));\n\n        JPanel panel2 = new JPanel();\n        panel2.add(new JLabel(&quot;Exit Code:&quot;));\n        panel2.add(exitCodeSpinner);\n        panel2.add(new JButton(new ExitCodeAction()));\n        panel2.add(new JButton(new ThrowExceptionAction()));\n        \n        setLayout(new BoxLayout(this, BoxLayout.PAGE_AXIS));\n        add(panel1);\n        add(panel2);\n    }\n\n    private static abstract class MyAction extends AbstractAction {\n        public MyAction(String name, int mnemonic) {\n            super(name);\n            putValue(MNEMONIC_KEY, mnemonic);\n        }\n\n    }\n    \n    private class SendTextAction extends MyAction {\n        public SendTextAction() {\n            super(&quot;Send Text&quot;, KeyEvent.VK_S);\n        }\n        \n        @Override\n        public void actionPerformed(ActionEvent e) {\n            String text = textField.getText();\n            textField.setText(&quot;&quot;);\n            System.out.println(text);\n        }\n    }\n    \n    private class ExitCodeAction extends MyAction {\n        public ExitCodeAction() {\n            super(&quot;Exit Code&quot;, KeyEvent.VK_X);\n        }\n\n        @Override\n        public void actionPerformed(ActionEvent e) {\n            int exitCode = (int) exitCodeSpinner.getValue();\n            System.exit(exitCode);\n        }\n    }\n    \n    private class ThrowExceptionAction extends MyAction {\n        public ThrowExceptionAction() {\n            super(&quot;Throw Exception&quot;, KeyEvent.VK_T);\n        }\n\n        @Override\n        public void actionPerformed(ActionEvent e) {\n            // throw some unchecked exception\n            throw new NumberFormatException(&quot;Unchecked exception thrown from within TestProgram&quot;);\n        }\n    }\n    \n    private static void createAndShowGui() {\n        TestProgram mainPanel = new TestProgram();\n\n        JFrame frame = new JFrame(&quot;Test Program&quot;);\n        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        frame.getContentPane().add(mainPanel);\n        frame.pack();\n        frame.setLocationRelativeTo(null);\n        frame.setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -&gt; createAndShowGui());\n    }\n}\n</code></pre>\n","answer_id":39131364,"question_id":39131310,"last_edit_date":1592644375},{"owner":{"profile_image":"https://www.gravatar.com/avatar/cda2afaf3d425c6668075602859a33eb?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8240107,"user_type":"registered","user_id":6197987,"link":"https://stackoverflow.com/users/6197987/gilon-chiu","reputation":51,"display_name":"gilon chiu"},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1472125740,"creation_date":1472125740,"body":"<p>a task(<code>Callable</code> or <code>Runnable</code>) submitted to <code>ThreadPoolExecutors</code> will be convert to a <code>FuturnTask</code>, contains a prop named <b><code>callable</code></b> equals the task you submit. FuturnTask has its own <code>run</code> method as follows. All exception or throwable throwed in <code>c.call()</code> will be catched and put into a prop named <code>outcome</code>. When calling FuturnTask's <code>get</code> method, <code>outcome</code> will be throwed</p>\n\n<p>FuturnTask.run From Jdk1.8 Source Code</p>\n\n<pre><code>public void run() {\n        ...\n        try {\n            Callable&lt;V&gt; c = callable;\n            if (c != null &amp;&amp; state == NEW) {\n                V result;\n                boolean ran;\n                try {\n                    result = c.call();\n                    ran = true;\n                } catch (Throwable ex) {\n                    result = null;\n                    ran = false;\n                    // save ex into `outcome` prop\n                    setException(ex);\n                }\n                if (ran)\n                    set(result);\n            }\n        }\n        ...\n    }\n</code></pre>\n\n<p>if you want catch the exception :</p>\n\n<ul>\n    <ol> 1. skaffman's answer</ol>\n    <ol> 2. overwrite `afterExecute` when you new a ThreadPoolExecutor</ol>\n</ul>\n\n<pre><code>        @Override\n        protected void afterExecute(Runnable r, Throwable t) {\n            super.afterExecute(r, t);\n            Throwable cause = null;\n            if (t == null &amp;&amp; r instanceof Future) {\n                try {\n                    ((Future&lt;?&gt;) r).get();\n                } catch (InterruptedException | ExecutionException e) {\n                    cause = e;\n                }\n            } else if (t != null) {\n                cause = t;\n            }\n            if (cause != null) {\n                // log error\n            }\n        }\n</code></pre>\n","answer_id":39144481,"question_id":1687977},{"owner":{"profile_image":"https://www.gravatar.com/avatar/f53318df972a9be25d0cebf34d0420b6?s=256&d=identicon&r=PG","account_id":879004,"user_type":"registered","user_id":225703,"link":"https://stackoverflow.com/users/225703/andrew-lygin","reputation":6117,"display_name":"Andrew Lygin"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1472101254,"creation_date":1472100883,"body":"<p>The value of the local variable <code>ref2</code> itself cannot be changed outside your method (none can make it point to another object from outside). It's only the state of the object it references that can be changed (someone can call <code>ref1.setField(newValue)</code>) concurrently.</p>\n\n<p>People do that because they need to share objects between threads. Otherwise, they wouldn't be able to gain benefits of multithreading in many cases.</p>\n\n<p>But people don't do it recklessly, they usually introduce various forms of synchronization to guarantee thread safety. For instance, one can use <code>synchronized</code> section as the simplest and most straightforward tool to delineate a critical section that can be executed by only one thread at any given time:</p>\n\n<pre><code>synchronized(ref2) {\n    // Change or read object here\n}\n</code></pre>\n\n<p>If all the code uses the same approach, making changes (and reading them) on the object will be safe.</p>\n\n<p>There're many other, more specialised and more efficient, synchronization primitives and techniques that you should learn about if you're going to write multithreaded programs with shared objects: immutability, <code>volatile</code>, <code>ReadWriteLock</code> etc. Books like \"Java Concurrency in Practice\" can give you a good introduction into the field.</p>\n","answer_id":39136916,"question_id":39136104,"last_edit_date":1472101254},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b5f794b2b43dac2db47e5bb4c7849e79?s=256&d=identicon&r=PG","account_id":1355194,"user_type":"registered","user_id":1293733,"link":"https://stackoverflow.com/users/1293733/onsankawai","reputation":91,"display_name":"onsankawai"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1472099689,"creation_date":1472095064,"body":"<p>That's why people use methods like <code>clone</code> to ensure thread-safety.</p>\n\n<pre><code>Reference ref2 = ref1.clone(); \n</code></pre>\n\n<p>By referencing the copy of ref1, ref2 will not be affected regardless how ref1 is changed by some other threads.</p>\n\n<p><strong>Edit:</strong>\nAs pointed out in the comments, the <code>clone</code> method does not necessarily enforce thread-safety. It has to be correctly implemented in a way that modifying <code>ref1</code> will not change the state of <code>ref2</code>. i.e., <code>ref1</code> and <code>ref2</code> do not share any mutable fields.</p>\n","answer_id":39136156,"question_id":39136104,"last_edit_date":1472099689},{"owner":{"profile_image":"https://i.stack.imgur.com/nAGmt.png?s=256&g=1","account_id":6453072,"user_type":"registered","user_id":4999394,"link":"https://stackoverflow.com/users/4999394/ravindra-babu","reputation":37996,"display_name":"Ravindra babu","accept_rate":98},"content_license":"CC BY-SA 3.0","score":5,"is_accepted":false,"last_activity_date":1471970898,"creation_date":1450200353,"body":"<p>Your assumption:</p>\n\n<blockquote>\n  <p>ThreadPoolExecutor: Seems what I need, but with this I cannot change the pool size, moreover every thread should be linked to a single smartcard slot.</p>\n</blockquote>\n\n<p>is not right. </p>\n\n<p><strong><em><code>You can set thread pool size dynamically.</code></em></strong></p>\n\n<p>Have a look at below <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html\" rel=\"nofollow\">ThreadPoolExecutor</a> APIs</p>\n\n<pre><code>public void setMaximumPoolSize(int maximumPoolSize)\n</code></pre>\n\n<blockquote>\n  <p>Sets the maximum allowed number of threads. This overrides any value set in the constructor. If the new value is smaller than the current value, excess existing threads will be terminated when they next become idle.</p>\n</blockquote>\n\n<pre><code>public void setCorePoolSize(int corePoolSize)\n</code></pre>\n\n<blockquote>\n  <p>Sets the core number of threads. This overrides any value set in the constructor. If the new value is smaller than the current value, excess existing threads will be terminated when they next become idle. If larger, new threads will, if needed, be started to execute any queued tasks.</p>\n</blockquote>\n\n<pre><code>Core and maximum pool sizes:\n</code></pre>\n\n<p>A <code>ThreadPoolExecutor</code> will automatically adjust the pool size  according to the bounds set by <code>corePoolSize</code> and <code>maximumPoolSize</code>. </p>\n\n<p>When a new task is submitted in method <code>execute(java.lang.Runnable)</code>, and fewer than <code>corePoolSize</code> threads are running, a new thread is created to handle the request, even if other worker threads are idle. </p>\n\n<p>If there are more than <code>corePoolSize</code> but less than <code>maximumPoolSize</code> threads running, a new thread will be created only if the queue is full. </p>\n\n<p>By setting <code>maximumPoolSize</code> to an essentially unbounded value such as <code>Integer.MAX_VALUE</code>, <em>you allow the pool to accommodate an arbitrary number of concurrent tasks</em>. But I would not recommend to have those many number of threads. Set this value with caution.</p>\n\n<p>Most typically, core and maximum pool sizes are set only upon construction, but they may also be changed dynamically using <code>setCorePoolSize(int</code>) and <code>setMaximumPoolSize(int)</code>.</p>\n\n<p><strong>EDIT:</strong></p>\n\n<p>For better utilization of thread pool, if you know the maximum number of cards are 6, you can use</p>\n\n<pre><code> ExecutorService executor = Executors.newFixedThreadPool(6);\n</code></pre>\n\n<p>OR </p>\n","answer_id":34295636,"question_id":34138795,"last_edit_date":1471970898},{"owner":{"profile_image":"https://i.stack.imgur.com/WyEns.jpg?s=256&g=1","account_id":2111403,"user_type":"registered","user_id":1876620,"link":"https://stackoverflow.com/users/1876620/fps","reputation":33698,"display_name":"fps","accept_rate":94},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1463624677,"creation_date":1463624677,"body":"<p>In your example, there's no need to use <code>synchronized</code> in neither the <code>get()</code> nor the <code>set</code> method, given the <code>value</code> attribute is declared with the <code>volatile</code> keyword.</p>\n<p>This is because the <code>volatile</code> keyword forces a <em>happens-before</em> relation between writer and reader threads.</p>\n<p><a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.3.1.4\" rel=\"nofollow noreferrer\">Java Language Specification, Section 8.3.1.4. volatile fields</a>:</p>\n<blockquote>\n<p>The Java programming language allows threads to access shared variables (§17.1). As a rule, to ensure that shared variables are consistently and reliably updated, a thread should ensure that it has exclusive use of such variables by obtaining a lock that, conventionally, enforces mutual exclusion for those shared variables.</p>\n<p>The Java programming language provides a second mechanism, volatile fields, that is more convenient than locking for some purposes.</p>\n<p>A field may be declared volatile, in which case the Java Memory Model ensures that all threads see a consistent value for the variable (§17.4).</p>\n</blockquote>\n<p>So, in your case, there's no need to synchronize the <code>get()</code> and <code>set()</code> methods.</p>\n","answer_id":37312939,"question_id":37312655,"last_edit_date":1592644375},{"owner":{"profile_image":"https://www.gravatar.com/avatar/31464af5971655f11447e8cbb7e5210e?s=256&d=identicon&r=PG","account_id":1238647,"user_type":"registered","user_id":1201732,"link":"https://stackoverflow.com/users/1201732/jaime-casero","reputation":381,"display_name":"Jaime Casero"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1462971521,"creation_date":1462971521,"body":"<p>I would rather use the <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Lock.html\" rel=\"nofollow\">Lock</a> class</p>\n\n<p>Besides the naming matching, Java Semaphore is no way to implement a BinarySemaphore, and using Object wait/notify or synchronize is quite raw.</p>\n\n<p>Instead, the Lock class provides almost the same locking semantics as a Semaphore with its lock/unlock (versus acquire/release by Semaphore), but it is specifically targeted to solve critical section functionality, where just one thread is expected to enter at once.</p>\n\n<p>Worth noting Lock also provide try with timeout semantics thanks to <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Lock.html#tryLock(long,%20java.util.concurrent.TimeUnit)\" rel=\"nofollow\">tryLock</a> method.</p>\n","answer_id":37163441,"question_id":8286472},{"owner":{"profile_image":"https://i.stack.imgur.com/es6t5.jpg?s=256&g=1","account_id":3487753,"user_type":"registered","user_id":2918190,"link":"https://stackoverflow.com/users/2918190/dbk","reputation":411,"display_name":"DBK"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1461286752,"creation_date":1461286752,"body":"<p>Of course you can have a split in the middle of a job! Here is the example from Spring Batch In Action (2012).</p>\n\n<pre><code>&lt;batch:job id=\"importProductsJob\"&gt;\n  &lt;batch:step id=\"decompress\" next=\"readWrite\"&gt;\n    &lt;batch:tasklet ref=\"decompressTasklet\"/&gt;\n  &lt;/batch:step&gt;\n  &lt;batch:split id=\"readWrite\" next=\"moveProcessedFiles\"&gt;\n    &lt;batch:flow&gt;\n      &lt;batch:step id=\"readWriteBookProduct\"/&gt;\n    &lt;/batch:flow&gt;\n    &lt;batch:flow&gt;\n      &lt;batch:step id=\"readWriteMobileProduct\"/&gt;\n    &lt;/batch:flow&gt;\n  &lt;/batch:split&gt;\n  &lt;batch:step id=\"moveProcessedFiles\"&gt;\n    &lt;batch:tasklet ref=\"moveProcessedFilesTasklet\" /&gt;\n  &lt;/batch:step&gt;\n&lt;/batch:job&gt;\n</code></pre>\n","answer_id":36782910,"question_id":20269091},{"owner":{"profile_image":"https://www.gravatar.com/avatar/998a8344ea5412fcc0009faecb2e60dc?s=256&d=identicon&r=PG","account_id":1716952,"user_type":"registered","user_id":1573825,"link":"https://stackoverflow.com/users/1573825/vitalii","reputation":3345,"display_name":"vitalii"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":true,"last_activity_date":1456413939,"creation_date":1456413939,"body":"<p>The problem is that you use <code>synchronized</code> incorrectly. You should wrap all calls to <code>Referee.queue</code> into <code>Referee.synchronized {}</code> blocks in order to synchronization to work. Otherwise the calls are not synchronized, and it's possible for one thread to modify <code>Referee.queue</code> without other thread notice.</p>\n\n<p>Otherwise you should use thread safe collection. For example when I substitute <code>scala.collection.mutable.Queue</code> with <code>scala.collection.mutable.SynchronizedQueue</code> in the <code>Referee</code> class everything works ok, and you don't need to synchronize access to queue.\nEven better use <code>java.util.concurrent.ConcurrentLinkedQueue</code> instead, because \n<code>SynchronizedQueue</code> is deprecated in scala_2.11</p>\n","answer_id":35631458,"question_id":35616983},{"owner":{"profile_image":"https://lh3.googleusercontent.com/-d8OLojrfx04/AAAAAAAAAAI/AAAAAAAAAIA/kE6_MAvW0Uo/photo.jpg?sz=256","account_id":7905542,"user_type":"registered","user_id":5971182,"link":"https://stackoverflow.com/users/5971182/mason","reputation":26,"display_name":"Mason"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":true,"last_activity_date":1456264929,"creation_date":1456264929,"body":"<p>This looks like a known issue with MongoDB, at least up to version 2.6.   Their recommended fix is to have your code retry the upsert on error.\n<a href=\"https://jira.mongodb.org/browse/SERVER-14322\" rel=\"nofollow\">https://jira.mongodb.org/browse/SERVER-14322</a></p>\n","answer_id":35589137,"question_id":30404513},{"owner":{"profile_image":"https://www.gravatar.com/avatar/dc91a8e29fedbd6a6d7e03a8394009ab?s=256&d=identicon&r=PG","account_id":75804,"user_type":"registered","user_id":217324,"link":"https://stackoverflow.com/users/217324/nathan-hughes","reputation":94840,"display_name":"Nathan Hughes","accept_rate":96},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":true,"last_activity_date":1456259213,"creation_date":1456175632,"body":"<p>To answer part 1: Yes, you need to have your long task check the interrupted flag. Interruption requires the cooperation of the task being interrupted.</p>\n\n<p>Also you should use <code>Thread.currentThread().isInterrupted()</code> unless you specifically want to clear the interrupt flag. Code that throws (or rethrows) InterruptedException uses <code>Thread#interrupted</code> as a convenient way to both check the flag and clear it, when you're writing a Runnable or Callable this is usually not what you want.</p>\n\n<p>Now to answer part 2: Cancellation isn't what you want here.</p>\n\n<p>Using cancellation to stop the computation and return an intermediate result doesn't work, once you cancel the future you can't retrieve the return value from the get method. What you could do is make each refinement of the computation its own task, so that you submit one task, get the result, then submit the next using the result as a starting point, saving the latest result as you go.</p>\n\n<p>Here's an example I came up with to demonstrate this, calculating successive approximations of a square root using Newton's method. Each iteration is a separate task which gets submitted (using the previous task's approximation) when the previous task completes:</p>\n\n<pre><code>import java.util.concurrent.*;\nimport java.math.*;\n\npublic class IterativeCalculation {\n\n    static class SqrtResult {\n        public final BigDecimal value;\n        public final Future&lt;SqrtResult&gt; next;\n        public SqrtResult(BigDecimal value, Future&lt;SqrtResult&gt; next) {\n            this.value = value;\n            this.next = next;\n        }\n    }\n\n    static class SqrtIteration implements Callable&lt;SqrtResult&gt; {\n        private final BigDecimal x;\n        private final BigDecimal guess;\n        private final ExecutorService xs;\n        public SqrtIteration(BigDecimal x, BigDecimal guess, ExecutorService xs) {\n            this.x = x;\n            this.guess = guess; \n            this.xs = xs;\n        }\n\n        public SqrtResult call() {\n            BigDecimal nextGuess = guess.subtract(guess.pow(2).subtract(x).divide(new BigDecimal(2).multiply(guess), RoundingMode.HALF_EVEN));\n            return new SqrtResult(nextGuess, xs.submit(new SqrtIteration(x, nextGuess, xs)));\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        long timeLimit = 10000L;\n        ExecutorService xs = Executors.newSingleThreadExecutor();\n        try {\n            long startTime = System.currentTimeMillis();\n            Future&lt;SqrtResult&gt; f = xs.submit(new SqrtIteration(new BigDecimal(\"612.00\"), new BigDecimal(\"10.00\"), xs));\n            for (int i = 0; System.currentTimeMillis() - startTime &lt; timeLimit; i++) {\n                f = f.get().next;                \n                System.out.println(\"iteration=\" + i + \", value=\" + f.get().value);\n            }\n            f.cancel(true);\n        } finally {\n            xs.shutdown();\n        }\n    }\n}\n</code></pre>\n","answer_id":35563988,"question_id":35563921,"last_edit_date":1456259213},{"owner":{"profile_image":"https://www.gravatar.com/avatar/5cfe5f7d64f44be04f147295f5c7b88e?s=256&d=identicon&r=PG","account_id":71739,"user_type":"registered","user_id":207421,"link":"https://stackoverflow.com/users/207421/user207421","reputation":307163,"display_name":"user207421","accept_rate":82},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1455592542,"creation_date":1455592102,"body":"<p>In practice no. It is only connected to for very brief periods during a bind or lookup operation. Client-side connection pooling will in practice release those connections within a couple of tens of seconds, and server-side read timeouts will take care of any further tidying up required.</p>\n","answer_id":35422968,"question_id":35422541,"last_edit_date":1455592542},{"owner":{"profile_image":"https://i.stack.imgur.com/4xBBm.jpg?s=256&g=1","account_id":44830,"user_type":"registered","user_id":131795,"link":"https://stackoverflow.com/users/131795/trevor-harrison","reputation":1744,"display_name":"Trevor Harrison"},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1450798868,"creation_date":1450462295,"body":"<p>In answer to your question about how to return the result back to the caller:</p>\n\n<blockquote>\n  <p>Everyone waiting for something in the same input queue:</p>\n  \n  <p>BlockingQueue queue=new BlockingQueue();</p>\n  \n  <p>But how to return back output from smartcard-thread to the\n  webserver-client? This let me think that BlockingQueue is not my\n  solution.</p>\n</blockquote>\n\n<p>Your submission queue idea is mostly fine, but you also need a queue per thread to return the result to the job submitter...</p>\n\n<p>Change your submission queue to:</p>\n\n<pre><code>BlockingQueue&lt;JobSubmitRec&gt; queue=new BlockingQueue&lt;JobSubmitRec&gt;();\n</code></pre>\n\n<p>and JobSubmitRec will have the byte[] and a single-use queue to return the result:</p>\n\n<pre><code>class JobSubmitRec\n{\n  byte[] data;\n  BlockingQueue&lt;JobSubmitResult&gt; result=new LinkedBlockingQueue&lt;JobSubmitResult&gt;();\n}\n</code></pre>\n\n<p>and your worker Thread runnable will look something like:</p>\n\n<pre><code>public void run() {\n while(true){\n  JobSubmitRec submitrec = queue.take();\n  byte[] input = submitrec.data;\n  byte output = sw.compute(input);\n  submitrec.result.put( new JobSubmitResult(output) );\n }           \n}\n</code></pre>\n\n<p>and the client that submits the job will look like:</p>\n\n<pre><code>JobSubmitRec jsr = new JobSubmitRec( data );\nqueue.put( jsr );\nJobSubmitResult result = jsr.result.take();\n// use result here\n</code></pre>\n","answer_id":34361597,"question_id":34138795,"last_edit_date":1450798868},{"owner":{"profile_image":"https://i.stack.imgur.com/VDtbQ.jpg?s=256&g=1","account_id":3700031,"user_type":"registered","user_id":3080094,"link":"https://stackoverflow.com/users/3080094/vanoekel","reputation":6378,"display_name":"vanOekel"},"content_license":"CC BY-SA 3.0","score":3,"is_accepted":false,"last_activity_date":1450574401,"creation_date":1450574401,"body":"<p>I might have found a reasonable simple solution based on the following assumptions:</p>\n\n<ul>\n<li>a separate process manages (system-event) notifications for smartcards that become available or are removed.</li>\n<li>a client does not care which smartcard it gets to use, as long as it can use one without interference.</li>\n</ul>\n\n<p>These two assumptions actually make it easier to create a pooling (shared resources) solution, since it is usually the pool itself that is responsible for creating and removing resources when appropriate. Without this functionality, a pooling solution becomes simpler. I do assume that the client that gets a smartcard from the pool to use, can execute the required smartcard functions within its own execution thread (similar to how a database connection is used from a database connection pool to query data from a database).</p>\n\n<p>I have only done some minimal testing for the two classes shown below, and I'm afraid the bulk of the work is in writing (unit) tests that prove the pool works properly with concurrent client requests combined with adding and removing smartcard resources. If you do not want to do that, then the <a href=\"https://stackoverflow.com/a/34360973/3080094\">answer from user769771</a> is probably a better solution. But if you do, try it out, see if it fits. The idea is that only one resource-pool instance is created and used by all the clients and updated by the separate process that manages smartcard availability.</p>\n\n<pre><code>import java.util.*;\nimport java.util.concurrent.*;\n\n/**\n * A resource pool that expects shared resources \n * to be added and removed from the pool by an external process\n * (i.e. not done by the pool itself, see {@link #add(Object)} and {@link #remove(Object)}.\n * &lt;br&gt;A {@link ResourcePoolValidator} can optionally be used. \n * @param &lt;T&gt; resource type handed out by the pool.\n */\npublic class ResourcePool&lt;T&gt; {\n\n    private final Set&lt;T&gt; registered = Collections.newSetFromMap(new ConcurrentHashMap&lt;T, Boolean&gt;()); \n    /* Use a linked list as FIFO queue for resources to lease. */\n    private final List&lt;T&gt; available = Collections.synchronizedList(new LinkedList&lt;T&gt;()); \n    private final Semaphore availableLock = new Semaphore(0, true); \n\n    private final ResourcePoolValidator&lt;T&gt; validator;\n\n    public ResourcePool() {\n        this(null);\n    }\n\n    public ResourcePool(ResourcePoolValidator&lt;T&gt; validator) {\n        super();\n        this.validator = validator;\n    }\n\n    /**\n     * Add a resource to the pool.\n     * @return true if resource is not already in the pool.\n     */\n    public synchronized boolean add(T resource) {\n\n        boolean added = false;\n        if (!registered.contains(resource)) {\n            registered.add(resource);\n            available.add(resource);\n            availableLock.release();\n            added = true;\n        }\n        return added;\n    }\n\n    /**\n     * Removes a resource from the pool.\n     * The resource might be in use (see {@link #isLeased(Object)})\n     * in which case {@link ResourcePoolValidator#abandoned(Object)} will be called \n     * when the resource is no longer used (i.e. released). \n     * @return true if resource was part of the pool and removed from the pool.\n     */\n    public synchronized boolean remove(T resource) {\n\n        // method is synchronized to prevent multiple threads calling add and remove at the same time \n        // which could in turn bring the pool in an invalid state.\n        return registered.remove(resource);\n    }\n\n    /**\n     * If the given resource is (or was, see also {@link #remove(Object)} part of the pool,\n     * a returned value true indicates the resource is in use / checked out.\n     * &lt;br&gt;This is a relative expensive method, do not call it frequently.\n     */\n    public boolean isLeased(T resource) {\n        return !available.contains(resource);\n    }\n\n    /**\n     * Try to get a shared resource for usage. \n     * If a resource is acquired, it must be {@link #release(Object)}d in a finally-block.\n     * @return A resource that can be exclusively used by the caller.\n     * @throws InterruptedException When acquiring a resource is interrupted.\n     * @throws TimeoutException When a resource is not available within the given timeout period.\n     */\n    public T tryAcquire(long timeout, TimeUnit tunit) throws InterruptedException, TimeoutException {\n\n        T resource = null;\n        long timeRemaining = tunit.toMillis(timeout);\n        final long tend = System.currentTimeMillis() + timeRemaining;\n        do {\n            if (availableLock.tryAcquire(timeRemaining, TimeUnit.MILLISECONDS)) {\n                resource = available.remove(0);\n                if (registered.contains(resource)) {\n                    boolean valid = false;\n                    try {\n                        valid = (validator == null ? true : validator.isValid(resource));\n                    } catch (Exception e) {\n                        // TODO: log exception\n                        e.printStackTrace();\n                    }\n                    if (valid) {\n                        break; // return the \"checked out\" resource\n                    } else {\n                        // remove invalid resource from pool\n                        registered.remove(resource);\n                        if (validator != null) {\n                            validator.abandoned(resource);\n                        }\n                    }\n                }\n                // resource was removed from pool, try acquire again\n                // note that this implicitly lowers the maximum available resources\n                // (an acquired permit from availableLock goes unused).\n                // TODO: retry puts us at the back of availableLock queue but should put us at the front of the queue\n                resource = null;\n            }\n            timeRemaining = tend - System.currentTimeMillis();\n        } while (timeRemaining &gt; 0L);\n        if (resource == null) {\n            throw new TimeoutException(\"Unable to acquire a resource within \" + tunit.toMillis(timeout) + \" ms.\");\n        }\n        return resource;\n    }\n\n    /**\n     * This method must be called by the caller / client whenever {@link #tryAcquire(long, TimeUnit)}\n     * has returned a resource. If the caller has determined the resource is no longer valid,\n     * the caller should call {@link #remove(Object)} before calling this method.\n     * @param resource no longer used.\n     */\n    public void release(T resource) {\n\n        if (resource == null) {\n            return;\n        }\n        if (registered.contains(resource)) {\n            available.add(resource);\n            availableLock.release();\n        } else {\n            if (validator != null) {\n                validator.abandoned(resource);\n            }\n        }\n    }\n\n    /** An array (copy) of all resources registered in the pool. */\n    @SuppressWarnings(\"unchecked\")\n    public T[] getRegisteredResources() {\n        return (T[]) registered.toArray(new Object[registered.size()]);\n    }\n\n}\n</code></pre>\n\n<p>And a separate class with functions related to the separate process that manages smarcard availability. </p>\n\n<pre><code>import java.util.concurrent.TimeUnit;\n\n/**\n * Used by a {@link ResourcePool} to validate a resource before handing it out for lease\n * (see {@link #isValid(Object)} and signal a resource is no longer used (see {@link #abandoned(Object)}). \n */\npublic class ResourcePoolValidator&lt;T&gt; {\n\n    /**\n     * Overload this method (this method does nothing by default) \n     * to validate a resource before handing it out for lease.\n     * If this method returns false or throws an exception (which it preferably should not do), \n     * the resource is removed from the pool.\n     * @return true if the resource is valid for leasing\n     */\n    public boolean isValid(T resource) {\n        return true;\n    }\n\n    /**\n     * Called by the {@link ResourcePool#release(Object)} method when a resource is released by a caller \n     * but the resource was previously removed from the pool and in use.\n     * &lt;br&gt;Called by {@link ResourcePool#tryAcquire(long, TimeUnit)} if a resource if not valid \n     * (see {@link #isValid(Object)}.\n     * &lt;br&gt;Overload this method (this method does nothing by default) to create a notification of an unused resource,\n     * do NOT do any long period of processing as this method is called from a caller (client) thread.\n     */\n    public void abandoned(T resource) {\n        // NO-OP\n    }\n\n}\n</code></pre>\n","answer_id":34377106,"question_id":34138795,"last_edit_date":1495541392},{"owner":{"profile_image":"https://www.gravatar.com/avatar/a3da4162a16d2094f358b035ec26d7ea?s=256&d=identicon&r=PG","account_id":402539,"user_type":"registered","user_id":769771,"link":"https://stackoverflow.com/users/769771/vladimir-g","reputation":418,"display_name":"Vladimir G."},"content_license":"CC BY-SA 3.0","score":5,"is_accepted":false,"last_activity_date":1450459914,"creation_date":1450459914,"body":"<p>Have you considered using <a href=\"https://commons.apache.org/proper/commons-pool/\">Apache Commons Pool</a> at all?</p>\n\n<p>You need to maintain a pool of SmartcardWrapper objects where each SmartcardWrapper will represent a physical SmartCard. Whenever you need to make a new computation, you borrow the object from the pool, do the calculation and return the object in the pool so it can be reused by the next thread. </p>\n\n<p>The pool itself is thread-safe and blocks when there are no available objects. All you need to do is implement an api to add/remove SmartcardWrapper Objects to the pool.</p>\n","answer_id":34360973,"question_id":34138795},{"owner":{"profile_image":"https://i.stack.imgur.com/5rgcB.jpg?s=256&g=1","account_id":1968635,"user_type":"registered","user_id":1768226,"link":"https://stackoverflow.com/users/1768226/shazin","reputation":21509,"display_name":"shazin","accept_rate":80},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1450164350,"creation_date":1450164350,"body":"<p>By looking at the requirements the best architecture would be to decouple the computation of the smart card from your web services.</p>\n\n<p>Relying on Web Services to wait on processor intensive tasks will result in timeouts.</p>\n\n<p>The best solution is pre computing smartcard using a periodic job and storing those slot, computation pairs in a Cache Server like Redis. </p>\n\n<p><a href=\"https://i.stack.imgur.com/Zvhua.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/Zvhua.png\" alt=\"enter image description here\"></a></p>\n\n<p>The Smart Card Synchronizer Job is a Seperate J2SE Stand Alone application which periodically checks which Smart Card is available and active (Error free) and update the Redis Cache with slot and computation as a Key/Value pair. If there is a Smart Card unavailable it will be removed from the cache. </p>\n\n<p>The Web Service will just check the Redis cache for a particular slot key and if it finds a value will return it or else return a not found for that slot (Unavailable or Error)</p>\n\n<p>This design is scalable in both Smart Card end as well as Client Requests end.</p>\n","answer_id":34283275,"question_id":34138795},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b10825056024fb644533444ec459ff7e?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":2542161,"user_type":"registered","user_id":2207729,"link":"https://stackoverflow.com/users/2207729/pedrod","reputation":5710,"display_name":"PedroD","accept_rate":56},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1439911564,"creation_date":1439911564,"body":"<p>I have my own implementation of a <strong>Binary Semaphore</strong> in Java.</p>\n\n<pre><code>import java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * A binary semaphore extending from the Java implementation {@link Semaphore}.\n * &lt;p&gt;\n * This semaphore acts similar to a mutex where only one permit is acquirable. Attempts to acquire or release more than one permit\n * are forbidden.\n * &lt;p&gt;\n * Has in {@link Semaphore}, there is no requirement that a thread that releases a permit must have acquired that permit. However,\n * no matter how many times a permit is released, only one permit can be acquired at a time. It is advised that the program flow\n * is such that the thread making the acquiring is the same thread making the release, otherwise you may end up having threads\n * constantly releasing this semaphore, thus rendering it ineffective.\n * \n * @author Pedro Domingues\n */\npublic final class BinarySemaphore extends Semaphore {\n\n    private static final long serialVersionUID = -927596707339500451L;\n\n    private final Object lock = new Object();\n\n    /**\n     * Creates a {@code Semaphore} with the given number of permits between 0 and 1, and the given fairness setting.\n     *\n     * @param startReleased\n     *            &lt;code&gt;true&lt;/code&gt; if this semaphore starts with 1 permit or &lt;code&gt;false&lt;/code&gt; to start with 0 permits.\n     * @param fairMode\n     *            {@code true} if this semaphore will guarantee first-in first-out granting of permits under contention, else\n     *            {@code false}\n     */\n    public BinarySemaphore(boolean startReleased, boolean fairMode) {\n        super((startReleased ? 1 : 0), fairMode);\n    }\n\n    @Override\n    public void acquire(int permits) throws InterruptedException {\n        if (permits &gt; 1)\n            throw new UnsupportedOperationException(\"Cannot acquire more than one permit!\");\n        else\n            super.acquire(permits);\n    }\n\n    @Override\n    public void acquireUninterruptibly(int permits) {\n        if (permits &gt; 1)\n            throw new UnsupportedOperationException(\"Cannot acquire more than one permit!\");\n        else\n            super.acquireUninterruptibly(permits);\n    }\n\n    @Override\n    public void release() {\n        synchronized (lock) {\n            if (this.availablePermits() == 0)\n                super.release();\n        }\n    }\n\n    @Override\n    public void release(int permits) {\n        if (permits &gt; 1)\n            throw new UnsupportedOperationException(\"Cannot release more than one permit!\");\n        else\n            this.release();\n    }\n\n    @Override\n    public boolean tryAcquire(int permits) {\n        if (permits &gt; 1)\n            throw new UnsupportedOperationException(\"Cannot acquire more than one permit!\");\n        else\n            return super.tryAcquire(permits);\n    }\n\n    @Override\n    public boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException {\n        if (permits &gt; 1)\n            throw new UnsupportedOperationException(\"Cannot release more than one permit!\");\n        else\n            return super.tryAcquire(permits, timeout, unit);\n    }\n}\n</code></pre>\n\n<p>Tell me if you find any bug in the code please, but so far it always worked fine! :)</p>\n","answer_id":32076546,"question_id":8286472},{"owner":{"profile_image":"https://www.gravatar.com/avatar/8d8f06c0a8be909e3cd0218da28a5b73?s=256&d=identicon&r=PG","account_id":1463667,"user_type":"registered","user_id":1377224,"link":"https://stackoverflow.com/users/1377224/philnate","reputation":1506,"display_name":"philnate","accept_rate":50},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1432581206,"creation_date":1432323682,"body":"<p>Your query is too specific, not finding the document even if it's created, e.g. not only searching for the unique field. Then the upsert tries to create it a second time (another thread) but fails as it actually exists, but wasn't found. Please see <a href=\"http://docs.mongodb.org/manual/reference/method/db.collection.update/#upsert-behavior\" rel=\"nofollow\">http://docs.mongodb.org/manual/reference/method/db.collection.update/#upsert-behavior</a> for more details.</p>\n\n<p>Boil down from doc: <em>To avoid inserting the same document more than once, only use upsert: true if the query field is uniquely indexed.</em>\n<em>Use modify operators like $set, to include your query document into the upsert doc</em></p>\n\n<p>If you feel that this isn't the case for you. Please provide us with the query and some information about your index.</p>\n\n<p>Update:</p>\n\n<p>If you try to run your code from cli, you'll see the following:</p>\n\n<pre><code>&gt; db.upsert.ensureIndex({docid:1},{unique:true})\n{\n    \"createdCollectionAutomatically\" : true,\n    \"numIndexesBefore\" : 1,\n    \"numIndexesAfter\" : 2,\n    \"ok\" : 1\n}\n&gt; db.upsert.update({\"docid\":123},{one:1,two:2},true,false)\nWriteResult({\n    \"nMatched\" : 0,\n    \"nUpserted\" : 1,\n    \"nModified\" : 0,\n    \"_id\" : ObjectId(\"55637413ad907a45eec3a53a\")\n})\n&gt; db.upsert.find()\n{ \"_id\" : ObjectId(\"55637413ad907a45eec3a53a\"), \"one\" : 1, \"two\" : 2 }\n&gt; db.upsert.update({\"docid\":123},{one:1,two:2},true,false)\nWriteResult({\n    \"nMatched\" : 0,\n    \"nUpserted\" : 0,\n    \"nModified\" : 0,\n    \"writeError\" : {\n        \"code\" : 11000,\n        \"errmsg\" : \"insertDocument :: caused by :: 11000 E11000 duplicate key error index: test.upsert.$docid_1  dup key: { : null }\"\n    }\n})\n</code></pre>\n\n<p>You have the following issue:</p>\n\n<ul>\n<li>You want to update the document but don't find it. And your update contains no modify operators, thus your <em>docid</em> field won't be included in the newly created document (or better it's set to null, and null can be set only once in a unique index, too).</li>\n<li>Next time you try to update your document, you still don't find it, because of the last step. So MongoDB tries to insert it following the same procedure as before, and fails again. No second null allowed.</li>\n</ul>\n\n<p>Simply change your update query to this, to modify the document/ on upsert case include your query into it: <strong>db.upsert.update({\"docid\":123},{$set:{one:1,two:2}},true,false)</strong></p>\n\n<pre><code>db.upsert.update({\"docid\":123},{$set:{one:1,two:2}},true,false)\nWriteResult({\n    \"nMatched\" : 0,\n    \"nUpserted\" : 1,\n    \"nModified\" : 0,\n    \"_id\" : ObjectId(\"5562164f0f63858bf27345f3\")\n})\n&gt; db.upsert.find()\n{ \"_id\" : ObjectId(\"5562164f0f63858bf27345f3\"), \"docid\" : 123, \"one\" : 1, \"two\" : 2 }\n&gt; db.upsert.update({\"docid\":123},{$set:{one:1,two:2}},true,false)\nWriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 0 })\n</code></pre>\n","answer_id":30404730,"question_id":30404513,"last_edit_date":1432581206},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c5cb4916fb1a9cb0a8fb407fb7cb90cd?s=256&d=identicon&r=PG","account_id":2666332,"user_type":"registered","user_id":2304702,"link":"https://stackoverflow.com/users/2304702/rmalchow","reputation":2699,"display_name":"rmalchow","accept_rate":36},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1431117560,"creation_date":1431117560,"body":"<p>the point here is, i guess, that you need to check if the LRU is at it's maximum size. the check here is NOT (map.size() > maxSize), it is \">=\". now, you could probably replace that with \"if (map.size() == maxSize) {...}\" - which, in ideal conditions, should do exactly the same thing. </p>\n\n<p>but in not-so-ideal conditions, if for whatever reason, somebody put an EXTRA entry in the map without checking, then with this code, the map would NEVER go down in size again, because the if condition would never be true.</p>\n\n<p>so - why not \"while\" and \">=\" instead of \"if\" and \"==\"? same amount of code, plus more robust against \"unexpected\" conditions.</p>\n","answer_id":30132509,"question_id":30129960},{"owner":{"profile_image":"https://www.gravatar.com/avatar/590b5c82f8110072100be221bad5b2dd?s=256&d=identicon&r=PG","account_id":2522963,"user_type":"registered","user_id":2192932,"link":"https://stackoverflow.com/users/2192932/xsilmarx","reputation":739,"display_name":"xsilmarx","accept_rate":33},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1418925404,"creation_date":1418925404,"body":"<p>EMF generated models by default are not prepared for multi-threading. \"Volatile\" in EMF means the property (a.k.a, feature) won't generate any field, it has nothing to do with the volatile syntax from Java. \n(You should read the EMF book or at least the EMF Refcardz)</p>\n\n<p>You could always modify the javajet templates to generate different code, but again, this is not recommended since default EMF generation was not designed for multi-threading.</p>\n\n<p>In case you need a multi-threading EMF-based application, consider to use EMF <a href=\"http://wiki.eclipse.org/CDO\" rel=\"nofollow\">CDO</a> which also supports transactions.</p>\n","answer_id":27552802,"question_id":27529398},{"owner":{"profile_image":"https://www.gravatar.com/avatar/29ab64a6d399ed6c8c2fb5033d5b8204?s=256&d=identicon&r=PG","account_id":1308955,"user_type":"registered","user_id":1257372,"link":"https://stackoverflow.com/users/1257372/nick-wilson","reputation":4959,"display_name":"Nick Wilson"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1418832300,"creation_date":1418832300,"body":"<p>In the ecore model under the EClass select the EAttribute or EReference that you want to make volatile. Right click->Show Properties. At the end of the properties view there is a <code>Volatile</code> setting that defaults to `false'.</p>\n\n<p>Note: I haven't actually tried it, but I'm guessing changing that should work.</p>\n","answer_id":27529770,"question_id":27529398},{"owner":{"profile_image":"https://i.stack.imgur.com/qGpzh.jpg?s=256&g=1","account_id":3514439,"user_type":"registered","user_id":2938217,"link":"https://stackoverflow.com/users/2938217/mike-wilklow","reputation":128,"display_name":"Mike Wilklow"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1416424320,"creation_date":1416424320,"body":"<p>You don't need the esparanto field and you don't need to check the state of 'valor' every time you up() the number of available semaphores. I'm bored at work so I trimmed your code:</p>\n\n<pre><code>private class Semaforo {\n    private int valor;\n\n    public Semaforo(int valor) {\n        this.valor=valor;\n    }\n\n    public int getValor() {\n        return valor;\n    }\n\n    public synchronized void down() {\n        if (this.valor &gt;0 ){\n            this.valor--;\n        } else {\n            try {\n                wait();\n            } catch (InterruptedException e) {}\n        }\n    }\n\n    public synchronized void up() {\n        this.valor++;\n        notify();\n    }\n}\n</code></pre>\n","answer_id":27025016,"question_id":7948815},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG","account_id":2518243,"user_type":"registered","user_id":2189127,"link":"https://stackoverflow.com/users/2189127/james-d","reputation":203472,"display_name":"James_D"},"content_license":"CC BY-SA 3.0","score":21,"is_accepted":true,"last_activity_date":1407675681,"creation_date":1407637178,"body":"<p>The <code>Task</code> and <code>Service</code> classes are designed to encourage good practice and proper use of concurrency for some (but not all) common scenarios in GUI programming. </p>\n\n<p>A typical scenario is that the application needs to execute some logic in response to a user action which may take a long time (maybe a long calculation, or, more commonly, a database lookup). The process will return a result which is then used to update the UI. As you know, the long-running process needs to be executed on a background thread to keep the UI responsive, and the update to the UI must be executed on the FX Application Thread. </p>\n\n<p>The <code>Task</code> class provides an abstraction for this kind of functionality, and represents a \"one-off\" task that is executed and produces a result. The <code>call()</code> method will be executed on the background thread, and is designed to return the result of the process, and there are event listeners for when the task completes that are notified on the FX Application thread. The developer is strongly encouraged to initialize the <code>Task</code> implementation with immutable state and have the <code>call()</code> method return an immutable object, which guarantees proper synchronization between the background thread and the FX Application Thread.</p>\n\n<p>There are additional common requirements on these kinds of tasks, such as updating a message or the progress as the task progresses. The application may also need to monitor the life-cycle state of the class (waiting to run, running, completed, failed with an exception, etc). Programming this correctly is quite subtly difficult, as it necessarily involves accessing mutable state in two different threads, and there are many application developers who are unaware of the subtleties. The <code>Task</code> class provides simple hooks for this kind of functionality and takes care of all the synchronization.</p>\n\n<p>To use this functionality, just create a <code>Task</code> whose <code>call()</code> method returns the result of your computation, register a handler for when the state transitions from <code>RUNNING</code> to <code>SUCCEEDED</code>, and run the task in a background thread:</p>\n\n<pre><code>final Task&lt;MyDataType&gt; task = new Task&lt;MyDataType&gt;() {\n    @Override\n    public MyDataType call() throws Exception {\n        // do work here...\n        return result ;\n    }\n};\n\ntask.setOnSucceeded(new EventHandler&lt;WorkerStateEvent&gt;() {\n    @Override\n    public void handle(WorkerStateEvent event) {\n        MyDataType result = task.getValue(); // result of computation\n        // update UI with result\n    }\n});\n\nThread t = new Thread(task);\nt.setDaemon(true); // thread will not prevent application shutdown\nt.start();\n</code></pre>\n\n<p>The way this works behind the scenes is that the <code>Task</code> maintains a <code>state</code> property, which is implemented using a regular JavaFX <code>ObjectProperty</code>. The <code>Task</code> itself is wrapped in a private implementation of <code>Callable</code>, and the <code>Callable</code> implementation is the object passed to the superclass constructor. Consequently, the <code>Callable</code>'s <code>call()</code> method is actually the method executed in the background thread. The <code>Callable</code>'s <code>call()</code> method is implemented as follows:</p>\n\n<ol>\n<li>Schedule a call on the FX Application thread (i.e. using <code>Platform.runLater()</code>) that updates the <code>state</code>, first to <code>SCHEDULED</code>, then to <code>RUNNING</code></li>\n<li>Invoke the <code>call()</code> method of the <code>Task</code> (i.e. the user-developed <code>call()</code> method)</li>\n<li>Schedule a call on the FX Application Thread that updates the <code>value</code> property to the result of the <code>call()</code> method</li>\n<li>Schedule a call on the FX Application Thread that updates the <code>state</code> property to <code>SUCCEEDED</code></li>\n</ol>\n\n<p>This last step will of course invoke listeners registered with the <code>state</code> property, and since the state change was invoked on the FX Application Thread, so to will those listeners' <code>handle()</code> methods.</p>\n\n<p>For a full understanding of how this works, see the <a href=\"http://hg.openjdk.java.net/openjfx/8/master/rt/file/f89b7dc932af/modules/graphics/src/main/java/javafx/concurrent/Task.java\">source code</a>.</p>\n\n<p>Commonly, the application may want to execute these tasks multiple discrete times, and monitor the current state representing all of the processes (i.e. \"running\" now means one instance is running, etc). The <code>Service</code> class simply provides a wrapper for this via a <code>createTask()</code> method. When the <code>Service</code> is started, it gets a <code>Task</code> instance by calling <code>createTask()</code>, executes it via its <code>Executor</code>, and transitions its own state accordingly. </p>\n\n<p>There are of course many concurrency use cases that don't fit (at least cleanly) into the <code>Task</code> or <code>Service</code> implementations. If you have a single background <code>Thread</code> that is running for the entire duration of your application (so it represents a continuous process, rather than a one-off task), then the <code>Task</code> class is not a good fit. Examples of this might include a game loop, or (perhaps) polling. In these cases you may well be better off using your own <code>Thread</code> with <code>Platform.runLater()</code> to update the UI, but of course you have to handle proper synchronization of any variables that may be accessed by both threads. In my experience, it is worth spending some time thinking about whether these requirements can be re-organized into something that does fit into the <code>Task</code> or <code>Service</code> model, as if this can be done the resulting code structure is often much cleaner and easier to manage. There are certainly cases where this is not the case, however, in which case using a  <code>Thread</code> and <code>Platform.runLater()</code> is appropriate. </p>\n\n<p>One last comment on polling (or any other requirement for a periodically-scheduled background task). The <code>Service</code> class looks like a good candidate for this, but it turns out to be quite hard to manage the periodicity effectively. JavaFX 8 introduced a <code>ScheduledService</code> class which takes care of this functionality quite nicely, and also adds handling for cases such as repeated failure of the background task.</p>\n","answer_id":25224921,"question_id":25224323,"last_edit_date":1407675681},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b942d91f7affb127a69d54c71dd26580?s=256&d=identicon&r=PG","account_id":2166141,"user_type":"registered","user_id":1919228,"link":"https://stackoverflow.com/users/1919228/pablo-lozano","reputation":10222,"display_name":"Pablo Lozano","accept_rate":83},"content_license":"CC BY-SA 3.0","score":5,"is_accepted":true,"last_activity_date":1407154517,"creation_date":1407153792,"body":"<p>I've stumbled upon this question asking about how split works, and maybe this answer arrives a bit (one year) late, but here I go...</p>\n\n<p>The issue there is \"split\" is not a step by itself, but you were naming (and referencing) it as it was:</p>\n\n<pre><code>&lt;batch:job id=\"webServiceJob2\"&gt;\n    &lt;batch:step id=\"step1\" next=\"step2\"&gt;&lt;/batch:step&gt;\n    &lt;batch:split id=\"step2\" next=\"step3\"&gt;&lt;/batch:split&gt; &lt;!-- This is not a step --&gt;\n    &lt;batch:step id=\"step3\"&gt;&lt;/batch:step&gt;\n&lt;/batch:job&gt;\n</code></pre>\n\n<p>The correct syntax would be:</p>\n\n<pre><code>&lt;batch:job id=\"webServiceJob2\"&gt;\n    &lt;batch:step id=\"step1\" next=\"step2\"&gt;&lt;/batch:step&gt;\n    &lt;batch:split id=\"split_step2\" next=\"step3\"&gt;\n        &lt;flow&gt; \n             &lt;step id=\"step2_A_1\" ... next=\"step2_A_2\"/&gt;\n             &lt;step id=\"step2_A_2\" ... /&gt;\n        &lt;/flow&gt;\n        &lt;flow&gt; \n             &lt;step id=\"step2_B_1\" ... /&gt;\n        &lt;/flow&gt;\n    &lt;/batch:split&gt;\n    &lt;batch:step id=\"step3\"&gt;&lt;/batch:step&gt;\n&lt;/batch:job&gt;\n</code></pre>\n\n<p>But this is not what you want to achieve, because by <code>split</code> declarations you have to set in compile time the exact number of parallel steps that will be executed, and the purpose of split is using different steps in each flow instead calling several times the same one. </p>\n\n<p>You should check the documentation about <a href=\"http://docs.spring.io/spring-batch/reference/html/scalability.html#partitioning\" rel=\"noreferrer\">Scaling and Parallel processes</a>, the <strong>partition step</strong> seems a good candidate for your requirements.</p>\n","answer_id":25118268,"question_id":20269091,"last_edit_date":1407154517},{"owner":{"profile_image":"https://i.stack.imgur.com/5oC31.jpg?s=256&g=1","account_id":263115,"user_type":"registered","user_id":548473,"link":"https://stackoverflow.com/users/548473/grigory-kislin","reputation":16960,"display_name":"Grigory Kislin"},"content_license":"CC BY-SA 3.0","score":9,"is_accepted":false,"last_activity_date":1393273196,"creation_date":1393273196,"body":"<p>Suggested here <a href=\"https://stackoverflow.com/questions/3353002/why-does-scheduledthreadpoolexecutor-only-accept-a-fixed-number-of-threads\">Why does ScheduledThreadPoolExecutor only accept a fixed number of threads?</a> workaround:</p>\n\n<pre><code>scheduledExecutor = new ScheduledThreadPoolExecutor(128); //no more than 128 threads\nscheduledExecutor.setKeepAliveTime(10, TimeUnit.SECONDS);\nscheduledExecutor.allowCoreThreadTimeOut(true);\n</code></pre>\n","answer_id":21998149,"question_id":3281269,"last_edit_date":1495535459},{"owner":{"profile_image":"https://www.gravatar.com/avatar/f30a1570b27c1389f4decdd649ebe9d9?s=256&d=identicon&r=PG","account_id":1491409,"user_type":"registered","user_id":1398418,"link":"https://stackoverflow.com/users/1398418/oleg","reputation":6134,"display_name":"Oleg"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1389809785,"creation_date":1389809785,"body":"<p>I stumbled upon this question and after playing with the code for a little bit found a very simple answer.</p>\n\n<p>After initial warm up and optimizations (the first 2 numbers before the zeros) when the JVM is working at full speed <code>T1</code> simply <strong>starts and finishes before</strong> <code>T2</code> even starts, so <code>count</code> is going all the way up to 10000 and then to 0. \nWhen I changed the number of iterations in the worker threads from 10000 to 100000000 the output is very unstable and different every time.</p>\n\n<p>The reason for the unstable output when adding <code>volatile</code> is that it makes the code much slower and even with 10000 iterations <code>T2</code> has enough time to start and interfere with <code>T1</code>.</p>\n","answer_id":21145218,"question_id":4130625},{"owner":{"profile_image":"https://www.gravatar.com/avatar/3deab5aa1be96fe145d3103251263523?s=256&d=identicon&r=PG","account_id":1041463,"user_type":"registered","user_id":1047418,"link":"https://stackoverflow.com/users/1047418/torben","reputation":3845,"display_name":"Torben"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1389097354,"creation_date":1389097354,"body":"<p>From the JavaDocs: \"A thread interruption ignored because a thread was not alive at the time of the interrupt will be reflected by this method returning false.\"</p>\n\n<p>Your thread had not started yet when you called \"Thread.interrupt()\".</p>\n\n<p>Making unit tests for concurrent systems is pretty tricky. You can make it slightly more robust by adding a delay into the test but that unfortunately slows down the test execution so you can not have a lot of them.</p>\n\n<p>To make it fail safe you need to add a boolean flag to the thread class that tells the test that it has started and wait for that flag to be raised in a busy loop. Only then you can call interrupt and join.</p>\n","answer_id":20971521,"question_id":20969486},{"owner":{"profile_image":"https://i.stack.imgur.com/NMBDq.jpg?s=256&g=1","account_id":1244574,"user_type":"registered","user_id":1206301,"link":"https://stackoverflow.com/users/1206301/alexei-kaigorodov","reputation":13277,"display_name":"Alexei Kaigorodov","accept_rate":10},"content_license":"CC BY-SA 3.0","score":5,"is_accepted":false,"last_activity_date":1389095962,"creation_date":1389095962,"body":"<p>what we see is that interrupted status of a thread is cleared when that thread finishes. It is not documented in <a href=\"http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html\" rel=\"noreferrer\">http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html</a>, so can be considered as a spec or implementation bug.</p>\n","answer_id":20971078,"question_id":20969486},{"owner":{"profile_image":"https://i.stack.imgur.com/oqbUC.png?s=256&g=1","account_id":1455702,"user_type":"registered","user_id":1371329,"link":"https://stackoverflow.com/users/1371329/jaco0646","reputation":15684,"display_name":"jaco0646","accept_rate":64},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1385662374,"creation_date":1385662374,"body":"<p>Parallel steps would indicate a different step for each sub-list, which I don't think is what you want.<br>\nA single <a href=\"http://docs.spring.io/spring-batch/reference/html/scalability.html\" rel=\"nofollow\">Multi-threaded Step</a> seems more appropriate.<br>\nAs documented, you start by defining a <code>TaskExecutor</code> bean, which will process each <em>chunk</em> in a separate thread. Since TaskExecutors are fairly simple to use, you could also invoke the TaskExecutor on your own. In this case, your step can be multi-threaded without Spring Batch needing to know about it.</p>\n","answer_id":20272511,"question_id":20269091},{"owner":{"profile_image":"https://www.gravatar.com/avatar/5157c85241735be907883a99e7392443?s=256&d=identicon&r=PG","account_id":419305,"user_type":"registered","user_id":796401,"link":"https://stackoverflow.com/users/796401/ralphchapin","reputation":3118,"display_name":"RalphChapin"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":true,"last_activity_date":1381430621,"creation_date":1381430621,"body":"<p><strong>The reason for all those zeroes is <em>not</em> that the ++'s and --'s are balancing each other out.</strong>  The reason is that there is nothing here to cause <code>count</code> in the looping threads to affect <code>count</code> in the main thread.  You need synch blocks or a volatile <code>count</code> (a \"memory barrier) to force the JVM to make everything see the same value.  With your particular JVM/hardware, what is most likely happening that the value is kept in a register at all times and never getting to cache--let alone main memory--at all.</p>\n\n<p>In the second case you are doing what you intended:  non-atomic increments and decrements on the same <code>course</code> and getting results something like what you expected.</p>\n\n<p>This is an ancient question, but something needed to be said about each thread keeping it's <em>own</em>, independent copy of the data.</p>\n","answer_id":19303745,"question_id":4130625},{"owner":{"profile_image":"https://www.gravatar.com/avatar/9870a37447a4ae811096e8e7d10ed3f9?s=256&d=identicon&r=PG","account_id":123958,"user_type":"registered","user_id":318758,"link":"https://stackoverflow.com/users/318758/joni","reputation":109295,"display_name":"Joni","accept_rate":100},"content_license":"CC BY-SA 3.0","score":11,"is_accepted":false,"last_activity_date":1373900868,"creation_date":1373898057,"body":"<p>The <code>TreeMap</code> class is called that way because it is implemented using a <a href=\"https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree\" rel=\"noreferrer\">balanced search tree</a>. The <code>ConcurrentSkipListMap</code> is called that way because it's implemented using a <a href=\"https://en.wikipedia.org/wiki/Skip_list\" rel=\"noreferrer\">skip list</a>. Why is there no concurrent version of <code>TreeMap</code>? Possibly because it's hard to make a tree structure that scales to high levels of concurrency; a concurrent skip list is easier to implement correctly.</p>\n","answer_id":17656510,"question_id":17656373,"last_edit_date":1373900868},{"owner":{"profile_image":"https://www.gravatar.com/avatar/53ee9941b3fefef67175daf212e62d41?s=256&d=identicon&r=PG","account_id":23121,"user_type":"registered","user_id":57695,"link":"https://stackoverflow.com/users/57695/peter-lawrey","reputation":527376,"display_name":"Peter Lawrey","accept_rate":75},"content_license":"CC BY-SA 3.0","score":31,"is_accepted":true,"last_activity_date":1370811177,"creation_date":1324549506,"body":"<p>You can use multiple threads writing a to a file e.g. a log file. but you have to co-ordinate your threads as @Thilo points out.  Either you need to synchronize file access and only write whole record/lines, or you need to have a strategy for allocating regions of the file to different threads e.g. re-building a file with known offsets and sizes.</p>\n\n<p>This is rarely done for performance reasons as most disk subsystems perform best when being written to sequentially and disk IO is the bottleneck.  If CPU to create the record or line of text (or network IO) is the bottleneck it can help.</p>\n\n<blockquote>\n  <p>Image that you want to dump a big database table to a file, and how to make this job faster?</p>\n</blockquote>\n\n<p>Writing it sequentially is likely to be the fastest.</p>\n","answer_id":8602504,"question_id":8602466,"last_edit_date":1370811177},{"owner":{"profile_image":"https://i.stack.imgur.com/lcPr5.png?s=256&g=1","account_id":113085,"user_type":"registered","user_id":298029,"link":"https://stackoverflow.com/users/298029/fgb","reputation":18448,"display_name":"fgb"},"content_license":"CC BY-SA 3.0","score":3,"is_accepted":false,"last_activity_date":1366388372,"creation_date":1366387900,"body":"<pre><code>public class Holder {\n  private int n;\n  public Holder(int n) { this.n = n; }\n\n  public void assertSanity() {\n    if (n!=n)\n      throw new AssertionError(\"This statement is false\");\n  }\n}\n</code></pre>\n\n<p>Say one thread creates an instance of <code>Holder</code>, and passes the reference to another thread, which calls <code>assertSanity</code>.</p>\n\n<p>The assignment to <code>this.n</code> in the constructor occurs in one thread. And two reads of <code>n</code> occur in another thread. The only happens-before relation here is between the two reads. There is no happens-before relation involving the assignment and any of the reads.</p>\n\n<p>Without any happens-before relations, statements can be reordered in various ways, so from the perspective of one thread, <code>this.n = n</code> can occur after the constructor has returned.</p>\n\n<p>This means that the assignment can appear to occur in the second thread after the first read and before the second, resulting in inconsistent values. The can be prevented by making <code>n</code> final, which guarantees that the value is assigned before the constructor finishes.</p>\n","answer_id":16109001,"question_id":16107683,"last_edit_date":1366388372},{"owner":{"profile_image":"https://www.gravatar.com/avatar/8550f0386287de4073e022c401b9d4aa?s=256&d=identicon&r=PG","account_id":170809,"user_type":"registered","user_id":397786,"link":"https://stackoverflow.com/users/397786/tassos-bassoukos","reputation":16057,"display_name":"Tassos Bassoukos"},"content_license":"CC BY-SA 3.0","score":-1,"is_accepted":false,"last_activity_date":1366387254,"creation_date":1366387254,"body":"<p>The <code>Holder</code> class is OK, but the class <code>someClass</code> can appear in an inconsisten state - between creation and the call to <code>initialize()</code> the <code>holder</code> instance variable is <code>null</code>. </p>\n","answer_id":16108800,"question_id":16107683},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c53d539b59c19087182f0b1c53bb52de?s=256&d=identicon&r=PG","account_id":7450,"user_type":"registered","user_id":12960,"link":"https://stackoverflow.com/users/12960/brian-agnew","reputation":269220,"display_name":"Brian Agnew"},"content_license":"CC BY-SA 3.0","score":9,"is_accepted":false,"last_activity_date":1362681889,"creation_date":1257518912,"body":"<p>Why not call <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html#submit%28java.lang.Runnable%29\" rel=\"nofollow noreferrer\"><code>ExecutorService#submit()</code></a>, get the <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html\" rel=\"nofollow noreferrer\"><code>Future</code></a> back and then handle possible exceptions yourself when calling <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html#get%28%29\" rel=\"nofollow noreferrer\"><code>Future#get()</code></a> ?</p>\n","answer_id":1688067,"question_id":1687977,"last_edit_date":1362681889},{"owner":{"profile_image":"https://www.gravatar.com/avatar/964a6add1e31d9bcab78c793d8b39e9c?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":211081,"user_type":"registered","user_id":463052,"link":"https://stackoverflow.com/users/463052/david-bullock","reputation":6152,"display_name":"David Bullock","accept_rate":47},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1355061375,"creation_date":1355061375,"body":"<p>(Just clarifying it for my own poor head - the other answers are correct).</p>\n\n<p>Instances of this hypothetical <code>SemaphoreOnLock</code> class are intended to be shared.  So thread <code>T1</code> fully constructs an instance, and puts it somewhere where thread <code>T2</code> can see it and invoke some method which requires reading the <code>permits</code> field.  Some important things to note about the <code>permits</code> field:</p>\n\n<ol>\n<li>it gets initialized, in the first case, to a default value of <code>0</code></li>\n<li>it is then assigned a value (which may be other than the default of <code>0</code>), by thread <code>T1</code></li>\n<li>it's not <code>volatile</code></li>\n<li>it's not <code>final</code> (which makes it kind of like a 'one shot volatile')</li>\n</ol>\n\n<p>Therefore, if we want <code>T2</code> to read the value that <code>T1</code> last wrote, we need to synchronize.  We have to do this in the constructor, just as we must in every other case.  (That fact of it being an atomic assignment or not doesn't affect this <em>visibility</em> issue).   The strategy of <em>confining</em> the constructed <code>SemaphoreOnLock</code> to a single thread doesn't work for us, because the whole idea of making it <code>@Threadsafe</code> is so that we can <em>safely share it</em>.</p>\n\n<p><strong>What this example illustrates is that \"being threadsafe\" applies to the <em>construction</em> of an object as well, when setting any non-static, non-final, non-volatile field to a value other than its default value.</strong></p>\n\n<p>Of course, we're not obliged to even think about this when we've got a <code>@NotThreadsafe</code> class.  If the caller constructs us and decides to share us between two threads, then <em>the caller must arrange for appropriate synchronization</em>.  In that scenario, we can do whatever we like in the constructor without worrying about visibility concerns - that's somebody else's problem.</p>\n","answer_id":13788046,"question_id":10528572},{"owner":{"profile_image":"https://www.gravatar.com/avatar/11e99704eda452b5ab10a41ad5a91b1f?s=256&d=identicon&r=PG","account_id":2028552,"user_type":"unregistered","user_id":1812905,"link":"https://stackoverflow.com/users/1812905/padmakumar","reputation":29,"display_name":"Padmakumar"},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1352482771,"creation_date":1352481415,"body":"<p>The synchronized declaration enables doing this. Try the below code which I use in a similar context.</p>\n\n<pre><code>package hrblib;\n\nimport java.io.*;\n\npublic class FileOp {\n\n    static int nStatsCount = 0;\n\n    static public String getContents(String sFileName) {  \n\n        try {\n            BufferedReader oReader = new BufferedReader(new FileReader(sFileName));\n            String sLine, sContent = \"\";\n            while ((sLine=oReader.readLine()) != null) {\n                sContent += (sContent==\"\")?sLine: (\"\\r\\n\"+sLine);\n            }\n            oReader.close();\n            return sContent;\n        }\n        catch (IOException oException) {\n            throw new IllegalArgumentException(\"Invalid file path/File cannot be read: \\n\" + sFileName);\n        }\n    }\n    static public void setContents(String sFileName, String sContent) {\n        try {\n            File oFile = new  File(sFileName);\n            if (!oFile.exists()) {\n                oFile.createNewFile();\n            }\n            if (oFile.canWrite()) {\n                BufferedWriter oWriter = new BufferedWriter(new FileWriter(sFileName));\n                oWriter.write (sContent);\n                oWriter.close();\n            }\n        }\n        catch (IOException oException) {\n            throw new IllegalArgumentException(\"Invalid folder path/File cannot be written: \\n\" + sFileName);\n        }\n    }\n    public static synchronized void appendContents(String sFileName, String sContent) {\n        try {\n\n            File oFile = new File(sFileName);\n            if (!oFile.exists()) {\n                oFile.createNewFile();\n            }\n            if (oFile.canWrite()) {\n                BufferedWriter oWriter = new BufferedWriter(new FileWriter(sFileName, true));\n                oWriter.write (sContent);\n                oWriter.close();\n            }\n\n        }\n        catch (IOException oException) {\n            throw new IllegalArgumentException(\"Error appending/File cannot be written: \\n\" + sFileName);\n        }\n    }\n}\n</code></pre>\n","answer_id":13312815,"question_id":8602466,"last_edit_date":1352482771},{"owner":{"profile_image":"https://www.gravatar.com/avatar/3569d716e9ec1d0d9b93500cfb609947?s=256&d=identicon&r=PG","account_id":437352,"user_type":"registered","user_id":824987,"link":"https://stackoverflow.com/users/824987/amit-deshpande","reputation":19077,"display_name":"Amit Deshpande","accept_rate":56},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1349342594,"creation_date":1349342594,"body":"<p>I guess you will not able to do that with <code>ScheduledExecutor</code>, because it uses <a href=\"http://www.cs.rit.edu/usr/local/pub/swm/jdoc6/java/util/concurrent/ScheduledThreadPoolExecutor.DelayedWorkQueue.html\" rel=\"nofollow\">DelayedWorkQueue</a> where as <code>newCachedThreadPool</code> uses <code>ThreadPoolExecutor</code> <a href=\"http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/SynchronousQueue.html\" rel=\"nofollow\">SynchronousQueue</a> as a work queue.</p>\n\n<p>So you can not change implementation of <a href=\"http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html\" rel=\"nofollow\">ScheduledThreadPoolExecutor</a> to act like that.</p>\n","answer_id":12724143,"question_id":12723001},{"owner":{"profile_image":"https://www.gravatar.com/avatar/a0a3a4200899708103f7430d87d56e24?s=256&d=identicon&r=PG","account_id":299251,"user_type":"registered","user_id":605744,"link":"https://stackoverflow.com/users/605744/tomasz-nurkiewicz","reputation":335925,"display_name":"Tomasz Nurkiewicz","accept_rate":100},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1349338940,"creation_date":1349338940,"body":"<p>Isn't <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html#ScheduledThreadPoolExecutor%28int%29\" rel=\"nofollow\"><code>ScheduledThreadPoolExecutor.ScheduledThreadPoolExecutor(int)</code></a>:</p>\n\n<pre><code>ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(0);\n</code></pre>\n\n<p>what you need? <code>0</code> is the <code>corePoolSize</code>:</p>\n\n<blockquote>\n  <p><code>corePoolSize</code> - the number of threads to keep in the pool, even if they are idle, unless <code>allowCoreThreadTimeOut</code> is set</p>\n</blockquote>\n","answer_id":12723151,"question_id":12723001},{"owner":{"profile_image":"https://i.stack.imgur.com/6FThj.jpg?s=256&g=1","account_id":557088,"user_type":"registered","user_id":919415,"link":"https://stackoverflow.com/users/919415/pankaj-sejwal","reputation":1605,"display_name":"Pankaj Sejwal","accept_rate":71},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1342694126,"creation_date":1342693013,"body":"<p>I don't have commenting rights so writing is here...\nJVM invokes pthreads(generally used threading mechanism,other variants are there) for each corresponding request. But the scheduling here is done entirely by OS acting as host.\nBut it is a preferred approach and it is possible to schedule these threads by JVM. For example in Jikes RVM there are options to override this approach of OS decision. For example, in it threads are referred as RVMThread and they can be scheduled/manipulated using org.jikesrvm.schedular package classes. \nFor more <a href=\"http://docs.codehaus.org/display/RVM/Thread+Management\" rel=\"nofollow\">reference</a></p>\n","answer_id":11558672,"question_id":2816011,"last_edit_date":1342694126},{"owner":{"profile_image":"https://i.stack.imgur.com/ENkcp.jpg?s=256&g=1","account_id":426969,"user_type":"registered","user_id":808486,"link":"https://stackoverflow.com/users/808486/tudor","reputation":61751,"display_name":"Tudor","accept_rate":100},"content_license":"CC BY-SA 3.0","score":-1,"is_accepted":false,"last_activity_date":1336638903,"creation_date":1336638903,"body":"<p>I honestly don't see any valid use for the lock here, other than the fact that it introduces a memory fence. <code>int</code> assignments are atomic on 32/64 bit anyway.</p>\n","answer_id":10530270,"question_id":10528572},{"owner":{"profile_image":"https://www.gravatar.com/avatar/caa09b52f2616de4fd1a6ffcc65a5859?s=256&d=identicon&r=PG","account_id":65386,"user_type":"registered","user_id":192444,"link":"https://stackoverflow.com/users/192444/john-vint","reputation":39895,"display_name":"John Vint","accept_rate":100},"content_license":"CC BY-SA 3.0","score":13,"is_accepted":true,"last_activity_date":1336412764,"creation_date":1336412402,"body":"<blockquote>\n  <p>So it doesnt update a key's value. is this correct?</p>\n</blockquote>\n\n<p>That is correct.  It will return the current value that was already in the Map.</p>\n\n<blockquote>\n  <p>would this be a better impl for adding and updating cache?</p>\n</blockquote>\n\n<p>A couple things would make your implementation better.</p>\n\n<p><strong>1.</strong> You shouldn't use putIfAbsent to test if it exists, you should only use it when you want to ensure if one does not exist then <code>putIfAbsent</code>.  Instead you should use <code>map.get</code> to test it's existence (or map.contains).</p>\n\n<pre><code>    V local = _cache.get(key);\n    if (local.equals(value) &amp;&amp; !local.IsExpired()) {\n        return;\n    }\n</code></pre>\n\n<p><strong>2.</strong> Instead of put you will want to replace, this is because a race condition can occur where the <code>if</code> can be evaluated as false by two or more threads in which one of the two (or more) threads will overwrite the other thread's puts.</p>\n\n<p>What you can do instead is <a href=\"http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ConcurrentHashMap.html#replace%28K,%20V,%20V%29\" rel=\"noreferrer\">replace</a></p>\n\n<p>When all is said and done it could look like this</p>\n\n<pre><code>public void AddToCache(T key, V value) {\n    for (;;) {\n\n        V local = _cache.get(key);\n        if(local == null){\n            local = _cache.putIfAbsent(key, value);\n            if(local == null)\n                return;\n        }\n        if (local.equals(value) &amp;&amp; !local.IsExpired()) {\n            return;\n        }\n\n        if (_cache.replace(key, local, value))\n            return;\n    }\n}\n</code></pre>\n","answer_id":10486531,"question_id":10486413,"last_edit_date":1336412764},{"owner":{"profile_image":"https://www.gravatar.com/avatar/4fc4ccdb7469e80d1ab638c74ecd8d09?s=256&d=identicon&r=PG","account_id":1017722,"user_type":"registered","user_id":1028893,"link":"https://stackoverflow.com/users/1028893/dman","reputation":289,"display_name":"DMan"},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1335565706,"creation_date":1335565706,"body":"<p>Here is a simple implementation I did for a binary  semaphore:</p>\n\n<pre><code>public class BinarySemaphore {\n\n    private final Semaphore countingSemaphore;\n\n    public BinarySemaphore(boolean available) {\n        if (available) {\n            countingSemaphore = new Semaphore(1, true);\n        } else {\n            countingSemaphore = new Semaphore(0, true);\n        }\n    }\n\n    public void acquire() throws InterruptedException {\n        countingSemaphore.acquire();\n    }\n\n    public synchronized void release() {\n        if (countingSemaphore.availablePermits() != 1) {\n            countingSemaphore.release();\n        }\n    }\n}\n</code></pre>\n\n<p>This implementation has one property of binary semaphores that you cannot get with counting semaphores that only have one permit - multiple calls to release will still leave just one resource available. This property is mentioned <a href=\"http://www.cs.umd.edu/~shankar/412-Notes/10-BinarySemaphores.html\" rel=\"nofollow\">here</a>.</p>\n","answer_id":10358684,"question_id":8286472},{"owner":{"profile_image":"https://i.stack.imgur.com/dieij.jpg?s=256&g=1","account_id":139194,"user_type":"registered","user_id":344638,"link":"https://stackoverflow.com/users/344638/antiduh","reputation":12003,"display_name":"antiduh","accept_rate":100},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1327264381,"creation_date":1327083251,"body":"<p>I've not tried to construct a happens-before model, but I have implemented lock-free data structures in .Net (lock-free ring buffer, most recently).</p>\n\n<p>References published from volatile variables are guaranteed to be 'safe', the volatile keyword in .Net forces a direct-from-memory read of that reference, and forces any change to that reference to be direct-to-memory write.</p>\n\n<p>Comparing two volatile variables to each other may result in stale conclusions however. In the lock-free ring buffer I wrote, this was not a problem. The enqueue method would occasionally think the buffer was full when it was one item shy (dequeue happens just as i compare my volatile head and tail pointers); the dequeue method would occasionally think the buffer was empty for the same reason. However, in my case, no data was lost.</p>\n\n<p>So to answer your sort-of general question, implementing lock-free data structures in .Net is certainly possible, I've done it, and without much pain.</p>\n","answer_id":8945944,"question_id":8707215,"last_edit_date":1327264381},{"owner":{"profile_image":"https://www.gravatar.com/avatar/031d349e27a3c04ea878413e9af1e62f?s=256&d=identicon&r=PG","account_id":62599,"user_type":"registered","user_id":185881,"link":"https://stackoverflow.com/users/185881/ern0","reputation":3114,"display_name":"ern0","accept_rate":71},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1324551523,"creation_date":1324551523,"body":"<p>What kind of file is this? Why do you need to feed it with more threads? It depends on the <em>characteristics</em> (I don't know better word for it) of the file usage.</p>\n\n<p><strong>Transferring a file from several places over network (short: Torrent-like)</strong></p>\n\n<p>If you are transferring an existing file, the program should</p>\n\n<ul>\n<li>as soon, as it gets know the size of the file, create it with empty content: this prevents later out-of-disk error (if there's not enough space, it will turns out at the creation, before downloading anything of it), also it helps the the performance;</li>\n<li>if you organize the transfer well (and why not), each thread will responsible for a distinct portion of the file, thus file writes will be distinct,</li>\n<li>even if somehow two threads pick the same portion of the file, it will cause no error, because they write the same data for the same file positions.</li>\n</ul>\n\n<p><strong>Appending data blocks to a file (short: logging)</strong></p>\n\n<p>If the threads just appends fixed or various-lenght info to a file, you should use a common thread. It should use a relatively large write buffer, so it can serve client threads quick (just taking the strings), and flush it out optimal scheduling and block size. It should use dedicated disk or even computer.</p>\n\n<p>Also, there can be several performance issues, that's why are there <em>logging servers</em> around, even expensive commercial ones.</p>\n\n<p><strong>Reading and writing random time, random position (short: database)</strong></p>\n\n<p>It requires complex design, with mutexes etc., I never done this kinda stuff, but I can imagine. Ask Oracle for some tricks :)</p>\n","answer_id":8602867,"question_id":8602466},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e07e315bf10ef17712acc1d757196123?s=256&d=identicon&r=PG","account_id":146411,"user_type":"registered","user_id":356857,"link":"https://stackoverflow.com/users/356857/wemakesoftware","reputation":9094,"display_name":"WeMakeSoftware","accept_rate":80},"content_license":"CC BY-SA 3.0","score":19,"is_accepted":false,"last_activity_date":1324549686,"creation_date":1324549686,"body":"<p>Java nio package was designed to allow this. Take a look for example at <a href=\"http://docs.oracle.com/javase/1.5.0/docs/api/java/nio/channels/FileChannel.html\">http://docs.oracle.com/javase/1.5.0/docs/api/java/nio/channels/FileChannel.html</a> .</p>\n\n<p>You can map several regions of one file to different buffers, each buffer can be filled separately by a separate thread.</p>\n","answer_id":8602540,"question_id":8602466},{"owner":{"profile_image":"https://www.gravatar.com/avatar/df794ebd86e84d203c5c42a475c96d91?s=256&d=identicon&r=PG","account_id":341781,"user_type":"registered","user_id":672586,"link":"https://stackoverflow.com/users/672586/gkamal","reputation":20847,"display_name":"gkamal"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1324549561,"creation_date":1324549561,"body":"<p>You can have multiple threads write to the same file - but one at a time.  All threads will need to enter a synchronized block before writing to the file.</p>\n\n<p>In the P2P example - one way to implement it is to find the size of the file and create a empty file of that size.  Each thread is downloading different sections of the file - when they need to write they will enter a synchronized block - move the file pointer using seek and write the contents of the buffer.</p>\n","answer_id":8602516,"question_id":8602466},{"owner":{"profile_image":"https://www.gravatar.com/avatar/f98a2f13a970c7eca6b623117d2b34f5?s=256&d=identicon&r=PG","account_id":238007,"user_type":"registered","user_id":506598,"link":"https://stackoverflow.com/users/506598/surlac","reputation":2961,"display_name":"surlac","accept_rate":68},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":true,"last_activity_date":1322410315,"creation_date":1322408563,"body":"<p>I think you're talking about mutex (or mutual exclusion locks). If so, you can use intrinsic locks. This kind of locks in Java act as mutexes, which means that at most one thread may own the lock:</p>\n\n<pre><code>synchronized (lock) { \n    // Access or modify shared state guarded by lock \n}\n</code></pre>\n\n<p>Where lock is a mock object, used only for locking.</p>\n\n<hr>\n\n<p><strong>EDIT:</strong></p>\n\n<p>Here is an implementation for you — non-reentrant mutual exclusion lock class that uses the value zero to represent the unlocked state, and one to represent the locked state.</p>\n\n<pre><code>class Mutex implements Lock, java.io.Serializable {\n\n    // Our internal helper class\n    private static class Sync extends AbstractQueuedSynchronizer {\n      // Report whether in locked state\n      protected boolean isHeldExclusively() {\n        return getState() == 1;\n      }\n\n      // Acquire the lock if state is zero\n      public boolean tryAcquire(int acquires) {\n        assert acquires == 1; // Otherwise unused\n        if (compareAndSetState(0, 1)) {\n          setExclusiveOwnerThread(Thread.currentThread());\n          return true;\n        }\n        return false;\n      }\n\n      // Release the lock by setting state to zero\n      protected boolean tryRelease(int releases) {\n        assert releases == 1; // Otherwise unused\n        if (getState() == 0) throw new IllegalMonitorStateException();\n        setExclusiveOwnerThread(null);\n        setState(0);\n        return true;\n      }\n\n      // Provide a Condition\n      Condition newCondition() { return new ConditionObject(); }\n\n      // Deserialize properly\n      private void readObject(ObjectInputStream s)\n          throws IOException, ClassNotFoundException {\n        s.defaultReadObject();\n        setState(0); // reset to unlocked state\n      }\n    }\n\n    // The sync object does all the hard work. We just forward to it.\n    private final Sync sync = new Sync();\n\n    public void lock()                { sync.acquire(1); }\n    public boolean tryLock()          { return sync.tryAcquire(1); }\n    public void unlock()              { sync.release(1); }\n    public Condition newCondition()   { return sync.newCondition(); }\n    public boolean isLocked()         { return sync.isHeldExclusively(); }\n    public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }\n    public void lockInterruptibly() throws InterruptedException {\n      sync.acquireInterruptibly(1);\n    }\n    public boolean tryLock(long timeout, TimeUnit unit)\n        throws InterruptedException {\n      return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n    }\n  }\n</code></pre>\n\n<p>If you need to know where should you call <code>wait()</code> and <code>notify()</code>, have a look at <code>sun.misc.Unsafe#park()</code>. It is used within java.util.concurrent.locks package (AbstractQueuedSynchronizer &lt;- LockSupport &lt;- Unsafe).</p>\n\n<p>Hope this helps.</p>\n","answer_id":8286715,"question_id":8286472,"last_edit_date":1322410315},{"owner":{"profile_image":"https://i.stack.imgur.com/ix9H6.png?s=256&g=1","account_id":344466,"user_type":"registered","user_id":676803,"link":"https://stackoverflow.com/users/676803/drona","reputation":7026,"display_name":"Drona","accept_rate":64},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1322407688,"creation_date":1322407688,"body":"<p>Yes, you can. A semaphore with a single permit is a binary semaphore. They control access to a single resource. They can be viewed as some kind of a mutex/lock.</p>\n\n<pre><code>Semaphore binarySemaphore = new Semaphore(1);\n</code></pre>\n","answer_id":8286629,"question_id":8286472},{"owner":{"profile_image":"https://www.gravatar.com/avatar/f6c15e21ea2efa8c15aa959a0d790b36?s=256&d=identicon&r=PG","account_id":62515,"user_type":"registered","user_id":185722,"link":"https://stackoverflow.com/users/185722/alexander-pogrebnyak","reputation":45036,"display_name":"Alexander Pogrebnyak","accept_rate":100},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1322407569,"creation_date":1322407569,"body":"<p>Here is straight from the <a href=\"http://java.sun.com/developer/technicalArticles/releases/j2se15/\" rel=\"nofollow\">Java site</a></p>\n\n<blockquote>\n  <p>The concurrency utility library, led by Doug Lea in JSR-166, is a\n  special release of the popular concurrency package into the J2SE 5.0\n  platform. It provides powerful, high-level thread constructs,\n  including executors, which are a thread task framework, thread safe\n  queues, Timers, locks (including atomic ones), and other\n  synchronization primitives.</p>\n  \n  <p>One such lock is the well known semaphore. A semaphore can be used in\n  the same way that wait is used now, to restrict access to a block of\n  code. Semaphores are more flexible and can also allow a number of\n  concurrent threads access, as well as allow you to test a lock before\n  acquiring it. The following example uses just one semaphore, also\n  known as a binary semaphore. See the java.util.concurrent package for\n  more information.</p>\n</blockquote>\n\n<pre><code>final  private Semaphore s= new Semaphore(1, true);\n\n    s.acquireUninterruptibly(); //for non-blocking version use s.acquire()\n\ntry {     \n   balance=balance+10; //protected value\n} finally {\n  s.release(); //return semaphore token\n}\n</code></pre>\n\n<p>I think, the whole reason of using higher-level abstracts such as Semaphore class is that you don't have to call low level <code>wait</code>/<code>notify</code>.</p>\n","answer_id":8286619,"question_id":8286472},{"owner":{"profile_image":"https://www.gravatar.com/avatar/11498b47f1326cca63f7571a72e2dd1b?s=256&d=identicon&r=PG","account_id":156587,"user_type":"registered","user_id":373962,"link":"https://stackoverflow.com/users/373962/miquel","reputation":15475,"display_name":"Miquel","accept_rate":86},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1322407061,"creation_date":1322407061,"body":"<p>You could have a look at the source code for the Java implementation of the <a href=\"http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/Semaphore.html\" rel=\"nofollow\">Semaphore</a> class (or perhaps use it directly?)</p>\n","answer_id":8286555,"question_id":8286472},{"owner":{"profile_image":"https://www.gravatar.com/avatar/94e2dd813e278309b6281b4a4b7fdddd?s=256&d=identicon&r=PG","account_id":933555,"user_type":"registered","user_id":963864,"link":"https://stackoverflow.com/users/963864/curiousguy","reputation":8064,"display_name":"curiousguy","accept_rate":17},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1319023707,"creation_date":1319023707,"body":"<p>If you see a value of <code>count</code> that is <strong>not</strong> a multiple of 10000, it just shows that you have a poor optimiser.</p>\n","answer_id":7820633,"question_id":4130625},{"owner":{"profile_image":"https://www.gravatar.com/avatar/cbfa20635c9269675d54547c080c9b64?s=256&d=identicon&r=PG","account_id":18914,"user_type":"registered","user_id":43836,"link":"https://stackoverflow.com/users/43836/pondermatic","reputation":6473,"display_name":"pondermatic","accept_rate":75},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1318370246,"creation_date":1318370246,"body":"<p>For memcached you can utilize the cas() operation to check prior to doing the put() that another operation hasn't updated the data.</p>\n","answer_id":7733020,"question_id":1436483},{"owner":{"profile_image":"https://www.gravatar.com/avatar/5cfe5f7d64f44be04f147295f5c7b88e?s=256&d=identicon&r=PG","account_id":71739,"user_type":"registered","user_id":207421,"link":"https://stackoverflow.com/users/207421/user207421","reputation":307163,"display_name":"user207421","accept_rate":82},"content_license":"CC BY-SA 2.5","score":-1,"is_accepted":false,"last_activity_date":1289295760,"creation_date":1289295760,"body":"<p>It doesn't 'make things less synchronized'. It makes them <em>more</em> synchronized, in that threads will always 'see' an up to date value for the variable. This requires erection of memory barriers, which have a time cost.</p>\n","answer_id":4132250,"question_id":4130625},{"owner":{"profile_image":"https://www.gravatar.com/avatar/76838270770a11504bab725da4013f51?s=256&d=identicon&r=PG","account_id":161623,"user_type":"registered","user_id":382546,"link":"https://stackoverflow.com/users/382546/mania","reputation":1718,"display_name":"Mania","accept_rate":88},"content_license":"CC BY-SA 2.5","score":5,"is_accepted":false,"last_activity_date":1289279876,"creation_date":1289279454,"body":"<p>An educated guess at what you're seeing - when not marked as volatile the JIT compiler is using the x86 inc/dec operations which can update the variable atomically. Once marked volatile these operations are no longer used and the variable is instead read, incremented/decremented, and then finally written causing more \"errors\".</p>\n\n<p>The non-volatile setup has no guarantees it'll function well though - on a different architecture it could be worse than when marked volatile. Marking the field volatile does not begin to solve any of the race issues present here.</p>\n\n<p>One solution would be to use the AtomicInteger class, which does allow atomic increments/decrements.</p>\n","answer_id":4130710,"question_id":4130625,"last_edit_date":1289279876},{"owner":{"profile_image":"https://i.stack.imgur.com/K8ZgW.jpg?s=256&g=1","account_id":232030,"user_type":"registered","user_id":496599,"link":"https://stackoverflow.com/users/496599/zack-bloom","reputation":8329,"display_name":"Zack Bloom","accept_rate":50},"content_license":"CC BY-SA 2.5","score":3,"is_accepted":false,"last_activity_date":1289279635,"creation_date":1289279635,"body":"<p>Volatile variables act as if each interaction is enclosed in a synchronized block.  As you mentioned, increment and decrement is not atomic, meaning each increment and decrement contains two synchronized regions (the read and the write).  I suspect that the addition of these pseudolocks is increasing the chance that the operations conflict.</p>\n\n<p>In general the two threads would have a random offset from another, meaning that the likelihood of either one overwriting the other is even. But the synchronization imposed by volatile may be forcing them to be in inverse-lockstep, which, if they mesh together the wrong way, increases the chance of a missed increment or decrement.  Further, once they get in this lockstep, the synchronization makes it less likely that they will break out of it, increasing the deviation.</p>\n","answer_id":4130730,"question_id":4130625},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e785c64da9b13708acdff0642db273f2?s=256&d=identicon&r=PG","account_id":30659,"user_type":"registered","user_id":83695,"link":"https://stackoverflow.com/users/83695/andersoj","reputation":22506,"display_name":"andersoj","accept_rate":86},"content_license":"CC BY-SA 2.5","score":0,"is_accepted":false,"last_activity_date":1287278094,"creation_date":1287278094,"body":"<p>Someone should cite the API contract for <a href=\"http://download.oracle.com/javase/6/docs/api/java/lang/Object.html#wait%28%29\" rel=\"nofollow\"><code>java.lang.Object.wait()</code></a>, which explains this directly.  If a method raises an exception, read the documentation.</p>\n\n<p>When in doubt, read the contract.  (Bill McNeal on NewsRadio always kept his in his jacket pocket, a good metaphor for the JavaDoc API.. see \"Crazy Prepared\" under <a href=\"http://tvtropes.org/pmwiki/pmwiki.php/Main/NewsRadio\" rel=\"nofollow\">NewsRadio</a> and ponder the imponderable.)</p>\n","answer_id":3951544,"question_id":3903039},{"owner":{"profile_image":"https://i.stack.imgur.com/5DblQ.png?s=256&g=1","account_id":8326,"user_type":"registered","user_id":14955,"link":"https://stackoverflow.com/users/14955/thilo","reputation":258555,"display_name":"Thilo","accept_rate":55},"content_license":"CC BY-SA 2.5","score":12,"is_accepted":true,"last_activity_date":1286761833,"creation_date":1286761533,"body":"<p>You need to hold the lock on the object you want to <code>wait</code> on (you can only call it within a <code>synchronized</code> block).</p>\n\n<p>Also, calling <code>wait</code> on a <code>Thread</code> is very unusual and probably not what you want.</p>\n\n<p>I am not sure what you are trying to do, but could you be confusing <code>wait</code> with <code>sleep</code>?</p>\n\n<p>If you want to wait for another thread to finish, that would be <code>anotherThread.join()</code>.</p>\n","answer_id":3903047,"question_id":3903039,"last_edit_date":1286761833},{"owner":{"profile_image":"https://i.stack.imgur.com/B53xA.jpg?s=256&g=1","account_id":3282,"user_type":"registered","user_id":4725,"link":"https://stackoverflow.com/users/4725/tom-hawtin-tackline","reputation":146296,"display_name":"Tom Hawtin - tackline","accept_rate":100},"content_license":"CC BY-SA 2.5","score":0,"is_accepted":false,"last_activity_date":1280446315,"creation_date":1280446315,"body":"<p>It looks like you are busy waiting, assuming a standard <code>BlockingQueue</code>. Use <code>take</code> instead of <code>poll</code>.</p>\n\n<p>Other than that, <code>for (;;)</code> is nicer than <code>while (true)</code>, IMO. </p>\n","answer_id":3367766,"question_id":3367192},{"owner":{"profile_image":"https://www.gravatar.com/avatar/3dd5995d3fc1198e61b60002b5d3ecea?s=256&d=identicon&r=PG","account_id":159829,"user_type":"registered","user_id":379472,"link":"https://stackoverflow.com/users/379472/heater","reputation":195,"display_name":"heater","accept_rate":78},"content_license":"CC BY-SA 2.5","score":-2,"is_accepted":false,"last_activity_date":1280442063,"creation_date":1280442063,"body":"<p>If I were do what you are talking about I would try this:</p>\n\n<pre><code>private Object lock = new Object();    \n\npublic void run(){\n    while(true){\n        synchronized(lock){\n            Message msg = messageQueue.poll();\n            if (msg != null) {\n                ... // do something with the message\n            }else{\n                try{\n                    lock.wait();\n                }catch(InterruptedException e){\n                    e.printStackTrace();\n                    continue;\n                }\n            }\n        }\n    }\n}\n</code></pre>\n\n<p>This allows you to make sure that you don't get any concurrent modification exepction on your messageQueue, as well as when there is no message you will not be using CPU time in the while(true) loop. Now you just need to make sure that when you do add something to your messageQueue you can call <code>lock.notifyAll()</code> so that the thread will know to run again.</p>\n","answer_id":3367437,"question_id":3367192},{"owner":{"profile_image":"https://www.gravatar.com/avatar/23de335ea2208b179ece18bec0b2597f?s=256&d=identicon&r=PG","account_id":91502,"user_type":"registered","user_id":251173,"link":"https://stackoverflow.com/users/251173/buhake-sindi","reputation":88311,"display_name":"Buhake Sindi","accept_rate":86},"content_license":"CC BY-SA 2.5","score":1,"is_accepted":false,"last_activity_date":1280441268,"creation_date":1280441268,"body":"<p><code>while (true)</code> isn't bad if there is a way to exit the loop otherwise the call will run indefinitely.</p>\n\n<p>For 10000 threads doing the <code>while(true)</code> call is bad practice...why don't you have a <code>sleep()</code> on the thread to allow other threads to run or an exit strategy if the thread finish running?</p>\n","answer_id":3367358,"question_id":3367192},{"owner":{"profile_image":"https://www.gravatar.com/avatar/25f34f4e32aedf7ec473fd803824a65c?s=256&d=identicon&r=PG","account_id":39758,"user_type":"registered","user_id":114847,"link":"https://stackoverflow.com/users/114847/justjeff","reputation":12690,"display_name":"JustJeff","accept_rate":85},"content_license":"CC BY-SA 2.5","score":0,"is_accepted":false,"last_activity_date":1280441208,"creation_date":1280441208,"body":"<p>I usually go with a class attribute boolean called 'done', then the threads' run methods look like</p>\n\n<pre><code>done = false;\nwhile( !done ) {\n    // ... process stuff\n}\n</code></pre>\n\n<p>You can then set done=true to kill the loop. This can be done from inside the loop, or you can have another method that sets it, so that other threads can pull the plug.</p>\n","answer_id":3367349,"question_id":3367192},{"owner":{"profile_image":"https://www.gravatar.com/avatar/d155a73860f84fb9f1eb8652a534f3fd?s=256&d=identicon&r=PG","account_id":16366,"user_type":"registered","user_id":35501,"link":"https://stackoverflow.com/users/35501/jrl","reputation":77097,"display_name":"JRL","accept_rate":83},"content_license":"CC BY-SA 2.5","score":21,"is_accepted":false,"last_activity_date":1280441029,"creation_date":1280441029,"body":"<p>Instead of looping forever and breaking or returning, you might choose to check the interrupted status.</p>\n\n<pre><code>while (!Thread.currentThread().isInterrupted()) {\n    try {\n        doWork();\n        wait(1000);\n    } catch (InterruptedException ex) {\n        Thread.currentThread().interrupt();\n    }\n}\n</code></pre>\n\n<p>If your threads are tasks managed by an ExecutorService, you can have them all end gracefully simply by calling shutdownNow().</p>\n","answer_id":3367326,"question_id":3367192},{"owner":{"profile_image":"https://i.stack.imgur.com/cFyP6.jpg?s=256&g=1","account_id":164368,"user_type":"registered","user_id":387076,"link":"https://stackoverflow.com/users/387076/gilles-so-stop-being-evil","reputation":104823,"display_name":"Gilles &#39;SO- stop being evil&#39;","accept_rate":47},"content_license":"CC BY-SA 2.5","score":1,"is_accepted":false,"last_activity_date":1280440757,"creation_date":1280440757,"body":"<p>It's better to have the termination condition on the <code>while (...)</code> line, but sometimes the termination condition is something you can only test somewhere deep inside the loop. Then that's what <code>break</code> is for (or exceptions). In fact maybe your thread must run forever until your program terminates (with <code>System.exit</code>); then <code>while (true)</code> is definitely right.</p>\n\n<p>But maybe you're asking about what should go inside the loop. You need to make sure to include some blocking operation, i.e., some function call where your thread will wait for someone else (another thread, another program, the OS) to do something. This is typically <code>Condition.wait</code> if you're programming with locks, or reading from a message queue, or reading from a file or network socket, or some other blocking I/O operation.</p>\n\n<p>Note that <code>sleep</code> is generally <em>not</em> good enough. You can't know when other participants are going to do something, so there's no way to avoid waking up too often (thus burning up CPU time needlessly) or too seldom (thus not reacting to events in a timely way). Always design your system so that when a thread has completed its job, it notifies whoever is waiting on that job (often with <code>Condition.signal</code> or by joining).</p>\n","answer_id":3367296,"question_id":3367192},{"owner":{"profile_image":"https://i.stack.imgur.com/enNdg.jpg?s=256&g=1","account_id":21994,"user_type":"registered","user_id":53897,"link":"https://stackoverflow.com/users/53897/thorbj%c3%b8rn-ravn-andersen","reputation":73808,"display_name":"Thorbj&#248;rn Ravn Andersen","accept_rate":56},"content_license":"CC BY-SA 2.5","score":3,"is_accepted":false,"last_activity_date":1280440691,"creation_date":1280440691,"body":"<p>Depends on the definition of \"bad\".  It means that the person trying to read the code has to look elsewhere for the reason that the loop is terminated.  That may make it less readable.</p>\n\n<p>This mentality taken to the extreme results in the COMEFROM keyword.  <a href=\"http://en.wikipedia.org/wiki/COMEFROM\" rel=\"nofollow noreferrer\">http://en.wikipedia.org/wiki/COMEFROM</a></p>\n\n<pre><code>10 COMEFROM 40\n20 INPUT \"WHAT IS YOUR NAME? \"; A$\n30 PRINT \"HELLO, \"; A$\n40 REM\n</code></pre>\n","answer_id":3367289,"question_id":3367192},{"owner":{"profile_image":"https://i.stack.imgur.com/oK3oC.jpg?s=256&g=1","account_id":25331,"user_type":"registered","user_id":65070,"link":"https://stackoverflow.com/users/65070/eric-petroelje","reputation":60040,"display_name":"Eric Petroelje","accept_rate":82},"content_license":"CC BY-SA 2.5","score":7,"is_accepted":false,"last_activity_date":1280440152,"creation_date":1280440152,"body":"<p>Not inherently, no.  You can always bail using <code>break</code> or <code>return</code>.  Just make sure you actually do (at some point)</p>\n\n<p>The problem is what happens when your thread has nothing to do?  If you just loop around and around checking a condition, your thread will eat up the whole CPU doing nothing.   So make sure to use <code>wait</code> to cause your thread to block, or <code>sleep</code> if you don't have anything to <code>wait</code> on.</p>\n","answer_id":3367233,"question_id":3367192},{"owner":{"profile_image":"https://www.gravatar.com/avatar/55b5b30518e5b86818a76fb964aff530?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":117983,"user_type":"registered","user_id":308668,"link":"https://stackoverflow.com/users/308668/mike3996","reputation":17117,"display_name":"mike3996","accept_rate":77},"content_license":"CC BY-SA 2.5","score":9,"is_accepted":false,"last_activity_date":1280440114,"creation_date":1280440114,"body":"<pre><code>while (!stop_running) { ... }\n</code></pre>\n\n<p>...perhaps? A some sort of exit flag is often used to control thread running.</p>\n","answer_id":3367228,"question_id":3367192},{"owner":{"profile_image":"https://i.stack.imgur.com/IHsGu.png?s=256&g=1","account_id":29046,"user_type":"registered","user_id":78182,"link":"https://stackoverflow.com/users/78182/stefan-kendall","reputation":66704,"display_name":"Stefan Kendall","accept_rate":94},"content_license":"CC BY-SA 2.5","score":1,"is_accepted":false,"last_activity_date":1280440015,"creation_date":1280440015,"body":"<p>Usually, you'll want to <code>wait</code> on a resource of some kind to do work, which hides actual threading details from you. It sounds like you wanted to implement your own <a href=\"http://en.wikipedia.org/wiki/Spinlock\" rel=\"nofollow noreferrer\">spinlock</a>.</p>\n\n<p><a href=\"http://www.ibm.com/developerworks/library/j-thread.html\" rel=\"nofollow noreferrer\">Here's some tutorial about locking I found I google.</a></p>\n","answer_id":3367212,"question_id":3367192},{"owner":{"profile_image":"https://www.gravatar.com/avatar/40d9bb2e8df635f2f598b7577c5b3eb9?s=256&d=identicon&r=PG","account_id":10326,"user_type":"registered","user_id":19450,"link":"https://stackoverflow.com/users/19450/ben-manes","reputation":9293,"display_name":"Ben Manes"},"content_license":"CC BY-SA 2.5","score":10,"is_accepted":false,"last_activity_date":1279605336,"creation_date":1279605336,"body":"<p>By design the ScheduledThreadPoolExecutor is a fixed size. You can use a single threaded version that submits to a normal  ExecutorService for performing the task. This event thread + worker pool is fairly ease to coordinate and the flexibility makes up for the dedicated thread. I've used this in the past to replace TimerTasks and other non-critical tasks to utilize a common executor as a system-wide pool.</p>\n","answer_id":3287362,"question_id":3281269},{"owner":{"profile_image":"https://www.gravatar.com/avatar/2f169a510b7cba5a57e86d520b268447?s=256&d=identicon&r=PG","account_id":8620,"user_type":"registered","user_id":15619,"link":"https://stackoverflow.com/users/15619/riduidel","reputation":22142,"display_name":"Riduidel","accept_rate":91},"content_license":"CC BY-SA 2.5","score":-3,"is_accepted":false,"last_activity_date":1279545911,"creation_date":1279545911,"body":"<p>Like skaffman says, <code><a href=\"http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/api/java/util/concurrent/Executors.html\" rel=\"nofollow noreferrer\">Executors</a></code> is only a collection of factory method. if you need a particular instance, you can always check all existing <code><a href=\"http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/api/java/util/concurrent/Executor.html\" rel=\"nofollow noreferrer\">Executor</a></code> implementors. In your case, i think that calling one of the various constructors of <a href=\"http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html\" rel=\"nofollow noreferrer\">ScheduledThreadPoolExecutor</a> would be a good idea.</p>\n","answer_id":3281418,"question_id":3281269},{"owner":{"profile_image":"https://www.gravatar.com/avatar/d5f91983a9d9cfb69981b6108a63b412?s=256&d=identicon&r=PG","account_id":11089,"user_type":"registered","user_id":21234,"link":"https://stackoverflow.com/users/21234/skaffman","reputation":400050,"display_name":"skaffman","accept_rate":91},"content_license":"CC BY-SA 2.5","score":3,"is_accepted":false,"last_activity_date":1279545196,"creation_date":1279545196,"body":"<p><code>java.util.concurrent.Executors</code> is nothing more than a collection of static convenience methods that construct common arrangements of executors.</p>\n\n<p>If you want something specific that isn't offered by <code>Executors</code>, then feel free to construct your own instance of the implemention classes, using the examples in <code>Executors</code> as a guide.</p>\n","answer_id":3281294,"question_id":3281269},{"owner":{"profile_image":"https://www.gravatar.com/avatar/72641170cc9abff008d21ac50894803b?s=256&d=identicon&r=PG","account_id":20470,"user_type":"registered","user_id":48933,"link":"https://stackoverflow.com/users/48933/neil-coffey","reputation":21695,"display_name":"Neil Coffey","accept_rate":90},"content_license":"CC BY-SA 2.5","score":2,"is_accepted":false,"last_activity_date":1273655227,"creation_date":1273655227,"body":"<p>A while ago I wrote some articles on <a href=\"http://www.javamex.com/tutorials/threads/thread_scheduling.shtml\" rel=\"nofollow noreferrer\">thread scheduling</a> from the point of view of Java. However, on mainstream platforms, threading behaviour essentially depends on underlying OS threading.</p>\n\n<p>Have a look in particular at my page on what is <a href=\"http://www.javamex.com/tutorials/threads/priority_what.shtml\" rel=\"nofollow noreferrer\">Java thread priority</a>, which explains how Java's priority levels map to underlying OS threading priorities, and how in practice this makes threads of different priorities behave on Linux vs Windows. A major difference discussed is that under Linux there's more of a relationship between thread priority and the proportion of CPU allocated to a thread, whereas under Windows this isn't directly the case (see the graphs).</p>\n","answer_id":2817331,"question_id":2816011},{"owner":{"profile_image":"https://www.gravatar.com/avatar/a4d5888f021e337d09be5b3109c11e72?s=256&d=identicon&r=PG","account_id":46249,"user_type":"registered","user_id":136540,"link":"https://stackoverflow.com/users/136540/michael-aaron-safyan","reputation":94060,"display_name":"Michael Aaron Safyan","accept_rate":83},"content_license":"CC BY-SA 2.5","score":23,"is_accepted":true,"last_activity_date":1273636467,"creation_date":1273636467,"body":"<p>There is no single Java Virtual Machine; JVM is a specification, and there are multiple implementations of it, including the OpenJDK version and the Sun version of it, among others. I don't know for certain, but I would guess that any reasonable JVM would simply use the underlying threading mechanism provided by the OS, which would imply POSIX Threads (pthreads) on UNIX (Mac OS X, Linux, etc.) and would imply WIN32 threads on Windows. Typically, those systems use a round-robin strategy by default.</p>\n","answer_id":2816025,"question_id":2816011},{"owner":{"profile_image":"https://www.gravatar.com/avatar/7f7ebc731345d37a667c3242cf928703?s=256&d=identicon&r=PG","account_id":8258,"user_type":"registered","user_id":14783,"link":"https://stackoverflow.com/users/14783/chris-dolan","reputation":8945,"display_name":"Chris Dolan","accept_rate":96},"content_license":"CC BY-SA 2.5","score":7,"is_accepted":false,"last_activity_date":1273636427,"creation_date":1273636427,"body":"<p>It doesn't.  The JVM uses operating system native threads, so the OS does the scheduling, not the JVM.</p>\n","answer_id":2816023,"question_id":2816011},{"owner":{"profile_image":"https://www.gravatar.com/avatar/6cd776da01e915df274276084eb9858b?s=256&d=identicon&r=PG","account_id":43577,"user_type":"registered","user_id":127479,"link":"https://stackoverflow.com/users/127479/adamski","reputation":54129,"display_name":"Adamski","accept_rate":95},"content_license":"CC BY-SA 2.5","score":6,"is_accepted":false,"last_activity_date":1257519859,"creation_date":1257519533,"body":"<p>skaffman is correct in that using <code>submit</code> is the cleanest approach.  An alternative approach is to subclass <a href=\"http://java.sun.com/javase/6/docs/api/java/util/concurrent/ThreadPoolExecutor.html\" rel=\"noreferrer\"><code>ThreadPoolExecutor</code></a> and override <code>afterExecute(Runnable, Throwable)</code>.  If you follow this approach <strong>be sure to call <code>execute(Runnable)</code></strong> rather than <code>submit(Runnable)</code> or <code>afterExecute</code> will not be invoked.</p>\n\n<p>Per the API description:</p>\n\n<blockquote>\n  <p>Method invoked upon completion of\n  execution of the given Runnable. This\n  method is invoked by the thread that\n  executed the task. If non-null, the\n  Throwable is the uncaught\n  <strong><code>RuntimeException</code></strong>  or <strong><code>Error</code></strong> that caused\n  execution to terminate abruptly.</p>\n  \n  <p>Note: When actions are enclosed in\n  tasks (such as FutureTask) either\n  explicitly or via methods such as\n  submit, these task objects catch and\n  maintain computational exceptions, and\n  so they do not cause abrupt\n  termination, and the internal\n  exceptions are <strong>not passed to this\n  method</strong>.</p>\n</blockquote>\n","answer_id":1688135,"question_id":1687977,"last_edit_date":1257519859},{"owner":{"profile_image":"https://www.gravatar.com/avatar/8a4d6f03a8879432d8563aefbf48e787?s=256&d=identicon&r=PG","account_id":15903,"user_type":"registered","user_id":34088,"link":"https://stackoverflow.com/users/34088/aaron-digulla","reputation":323453,"display_name":"Aaron Digulla","accept_rate":77},"content_license":"CC BY-SA 2.5","score":11,"is_accepted":false,"last_activity_date":1257519755,"creation_date":1257519755,"body":"<p>Decorate the runnable in another runnable which catches the runtime exceptions and handles them:</p>\n\n<pre><code>public class REHandler implements Runnable {\n    Runnable delegate;\n    public REHandler (Runnable delegate) {\n        this.delegate = delegate;\n    }\n    public void run () {\n        try {\n            delegate.run ();\n        } catch (RuntimeException e) {\n            ... your fancy error handling here ...\n        }\n    }\n}\n\nexecutor.execute(new REHandler (myRunnable));\n</code></pre>\n","answer_id":1688161,"question_id":1687977},{"owner":{"profile_image":"https://www.gravatar.com/avatar/d5f91983a9d9cfb69981b6108a63b412?s=256&d=identicon&r=PG","account_id":11089,"user_type":"registered","user_id":21234,"link":"https://stackoverflow.com/users/21234/skaffman","reputation":400050,"display_name":"skaffman","accept_rate":91},"content_license":"CC BY-SA 2.5","score":60,"is_accepted":true,"last_activity_date":1257519216,"creation_date":1257519216,"body":"<p>The clean workaround is to use <code>ExecutorService.submit()</code> instead of <code>execute()</code>. This returns you a <code>Future</code> which you can use to retrieve the result or exception of the task:</p>\n\n<pre><code>ExecutorService executor = Executors.newSingleThreadExecutor();\nRunnable task = new Runnable() {\n  public void run() {\n    throw new RuntimeException(\"foo\");\n  }\n};\n\nFuture&lt;?&gt; future = executor.submit(task);\ntry {\n  future.get();\n} catch (ExecutionException e) {\n  Exception rootException = e.getCause();\n}\n</code></pre>\n","answer_id":1688096,"question_id":1687977},{"owner":{"profile_image":"https://www.gravatar.com/avatar/2f364c2e36b52bc80296cbf23da8b231?s=256&d=identicon&r=PG","account_id":9867,"user_type":"registered","user_id":18393,"link":"https://stackoverflow.com/users/18393/cletus","reputation":618201,"display_name":"cletus","accept_rate":82},"content_license":"CC BY-SA 2.5","score":3,"is_accepted":true,"last_activity_date":1253156064,"creation_date":1253156064,"body":"<p>The way to handle this kind of situation is to not to cache writes from multiple places or to control access in some other way.</p>\n\n<p>A simple solution to this is to not do any writes to the cache from your clients. Instead if you want to update the value you fire off a request to have the value updated. If that value is retrieved from somewhere else then this can work well. If it is calculated or otherwise comes from the client then it can be more problematic.</p>\n\n<p>A common component to use with memcache&mdash;at least in the PHP world&mdash;is beanstalkd as a distributed work queue processor. In this scenario you can fire off an \"update cache\" request as a unit of work.</p>\n\n<p>If you are doing an operation on the cache entry that uses the existing value as an input or in some other way would introduce a race condition if get-then-update weren't an atomic operation, an alternative is to create a unit of work that includes the old value and the new value. That way, whatever process handles the updates can invalidate or otherwise handle those situations where the current value isn't the expected value.</p>\n\n<p>Incrementing and decrementing are handled by the memcached interface so if your accesses are of that type (or can be reduced to that kind of operation) then that solves the problem as well.</p>\n","answer_id":1436505,"question_id":1436483}]