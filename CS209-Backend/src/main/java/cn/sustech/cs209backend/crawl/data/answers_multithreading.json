[{"owner":{"profile_image":"https://www.gravatar.com/avatar/6b2c535fac79e482b71f15de561f55ca?s=256&d=identicon&r=PG","account_id":60171,"user_type":"registered","user_id":179850,"link":"https://stackoverflow.com/users/179850/gray","reputation":115485,"display_name":"Gray","accept_rate":100},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1676413077,"creation_date":1676413077,"body":"<blockquote>\n<p>while I was doing an exercise on the synchronization method I couldn't able to get a proper output but when I'm trying the same exercise by implementing Runnable it's working fine</p>\n</blockquote>\n<p>So your &quot;proper output&quot; is when the output is synchronized that each teacher enters, teaches, and exits before other teacher output is displayed.</p>\n<pre><code>Physics teacher enters class room\nPhysics teacher teaching students\nPhysics teacher exits class room\nEnglish teacher enters class room\nEnglish teacher teaching students\nEnglish teacher exits class room\nCS teacher enters class room\n...\n</code></pre>\n<p>When you have the <code>synchronize</code> keyword on a non-static method, the lock that gets enabled when the method is called is applied on the <em>instance</em> of the object that contains the method.  In the case of the <code>ClassRoom</code> <code>Runnable</code>, each of the threads is sharing <code>class_room</code>:</p>\n<pre><code>ClassRoom class_room = new ClassRoom();\nThread t1 = new Thread(class_room);\nThread t2 = new Thread(class_room);\nThread t3 = new Thread(class_room);\n</code></pre>\n<p>In this case the same <code>ClassRoom</code> object instance is being locked by all 3 threads and the synchronization ensures that only one thread executes the <code>run()</code> method at a time.  Excellent.</p>\n<p>Now let's look at the <code>Thread</code> case:</p>\n<pre><code>ClassRoom physics_class = new ClassRoom();\nClassRoom cs_class = new ClassRoom();\nClassRoom english_class = new ClassRoom();\n</code></pre>\n<p>In this case, there are 3 separate instances of <code>ClassRoom</code> so the <code>synchronized</code> keyword is locking on 3 different objects so each thread works independently.</p>\n<pre><code>Thread t1 = new Thread(new ClassRoom()); // &lt;- distinct instance\n</code></pre>\n<p>Aside from the locking issue, you don't want to do this if <code>ClassRoom</code> extends <code>Thread</code> because you are creating 2 <code>Thread</code> objects – the <code>ClassRoom</code> and the <code>new Thread(...)</code> that wraps the <code>ClassRoom</code> but only starting one of them.  This is very confusing and unnecessary.  <code>ClassRoom</code> should implement <code>Runnable</code> instead.</p>\n","answer_id":75453771,"question_id":75433400},{"owner":{"profile_image":"https://lh3.googleusercontent.com/a/AEdFTp7DA9dycOPxmVqchXxiKqTDCkZOCxgPtCijdF0B=k-s256","account_id":27771970,"user_type":"registered","user_id":21202100,"link":"https://stackoverflow.com/users/21202100/pt7092","reputation":11,"display_name":"pt7092 "},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1676292635,"creation_date":1676292557,"body":"<p>Yield(): When a running thread is stopped to give its space to another thread with a high priority, this is called Yield.Here the running thread changes to runnable thread.</p>\n<p>Wait(): A thread is waiting to get resources from a thread to continue its execution.</p>\n","answer_id":75436114,"question_id":26798073,"last_edit_date":1676292635},{"owner":{"profile_image":"https://lh3.googleusercontent.com/a/AEdFTp61CUpQI3VbC_PLq34lGLauPTVC9VC23rZkIOSpZw=k-s256","account_id":27772393,"user_type":"registered","user_id":21202467,"link":"https://stackoverflow.com/users/21202467/nasir-mushtaq","reputation":1,"display_name":"Nasir Mushtaq"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1676279114,"creation_date":1676279114,"body":"<p>Was facing the same issue,  Paul Samsotha's answer helped. Creating Client loads jersey jars and JARFile in java overrides finalize method putting lot of overhead on finalizer thread.</p>\n","answer_id":75433827,"question_id":38570732},{"owner":{"profile_image":"https://i.stack.imgur.com/zHTaT.png?s=256&g=1","account_id":39208,"user_type":"registered","user_id":112968,"link":"https://stackoverflow.com/users/112968/knittl","reputation":251260,"display_name":"knittl","accept_rate":68},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1676278578,"creation_date":1676278578,"body":"<p>With the <code>Runnable</code> implementation, you are sharing a single instance across all threads. In the former, you are having 3 separate instances.</p>\n<p>To match the behavior of separate threads with a runnable, you have to use separate runnables too:</p>\n<pre><code>public class ClassRoomApp  {\n\n    public static void main(String[] args) throws InterruptedException {\n        \n        Thread t1 = new Thread(new ClassRoom()); // &lt;- distinct instance\n        Thread t2 = new Thread(new ClassRoom()); // &lt;- distinct instance\n        Thread t3 = new Thread(new ClassRoom()); // &lt;- distinct instance\n            \n        t1.setName(&quot;Physics teacher&quot;);\n        t2.setName(&quot;CS teacher&quot;);\n        t3.setName(&quot;English teacher&quot;);\n    \n        t1.start();\n        t2.start();\n        t3.start();\n        \n    }\n\n}\n</code></pre>\n","answer_id":75433733,"question_id":75433400},{"owner":{"profile_image":"https://www.gravatar.com/avatar/97cbc5a26a5cfcdbb3fb718c3e066d87?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":21083132,"user_type":"registered","user_id":15496965,"link":"https://stackoverflow.com/users/15496965/henning","reputation":3240,"display_name":"Henning"},"content_license":"CC BY-SA 4.0","score":-1,"is_accepted":false,"last_activity_date":1676135847,"creation_date":1675979780,"body":"<p>Skipped lines are not counted when considering whether <code>maxItemCount</code> lines have been read.</p>\n<p>Instead of calculating the variable <code>toId</code> and passing it to <code>maxItemCount</code>, you need to pass the fixed value <code>range</code> to <code>maxItemCount</code>.</p>\n<p>edit: As the answer has been down-voted, I've pushed the <code>RangePartitioner</code> from the question and a <code>FixedRangePartitioner</code> to github. The latter sets <code>maxItemCount</code> to <code>range</code> and works as expected: <a href=\"https://github.com/hpoettker/so-partitioning\" rel=\"nofollow noreferrer\">https://github.com/hpoettker/so-partitioning</a></p>\n","answer_id":75404837,"question_id":55227133,"last_edit_date":1676135847},{"owner":{"profile_image":"https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG","account_id":47283,"user_type":"registered","user_id":139985,"link":"https://stackoverflow.com/users/139985/stephen-c","reputation":703927,"display_name":"Stephen C","accept_rate":69},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1676124875,"creation_date":1301873225,"body":"<blockquote>\n<p>What are the caveats for using thread.setName() apart from those mentioned in the javadoc? How does it affect performance? The peak frequency of calling thread.setName() would be about 200 per second and average about 0.3 per second.</p>\n</blockquote>\n<p>Performance should not be a significant issue.  <code>Thread.setName()</code> does a security check and then copies / sets an attribute.  The security check should be cheap unless your code is privileged code running in a security sandbox that forbids unprivileged calls to the <code>Thread.setName()</code> method.</p>\n<p><sup>In Java 9 and later, <code>setName</code> is going to tell the OS to change the native thread's name.  For Linux, Solaris, AIX and BSD (e.g. MacOS) this is done via a call to <code>pthread_setname_np</code> which makes a syscall under the hood.  With Windows, it does some weird thing with the Windows debugger ... and only works if there is a debugger already attached.  In Java 8, no attempt is made to change the native thread name.</sup></p>\n<p>The only other caveat I can think of is that thread names changing all of the time could be confusing if you are trying to debug threading behavior; e.g. looking at thread dumps, etc.o</p>\n","answer_id":5533219,"question_id":5532864,"last_edit_date":1676124875},{"owner":{"profile_image":"https://lh3.googleusercontent.com/-CNNlW_hAMJI/AAAAAAAAAAI/AAAAAAAAPFk/OfGtXwoVyTM/photo.jpg?sz=256","account_id":6183990,"user_type":"registered","user_id":4818628,"link":"https://stackoverflow.com/users/4818628/sergey-kosarev","reputation":71,"display_name":"Sergey Kosarev"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1676025693,"creation_date":1676025693,"body":"<p>There is <code>happens-before</code> between <code>Holder.read</code> and <code>Holder.write</code> methods obviously. But no any guaranties between <code>State.getAge</code> and <code>Holder.write</code>.\nif you want to read age you actually need to execute two operations:</p>\n<pre><code>(1) State state = holder.read(key);\n\n(2) int age = state.getAge();\n</code></pre>\n<p>So, if <code>Holder.write</code> in another thread happens after (1) but before (2), you may see old age value in (2).</p>\n","answer_id":75409974,"question_id":67825678},{"owner":{"profile_image":"https://i.stack.imgur.com/SEQOn.jpg?s=256&g=1","account_id":10611364,"user_type":"registered","user_id":7815223,"link":"https://stackoverflow.com/users/7815223/shagun-verma","reputation":163,"display_name":"Shagun Verma"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1675909718,"creation_date":1675909368,"body":"<p>To accomplish this, you have to use <code>Executors</code> in Java. The below code will be done the job for you-</p>\n<pre><code>btnPausePlay.setOnClickListener(view -&gt; {\n    btnPausePlay.setVisibility(View.GONE);\n    progressPausePlay.setVisibility(View.VISIBLE);\n    ExecutorService executorService =  Executors.newSingleThreadExecutor();\n        executorService.execute(() -&gt; {\n            // Implement your file download code here i.e.\n            // httpRequest_noBackgroundThread( urlStr, urlParams, fileStr, itf );\n        handler.post(() -&gt; {\n            btnPausePlay.setVisibility(View.VISIBLE);\n            progressPausePlay.setVisibility(View.GONE);\n        });\n    });\n});\n</code></pre>\n<p>When you press the btnPausePlay button, then it will become invisible and the progress bar becomes visible. After that, once the download is completed reverse will happen.</p>\n","answer_id":75393592,"question_id":75389536,"last_edit_date":1675909718},{"owner":{"profile_image":"https://www.gravatar.com/avatar/67f2ccd17aa6fd622152ad88fc2ae784?s=256&d=identicon&r=PG","account_id":422870,"user_type":"registered","user_id":801894,"link":"https://stackoverflow.com/users/801894/solomon-slow","reputation":25925,"display_name":"Solomon Slow"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1665068370,"creation_date":1665068370,"body":"<p>Not sure I understand what you're really trying to do, but changing your <code>run()</code> function so that it spends most of its time &quot;sleeping&quot; might improve the performance of your program:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public void run() {\n    System.out.println(&quot;it is running&quot;);\n    while(true) {\n        long timeUntilDelete = lastEdit - System.currentTimeMillis();\n        if (timeUntilDelete &gt; 0) {\n            try {\n                Thread.sleep(timeUntilDelete);\n            }\n            catch(InterruptedException ex) {\n                ...What you do here is up to you...\n            }\n            continue;\n        }\n        System.out.println(&quot;DELETE&quot;);\n        timerStart(12000);\n    }\n}\n</code></pre>\n","answer_id":73975979,"question_id":73968499},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG","account_id":401843,"user_type":"registered","user_id":768644,"link":"https://stackoverflow.com/users/768644/rzwitserloot","reputation":89863,"display_name":"rzwitserloot"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1665067435,"creation_date":1665067435,"body":"<p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/LockSupport.html#park()\" rel=\"nofollow noreferrer\">Reading docs</a> is fundamental.</p>\n<p>As the docs indicate, <code>LockSupport.park()</code> is allowed to spuriously return. In other words, the docs literally spell out:</p>\n<ul>\n<li>Q: &quot;Why did the park() call return so quickly?&quot;</li>\n<li>A: Because the JVM felt like it.</li>\n</ul>\n<p>LockSupport's locks are thread-global. There is exactly one semaphore (which LockSupport calls a 'permit') for each thread, you can't make more and you can't make less. Basically meaning, exactly one system within your JVM can use it, because if two use it, they confuse each other.</p>\n<p>As the docs also say:</p>\n<blockquote>\n<p>Basic thread blocking primitives for creating locks and other synchronization classes.</p>\n</blockquote>\n<p>Which in essence means: Why are you doing this? If you want locking behaviour, use e.g. <code>ReentrantLock</code> from the <code>java.util.concurrent</code> package; this isn't meant for you, and hence it has all sorts of bizarre weirdness in it, such as <code>park()</code>'s rule that it is allowed spurious returns.</p>\n<p>Most likely the <code>log.debug</code> code either [A] ends up calling <code>LockSupport.unpark(ownThread)</code> for some reason, which means the next <code>park()</code> call returns immediately, or [B] it's a timing matter. <code>log.debug</code> is not 'free', many log frameworks run 'in-place', meaning, the <code>log.debug</code> call actually goes out on disk and fsyncs, meaning, it takes a very long time indeed compared to your average non-disk-interacting java instruction (hundreds of instructions worth of time). That time is enough for the scheduler to fly by it, especially considering 'write to disk' or 'fsync' is a natural stopping point (threads in java are pre-emptive, but if you give the scheduler an excuse to pause your thread, it will usually take it).</p>\n<p>In the end, the docs are clear: You don't get an answer to your 'why' question. The specs give the JVM free reign not to have to explain to you why <code>park()</code> spuriously returns. Therefore there isn't much point chasing down the why for this case - even if you have an answer, tomorrow there can be a different reason. If your code can't handle spurious returns on <code>LockSupport.park()</code>, your code is by definition broken. Even if you can make it work on your machine, today, with this phase of the moon, then that's no guarantee it would work fine tomorrow.</p>\n<p>Once your code can handle spurious returns, figuring out why it spuriously returns here isn't interesting anymore. Thus, solution: Deal with spurious returns properly. Or, more likely, don't use this for locks, use something more friendly to end users.</p>\n","answer_id":73975752,"question_id":73975470},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e648659dd573c1161a370efa0f5e10d6?s=256&d=identicon&r=PG","account_id":238127,"user_type":"registered","user_id":506796,"link":"https://stackoverflow.com/users/506796/tenfour04","reputation":86162,"display_name":"Tenfour04","accept_rate":83},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1665061342,"creation_date":1665061342,"body":"<p>If you truly want to fire and forget, such that the coroutine will not be cancelled under any circumstance, GlobalScope is the right way to do it. The need to truly fire and forget is rare enough in practice that Kotlin gives you a warning about a &quot;fragile API&quot; if you use it, I think because so many newbies were using it for everything. This was especially a problem on Android (where Kotlin is primarily used), where long running tasks that should run even off-screen should be handled in services instead of coroutines.</p>\n<p>But, referring to your example, if <code>inventory</code> is something that could become obsolete and you want to free it to the GC at some point, you should use your own created CoroutineScope that you store in a property, so you can cancel it to clear any running coroutines and prevent them from hanging onto references that should be freed for the GC. If the scope might be used for more than one coroutine, then you should give it a <code>SupervisorJob()</code>.</p>\n<pre><code>private val coroutineScope = CoroutineScope(SupervisorJob())\n\nfun onEndOfLifecycle() { // some function called when cleaning up memory \n    coroutineScope.cancel()\n}\n</code></pre>\n","answer_id":73974282,"question_id":73973632},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e34d0dd755c1ca59cd89d4a4e566439a?s=256&d=identicon&r=PG","account_id":2226374,"user_type":"registered","user_id":1965042,"link":"https://stackoverflow.com/users/1965042/vcg","reputation":106,"display_name":"vcg"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1665028662,"creation_date":1665028662,"body":"<p>Hi so you could be using <code>ScheduledExecutorService</code>, take a look to oracle docs, you will find an example, I believe solves your problem</p>\n","answer_id":73968534,"question_id":73968499},{"owner":{"profile_image":"https://www.gravatar.com/avatar/6b2c535fac79e482b71f15de561f55ca?s=256&d=identicon&r=PG","account_id":60171,"user_type":"registered","user_id":179850,"link":"https://stackoverflow.com/users/179850/gray","reputation":115485,"display_name":"Gray","accept_rate":100},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1664922241,"creation_date":1664903717,"body":"<blockquote>\n<p>What can be the reasons for the above assumptions or the observations?</p>\n</blockquote>\n<p>One of the issues that you need to realize is that you will not get more than the core number of threads allocated in your thread-pool until the queue fills up.  I kid you not.  In your case, it's only when the 5 threads are busy and 10000 jobs are queued that the 6th thread will be started.</p>\n<p>I would set the <code>corePoolSize</code> and the <code>maxPoolSize</code> both to be 100 and then set the <code>keepAliveSeconds</code> to 30 or something if you want the core threads to drop down during periods of inactivity.  See this question for more details: <a href=\"https://stackoverflow.com/q/19528304/179850\">How to get the ThreadPoolExecutor to increase threads to max before queueing?</a></p>\n<p>Couple other comments:</p>\n<blockquote>\n<pre><code>int i = Thread.activeCount();\nlogger.info(&quot;Point 1: Active thread count : [{}]&quot;, i);\naskExecutor.execute(new Runnable() { ... });\nlogger.info(&quot;Point 2: Active thread count : [{}]&quot;, i);\n</code></pre>\n</blockquote>\n<p>The active-count won't change at point 2 since you aren't making another call to <code>Thread.activeCount()</code>.  Also, you are scheduling a job to be run by the thread-pool but that doesn't necessarily mean that a thread will be created.</p>\n<p>If you are using a <code>ThreadPoolExecutor</code> directly (as opposed to the Spring wrapper) then you could call <code>pool.getActiveCount()</code> and other methods to get a more accurate picture of the threads running in your thread pool.  The 114 threads running in your application may be associated with the tomcat handlers and other JVM threads instead of your pool specifically.  You can also use jconsole, jstack, or a <code>SIGQUIT</code> to dump the thread stacks and see how many threads are associated with your pool.  The thread names should be something like xxx-pool-1 or something unless you are using a thread-factory.</p>\n<p>Lastly a general comment.  Maybe this is obvious but you really should be trying to optimize your throughput as opposed to worrying about the number of threads.  100 may be too many threads if you are pounding the server too hard or if the job is computational or 100 may be too few if your HTTP connections take a while to be satisfied because of latency.</p>\n","answer_id":73951424,"question_id":73920478,"last_edit_date":1664922241},{"owner":{"profile_image":"https://i.stack.imgur.com/wOpca.jpg?s=256&g=1","account_id":1901420,"user_type":"registered","user_id":1717210,"link":"https://stackoverflow.com/users/1717210/tachedechoco","reputation":3763,"display_name":"TacheDeChoco"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1664813945,"creation_date":1664811858,"body":"<blockquote>\n<p>We have no control over their timeout time</p>\n</blockquote>\n<p>Do not care about the server timeouts. As an HTTP client, you can define your own timeouts, on two distinct levels:</p>\n<ul>\n<li>a <strong>connection</strong> timeout : how long max to reach the target server</li>\n<li>a <strong>read</strong> timeout : allowing you to give up after a certain amount of time (and potentially earlier than the server will abort) in case the HTTP response does not come</li>\n</ul>\n<p>See Spring doc on how to configure these two timeouts.</p>\n","answer_id":73937781,"question_id":73937447,"last_edit_date":1664813945},{"owner":{"profile_image":"https://www.gravatar.com/avatar/dc91a8e29fedbd6a6d7e03a8394009ab?s=256&d=identicon&r=PG","account_id":75804,"user_type":"registered","user_id":217324,"link":"https://stackoverflow.com/users/217324/nathan-hughes","reputation":94840,"display_name":"Nathan Hughes","accept_rate":96},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1664737739,"creation_date":1664717306,"body":"<p>Exceptions don't propagate across threads, for instance you need an UncaughtExceptionHandler to retrieve the exception thrown by another thread, see <a href=\"https://stackoverflow.com/q/6546193/217324\">How to catch an Exception from a thread</a>.</p>\n<p>So putting InterruptedException in the throws clause creates a false expectation, the exception still can't be thrown in one thread and caught in another. That's the only reason I can think of for not doing this, they are trying to communicate to the developer that the toplevel run method for a thread needs to handle everything. Putting InterruptedException in the throws clause dilutes this message, as the developer isn't forced to deal with it.</p>\n<p>But yes, they could have added InterruptedException to the throws clause of Runnable, that would make this case much simpler. But there are design goals in conflict. The designars want developers to be very aware of the exception behavior, including making  InterruptedException checked, but it's not having it in the throws clause that forces people to deal with it. The goal of letting simple things be easy and having a thread call sleep without a catch is at odds with that so it wasn't implemented.</p>\n","answer_id":73926210,"question_id":73926124,"last_edit_date":1664737739},{"owner":{"profile_image":"https://i.stack.imgur.com/MEVJT.jpg?s=256&g=1","account_id":6589671,"user_type":"registered","user_id":5091346,"link":"https://stackoverflow.com/users/5091346/andrii-abramov","reputation":10127,"display_name":"Andrii Abramov","accept_rate":72},"content_license":"CC BY-SA 4.0","score":8,"is_accepted":false,"last_activity_date":1664737068,"creation_date":1522142645,"body":"<p>Since Java 8 release, there is more declarative way to initialize <code>ThreadLocal</code>:</p>\n<pre><code>ThreadLocal&lt;String&gt; local = ThreadLocal.withInitial(() -&gt; &quot;init value&quot;);\n</code></pre>\n<p>Until Java 8 release you had to do the following:</p>\n<pre><code>ThreadLocal&lt;String&gt; local = new ThreadLocal&lt;String&gt;(){\n    @Override\n    protected String initialValue() {\n        return &quot;init value&quot;;\n    }\n};\n</code></pre>\n<p>Moreover, if instantiation method (constructor, factory method) of class that is used for <code>ThreadLocal</code> does not take any parameters, you can simply use method references (introduced in Java 8):</p>\n<pre><code>class NotThreadSafe {\n    // no parameters\n    public NotThreadSafe(){}\n}\n    \nThreadLocal&lt;NotThreadSafe&gt; container = ThreadLocal.withInitial(NotThreadSafe::new);\n</code></pre>\n<p><strong>Note:</strong>\nEvaluation is lazy since you are passing <code>java.util.function.Supplier</code> lambda that is evaluated only when <code>ThreadLocal#get</code> is called but value was not previously evaluated.</p>\n","answer_id":49509030,"question_id":817856,"last_edit_date":1664737068},{"owner":{"profile_image":"https://i.stack.imgur.com/WAhD8.png?s=256&g=1","account_id":1129864,"user_type":"registered","user_id":1116216,"link":"https://stackoverflow.com/users/1116216/michele-la-ferla","reputation":6795,"display_name":"Michele La Ferla","accept_rate":100},"content_license":"CC BY-SA 4.0","score":7,"is_accepted":false,"last_activity_date":1662061119,"creation_date":1464877239,"body":"<p>Within the lifecycle callback methods, you can declare how your activity behaves when the user leaves and re-enters the activity. Remember that the way Android is designed, there is a lifecycle for each and every app. If you put too much load to the <code>onCreate()</code> method (which is the method used to load the layout files and initalise any controls you have in it), then the white screen will become more visible, as the layout file will take longer to load.</p>\n<p>I suggest using several different methods when starting an activity. Such are the <code>onStart()</code> (being called as the first thing once the app is loaded), <code>onActivityCreated()</code> (being called after the layout is displayed and useful if you are making any data processing upon starting the activity).</p>\n<p>To make it easier for you, below is the official activity lifecycle diagram (from <a href=\"http://web.archive.org/web/20140218132043/http://developer.android.com/training/basics/activity-lifecycle/starting.html\" rel=\"nofollow noreferrer\">http://web.archive.org/web/20140218132043/http://developer.android.com/training/basics/activity-lifecycle/starting.html</a>):</p>\n<p><a href=\"https://i.stack.imgur.com/KozRu.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/KozRu.png\" alt=\"enter image description here\" /></a></p>\n","answer_id":37594546,"question_id":37437037,"last_edit_date":1662061119},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e442a53d36f9351aee11b5ecb8369691?s=256&d=identicon&r=PG","account_id":6520,"user_type":"registered","user_id":11002,"link":"https://stackoverflow.com/users/11002/tgdavies","reputation":10523,"display_name":"tgdavies","accept_rate":75},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1659525121,"creation_date":1659525121,"body":"<p>Why not simply:</p>\n<pre><code>ExecutorService executorService = Executors.newSingleThreadExecutor();\n        executorService.submit((Runnable) () -&gt; {\n            while (true) {\n                try {\n                    ...\n                } catch (Exception e) {\n                    // log\n                }\n            }\n        });\n</code></pre>\n<p>There doesn't seem to be any need for a <code>Callable</code> or a <code>Future</code>.</p>\n","answer_id":73220736,"question_id":73220654},{"owner":{"profile_image":"https://i.stack.imgur.com/b5Dq4.jpg?s=256&g=1","account_id":476019,"user_type":"registered","user_id":886697,"link":"https://stackoverflow.com/users/886697/stanislav-bashkyrtsev","reputation":14699,"display_name":"Stanislav Bashkyrtsev","accept_rate":92},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1654931009,"creation_date":1654928561,"body":"<p>I don't think you're measuring what you think you're measuring. You have 100 tasks and you measure how much time each task takes to finish. Suppose each takes 2sec. So if we execute them one after another it'll be 2sec * 100.</p>\n<p>Now suppose you run them in 8 threads and 8 cores. This doesn't (ideally) change the amount of time each task takes, so you still have 2sec for each task. And you again have 2sec * 100 of <em>summed</em> time. But the overall execution time changes - it's <code>(2sec * 100) / 8</code> because this <em>summed</em> time is now spread across 8 cores instead of 1.</p>\n<p>So what you need to measure is the total time it takes for the program to run. Just measure it in <code>runBenchmark()</code> method:</p>\n<pre><code>private void runBenchmark() throws Exception {\n  try {\n      long started = System.nanoTime();\n      for (int i = 0; i &lt; numThreads; i++)\n          benchMarkResultsFuture.add(executorService.submit(new BenchmarkThread(numOperationsPerThread)));\n      for (Future&lt;BenchmarkResult&gt; resultFuture : benchMarkResultsFuture)\n          resultFuture.get();\n\n      long timeToComplete = (System.nanoTime() - started) / 1000;\n      System.out.println(&quot;=====runBenchmark() FINISHED in &quot; + timeToComplete);\n  } finally {\n      executorService.shutdown();\n  }\n}\n</code></pre>\n","answer_id":72582182,"question_id":72582076,"last_edit_date":1654931009},{"owner":{"profile_image":"https://i.stack.imgur.com/Klcqr.gif?s=256&g=1","account_id":292208,"user_type":"registered","user_id":2245707,"link":"https://stackoverflow.com/users/2245707/pveentjer","reputation":10665,"display_name":"pveentjer","accept_rate":17},"content_license":"CC BY-SA 4.0","score":4,"is_accepted":false,"last_activity_date":1654927764,"creation_date":1654927764,"body":"<p>This could be the cause of the problem:</p>\n<pre><code>  private static final Random RANDOM = new Random();\n</code></pre>\n<p>Because this is contended between all threads.</p>\n<p>Try a ThreadLocalRandom instead.</p>\n<p>Also, I would use a more reliable benchmarking approach like JMH.</p>\n","answer_id":72582123,"question_id":72582076},{"owner":{"profile_image":"https://lh3.googleusercontent.com/a/AATXAJxX9Iix5-V4Afy0vaosyCz1npCO7X3fhNOxSnIe=k-s256","account_id":25423725,"user_type":"registered","user_id":19229200,"link":"https://stackoverflow.com/users/19229200/scizora","reputation":21,"display_name":"Scizora"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1654922791,"creation_date":1654922791,"body":"<p>Hi just to update after deploying and testing my code the implementation of shutdown hooks and setting to daemon solved this issue of threads running despite closing the jar file via cmd/pressing x. I am still looking at the Executor service as an alternative way to encapsulate my code better but tbh its still quite hard to grasp its concepts. It would be fantastic if there was an example of its implementation!</p>\n","answer_id":72581802,"question_id":72429901},{"owner":{"profile_image":"https://i.stack.imgur.com/ZWEI3.jpg?s=256&g=1","account_id":322981,"user_type":"registered","user_id":642706,"link":"https://stackoverflow.com/users/642706/basil-bourque","reputation":310755,"display_name":"Basil Bourque","accept_rate":58},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1654919342,"creation_date":1654919342,"body":"<p>Currently in Java, threads are quite expensive, being mapped directly one-to-one to host OS threads. They impact both memory usage and CPU usage. So we usually limit the number of threads to a few, often roughly the number of cores or so. So increasing/decreasing the size of the thread pool is not likely to make sense nowadays.</p>\n<h1>Virtual threads in <em>Project Loom</em></h1>\n<p>Sounds like your scenario is ideal for the <a href=\"https://openjdk.java.net/jeps/425\" rel=\"nofollow noreferrer\">virtual threads</a> (<a href=\"https://en.wikipedia.org/wiki/Fiber_(computer_science)\" rel=\"nofollow noreferrer\">fibers</a>) coming from the <a href=\"https://wiki.openjdk.java.net/display/loom/Main\" rel=\"nofollow noreferrer\"><em>Project Loom</em></a> project. Many virtual threads are mapped to a single host OS thread.</p>\n<p>In today's Java threading, if the Java code blocks, the host OS thread blocks. No further work is performed on that thread. With virtual threads, when the Java code blocks the virtual thread is dismounted from its assigned host OS thread, and “parked”. When that code eventually returns, and therefore needs further execution, it is mounted onto another host OS thread. This parking and mounting of virtual threads is <em>much</em> faster than blocking/unblocking of host OS threads. Virtual threads have much less impact on memory and and CPU. So we can have thousands, or even millions, of threads running simultaneously on conventional hardware.</p>\n<p>In your scenario where your work load may go up or down, the virtual thread facility in Project Loom will automatically manage the thread pool and scheduling. You should see vastly improved throughput with no effort on your part.</p>\n<p>A few caveats:</p>\n<ul>\n<li>Cheap threads can still do expensive things. So you may need to manage or limit your particular concurrent tasks to avoid blowing out memory or overburdening other resources.</li>\n<li>Virtual threads only make sense for tasks that block. That means most common Java work. But for entirely CPU bound tasks such as video encoding/decoding with little to no logging, storage I/O, network I/O, etc. you would stick with conventional Java threads.</li>\n<li>There may be some situations where the particular content in your task may prevent the parking while blocked. You may choose to alter your code a bit to enable the virtual thread from being “pinned” to the host OS thread. This may be especially the case with the initial releases of Loom. This situation is fluid right now in pre-release Loom, so we will need to stay informed as to changes.</li>\n</ul>\n<p>Virtual threads and other Project Loom features are available as preview features in Java 19, with experimental builds available now.</p>\n<p>For more information, see the articles, presentations, and interviews by members of the Project Loom team such as Ron Pressler and Alan Bateman.</p>\n","answer_id":72581584,"question_id":72580556},{"owner":{"profile_image":"https://lh3.googleusercontent.com/a/AATXAJzJlRNdxfu9SC29izHRXdSfvH-4Ns7e7qVBN1Yq=k-s256","account_id":25335362,"user_type":"registered","user_id":19154594,"link":"https://stackoverflow.com/users/19154594/rohit-dakota","reputation":13,"display_name":"Rohit Dakota"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1654850384,"creation_date":1654850384,"body":"<p>You should associate the properties map with the user session or request</p>\n","answer_id":72571407,"question_id":45265777},{"owner":{"profile_image":"https://i.stack.imgur.com/FKKLW.jpg?s=256&g=1","account_id":404649,"user_type":"registered","user_id":773113,"link":"https://stackoverflow.com/users/773113/mike-nakis","reputation":57192,"display_name":"Mike Nakis","accept_rate":72},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1654848295,"creation_date":1654848295,"body":"<p>All the stuff about android, java, C#, xamarin, bluetooth, etc. is irrelevant. This question is essentially asking how to build a socket server application for a small number of clients, where &quot;small&quot; here means that you have the luxury of spawning one thread per client. (If you were to serve a large number of clients, then you would have to resort to a threadpool, but in your case that would be an unnecessary complication.)</p>\n<p>The way we build a socket server application for a small number of clients is as follows:</p>\n<ol>\n<li>One thread (the &quot;Accept&quot; thread) does nothing but an endless loop where it invokes <code>serverSocket.Accept()</code>.</li>\n<li>When a socket connection is established, the &quot;Accept&quot; thread creates a &quot;Session&quot; thread for the connected socket. So, we have one &quot;Session&quot; thread per client.</li>\n<li>Each &quot;Session&quot; thread receives packets from a client and sends packets back to the client. When a &quot;Session&quot; thread has something to useful to show to the user, the &quot;Session&quot; thread &quot;posts&quot; a message to the GUI thread, which means that it sends it in a thread-safe way. Different GUI systems support different means of accomplishing this; I am not sure about Xamarin, perhaps with <code>MessagingCenter.Send()</code>.</li>\n</ol>\n","answer_id":72570970,"question_id":72557561},{"owner":{"profile_image":"https://www.gravatar.com/avatar/18b9001fd20c1e089d19f4a1e994bcdc?s=256&d=identicon&r=PG","account_id":6482932,"user_type":"registered","user_id":5019386,"link":"https://stackoverflow.com/users/5019386/mahmoud-ben-hassine","reputation":29552,"display_name":"Mahmoud Ben Hassine"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1654843263,"creation_date":1654843263,"body":"<p>While it is possible to make the commit interval and thread pool size configurable and change them at startup time, it is not possible to change them at runtime (ie &quot;in-flight&quot;) once the job execution has started.</p>\n<p>Making the commit interval and thread pool size configurable (via application/system properties or passing them as job parameters) will allow you to empirically adapt the values to best utilize your resources without having to recompile/repackage your application.</p>\n<p>The <em>runtime</em> dynamism you are looking for is not available by default, but you can always implement the <code>Step</code> interface and use it as part of a Spring Batch job next to other step types provided out-of-the-box by the framework.</p>\n","answer_id":72570061,"question_id":72567117},{"owner":{"profile_image":"https://www.gravatar.com/avatar/dc91a8e29fedbd6a6d7e03a8394009ab?s=256&d=identicon&r=PG","account_id":75804,"user_type":"registered","user_id":217324,"link":"https://stackoverflow.com/users/217324/nathan-hughes","reputation":94840,"display_name":"Nathan Hughes","accept_rate":96},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1654778339,"creation_date":1654715348,"body":"<p>The notify/notifyAll methods tell the scheduler to notify one/all of the threads currently waiting on the lock that notify or notifyAll was called on. But if a thread hasn't started waiting yet then it doesn't get notified.</p>\n<p>The solution is to introduce a condition variable that keeps wait from being called if the notifying has happened already. Define it in the same scope as your lock:</p>\n<pre><code>public static volatile boolean ready = false;\n</code></pre>\n<p>Then use it to guard the wait block, like this:</p>\n<pre><code>while (!ready) {\n    object.wait();\n}\n</code></pre>\n<p>The code calling notify/notifyAll needs to set the variable (it doesn't matter what order you do it in because the notification doesn't happen until the lock is released):</p>\n<pre><code>synchronized (object) {\n    ready = true;\n    object.notifyAll();\n}\n</code></pre>\n<p>What happens:</p>\n<p>If the waiting thread gets to the waiting part before the notifying thread does its notifying, then the waiting thread finds ready is false, so it enters the wait method, releases the lock, and stays there.  Then the notifying thread changes the flag to true and wakes up the waiting thread, which can leave the wait, reacquire the lock, and then leave the loop now that the flag is set.</p>\n<p>But if the notifying thread does its notify before the other thread waits, that's ok, because the ready flag now prevents the thread from entering the wait, it can skip over it.</p>\n<p>Further reading: <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html</a></p>\n","answer_id":72551003,"question_id":72547510,"last_edit_date":1654778339},{"owner":{"profile_image":"https://i.stack.imgur.com/qHEzx.png?s=256&g=1","account_id":3192259,"user_type":"registered","user_id":2696260,"link":"https://stackoverflow.com/users/2696260/m-deinum","reputation":117619,"display_name":"M. Deinum"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":true,"last_activity_date":1654761035,"creation_date":1654760603,"body":"<p>Do something like this.</p>\n<pre><code>ExecutorService exector = Executors.newCachedThreadPool();\n\npublic List&lt;ResultDto&gt; queryAll(List&lt;String&gt; ids) throws ExecutionException, InterruptedException {\n\n    List&lt;CompletableFuture&gt; cfs = new ArrayList&lt;&gt;(ids.size());\n    for (String id : ids) {\n      CompletableFuture cf = Completableuture.supplyAsync(() -&gt; getResult(id), exector);\n      cfs.add(cf);\n    }\n    CompletableFuture allOfThem = CompletableFuture.allOf(cfs.toArray(new CompletableFuture[0]);\n \n    CompletableFuture&lt;List&lt;ResultDto&gt;&gt; allCompletableFutures = allOfThem .thenApply(future -&gt; {\n    return cfs.stream()\n            .map(completableFuture -&gt; completableFuture.join())\n            .collect(Collectors.toList());\n});\n    return allCompletableFutures.get();\n}\n\nResultDto getResult(String id) {\n    String remoteResult = &quot; httpUtils.get()&quot; + id;\n    BaseData baseData = new BaseData();\n    baseData.setBaseInfo(&quot;baseData&quot; + id);\n    baseData.setRemoteInfo(remoteResult);\n    ResultDto resultDto = new ResultDto();\n    resultDto.setBaseData(baseData);\n    return resultDto;\n}\n</code></pre>\n<p>This will give you a non-blocking solution (it will only block in the end).</p>\n<p>Or you can make it even easier and just use a <code>parallelStream</code> and use the default fork-join pool.</p>\n<pre class=\"lang-java prettyprint-override\"><code>public List&lt;ResultDto&gt; queryAll(List&lt;String&gt; ids) throws ExecutionException, InterruptedException {\n    return ids.parallelStream().map(id -&gt; getResult(id)).collect(Collectors.toList());\n}\n\nResultDto getResult(String id) {\n    String remoteResult = &quot; httpUtils.get()&quot; + id;\n    BaseData baseData = new BaseData();\n    baseData.setBaseInfo(&quot;baseData&quot; + id);\n    baseData.setRemoteInfo(remoteResult);\n    ResultDto resultDto = new ResultDto();\n    resultDto.setBaseData(baseData);\n    return resultDto;\n}\n</code></pre>\n<p>You can probably decide which is better to read...</p>\n","answer_id":72556469,"question_id":72556212,"last_edit_date":1654761035},{"owner":{"profile_image":"https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG","account_id":47283,"user_type":"registered","user_id":139985,"link":"https://stackoverflow.com/users/139985/stephen-c","reputation":703927,"display_name":"Stephen C","accept_rate":69},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1654760346,"creation_date":1654759924,"body":"<blockquote>\n<p>Some people say that: the thread pool get method is Blocking methods, so it is no different from writing without threads.</p>\n</blockquote>\n<p>They are correct.  If you call <code>get()</code> at that point, it immediately blocks until the that particular task has completed.  So the 2nd task isn't submitted until the first one completes ... and so on.</p>\n<p>What you need to do is submit all of the tasks before calling <code>get()</code>. Something like the following pseudo-code.</p>\n<pre><code>List&lt;Future&gt; futures\nfor each id in ids:\n   futures.add(executor.submit(...))\n\nfor each future in futures:\n   result = future.get()\n   results.add(process(result))\n</code></pre>\n<p>If you can arrange that each task does the processing of its result, you potentially get more parallelism.</p>\n<p>As noted, you could use <code>CompleteableFuture.allOf</code> instead of the second loop.</p>\n","answer_id":72556323,"question_id":72556212,"last_edit_date":1654760346},{"owner":{"profile_image":"https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8532578,"user_type":"registered","user_id":6395627,"link":"https://stackoverflow.com/users/6395627/slaw","reputation":39918,"display_name":"Slaw"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1654719209,"creation_date":1654719209,"body":"<p>The problem, I believe, is in your <code>SpiderUtils</code> class. More specifically, this method:</p>\n<blockquote>\n<pre class=\"lang-java prettyprint-override\"><code>public static boolean isLinkURLValid(URI url) {\n    return url.getHost().equalsIgnoreCase(baseUrl.getHost()) &amp;&amp;\n            !containsURL(linksCrawled, url) &amp;&amp;\n            !containsURL(linksInProgress, url) &amp;&amp;\n            !url.getPath().contains(&quot;.&quot;);\n}\n</code></pre>\n</blockquote>\n<p>And this method:</p>\n<blockquote>\n<pre class=\"lang-java prettyprint-override\"><code>public static boolean containsURL(ArrayList&lt;URI&gt; urls, URI left) {\n    return urls.stream().anyMatch(right -&gt; urlsMatch(left, right));\n}\n</code></pre>\n</blockquote>\n<p>Both these methods are not <code>synchronized</code>, which means multiple threads can execute them at the same time. This is likely not a problem for the <code>containsURL(...)</code> method. Given what it does, it has no reason to be <code>synchronized</code> (neither it, nor the <code>urlsMatch(...)</code> method, rely on any external state). The problem is with how the <code>isLinkURLValid(...)</code> method passes both <code>linksCrawled</code> and <code>linksInProgress</code> to the <code>containsURL(...)</code> method.</p>\n<p>These list variables are static, and thus the same instances are passed to the <code>isLinkURLValid(...)</code> method on different threads. This would be okay, if all you did was stream the elements of these lists (i.e., only <em>read</em> from the lists). However, elsewhere in your code you also <em>add elements</em> to these lists (i.e., you <em>write</em> to the lists). These writes are performed in <code>synchronized</code> methods, but that doesn't matter because you're reading the lists without synchronizing on the same object. So, your code is vulnerable to <code>ConcurrentModificationException</code>s (you cannot modify a non-concurrent collection while iterating over it).</p>\n<p><em>I believe</em> the solution would be to simply make the <code>isLinkURLValid(...)</code> method <code>synchronized</code>, but I'm not 100% positive as I haven't tested it.</p>\n","answer_id":72551685,"question_id":72525288},{"owner":{"profile_image":"https://i.stack.imgur.com/5EJGg.png?s=256&g=1","account_id":4104221,"user_type":"registered","user_id":3368818,"link":"https://stackoverflow.com/users/3368818/woodchuck","reputation":3989,"display_name":"Woodchuck","accept_rate":75},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1649619176,"creation_date":1649617272,"body":"<p>I don't exactly follow what you're looking for. But it sounds like you're looking to execute those methods in a multi-threaded way.</p>\n<p>If that's the case, you appear to be missing some things, such as the <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html\" rel=\"nofollow noreferrer\">synchronized</a> keyword and the <a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html\" rel=\"nofollow noreferrer\">Runnable</a> interface.</p>\n<p>The following is an example to perhaps get you started down the right path. It runs as it is, but I'm sure you'll need to tweak it to accomplish your goal:</p>\n<pre><code>package SatrancSaatiRunner ;\n\nimport java.util.Scanner;\n\npublic class SatrancSaatiRunner {\n    static int beyazZamani = 60;\n    static int siyahZamani = 60;\n\n    static boolean BeyazinSirasi = false;\n    static boolean SiyahinSirasi = false;// rakip baslar\n\n    static boolean zamanVarMi = true;\n\n    public static void main(String[] args) throws InterruptedException {\n\n        SatrancSaatiRunner s = new SatrancSaatiRunner();\n\n        for (int i = 0; i &lt; 999; i++) {\n\n            //Scanner scanner = new Scanner(System.in);\n            System.out.println(&quot;Beyaz hamle yaptiktan sonra 1 e basmali&quot;);\n            System.out.println(&quot;Siyah hamle yaptiktan sonra 2 e basmali&quot;);\n\n            //int kiminSirasi = scanner.nextInt();\n            //if (kiminSirasi == 1) {\n            //    saatCalistirSiyah(BeyazinSirasi, siyahZamani, zamanVarMi, beyazZamani, siyahZamani);\n\n            //} else if (kiminSirasi == 2) {\n            //      saatCalistirBeyaz(BeyazinSirasi, siyahZamani, zamanVarMi, beyazZamani, siyahZamani);\n            //}\n        //}\n      }\n\n        Thread t1 = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                try {\n                    s.saatCalistirSiyah(BeyazinSirasi, siyahZamani, zamanVarMi, beyazZamani, siyahZamani);\n                } catch (InterruptedException e) {\n                    System.out.println(e);\n                }\n            }\n        });\n\n        Thread t2 = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                try {\n                    s.saatCalistirBeyaz(BeyazinSirasi, siyahZamani, zamanVarMi, beyazZamani, siyahZamani);\n                } catch (InterruptedException e) {\n                    System.out.println(e);\n                }\n            }\n        });\n\n        t1.start();\n        t2.start();\n\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void saatCalistirBeyaz(boolean beyazinSirasi, int siyahZamani, boolean zamanVarMi, int beyazZamani,\n            int siyahZamani1) throws InterruptedException {\n        synchronized (this) {\n            System.out.println(&quot;***Hamle Beyazda***&quot;);\n            while (true) {\n                siyahZamani++;\n                beyazZamani--;\n                System.out.print(&quot;Beyaz: &quot; + beyazZamani + &quot; &quot;);\n                System.out.print(&quot;Siyah: &quot; + siyahZamani);\n                System.out.print(&quot;\\u000C&quot;);\n                Thread.sleep(1000);\n\n                if (beyazZamani &lt;= 0 || siyahZamani &lt;= 0) {\n                    break;\n                }\n            }\n        }\n    }\n\n    private void saatCalistirSiyah(boolean beyazinSirasi, int siyahZamani, boolean zamanVarMi, int beyazZamani,\n            int siyahZamani1) throws InterruptedException {\n        System.out.println(&quot;***Hamle Siyahta***&quot;);\n        while (true) {\n            beyazZamani++;\n            siyahZamani--;\n            System.out.print(&quot;Beyaz: &quot; + beyazZamani + &quot; &quot;);\n            System.out.print(&quot;Siyah: &quot; + siyahZamani);\n            System.out.print(&quot;\\u000C&quot;);\n            Thread.sleep(1000);\n\n            if (beyazZamani &lt;= 0 || siyahZamani &lt;= 0) {\n                break;\n            }\n        }\n    }\n}\n</code></pre>\n","answer_id":71819697,"question_id":71817703,"last_edit_date":1649619176},{"owner":{"profile_image":"https://www.gravatar.com/avatar/1f698e72460b5a8c716a0c1cea91b81e?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":13429972,"user_type":"registered","user_id":9690075,"link":"https://stackoverflow.com/users/9690075/zysaaa","reputation":1807,"display_name":"zysaaa"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1646282321,"creation_date":1646282321,"body":"<p>When a thread is woken up(<code>wait</code>-&gt;<code>runnable</code>), it needs to judge again whether the current <code>counter</code> is less than <code>LIMIT</code>, otherwise, it will continue to print until <code>while (counter &lt;= LIMIT)</code> does not hold.(That's why <code>11</code> and <code>12</code> are printed too).</p>\n<p>I would suggest that you determine in advance how many times each thread will loop(This will make the code simpler):</p>\n<pre><code>    // thread1\n    // prints 1, 4, 7, 10, ...\n    synchronized void printAPStartingFrom1() {\n        int count = LIMIT % 3 == 0 ? LIMIT / 3 : LIMIT / 3 + 1;\n        for (int i = 0; i &lt; count; i++) {\n            while (counter % 3 != 1) {\n                wait();\n            }\n            printAndAddCounter();\n            notifyAll();\n        }\n    }\n    // thread2\n    // prints 2, 5, 8, 11, ...\n    synchronized void printAPStartingFrom1() {\n        int count = (LIMIT - 1) % 3 == 0 ? LIMIT / 3 : LIMIT / 3 + 1;\n        for (int i = 0; i &lt; count; i++) {\n            while (counter % 3 != 2) {\n                wait();\n            }\n            printAndAddCounter();\n            notifyAll();\n        }\n    }\n    // thread3\n    // prints 3, 6, 9, 12, ...\n    synchronized void printAPStartingFrom1() {\n        int count = LIMIT / 3;\n        for (int i = 0; i &lt; count; i++) {\n            while (counter % 3 != 0) {\n                wait();\n            }\n            printAndAddCounter();\n            notifyAll();\n        }\n    }\n</code></pre>\n","answer_id":71332202,"question_id":71328425},{"owner":{"profile_image":"https://www.gravatar.com/avatar/6b2c535fac79e482b71f15de561f55ca?s=256&d=identicon&r=PG","account_id":60171,"user_type":"registered","user_id":179850,"link":"https://stackoverflow.com/users/179850/gray","reputation":115485,"display_name":"Gray","accept_rate":100},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":true,"last_activity_date":1646246685,"creation_date":1646246685,"body":"<blockquote>\n<p>java.lang.IllegalStateException: No thread-bound request found:</p>\n</blockquote>\n<p>This exception is trying to tell you that there is no current request being processed by the <code>HttpServletRequest</code> that has been auto-wired into your class.</p>\n<p>Something is calling the <code>putData()</code> method but not as through a call to the HTTP controller.  You mention that you are using the &quot;Kafka Consumer&quot; so maybe it is the consumer code which is calling <code>putData()</code>?  You can't call it because the method needs to have a web request context to work since it needs the request headers and cookie information.</p>\n<p>You should probably separate out the data persistence code so that both the controller <code>putData()</code> method and the kafka consumer can both call it.</p>\n","answer_id":71327704,"question_id":71311675},{"owner":{"profile_image":"https://www.gravatar.com/avatar/bc9274828a5770ef2f992f78fa8f3339?s=256&d=identicon&r=PG","account_id":1306332,"user_type":"registered","user_id":1255267,"link":"https://stackoverflow.com/users/1255267/tastywheat","reputation":2147,"display_name":"TastyWheat"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1646243274,"creation_date":1646243274,"body":"<p>The documentation is unfortunately not very clear about what can and can't be reused safely. When in doubt reuse nothing. However, if you're determined to minimize overhead you can safely reuse most objects depending on the methods called.</p>\n<p>Starting with your code, here's some comments about what's happening:</p>\n<pre class=\"lang-java prettyprint-override\"><code>// (1) Store an instance of Client with its own configuration\nprivate static Client client = ClientBuilder.newClient();\n// (2) Store an instance of WebTarget with its own configuration (inherited from client)\nprivate static WebTarget webTarget = client.target(&quot;someBaseUrl&quot;);\n...\npublic static String someMethod(String arg1, String arg2)\n{\n    // (3) New instance of WebTarget (copy entrTarget config) with &quot;arg1&quot; param\n    // (4) New instance of WebTarget (copy anonymous config) with &quot;arg2&quot; param\n    WebTarget target = entrTarget.queryParam(&quot;arg1&quot;, arg1).queryParam(&quot;arg2&quot;, arg2);\n    // (5) New instance of Invocation.Builder (copy target config)\n    // (6) Invoke GET request with stored configuration\n    Response response = target.request().get();\n    final String result = response.readEntity(String.class);\n    response.close();\n    return result;\n}\n</code></pre>\n<p>I commented on the code as-is but I'm guessing <code>(3)</code> should've referenced the static <code>webTarget</code> field.</p>\n<p>A lot of objects are getting created here. Every time an object is created there's a new instance with its own copy of the configuration (so it won't affect its predecessors). In this particular case there should be no race conditions, but there are definitely ways in which this could go wrong.</p>\n<p>If on or before <code>(3)</code> you had done something like this (assuming these are legitimate properties):</p>\n<pre class=\"lang-java prettyprint-override\"><code>WebTarget target = webTarget.property(&quot;foo&quot;, fooProperty).queryParam(&quot;arg1&quot;, arg1);\n</code></pre>\n<p>Then you would be altering the configuration of the static <code>webTarget</code> field and that could cause a race condition. There are many ways to alter the configuration from the static fields so you either need to guard them carefully or just not have them at all.</p>\n<p>Also, be aware that pretty much every object that spawns from the original <code>client</code> will have a reference to it for the purpose of determining if the httpEngine has been closed. So unless you're trying to gracefully shutdown your application it's likely never a good idea to close the client.</p>\n<p>And I found out all of this by digging through the source code because there's really no good reference.</p>\n","answer_id":71327053,"question_id":33097230},{"owner":{"profile_image":"https://i.stack.imgur.com/W6OMC.png?s=256&g=1","account_id":1056871,"user_type":"registered","user_id":1059372,"link":"https://stackoverflow.com/users/1059372/eugene","reputation":117749,"display_name":"Eugene","accept_rate":97},"content_license":"CC BY-SA 4.0","score":4,"is_accepted":false,"last_activity_date":1646233694,"creation_date":1645609597,"body":"<p>The <a href=\"https://stackoverflow.com/a/71212240/1059372\">accepted answer</a> is simple, yet great. <code>volatile</code> is rarely explained and used for safe publishing, yet it provides the needed guarantees.</p>\n<p>imho, to properly prove that this works with volatile, there are some things that need explaining.</p>\n<p>The first one is &quot;program order&quot;, or the perceivable order in which things happen within a thread. We can draw this to easier grasp things:</p>\n<pre><code> --------------- T1 -------------\n | write to num or this.num=num |\n --------------------------------\n                 |\n                \\|/  (PO)\n --------------- T1 -------------\n |    write Wrapper instance    |\n --------------------------------\n                 |\n                \\|/  (??)\n --------------- T2 -------------\n |    read Wrapper instance     |\n --------------------------------\n                 |\n                \\|/  (PO)\n --------------- T2 -------------\n |      read num first time     |\n --------------------------------\n                 |\n                \\|/  (PO)\n --------------- T2 -------------\n |      read num second time    |\n --------------------------------\n</code></pre>\n<p><code>T1</code> and <code>T2</code> are thread1 and thread2 and <code>PO</code> is program order. Now a rule in the <code>JLS</code> says this:</p>\n<blockquote>\n<p>If x and y are actions of the same thread and x comes before y in program order, then hb(x, y).</p>\n</blockquote>\n<p>As such we can replace <code>PO</code> in the above drawing with <code>HB</code> (happens-before).</p>\n<p>At the same time, if <code>wrapper</code> instance is <em>not</em> volatile, there is no special relation between <em>writing</em> to <code>wrapper</code> (from <code>T1</code>) and <em>reading</em> from <code>wrapper</code> in <code>T2</code>.</p>\n<p>We need to also introduce here <em>happen-before consistency</em>:</p>\n<blockquote>\n<p>a <em>read</em> sees the last <em>write</em> in happens-before order, or <em>any other</em> write.</p>\n</blockquote>\n<p>Since we do not have a full chain of happens-before here (that <code>??</code> does not establish one), we get that : &quot;...or any other read&quot;, which means we can read <em>different</em> values in those two reads of <code>num</code> (in that <code>num != num</code>).</p>\n<hr />\n<p>If you make <code>wrapper</code> instance <code>volatile</code>, <code>JLS</code> says that:</p>\n<blockquote>\n<p>A write to a volatile field (§8.3.1.4) happens-before every subsequent read of that field.</p>\n</blockquote>\n<p>As such, we have this now:</p>\n<pre><code> --------------- T1 -------------\n | write to num or this.num=num |\n --------------------------------\n                 |\n                \\|/  (HB)\n --------------- T1 -------------\n |    write Wrapper instance    |\n --------------------------------\n                 |\n                \\|/  (HB)\n --------------- T2 -------------\n |    read Wrapper instance     |\n --------------------------------\n                 |\n                \\|/  (HB)\n --------------- T2 -------------\n |      read num first time     |\n --------------------------------\n                 |\n                \\|/  (HB)\n --------------- T2 -------------\n |      read num second time    |\n --------------------------------\n</code></pre>\n<p>Now, happens-before consistency says : &quot;a <em>read</em> sees the last <em>write</em> in happens-before order...&quot;; the key part here is &quot;in happens-before order&quot;. This means that <em>both</em> reads of <code>num</code> will see the write of it (again: in happens before order).</p>\n","answer_id":71234632,"question_id":71212008,"last_edit_date":1646233694},{"owner":{"profile_image":"https://www.gravatar.com/avatar/a287ffec5b98c1e185187f04bbe8d424?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":10957698,"user_type":"registered","user_id":8051929,"link":"https://stackoverflow.com/users/8051929/echo-zeng","reputation":61,"display_name":"Echo Zeng"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1646226073,"creation_date":1646226073,"body":"<p>Like if you want a row in this table, and you do not want any cell would be changed during the period, so you can add one read-lock.</p>\n<p>Other guys can also read, it doesn't matter.</p>\n","answer_id":71323151,"question_id":33384822},{"owner":{"profile_image":"https://i.stack.imgur.com/t2hoD.jpg?s=256&g=1","account_id":3211603,"user_type":"registered","user_id":2711488,"link":"https://stackoverflow.com/users/2711488/holger","reputation":289317,"display_name":"Holger"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1646216677,"creation_date":1646216677,"body":"<p>You should not create a new <code>ScheduledThreadPoolExecutor</code> within the method. An executor is supposed to be reused. And you should call <code>shutdown()</code> on it once you really don’t need it anymore.</p>\n<p>But more important is that, since the scheduled action is performed by a different thread, <em>it must use <code>synchronized</code></em> when accessing the mutable state.</p>\n<p>This leads to the point you’re missing about <code>wait()</code>. The only way for the condition you’re waiting for to correctly become fulfilled, is by having another thread performing the necessary steps within a <code>synchronized</code> block and calling <code>notify()</code> or <code>notifyAll()</code>, both methods insisting on being called within that <code>synchronized</code> block.</p>\n<p>This can only work, when <code>wait()</code> releases the lock, so the other thread can acquire it and do the duty. And <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long,int)\" rel=\"nofollow noreferrer\">that’s precisely what <code>wait</code> does</a>:</p>\n<blockquote>\n<p>This method causes the current thread (referred to here as <em>T</em>) to place itself in the wait set for this object and then to relinquish any and all synchronization claims on this object. Note that only the locks on this object are relinquished; any other objects on which the current thread may be synchronized remain locked while the thread waits.</p>\n<p>Thread <em>T</em> then becomes disabled for thread scheduling purposes and lies dormant until one of the following occurs:</p>\n<p>…</p>\n<p>The thread <em>T</em> is then removed from the wait set for this object and re-enabled for thread scheduling. It competes in the usual manner with other threads for the right to synchronize on the object; once it has regained control of the object, all its synchronization claims on the object are restored to the status quo ante - that is, to the situation as of the time that the <code>wait</code> method was invoked. Thread <em>T</em> then returns from the invocation of the <code>wait</code> method. Thus, on return from the <code>wait</code> method, the synchronization state of the object and of thread <em>T</em> is exactly as it was when the <code>wait</code> method was invoked.</p>\n</blockquote>\n<p><sup>Note that <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait()\" rel=\"nofollow noreferrer\">the documentation of the no-arg <code>wait</code> method</a> redirects to the <code>wait(long,int)</code> documentation shown above</sup></p>\n<p>So the issue of your code is not that the initiating thread synchronizes but that the pool’s thread does not.</p>\n<pre class=\"lang-java prettyprint-override\"><code>static final ScheduledThreadPoolExecutor EXEC = new ScheduledThreadPoolExecutor(1);\n\npublic synchronized void joinClass(UUID student) throws InterruptedException {\n    this.students.add(student);\n\n    if(students.size() == 1) {\n        lecture = true;\n        EXEC.schedule(new Runnable() {\n            @Override\n            public void run() {\n                synchronized(OuterClassName.this) {\n                    students.clear();\n                    lecture = false;\n                    OuterClassName.this.notifyAll();\n                }\n            }\n        }, LECTURE_DURATION, TimeUnit.MILLISECONDS);\n    }\n    while(lecture) wait();\n}\n</code></pre>\n<p>As a side note, there is no reason to remove single elements in a loop to empty a list, <code>clear()</code> does the job. In case of an <code>ArrayList</code>, repeatedly calling <code>remove(0)</code> is the worst way to clear it.</p>\n<p>It’s also important to keep in mind that an inner class instance is a different object than the outer class instance. It’s simpler when using a lambda expression:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public synchronized void joinClass(UUID student) throws InterruptedException {\n    this.students.add(student);\n\n    if(students.size() == 1) {\n        lecture = true;\n        EXEC.schedule(() -&gt; {\n            synchronized(this) {\n                students.clear();\n                lecture = false;\n                notifyAll();\n            }\n        }, LECTURE_DURATION, TimeUnit.MILLISECONDS);\n    }\n\n    while(lecture) wait();\n}\n</code></pre>\n","answer_id":71321045,"question_id":71096361},{"owner":{"profile_image":"https://www.gravatar.com/avatar/2361856f85f6f797554dab9e867f868c?s=256&d=identicon&r=PG","account_id":24334457,"user_type":"unregistered","user_id":18272775,"link":"https://stackoverflow.com/users/18272775/user18272775","reputation":31,"display_name":"user18272775"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1645482567,"creation_date":1645482567,"body":"<p><a href=\"https://stackoverflow.com/a/71212240\">The answer above</a> is correct.</p>\n<p>Just keep in mind that  <code>effectively immutable + safe publication</code> behaves unintuitively in some cases.<br />\nFor instance:</p>\n<ol>\n<li><p>If</p>\n<ul>\n<li>at first <code>thread 1</code> safely publishes object <code>o</code> to <code>thread 2</code></li>\n<li>then <code>thread 2</code> unsafely publishes object <code>o</code> to <code>thread 3</code></li>\n</ul>\n<p>in the end <code>thread 3</code> can see object <code>o</code> in an inconsistent state<br />\nSee <a href=\"https://stackoverflow.com/questions/10254456/effectively-immutable-object/10254521#comment13189477_10254521\">[1]</a> and <a href=\"https://stackoverflow.com/q/66214096\">[2]</a></p>\n</li>\n<li><p>also <a href=\"https://shipilev.net/blog/2016/close-encounters-of-jmm-kind/#wishful-volatiles-are-finals\" rel=\"nofollow noreferrer\">this</a></p>\n</li>\n</ol>\n<p>Real immutable objects have no such problems.</p>\n","answer_id":71213773,"question_id":71212008},{"owner":{"profile_image":"https://i.stack.imgur.com/7H9TF.png?s=256&g=1","account_id":2994830,"user_type":"registered","user_id":2541560,"link":"https://stackoverflow.com/users/2541560/kayaman","reputation":1,"display_name":"Kayaman"},"content_license":"CC BY-SA 4.0","score":7,"is_accepted":true,"last_activity_date":1645473905,"creation_date":1645473019,"body":"<p>No, because <code>volatile</code> being used establishes a happens-before relationship. Without it various reorderings and other things are allowed, which make the inconsistent state possible, but with it the JVM must give you the expected outcome.</p>\n<p>In this case <code>volatile</code> is <strong>not</strong> used for the visibility effects (threads seeing up to date values), but the safe publishing provided by the happpens-before. This feature of <code>volatile</code> is often left out when its use is explained.</p>\n","answer_id":71212240,"question_id":71212008,"last_edit_date":1645473905},{"owner":{"profile_image":"https://i.stack.imgur.com/21IXR.jpg?s=256&g=1","account_id":1662506,"user_type":"registered","user_id":1530504,"link":"https://stackoverflow.com/users/1530504/asok-buzz","reputation":1874,"display_name":"asok Buzz","accept_rate":36},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1645074489,"creation_date":1645074489,"body":"<p>You should have <code>colors.xml</code> on values-night (create alongside values folder if it doesn't already exist) folder for dark theme colors.\neg.</p>\n<pre><code>&lt;resources&gt;\n    &lt;color name=&quot;status_bar&quot;&gt;#0e0e0e&lt;/color&gt;\n&lt;/resources&gt;\n</code></pre>\n<p>(<code>colors.xml</code> on regular values folder will be used for light theme)</p>\n<p>And on <code>styles.xml</code> which supplies your app theme you will have entry for background and statusbar which takes necessary values.\neg.</p>\n<pre><code>&lt;style name=&quot;Theme.&lt;AppName&gt;&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;\n        &lt;item name=&quot;colorPrimary&quot;&gt;@color/red700&lt;/item&gt;\n        &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/red900&lt;/item&gt;\n        &lt;item name=&quot;colorAccent&quot;&gt;@color/red700&lt;/item&gt;\n        &lt;item name=&quot;android:statusBarColor&quot;&gt;@color/status_bar&lt;/item&gt;\n        &lt;item name=&quot;android:background&quot;&gt;@color/status_bar&lt;/item&gt;\n    &lt;/style&gt;\n</code></pre>\n<p>This style is referenced on AndroidManifest.xml file</p>\n<pre><code>android:theme=&quot;@style/Theme.&lt;AppName&gt;&quot;&gt;\n</code></pre>\n","answer_id":71152787,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/53aa3f0985b383044bf3f33643ffde76?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":14584795,"user_type":"registered","user_id":10534012,"link":"https://stackoverflow.com/users/10534012/darkman","reputation":2961,"display_name":"Darkman"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1644908921,"creation_date":1644899177,"body":"<p>No idea if this going to solve your problem but it might give you an idea.</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class Main\n{\n    public static void main(String[] args) throws Exception\n    {\n        Classroom classroom = new Classroom();\n        Student studentA = new Student(&quot;Student A&quot;, classroom);\n        Student studentB = new Student(&quot;Student B&quot;, classroom);\n        Student studentC = new Student(&quot;Student C&quot;, classroom);\n        Student studentD = new Student(&quot;Student D&quot;, classroom);\n        \n        studentA.enterClass();\n        Thread.sleep(1000L); //1000 m/s early.\n        classroom.start();\n        Thread.sleep(1000L); //1 second late.\n        studentB.enterClass();\n        Thread.sleep(500L); //Late for 1.5 seconds.\n        studentC.enterClass();\n        classroom.join();\n        Thread.sleep(2000L); //Class has ended.\n        studentD.enterClass();\n        System.out.println(&quot;Main Thread&quot;);\n    }\n}\n\nclass Student implements Runnable\n{\n    public String name;\n    private Classroom classroom;\n    public Thread thread;\n    \n    Student(String name, Classroom classroom)\n    {\n        this.name = name;\n        this.classroom = classroom;\n        thread = new Thread(this);\n    }\n    public void enterClass()\n    {\n        thread.start();\n    }\n    public synchronized void exitClass()\n    {\n        this.notify();\n    }\n    @Override\n    public void run()\n    {\n        try {\n            System.out.println(name + &quot; entering the class.&quot;);\n            classroom.joinClass(this);\n            synchronized(this) {\n                while(!classroom.hasEnded) this.wait();\n            }\n            System.out.println(name + &quot; existing the class.&quot;);\n        } catch(Exception e) {}\n    }\n}\n\nclass Classroom implements Runnable\n{\n    private static final long LECTURE_DURATION = 3000L;\n    private Thread thread;\n    public volatile boolean hasEnded;\n    private List&lt;Student&gt; students;\n    \n    Classroom()\n    {\n        students = new ArrayList&lt;Student&gt;();\n        thread = new Thread(this);\n    }\n    public void start()\n    {\n        thread.start();\n    }\n    public void join() throws Exception\n    {\n        thread.join();\n    }\n    @Override\n    public void run()\n    {\n        System.out.println(&quot;Class starting...&quot;);\n        try {\n            Thread.sleep(LECTURE_DURATION);\n        } catch(Exception e) {}\n        hasEnded = true;\n        System.out.println(&quot;Class ended&quot;);\n        for(Student s : students) s.exitClass();\n    }\n    public void joinClass(Student student) throws Exception\n    {\n        if(!hasEnded) {\n            System.out.println(student.name + &quot; joins the class.&quot;);\n            students.add(student);\n        }\n    }\n}\n</code></pre>\n<p>Here is the output. It may vary in your system.</p>\n<pre><code>Student A entering the class.\nStudent A joins the class.\nClass starting...\nStudent B entering the class.\nStudent B joins the class.\nStudent C entering the class.\nStudent C joins the class.\nClass ended\nStudent B existing the class.\nStudent A existing the class.\nStudent C existing the class.\nMain Thread\nStudent D entering the class.\nStudent D existing the class.\n</code></pre>\n","answer_id":71121105,"question_id":71096361,"last_edit_date":1644908921},{"owner":{"profile_image":"https://i.stack.imgur.com/RDWxl.png?s=256&g=1","account_id":4342327,"user_type":"registered","user_id":3545273,"link":"https://stackoverflow.com/users/3545273/serge-ballesta","reputation":145474,"display_name":"Serge Ballesta","accept_rate":100},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1636974569,"creation_date":1636974348,"body":"<p>Let us look carefully to your test code:</p>\n<pre><code>    GameServer server = new GameServer();\n</code></pre>\n<p>Ok, this lines creates a server, and the test thread is ready to execute next line</p>\n<pre><code>    server.start(9000);\n</code></pre>\n<p>Ok, the test thread starts the server, and <strong>will be ready to execute the next line when the <code>start</code> method will return</strong>.</p>\n<p>What happens in <code>start</code>:</p>\n<pre><code>    System.out.println(&quot;Server started !!!&quot;);\n</code></pre>\n<p>Ok, you should see that message</p>\n<pre><code>    serverSocket = new ServerSocket(port);\n</code></pre>\n<p>Ok, you have created a <code>ServerSocket</code></p>\n<pre><code>    while (true) {\n        new Thread(new GameClientHandler(serverSocket.accept())).start();\n    }\n</code></pre>\n<p>ok you a waiting for a connection (at <code>serverSocket.accept()</code>), will create a new thread to handle it as soon as you will get one, and loop again.</p>\n<p>But as this point, the test thread is waiting and will never go to the following line to start the first connection. And it will remain stuck unless <em>something else</em> (maybe another thread) starts those damned connections.</p>\n","answer_id":69973382,"question_id":69973062,"last_edit_date":1636974569},{"owner":{"profile_image":"https://www.gravatar.com/avatar/0f3e2abdf89734028a734c821c4fab78?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8775035,"user_type":"registered","user_id":6560579,"link":"https://stackoverflow.com/users/6560579/ackdari","reputation":3254,"display_name":"Ackdari"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1636973254,"creation_date":1636973254,"body":"<p>The method <code>GameServer.start</code> will only return with an exception. That is because you have the while-loop.</p>\n<p>So your test execution will start the server and wait for someone to open a connection, but that never happens.</p>\n","answer_id":69973143,"question_id":69973062},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG","account_id":401843,"user_type":"registered","user_id":768644,"link":"https://stackoverflow.com/users/768644/rzwitserloot","reputation":89863,"display_name":"rzwitserloot"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1636927783,"creation_date":1636927783,"body":"<p>Sure it is. However, 'wake the thread' does not mean 'it will fly ahead and IMMEDIATELY start running this very instant in time, whilst your thread has to do the extremely slow move of.. looping a for loop'.</p>\n<p>It could (that's one of the problems of threads: Things are arbitrary, and arbitrary is bad, because it's untestable. There is no fix for this, other than not using threads that require synchronization, for example by doing all state communication via transactions and a database)... but it usually won't.</p>\n<p>Your dropBall runs to its natural end, then it releases the lock (as the dropBall method is synchronized). Only now can the other thread's takeBall move on from its wait (wait doesn't JUST wait for a notify - it also releases the lock and can't continue until it has both been notified AND it can re-acquire the lock, which initially it by definition cannot, because you can't notify without holding the lock).</p>\n<p>What actually happens is this:</p>\n<ul>\n<li>Player2's thread is watching out for the ball's lock being available; it currently is not.</li>\n<li>Player1's thread releases the lock, hops back to your for loop that loops 25 times, executes the takeBall method and re-acquires the lock.</li>\n<li>Sometime later Player2 looks up and goes: Oh, wait, WHAT? Oh nuts! I missed it!</li>\n</ul>\n<p>Locks are not guaranteed to be 'fair'. Because fair locks take time and the JVM is designed to fulfill all guarantees as fast as possible (and thus, doesn't give you unpromised freebies), JVM locks as a consequence are pretty much never fair except on <em>extremely</em> bizarro combinations of JVM impl, OS, and hardware.</p>\n<p>Shove a sleep in between the dropping and the re-taking and you'll likely see something you were expecting. Now the VM/OS/hardware either [A] actually lets player2's thread grab the lock and actually take the ball, or [B] twiddle its thumbs.</p>\n<p>Note that the <code>Thread.sleep</code> you'll be writing MUST NOT be in any place where you hold the lock. Given that the entirety of the takeBall method is synchronized, don't do it there; do it in your for loop. (And as a side note, catch an exception and do nothing? <em><strong>That is extremely bad, don't ever do that</strong></em><sup>1</sup> - I fixed that for you too):</p>\n<pre><code>try {\n  ball.takeBall();\n  sleep(1000);\n  ball.dropBall();\n  sleep(100);\n} catch (Exception e) {\n  throw new RuntimeException(&quot;Unhandled&quot;, e);\n}\n</code></pre>\n<p>[1] Unless you truly intend for code to silently ignore the error and carry on like nothing happened. There are times where that is the right move but extremely rare and not something a newbie should be meddling with. Far too easy to misunderstand something and then get utterly lost because crucial information (namely, that an error occured, where it occurred, why, and the details surrounding) got discarded.</p>\n","answer_id":69967575,"question_id":69967482},{"owner":{"profile_image":"https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG","account_id":47283,"user_type":"registered","user_id":139985,"link":"https://stackoverflow.com/users/139985/stephen-c","reputation":703927,"display_name":"Stephen C","accept_rate":69},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":true,"last_activity_date":1636864683,"creation_date":1636863799,"body":"<p>The <code>final</code> makes no difference here.  The code is not thread-safe, whether the <code>final</code> is there or not.</p>\n<p>There are two reasons that this is not thread-safe.</p>\n<ol>\n<li><p>You are publishing (and potentially mutating) the state of <code>Dummy</code> before its constructor has completed.  This is unsafe whether or not the variable is <code>final</code>.</p>\n</li>\n<li><p>You are returning a shared mutable object in the <code>getIntegers()</code> call.  So that means that the caller <em>could</em> change it, and a second caller may or may not see the results ... due to lack of synchronization.  Once again <code>final</code> makes no difference to this.</p>\n</li>\n</ol>\n<hr />\n<p>The thread-safety guarantees of <code>final</code> are limited.  Here's what the <a href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.5\" rel=\"nofollow noreferrer\">JLS</a> says:</p>\n<blockquote>\n<p><code>final</code> fields also allow programmers to implement thread-safe immutable objects without synchronization. A thread-safe immutable object is seen as immutable by all threads, even if a data race is used to pass references to the immutable object between threads. This can provide safety guarantees against misuse of an immutable class by incorrect or malicious code. <strong><code>final</code> fields must be used correctly to provide a guarantee of immutability.</strong></p>\n<p>An object is considered to be completely initialized when its constructor finishes. A thread that can only see a reference to an object after that object has been completely initialized is guaranteed to see the correctly initialized values for that object's <code>final</code> fields.</p>\n</blockquote>\n<p>The takeaways are that the <code>final</code> guarantees only apply to <strong>immutable</strong> objects, and they only apply <strong>after</strong> the return of the object's constructor.</p>\n<p>In your example does not satisfy either of these prerequisites.  Therefore, the guarantees do not apply.</p>\n","answer_id":69960265,"question_id":69960082,"last_edit_date":1636864683},{"owner":{"profile_image":"https://i.stack.imgur.com/ZWEI3.jpg?s=256&g=1","account_id":322981,"user_type":"registered","user_id":642706,"link":"https://stackoverflow.com/users/642706/basil-bourque","reputation":310755,"display_name":"Basil Bourque","accept_rate":58},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1636857098,"creation_date":1636831831,"body":"<p>To quote the <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/join.html\" rel=\"nofollow noreferrer\">Oracle tutorial</a>:</p>\n<blockquote>\n<p><code>t.join()</code> causes the current thread to pause execution until t's thread terminates</p>\n</blockquote>\n<p>So effectively you are not making any real use of threading. On every pass through your <code>for</code> loop, you launch a thread but then wait for it to complete. No point in doing that, you could forgo the threads and just sequentially do your tasks’ work within the current thread.</p>\n<hr />\n<p>In modern Java, we rarely need to address the <code>Thread</code> class directly. Instead we submit our <code>Runnable</code>/<code>Callable</code> task to an <code>ExecutorService</code>.</p>\n<p>To schedule repeated calculations every 5 seconds, use a <a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/ScheduledExecutorService.html\" rel=\"nofollow noreferrer\"><code>ScheduledExecutorService</code></a>.</p>\n<pre><code>ScheduledExecutorService ses = Executors. newSingleThreadScheduledExecutor() ;\n…\nses.scheduleAtFixedRate( myStatsCalcRunnable , 1 , 5 , TimeUnit.SECONDS ) ;\n</code></pre>\n<p>Caution: Be sure to eventually shut down your executor services. Otherwise their backing thread pools may continue running indefinitely, like a zombie 🧟‍♂️.</p>\n<p>Change this:</p>\n<pre><code>public class FestivalStatisticsThread extends Thread { … } \n</code></pre>\n<p>… with a <code>run</code> method into:</p>\n<pre><code>public class FestivalStatistics { … } \n</code></pre>\n<p>… with a <code>recalculate</code> method. Call that <code>recalculate</code> method from the <code>Runnable</code> task submitted to your scheduled executor service.</p>\n<p>Or perhaps that functionality should just be a part of the <code>Gate</code> class. (I’m not sure. I’d have to think more on that.)</p>\n<hr />\n<p>85,000 simultaneous threads may be too much of a burden on common hardware. Instead, start an executor service with a limited number of threads. Then submit your 85,000 tasks as <code>Runnable</code>/<code>Callable</code> objects. The executor service takes care of feeding those tasks to be executed on those limited number of threads.</p>\n<p>In the future, if <a href=\"https://wiki.openjdk.java.net/display/loom/Main\" rel=\"nofollow noreferrer\"><em>Project Loom</em></a> succeeds, you will be able to use 85,000 (or even millions) <em>virtual</em> threads (also known as “fibers”) at a time. To learn more, see the more recent talks by Ron Pressler or other members of the Loom team. Experimental builds based on early-access Java 18 are available now. The Loom team seeks feedback.</p>\n<hr />\n<p>All of these topics have been addressed already on Stack Overflow.  Search to learn more. I myself have written multiple Answers with code examples, as have others.</p>\n<hr />\n<p>By the way, I would make <code>FestivalGate</code> more encapsulated. The other classes should not have access to, or even know about, its internal use of a synchronized <code>List</code>. Add methods to collect and report on tickets.</p>\n<hr />\n<p>Here is some quick code I wrote as a demonstration of topics discussed above.</p>\n<p>Use at your own risk; I’ve not done any serious testing nor a thoughtful code review.</p>\n<p>Perhaps I have oversimplified your domain problem. You could of course expand or rearrange as needed. But hopefully this shows clearly how to use executor service.</p>\n<p>We have a basic <code>Ticket</code> class to represent each ticket. We use a <a href=\"https://openjdk.java.net/jeps/395\" rel=\"nofollow noreferrer\">record</a> here to define that class. We nest the enum of ticket types.</p>\n<pre class=\"lang-java prettyprint-override\"><code>package work.basil.festival;\n\nimport java.util.UUID;\n\npublic record Ticket( UUID id , Type type )\n{\n    enum Type\n    { FULL_VIP, FREE_PASS, ONE_DAY, ONE_DAY_VIP }\n}\n</code></pre>\n<p>We have a <code>Gate</code> class to hold our domain logic. We nest a <code>Statistics</code> class to hold our reported summary of tickets taken so far.</p>\n<pre class=\"lang-java prettyprint-override\"><code>package work.basil.festival;\n\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.*;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.stream.Collectors;\n\npublic class Gate\n{\n    final private Set &lt; Ticket &gt; ticketsTaken;\n\n    public Gate ( )\n    {\n        this.ticketsTaken = new HashSet &lt;&gt;();\n    }\n\n    synchronized public boolean takeTicket ( final Ticket ticket )\n    {\n        // Simulate hard work by sleeping some random amount of time.\n        int millis = ThreadLocalRandom.current().nextInt( 2 );\n        try { Thread.sleep( millis ); }catch ( InterruptedException e ) { e.printStackTrace(); }\n        return this.ticketsTaken.add( ticket );\n    }\n\n    synchronized public List &lt; Ticket &gt; ticketsTaken ( )\n    {\n        return List.copyOf( this.ticketsTaken );  // Returns unmodifiable list of the `Ticket` objects contained in our private member set.\n    }\n\n    record Statistics( Instant when , int countTicketsTaken , Map &lt; Ticket.Type, Integer &gt; countOfTicketsTakenByType )\n    {\n    }\n\n    synchronized public Statistics statistics ( )\n    {\n        int count = this.countTicketsTaken();\n        Map &lt; Ticket.Type, Integer &gt; map = this.reportCountOfTicketsTakenByType();\n        if ( count != map.values().stream().mapToInt( Integer :: intValue ).sum() ) { throw new IllegalStateException( &quot;Counts do not match in Gate.Statistics. Error # 898e905f-9432-4195-a3e0-118bede2872d.&quot; ); }\n        return new Statistics( Instant.now() , count , map );\n    }\n\n    private int countTicketsTaken ( )\n    {\n        return this.ticketsTaken.size();\n    }\n\n    private Map &lt; Ticket.Type, Integer &gt; reportCountOfTicketsTakenByType ( )\n    {\n        // We use `AtomicInteger` here not for thread-safety, but for the convenience of its `incrementAndGet` method.\n        Map &lt; Ticket.Type, AtomicInteger &gt; map = new EnumMap &lt; Ticket.Type, AtomicInteger &gt;( Ticket.Type.class );\n        Arrays.stream( Ticket.Type.values() ).forEach( type -&gt; map.put( type , new AtomicInteger( 0 ) ) ); // Initialize the map, so each ticket-type has an atomic integer set to zero.\n        this.ticketsTaken.stream().forEach( ticket -&gt; map.get( ticket.type() ).incrementAndGet() );\n\n        // Convert the AtomicInteger values to simply `Integer` values.\n        Map &lt; Ticket.Type, Integer &gt; result = map.entrySet().stream().collect( Collectors.toMap( Map.Entry :: getKey , atomicInteger -&gt; atomicInteger.getValue().intValue() ) );\n        return Map.copyOf( result ); // Return an unmodifiable map, as a good practice.\n    }\n}\n</code></pre>\n<p>And we have an <code>App</code> class to drive a demonstration.</p>\n<pre class=\"lang-java prettyprint-override\"><code>package work.basil.festival;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\nimport java.util.concurrent.*;\nimport java.util.stream.IntStream;\n\n/**\n * Hello world!\n */\npublic class App\n{\n    public static void main ( String[] args )\n    {\n        System.out.println( &quot;Hello World!&quot; );\n\n        App app = new App();\n        app.demo();\n    }\n\n    private void demo ( )\n    {\n        final List &lt; Ticket &gt; ticketsToTake = this.generateTicketsForFestival();\n\n        Gate gate = new Gate();\n\n        // Report every five seconds on the progress of our gate taking tickets.\n        ScheduledExecutorService reportingExecutorService = Executors.newSingleThreadScheduledExecutor();\n        reportingExecutorService.scheduleAtFixedRate( ( ) -&gt; System.out.println( gate.statistics() ) , 0 , 5 , TimeUnit.SECONDS );\n\n        ExecutorService ticketTakingExecutorService = Executors.newFixedThreadPool( 7 );\n        for ( Ticket ticket : ticketsToTake )\n        {\n            ticketTakingExecutorService.submit( ( ) -&gt; gate.takeTicket( ticket ) );\n        }\n        ticketTakingExecutorService.shutdown();\n        try { ticketTakingExecutorService.awaitTermination( 10 , TimeUnit.MINUTES ); } catch ( InterruptedException e ) { e.printStackTrace(); }\n        reportingExecutorService.shutdown();\n        try { reportingExecutorService.awaitTermination( 10 , TimeUnit.MINUTES ); } catch ( InterruptedException e ) { e.printStackTrace(); }\n\n        System.out.println( &quot;« FIN » &quot; + gate.statistics() );\n    }\n\n    private List &lt; Ticket &gt; generateTicketsForFestival ( )\n    {\n        List &lt; Ticket &gt; tickets = new ArrayList &lt;&gt;();\n        for ( int i = 0 ; i &lt; 85_000 ; i++ )\n        {\n            tickets.add(\n                    new Ticket(\n                            UUID.randomUUID() ,  // Randomly generate a UUID, to identify uniquely each ticket.\n                            Ticket.Type.values()[ ThreadLocalRandom.current().nextInt( Ticket.Type.values().length ) ]  // Randomly pick one of the ticket types.\n                    )\n            );\n        }\n        return List.copyOf( tickets );\n    }\n}\n</code></pre>\n<p>When run on an 8-core M1 MacBook Pro.</p>\n<pre class=\"lang-none prettyprint-override\"><code>Hello World!\nStatistics[when=2021-11-14T02:28:52.746596Z, countTicketsTaken=0, countOfTicketsTakenByType={FREE_PASS=0, ONE_DAY=0, ONE_DAY_VIP=0, FULL_VIP=0}]\nStatistics[when=2021-11-14T02:28:57.800514Z, countTicketsTaken=7517, countOfTicketsTakenByType={FREE_PASS=1862, ONE_DAY=1953, ONE_DAY_VIP=1889, FULL_VIP=1813}]\nStatistics[when=2021-11-14T02:29:02.804886Z, countTicketsTaken=15128, countOfTicketsTakenByType={FREE_PASS=3791, ONE_DAY=3788, ONE_DAY_VIP=3775, FULL_VIP=3774}]\nStatistics[when=2021-11-14T02:29:07.746712Z, countTicketsTaken=22819, countOfTicketsTakenByType={FREE_PASS=5764, ONE_DAY=5653, ONE_DAY_VIP=5703, FULL_VIP=5699}]\nStatistics[when=2021-11-14T02:29:12.769943Z, countTicketsTaken=30577, countOfTicketsTakenByType={FREE_PASS=7687, ONE_DAY=7631, ONE_DAY_VIP=7641, FULL_VIP=7618}]\nStatistics[when=2021-11-14T02:29:17.803627Z, countTicketsTaken=38146, countOfTicketsTakenByType={FREE_PASS=9553, ONE_DAY=9552, ONE_DAY_VIP=9554, FULL_VIP=9487}]\nStatistics[when=2021-11-14T02:29:22.785355Z, countTicketsTaken=45896, countOfTicketsTakenByType={FREE_PASS=11455, ONE_DAY=11497, ONE_DAY_VIP=11499, FULL_VIP=11445}]\nStatistics[when=2021-11-14T02:29:27.768809Z, countTicketsTaken=53563, countOfTicketsTakenByType={FREE_PASS=13448, ONE_DAY=13393, ONE_DAY_VIP=13386, FULL_VIP=13336}]\nStatistics[when=2021-11-14T02:29:32.739398Z, countTicketsTaken=61189, countOfTicketsTakenByType={FREE_PASS=15358, ONE_DAY=15291, ONE_DAY_VIP=15310, FULL_VIP=15230}]\nStatistics[when=2021-11-14T02:29:37.751764Z, countTicketsTaken=68758, countOfTicketsTakenByType={FREE_PASS=17214, ONE_DAY=17136, ONE_DAY_VIP=17226, FULL_VIP=17182}]\nStatistics[when=2021-11-14T02:29:42.759303Z, countTicketsTaken=76446, countOfTicketsTakenByType={FREE_PASS=19136, ONE_DAY=19057, ONE_DAY_VIP=19171, FULL_VIP=19082}]\nStatistics[when=2021-11-14T02:29:47.768858Z, countTicketsTaken=84030, countOfTicketsTakenByType={FREE_PASS=21086, ONE_DAY=20930, ONE_DAY_VIP=21062, FULL_VIP=20952}]\n« FIN » Statistics[when=2021-11-14T02:29:48.406351Z, countTicketsTaken=85000, countOfTicketsTakenByType={FREE_PASS=21321, ONE_DAY=21174, ONE_DAY_VIP=21305, FULL_VIP=21200}]\n</code></pre>\n","answer_id":69957568,"question_id":69954623,"last_edit_date":1636857098},{"owner":{"profile_image":"https://i.stack.imgur.com/5ovO7.png?s=256&g=1","account_id":9713597,"user_type":"registered","user_id":7204683,"link":"https://stackoverflow.com/users/7204683/umair","reputation":615,"display_name":"Umair","accept_rate":38},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1636835220,"creation_date":1636835220,"body":"<p>It is possible to use synchronized blocks inside a Java Lambda Expression and inside anonymous classes.</p>\n<p>Note: You have forgotten to add code snippet as no code snippet is visible in your code , So I ma adding my own code snippet to make clear my point.</p>\n<pre><code>    import java.util.function.Consumer;\n\npublic class SynchronizedExample {\n\n  public static void main(String[] args) {\n\n    Consumer&lt;String&gt; func = (String param) -&gt; {\n\n      synchronized(SynchronizedExample.class) {\n\n        System.out.println(\n            Thread.currentThread().getName() +\n                    &quot; step 1: &quot; + param);\n\n        try {\n          Thread.sleep( (long) (Math.random() * 1000));\n        } catch (InterruptedException e) {\n          e.printStackTrace();\n        }\n\n        System.out.println(\n            Thread.currentThread().getName() +\n                    &quot; step 2: &quot; + param);\n      }\n\n    };\n\n\n    Thread thread1 = new Thread(() -&gt; {\n        func.accept(&quot;Parameter&quot;);\n    }, &quot;Thread 1&quot;);\n\n    Thread thread2 = new Thread(() -&gt; {\n        func.accept(&quot;Parameter&quot;);\n    }, &quot;Thread 2&quot;);\n\n    thread1.start();\n    thread2.start();\n  }\n}\n</code></pre>\n","answer_id":69957970,"question_id":69957844},{"owner":{"profile_image":"https://i.stack.imgur.com/VlLm5.jpg?s=256&g=1","account_id":11179150,"user_type":"registered","user_id":8203686,"link":"https://stackoverflow.com/users/8203686/wangsir","reputation":374,"display_name":"wangsir"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1636815741,"creation_date":1636815741,"body":"<p>I had the same problem when using HSDB on openjdk-8. Installing lib <code>sudo apt-get install openjdk-8-dbg</code> works.</p>\n","answer_id":69955469,"question_id":49516601},{"owner":{"profile_image":"https://www.gravatar.com/avatar/1f698e72460b5a8c716a0c1cea91b81e?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":13429972,"user_type":"registered","user_id":9690075,"link":"https://stackoverflow.com/users/9690075/zysaaa","reputation":1807,"display_name":"zysaaa"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1636813384,"creation_date":1636813384,"body":"<p><code>ExecutorService</code> in Java, for example, is a producer-consumer model with a series of worker threads trying to fetch tasks from a work queue. I might close the thread pool by <code>ExecutorService#shutdownNow</code>, this method will set the thread pool state to <code>STOP</code> and interrupt each worker. Take a look at <code>shutdownNow</code> method and worker's run method(I removed the irrelevant code):</p>\n<pre><code>  public List&lt;Runnable&gt; shutdownNow() {\n            advanceRunState(STOP);\n            interruptWorkers();\n  }\n</code></pre>\n<pre><code>final void runWorker(Worker w) {\n        try {\n            while (task != null || (task = getTask()) != null) {\n                // ...\n            }\n        } \n    }\n</code></pre>\n<pre><code> private Runnable getTask() {\n        boolean timedOut = false; // Did the last poll() time out?\n        for (;;) {\n            // ...\n            // Check if queue empty only if necessary.\n            if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {\n                decrementWorkerCount();\n                return null;\n            }\n            try {\n                Runnable r = timed ?\n                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                    workQueue.take();\n                if (r != null)\n                    return r;\n                timedOut = true;\n            } \n        }\n    }\n</code></pre>\n<p>I think this is an example of using Flag &amp; interrupt to stop consumers. I don't think it's inelegant.</p>\n","answer_id":69955150,"question_id":69950945},{"owner":{"profile_image":"https://i.stack.imgur.com/9G6ke.png?s=256&g=1","account_id":439045,"user_type":"registered","user_id":827704,"link":"https://stackoverflow.com/users/827704/artyom-chernetsov","reputation":1394,"display_name":"Artyom Chernetsov","accept_rate":71},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1636774485,"creation_date":1636774485,"body":"<p>My approach would be to use framework with back-pressure mechanism support, for example <a href=\"https://vertx.io/docs/vertx-reactive-streams/java/\" rel=\"nofollow noreferrer\">vert.x reactive streams</a>.</p>\n<p>Good examples of systems handling back-pressure built on vert.x can be found in the book <a href=\"https://vertx.io/docs/vertx-reactive-streams/java/\" rel=\"nofollow noreferrer\">vert.x in action</a></p>\n","answer_id":69951248,"question_id":69950945},{"owner":{"profile_image":"https://i.stack.imgur.com/Poqe8.png?s=256&g=1","account_id":10898797,"user_type":"registered","user_id":8011734,"link":"https://stackoverflow.com/users/8011734/marwa-eltayeb","reputation":1961,"display_name":"Marwa Eltayeb"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1634784057,"creation_date":1634784057,"body":"<p>According to <strong>Google's recommendation</strong> <a href=\"https://developer.android.com/topic/performance/vitals/launch-time\" rel=\"nofollow noreferrer\">Here</a>, you <em>should not</em> prevent this white screen from launching. You can use this theme attribute to turn off the initial blank screen that the system process draws when launching the app.</p>\n<pre><code>&lt;item name=&quot;android:windowDisablePreview&quot;&gt;true&lt;/item&gt;\n</code></pre>\n<p>However, <strong>This approach is not recommended</strong> because it can result in a longer startup time than apps that don’t suppress the preview window. Also, it forces the user to wait with no feedback while the activity launches, making them wonder if the app is functioning properly.</p>\n<p>They recommend to use the activity's windowBackground theme attribute to provide a simple custom drawable for the starting activity instead of disabling the preview window.</p>\n<p>Therefore, here is the recommended solution:</p>\n<p>First, create a new drawable file for example startup_screen.xml</p>\n<pre><code> &lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:opacity=&quot;opaque&quot;&gt;\n    &lt;!-- The background color, preferably the same as normal theme --&gt;\n    &lt;item android:drawable=&quot;@android:color/white&quot;/&gt;\n    &lt;!-- Product logo - 144dp color version of App icon --&gt;\n    &lt;item&gt;\n        &lt;bitmap\n            android:src=&quot;@drawable/logo&quot;\n            android:gravity=&quot;center&quot;/&gt;\n    &lt;/item&gt;\n &lt;/layer-list&gt;\n</code></pre>\n<p>Second, reference it from your style file. If you use Night mode. Add it in both themes.xml files.</p>\n<pre><code>&lt;!-- Start Up Screen --&gt;\n&lt;style name=&quot;AppThemeLauncher&quot; parent=&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;&gt;\n     &lt;item name=&quot;android:statusBarColor&quot; tools:targetApi=&quot;l&quot;&gt;@color/lightGray&lt;/item&gt;\n     &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/startup_screen&lt;/item&gt;\n&lt;/style&gt;\n</code></pre>\n<p>If you notice, I added statusBarColor attribute to change the color of status Bar according to my custom design.</p>\n<p>Then, Add <em>AppThemeLauncher</em> Theme in your current activity.</p>\n<pre><code>&lt;activity\n    android:name=&quot;.MainActivity&quot;\n    android:theme=&quot;@style/AppThemeLauncher&quot;/&gt;\n</code></pre>\n<p>If you want to transition back to your normal theme, call setTheme(R.style.AppTheme) before calling super.onCreate() and setContentView():</p>\n<pre><code>class MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        // Make sure this is before calling super.onCreate\n        setTheme(R.style.AppTheme)\n        super.onCreate(savedInstanceState)\n        // ...\n    }\n}\n</code></pre>\n","answer_id":69655199,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/3c5fa52b5efec6532a8f33a920789d6d?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6089387,"user_type":"registered","user_id":4752240,"link":"https://stackoverflow.com/users/4752240/tuda224","reputation":1,"display_name":"tuda224"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1629096564,"creation_date":1629096564,"body":"<p>In my opinion you aren't testing a multithread scenario.</p>\n<p>You have one thread that is accessing everything one after each other. From the question I assume that this is not your intention.</p>\n<p>What I also like is using a locker object of type ReentrantLock(). Then you have a single instance of the object and lock it before the synchronized code block and you can unlock it when the work is done.</p>\n<p>Like in the following example (taken and adapted from <a href=\"https://winterbe.com/posts/2015/04/30/java8-concurrency-tutorial-synchronized-locks-examples/\" rel=\"nofollow noreferrer\">https://winterbe.com/posts/2015/04/30/java8-concurrency-tutorial-synchronized-locks-examples/</a>):</p>\n<pre><code>ReentrantLock lock = new ReentrantLock();\n\nvoid transaction(Long accountIdOne, Long accountIdTwo, int value) {\n    Account accountOne = accountRepository.findById(accountIdOne).orElseThrow();\n    Account accountTwo = accountRepository.findById(accountIdTwo).orElseThrow();\n\n    lock.lock();\n    try {\n        accountOne.withdrawal(value);\n        this.update(accountOne);\n        accountTwo.send(value);\n        this.update(accountTwo);\n    } finally {\n        lock.unlock();\n    }\n}\n</code></pre>\n","answer_id":68798496,"question_id":68791080},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG","account_id":401843,"user_type":"registered","user_id":768644,"link":"https://stackoverflow.com/users/768644/rzwitserloot","reputation":89863,"display_name":"rzwitserloot"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":true,"last_activity_date":1629077177,"creation_date":1629077177,"body":"<p>Make threads. A thousand if you want.</p>\n<p>At the CPU core level, here's what's happening:</p>\n<ul>\n<li>The CPU core is chugging along, doing work for a given websocket.</li>\n<li>Pretty soon the core runs into a road block: Half of an incoming bunch of data has arrived, the rest is still making its way down the network cable, and thus the CPU can't continue until it arrives. Alternatively, the code that the CPU core is running is sending data out, but the network card's buffer is full, so now the CPU core has to wait for that network card to find its way to sending another packet down the cable before there's room.</li>\n<li>Of course, if there's work to do (say, you have 10 cores in the box, and 15 web users are simultaneously connected, that leaves at least 5 users of your web site waiting around right now) - then the CPU should <strong>not</strong> just start twiddling its thumbs. It should go do <em>something</em>.</li>\n<li>In practice, then, there's a whole boatload of memory that WAS relevant that no longer is (all that memory that contained all that state and other 'working items' that was neccessary to do the work for the websocket that we were working on, but which is currently 'blocked' by the network), and a whole bunch of memory that wasn't relevant that now becomes relevant (All the state and working memory of a websocket connection that was earlier put in the 'have yourself a bit of a timeout and wait around for the network packet to arrive' - for which the network packet has since arrived, so if a CPU core is free to do work, it can now go do work).</li>\n<li>This is called a 'context switch', and it is <strong>ridiculously expensive</strong>, 500+ cycles worth. It is also <strong>completely unavoidable</strong>. You have to make the context switch. You can't avoid it. That means a cost is paid, and about 500 cycles worth just go down the toilet. It's what it is.</li>\n</ul>\n<p>The thing is, there are 2 ways to pay that cost: You can switch to another thread, which is all sorts of context switching. Or, you have a single thread running so-called 'async' code that manages all this stuff itself and hops to another job to do, but then there's still a context switch.</p>\n<p>Specifically, CPUs can't interact with memory at all anymore these days and haven't for the past decade. They can only interact with a CPU cache page. machine code is actually not really 'run directly' anymore, instead there's a level below that where a CPU notices it's about to run an instruction that touches some memory and will then map that memory command (after all, CPUs can no longer interact with it at all, memory is <em>far</em> too slow to wait for it) to the right spot in the cache. It'll also notice if the memory you're trying to access with your machinecode isn't in a cache page associated with that core at all, in which case it'll fire a page miss interrupt which causes the memory subsystem of your CPU/memory bus to 'evict a page' (write all back out to main memory) and then load in the right page, and only then does the CPU continue.</p>\n<p>This all happens 'under the hood', you don't have to write code to switch pages, the CPU manages it automatically. But it's a heavy cost. Not quite as heavy as a thread switch but almost as heavy.</p>\n<p><strong>CONCLUSION: Threads are good, have many of them. It ensures CPUs won't twiddle their thumbs when there is work to do. Note that there are MANY blog posts that extoll the virtues of async, claiming that threads 'do not scale'. They are wrong. Threads scale fine, and async code also pays the cost of context switching, all the time.</strong></p>\n<p>In case you weren't aware, 'async code' is code that tries to never sleep (never do something that would ever wait. So, instead of writing 'getMeTheNextBlockOfBytesFromTheNetworkCard', you'd write: &quot;onceBytesAreAvailableRunThis(code goes here)`). Writing async code in java is possible but incredibly difficult compared to using threads.</p>\n<p>Even in the extremely rare cases where async code would be a significant win, Project Loom is close to completion which will grant java the ability to have thread-like things that you can manually manage (so-called fibers). That is the route the OpenJDK has chosen for this. In that sense, even if you think async is the answer, no it's not. Wait for Project Loom to complete, instead. If you want to read more, read <a href=\"https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/\" rel=\"nofollow noreferrer\">What color is your function?</a>, and <a href=\"http://callbackhell.com\" rel=\"nofollow noreferrer\">callback hell</a>. Neither post is java-specific but covers some of the more serious problems inherent in async.</p>\n","answer_id":68796545,"question_id":68796254},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e442a53d36f9351aee11b5ecb8369691?s=256&d=identicon&r=PG","account_id":6520,"user_type":"registered","user_id":11002,"link":"https://stackoverflow.com/users/11002/tgdavies","reputation":10523,"display_name":"tgdavies","accept_rate":75},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1629062177,"creation_date":1629062177,"body":"<p>If we run the following code:</p>\n<pre><code>Account accountOneA = accountRepository.findById(1L).orElseThrow();\nAccount accountOneB = accountRepository.findById(1L).orElseThrow();\n</code></pre>\n<p>We expect that <code>accountOneA.equals(accountOneB)</code> will be true, assuming that <code>Account</code> has a sensible <code>equals()</code> implementation.</p>\n<p>We <em>don't</em> expect that <code>accountOneA == accountOneB</code> will be true, because <code>AccountRepository</code> will be creating a new object for the result of each query. We want this behaviour for thread safety, as two transactions might modify the data in different ways, to be reconciled when they try to save it.</p>\n<p>The <code>synchronized</code> keyword locks a <em>particular Object</em>, so for it to work, each thread must be synchronising using the same instance.</p>\n<p>That's why your synchronisation doesn't work.</p>\n<p>If <code>findById</code> <em>did</em> return the same instance for the same id, your code would be prone to deadlock. Imagine that one thread is transferring from account 1 to account 2, while another thread is doing the reverse, transferring from 2 to 1:</p>\n<ol>\n<li>Thread one locks account 1</li>\n<li>Thread two locks account 2</li>\n<li>Thread one tries to lock account 2, can't and waits</li>\n<li>Thread two tries to lock account1, can't and waits</li>\n</ol>\n<p>Now both threads are waiting forever.</p>\n<p>You could avoid this problem by sorting all the account numbers which are going to be locked in a given transaction, and always locking them in that order.</p>\n","answer_id":68795395,"question_id":68791080},{"owner":{"profile_image":"https://www.gravatar.com/avatar/124cda7f0e8d259e69d49ed43868639e?s=256&d=identicon&r=PG","account_id":99786,"user_type":"registered","user_id":269361,"link":"https://stackoverflow.com/users/269361/fool4jesus","reputation":2155,"display_name":"fool4jesus","accept_rate":79},"content_license":"CC BY-SA 4.0","score":4,"is_accepted":true,"last_activity_date":1629045421,"creation_date":1629045421,"body":"<p>I don't think this would compile as is. For one thing, System.out.println does not throw InterruptedException. I think you have a mistaken idea that calling threadB.interrupt() will cause threadB to throw an InterruptedException. But it won't: it will only set the interrupt flag. Remember, InterruptedException is a checked exception: it just doesn't appear out of nowhere, something has to throw it.</p>\n<p>So, leaving that aside, how close is your example to what really happens?</p>\n<p>If you need to, in general, know &quot;who set my interrupted flag&quot; I don't think there's any straightforward way to know that. If you really, really needed to know that, you could use something like Aspect4J and weave in advice on the <code>interrupt()</code> method that saves that information.</p>\n<p>But if you have more control over your code (as in the example above), the answer is to use object encapsulation and have B not directly interrupt A, but rather call a method that does. Really, I think this is better practice anyway, since it lets your own code do what it needs to do on the interrupted case. This isn't tested, but it's the idea:</p>\n<pre><code>static class MyThread extends Thread {\n  String interrupter;\n\n  public void interrupt(String interrupter) {\n    this.interrupter = interrupter;\n    super.interrupt();\n  }\n\n  public void run() {\n    while (!this.isInterrupted()) {\n      // Do the thing\n    }\n    // Here you can see who interrupted you and do whatever\n  }\n}\n</code></pre>\n","answer_id":68793486,"question_id":68784557},{"owner":{"profile_image":"https://i.stack.imgur.com/jgnbc.jpg?s=256&g=1","account_id":2174289,"user_type":"registered","user_id":1925388,"link":"https://stackoverflow.com/users/1925388/anmol-singh-jaggi","reputation":8434,"display_name":"Anmol Singh Jaggi","accept_rate":81},"content_license":"CC BY-SA 4.0","score":8,"is_accepted":false,"last_activity_date":1629042563,"creation_date":1620486781,"body":"<p>The <a href=\"https://stackoverflow.com/a/63365785/1925388\">other answer</a> works fine but is too complicated.</p>\n<p>A simpler way is to just execute <a href=\"https://en.wikipedia.org/wiki/Topological_sorting#Kahn%27s_algorithm\" rel=\"noreferrer\">Kahn's algorithm</a> but in parallel.</p>\n<p>The key is to execute all the tasks in parallel for whom all dependencies have been executed.</p>\n<pre><code>import java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n\nclass DependencyManager {\nprivate final ConcurrentHashMap&lt;String, List&lt;String&gt;&gt; _dependencies = new ConcurrentHashMap&lt;&gt;();\nprivate final ConcurrentHashMap&lt;String, List&lt;String&gt;&gt; _reverseDependencies = new ConcurrentHashMap&lt;&gt;();\nprivate final ConcurrentHashMap&lt;String, Runnable&gt; _tasks = new ConcurrentHashMap&lt;&gt;();\nprivate final ConcurrentHashMap&lt;String, Integer&gt; _numDependenciesExecuted = new ConcurrentHashMap&lt;&gt;();\nprivate final  AtomicInteger _numTasksExecuted = new AtomicInteger(0);\nprivate final ExecutorService _executorService = Executors.newFixedThreadPool(16);\n\nprivate static Runnable getRunnable(DependencyManager dependencyManager, String taskId){\n    return () -&gt; {\n    try {\n        Thread.sleep(2000);  // A task takes 2 seconds to finish.\n        dependencyManager.taskCompleted(taskId);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    };\n}\n\n/**\n* In case a vertex is disconnected from the rest of the graph.\n* @param taskId The task id\n*/\npublic void addVertex(String taskId) {\n    _dependencies.putIfAbsent(taskId, new ArrayList&lt;&gt;());\n    _reverseDependencies.putIfAbsent(taskId, new ArrayList&lt;&gt;());\n    _tasks.putIfAbsent(taskId, getRunnable(this, taskId));\n    _numDependenciesExecuted.putIfAbsent(taskId, 0);\n}\n\nprivate void addEdge(String dependentTaskId, String dependeeTaskId) {\n    _dependencies.get(dependentTaskId).add(dependeeTaskId);\n    _reverseDependencies.get(dependeeTaskId).add(dependentTaskId);\n}\n\npublic void addDependency(String dependentTaskId, String dependeeTaskId) {\n    addVertex(dependentTaskId);\n    addVertex(dependeeTaskId);\n    addEdge(dependentTaskId, dependeeTaskId);\n}\n\nprivate void taskCompleted(String taskId) {\n    System.out.println(String.format(&quot;%s:: Task %s done!!&quot;, Instant.now(), taskId));\n    _numTasksExecuted.incrementAndGet();\n    _reverseDependencies.get(taskId).forEach(nextTaskId -&gt; {\n        _numDependenciesExecuted.computeIfPresent(nextTaskId, (__, currValue) -&gt; currValue + 1);\n        int numDependencies = _dependencies.get(nextTaskId).size();\n        int numDependenciesExecuted = _numDependenciesExecuted.get(nextTaskId);\n        if (numDependenciesExecuted == numDependencies) {\n        // All dependencies have been executed, so we can submit this task to the threadpool. \n            _executorService.submit(_tasks.get(nextTaskId));\n        }\n        });\n    if (_numTasksExecuted.get() == _tasks.size()) {\n        topoSortCompleted();\n    }\n}\n\nprivate void topoSortCompleted() {\n    System.out.println(&quot;Topo sort complete!!&quot;);\n    _executorService.shutdownNow();\n}\n\npublic void executeTopoSort() {\n    System.out.println(String.format(&quot;%s:: Topo sort started!!&quot;, Instant.now()));\n    _dependencies.forEach((taskId, dependencies) -&gt; {\n    if (dependencies.isEmpty()) {\n        _executorService.submit(_tasks.get(taskId));\n    }\n    });\n}\n}\n\npublic class TestParallelTopoSort {\n\npublic static void main(String[] args) {\n    DependencyManager dependencyManager = new DependencyManager();\n    dependencyManager.addDependency(&quot;8&quot;, &quot;5&quot;);\n    dependencyManager.addDependency(&quot;7&quot;, &quot;5&quot;);\n    dependencyManager.addDependency(&quot;7&quot;, &quot;6&quot;);\n    dependencyManager.addDependency(&quot;6&quot;, &quot;3&quot;);\n    dependencyManager.addDependency(&quot;6&quot;, &quot;4&quot;);\n    dependencyManager.addDependency(&quot;5&quot;, &quot;1&quot;);\n    dependencyManager.addDependency(&quot;5&quot;, &quot;2&quot;);\n    dependencyManager.addDependency(&quot;5&quot;, &quot;3&quot;);\n    dependencyManager.addDependency(&quot;4&quot;, &quot;1&quot;);\n    dependencyManager.executeTopoSort();\n    // Parallel version takes 8 seconds to execute.\n    // Serial version would have taken 16 seconds.\n\n}\n}\n</code></pre>\n<p>The Directed Acyclic Graph constructed in this example is this:</p>\n<p><a href=\"https://i.stack.imgur.com/ZBDTT.jpg\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/ZBDTT.jpg\" alt=\"Directed Acyclic Graph\" /></a></p>\n","answer_id":67449067,"question_id":63354899,"last_edit_date":1629042563},{"owner":{"profile_image":"https://i.stack.imgur.com/Klcqr.gif?s=256&g=1","account_id":292208,"user_type":"registered","user_id":2245707,"link":"https://stackoverflow.com/users/2245707/pveentjer","reputation":10665,"display_name":"pveentjer","accept_rate":17},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1629015407,"creation_date":1629014278,"body":"<p>The problem is that within a single JVM you have very little control on how much memory a single thread is going to use; unless you make use of offheap (e.g. using Unsafe or direct memory as AnatolyG already mentioned). If you have huge array allocations, you could also control these. But we need to know more about the data-structures that consume the most memory.</p>\n<p>But if you have orbitrary object graphs you don't have much control over, perhaps it smarter to model the problem using multiple processes. You have 1 intake controller process and then a bunch of worker processes. And on each process you can configure the maximum amount of heap a JVM is allowed to use.</p>\n<p>Bumping into memory limits on OS level can be a huge PITA because it could lead to swapping and this will makes all the threads in a system slow. Or even worse, OOM-killer. Make sure you set the vm.swappiness to a very low value to prevent premature swapping.</p>\n<p>Do you know up front how much memory a process is going to consume? If so, then you could keep track of the maximum amount of memory being consumed in the system and don't allow for new tasks in the system before tasks have completed.</p>\n<p>If you don't know up front the memory limits, then you could assume each tasks will use the maximum, but this can lead to under-utilization of memory.</p>\n","answer_id":68789701,"question_id":68746177,"last_edit_date":1629015407},{"owner":{"profile_image":"https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG","account_id":47283,"user_type":"registered","user_id":139985,"link":"https://stackoverflow.com/users/139985/stephen-c","reputation":703927,"display_name":"Stephen C","accept_rate":69},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1629002962,"creation_date":1629002962,"body":"<p>@rzwitserloot's <a href=\"https://stackoverflow.com/a/68785361/139985\">answer</a> covers just about everything.  (And what he says about correctness ... is correct.)</p>\n<p>The reason why <code>sleep()</code> or <code>println()</code> calls change the behavior is that they have undocumented (serendipitous) effects on the memory cache flushing behavior.</p>\n<p>In the case of <code>println</code>, the current implementation of the output stream stack involves calls to internal synchronized methods.  This is apparently sufficient to cause your flag's change in value to be visible to the second thread.</p>\n<p>In the case of <code>sleep</code>, the call causes the current thread's state to be saved to memory so that execution can switch to a different thread.</p>\n<p>But in either case, your modified code is &quot;working&quot; because of <em>undocumented</em> behavior.  This behavior could change between different Java versions, across different hardware or OS platforms and so on.</p>\n","answer_id":68788797,"question_id":68785125},{"owner":{"profile_image":"https://i.stack.imgur.com/Klcqr.gif?s=256&g=1","account_id":292208,"user_type":"registered","user_id":2245707,"link":"https://stackoverflow.com/users/2245707/pveentjer","reputation":10665,"display_name":"pveentjer","accept_rate":17},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1629002343,"creation_date":1628998377,"body":"<p>Your code is not working correctly because you are violating the Java Memory model (JMM). The problem with your code is that a happens-before edge is missing between the write of the 'flag' and the read of 'flag' and as a consequence your code is suffering from a data race. When there is a data-race, you can get unexpected behavior. Luckily it is better defined than a data-race with C++ where it can lead to undefined behavior.</p>\n<p>The compiler is the typical component that will break this  example. It could transform your code into:</p>\n<pre><code>if(!flag) return;\n\nwhile(true){\n   ...\n}\n</code></pre>\n<p>There is no point in checking flag in the loop if inside the loop the flag isn't changed. This optimization is called loop-invariant code-motion or hoisting. If you would make the flag field volatile, then happens-before edge between the write and the read will exist and the compiler can't apply optimize out the read. Instead it needs to read the flag from 'shared memory' (this include reading it from the coherent CPU cache).</p>\n<p>Please do not think that volatile forces flushing to main memory and writing from main memory. Main memory is just a spill bucket for whatever doesn't fit into the CPU cache. Caches on modern CPU's are always coherent. If for every volatile read/write you would need to access main memory, concurrent programs would become very slow. In most cases a volatile read/write can be resolved locally if there is no read/write miss and no cache coherence traffic with other CPU's or main memory is needed. The main 'flushing' that needs to be done to preserve ordering between loads and stores is that loads need to wait for the stores in the store buffer to drain; but this is before the store hits the cache. And even 'flushing' here is an inappropriate term since the store buffer is already draining to the cache as fast as possible.</p>\n<p>Also do not believe that volatile prevents using registers in the CPU; modern processors are all load-store architectures which mean that there are separate load/store instructions that load/store from memory into a register and most normal instructions like those executed by the ALUs can only deal with registers and do not have the ability to access memory. Even the X86 which from the outside if a register-memory architecture, after uops conversion becomes a load-store architecture. So registers are always used; the key part is how often registers needs to be synchronized with the cache.</p>\n<p>Apart from that, the JMM isn't defined in terms of registers and flushing to main memory, so it isn't a suitable mental model.</p>\n","answer_id":68788509,"question_id":68785125,"last_edit_date":1629002343},{"owner":{"profile_image":"https://i.stack.imgur.com/ZWEI3.jpg?s=256&g=1","account_id":322981,"user_type":"registered","user_id":642706,"link":"https://stackoverflow.com/users/642706/basil-bourque","reputation":310755,"display_name":"Basil Bourque","accept_rate":58},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":true,"last_activity_date":1628973041,"creation_date":1628969057,"body":"<h1>tl;dr</h1>\n<p>Do not bother trying to optimize a sub-second operation executed occasionally.</p>\n<h1>Details</h1>\n<p>You may have fallen into the trap known as <em>premature optimization</em>.</p>\n<p>I created two Java 16+ <a href=\"https://openjdk.java.net/jeps/395\" rel=\"nofollow noreferrer\">records</a> for your <code>Human</code> and <code>HumanInfo</code> classes.</p>\n<pre class=\"lang-java prettyprint-override\"><code>package work.basil.creation;\n\npublic record Human( String name , double height , double weight ) { }\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>package work.basil.creation;\n\npublic record HumanInfo( String name , double height ) {\n    public HumanInfo ( Human human ) {\n        this( human.name() , human.height() );\n    }\n}\n</code></pre>\n<p>Then I wrote this app to populate sample data of a million objects, followed by transcoding those objects from <code>Human</code> to <code>HumanInfo</code>.</p>\n<pre class=\"lang-java prettyprint-override\"><code>package work.basil.creation;\n\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class App {\n    public static void main ( String[] args ) {\n        App app = new App();\n        int limit = 1_000_000;\n        List &lt; Human &gt; humans = app.populateSampleData( limit );\n        List &lt; HumanInfo &gt; humanInfos = app.transcodeToHumanInfo( humans );\n    }\n\n    private List &lt; HumanInfo &gt; transcodeToHumanInfo ( final List &lt; Human &gt; humans ) {\n        Instant start = Instant.now();  // Benchmarking.\n        List &lt; HumanInfo &gt; humanInfos = humans.stream().map( human -&gt; new HumanInfo( human ) ).toList();\n        System.out.println( &quot;transcodeToHumanInfo  elapsed = &quot; + Duration.between( start , Instant.now() ) );\n        for ( int i = 0 ; i &lt; 10 ; i++ ) {\n            System.out.println( humanInfos.get( i ) );\n        }\n        return humanInfos;\n    }\n\n    private List &lt; Human &gt; populateSampleData ( final int limit ) {\n        List &lt; Human &gt; humans = new ArrayList &lt;&gt;( limit );\n        Instant start = Instant.now();\n        for ( int i = 0 ; i &lt; limit ; i++ ) {\n            humans.add( new Human( UUID.randomUUID().toString() , ThreadLocalRandom.current().nextDouble( 145d , 185d ) , ThreadLocalRandom.current().nextDouble( 45d , 90d ) ) );\n        }\n\n        // Dump to console.\n        System.out.println( &quot;populateSampleData elapsed = &quot; + Duration.between( start , Instant.now() ) );\n        for ( int i = 0 ; i &lt; 10 ; i++ ) {\n            System.out.println( humans.get( i ) );\n        }\n        return humans;\n    }\n}\n</code></pre>\n<p>In my experiments, I changed the <code>.stream</code> to <code>.parallelStream</code>. I ran each several times, always ignoring the first run. Results were quite consistent.</p>\n<p>I am running on <a href=\"http://jdk.java.net/17/\" rel=\"nofollow noreferrer\">early-access Java 17</a> optimized for Apple Silicon (not Intel) on my MacBook Pro (13-inch, M1, 2020) with 16 gigs of memory with macOS Big Sur 11.5.1, with 8 (4 performance and 4 efficiency) cores.</p>\n<h2>0.01x seconds</h2>\n<p>Results:</p>\n<ul>\n<li>Transcoding a <em><strong>million objects takes a hundredth of a second</strong></em> without concurrency. So no practical point in trying to improve on that.</li>\n<li>Changing that code from <code>.stream</code> to <code>.parallelStream</code> takes three times longer. Running concurrently <em>costs</em> you time rather than saving you time.</li>\n</ul>\n<p>Some arbitrarily selected run numbers.</p>\n<div class=\"s-table-container\">\n<table class=\"s-table\">\n<thead>\n<tr>\n<th style=\"text-align: right;\"><code>.stream</code></th>\n<th style=\"text-align: right;\"><code>.parallelStream</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: right;\">PT0.013089S<br />PT0.019682S<br />PT0.018813S</td>\n<td style=\"text-align: right;\">PT0.044404S<br />PT0.043849S<br />PT0.042643S</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>You asked:</p>\n<blockquote>\n<p>Is there a reason why multithreading does not help here?</p>\n</blockquote>\n<p>Because multithreading and concurrency are not magic, there is a cost, an <a href=\"https://en.wikipedia.org/wiki/Overhead_(business)\" rel=\"nofollow noreferrer\">“overhead”</a>. Setting up the threads, scheduling their execution times, coordinating their work, and collecting the results are all work that takes time to execute.</p>\n<p>When choosing to parallelize, you must consider the costs versus the benefits. This calculation should include some concrete evidence such as micro-benchmarking, as programmers are notoriously bad at guesstimating bottlenecks and optimizations.</p>\n","answer_id":68786399,"question_id":68786081,"last_edit_date":1628973041},{"owner":{"profile_image":"https://lh4.googleusercontent.com/-xIoh0ve8hKc/AAAAAAAAAAI/AAAAAAAAAEw/lmhFmElveRY/photo.jpg?sz=256","account_id":10125444,"user_type":"registered","user_id":7480973,"link":"https://stackoverflow.com/users/7480973/zachary-sang","reputation":17,"display_name":"Zachary Sang"},"content_license":"CC BY-SA 4.0","score":-1,"is_accepted":false,"last_activity_date":1628968867,"creation_date":1628959827,"body":"<blockquote>\n<p>Why fct.isFlag() in the while loop of main thread can't get the latest value without some sleep?</p>\n</blockquote>\n<p>I believe that what is happening here is that without the <code>Thread.sleep(1)</code> you have a tight loop (<a href=\"https://stackoverflow.com/a/2212986/7480973\">relevant definition</a>). This means means that the main thread is not getting the latest value because it is using the cached value (as you said also fixable by making the flag valuable volatile).</p>\n<p>When the <code>Thread.sleep()</code> is added, the tight loop is broken since this moves the thread out of the <code>Runnable</code> state. When a thread moves out of the <code>Runnable</code> state, it is moved off of the CPU. when resuming from <code>Thread.sleep()</code>, the CPU cached value are reloaded from memory, which gives the freshest flag value.</p>\n","answer_id":68785320,"question_id":68785125,"last_edit_date":1628968867},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG","account_id":401843,"user_type":"registered","user_id":768644,"link":"https://stackoverflow.com/users/768644/rzwitserloot","reputation":89863,"display_name":"rzwitserloot"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1628960158,"creation_date":1628960158,"body":"<p>The reason is The Evil Coin.</p>\n<p>The specification that is relevant here is the Java Memory Model (JMM).</p>\n<p>The JMM has the following aspect to it:</p>\n<p><strong>Any thread is free to make a local cached copy of a variable, or not, and may refer, according to its whims and the phase of the moon if it wants, to either that copy or not.</strong></p>\n<p>In other words, the thread flips a coin to decide what to do. It is evil, in that it won't flip heads/tails at a roughly 50/50 split. Assume it flips coins to mess with you: It works great for an hour or so, and then all of a sudden it starts failing when you pick up the work again tomorrow morning, and you have no idea what happened.</p>\n<p>Thus, in some of your invocations, that boolean field you're looking at is getting cached copies.</p>\n<p>Said differently:</p>\n<p><strong>If multiple threads are working with the same field, the behaviour of your application is undefined unless you establish HB/HA</strong>.</p>\n<p>The reason it works in this bizarre fashion is speed: Any other definition would mean a JVM has to run code a few orders of magnitude more slowly.</p>\n<p>The solution is to establish HB/HA: Happens-Before/Happens-After relationships.</p>\n<p>HB/HA works like this: If there is an HB/HA relationship between 2 lines of code, then it is impossible to observe the state as it was <strong>before</strong> the Happens-Before line ran, from the Happens-After line. In other words, if a field has value '5' before the HB line, and value '7' after the 'HB' line, then the HA line cannot possibly observe 5. It can observe 7, or some update that occurred afterwards.</p>\n<p>The spec lists a bunch of things that establish HB/HA:</p>\n<ul>\n<li>Any access to <code>volatile</code> fields. You can try that right now: Make that field <code>volatile</code>, it'll 'fix' it.</li>\n<li>The exiting of a <code>synchronized(x)</code> block is HB vs. entering a <code>synchronized(theSameX)</code> block in another thread (if that entering that block actually happens afterwards, of course).</li>\n<li>The <code>t.start()</code> method is HB relative to the first line in the <code>run()</code> of the thread you started.</li>\n<li>Within one thread, any line of code that is run before any other is HB (that's the trivial case).</li>\n</ul>\n<p>Some things within the JVM use this stuff.</p>\n<p>Tips:</p>\n<ul>\n<li>Generally, use stuff from the <code>java.util.concurrent</code> package.</li>\n<li>Try to avoid interacting with the same field from different threads.</li>\n<li>Consider databases or message queues or other systems with less finicky rules about inter-thread communications.</li>\n<li>If writing to fields that other threads are supposed to read, you <strong>must</strong> consider HB/HA.</li>\n<li>None of this is a guarantee. <strong>You can write broken code that nevertheless passes all tests today, and tomorrow, and next week, and on the production machine, but fails next month when you're giving that important demo to the big customer</strong>. Hence, <strong>here be dragons</strong>: If you mess, you may not know until the cost the bug imposes on you has ballooned out of control. Thus, avoid this stuff unless you really, really, really know what you are doing.</li>\n</ul>\n","answer_id":68785361,"question_id":68785125},{"owner":{"profile_image":"https://www.gravatar.com/avatar/d6d4c4b8d52a51d9f7f64c1e5f2de0b3?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":4569994,"user_type":"registered","user_id":3709922,"link":"https://stackoverflow.com/users/3709922/jignesh-m-khatri","reputation":1447,"display_name":"Jignesh M. Khatri","accept_rate":33},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1628930828,"creation_date":1628789462,"body":"<p>Here is the one of the solution to solve the given problem. It uses <code>wait</code> to wait the current thread after printing one letter and <code>notify</code> the other thread to print its letter, and same cycle repeats. The concept of Thread <code>wait</code> and <code>notify</code> is very well explained <a href=\"https://stackoverflow.com/a/13664082/3709922\">here</a>.</p>\n<p><strong>Short description:</strong></p>\n<p>To <code>wait</code> or <code>notify</code> any thread, it (invoking thread) must acquire the lock on any common object. In below example, each thread is acquiring the lock on <code>this</code> (self) (via synchronized <code>run</code> method) to <code>wait</code> and on <code>opponent</code> to notify it (the another thread).</p>\n<pre><code>public class App implements Runnable {\n    char c;\n    App opponent;\n    boolean go;\n\n    public App(char c, boolean go) {\n        this.c = c;\n        this.go = go;\n    }\n\n    public void setOpponent(App opponent) {\n        this.opponent = opponent;\n    }\n\n    public static void main(String[] args) {\n        App a = new App('a', true);\n        App b = new App('A', false);\n\n        Thread t1 = new Thread(a);\n        Thread t2 = new Thread(b);\n\n        a.setOpponent(b);\n        b.setOpponent(a);\n\n        t1.start();\n        t2.start();\n    }\n\n    @Override\n    public synchronized void run() {\n        for (char i = 0; i &lt; 26; i++) {\n\n            try {\n                if (go) {\n                    System.out.println(c++);\n                    this.wait();\n                    synchronized (opponent) {\n                        opponent.notify();\n                    }\n                } else {\n                    System.out.println(c++);\n                    synchronized (opponent) {\n                        opponent.notify();\n                    }\n                    this.wait();\n                }\n\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre>\n<p>Here is the more simplified and understandable version of above code. In this code, both the threads are acquiring lock on same <code>lock</code> object, printing the letter, going in <code>WAIT</code> state (so release the lock) and giving turn to other <code>BLOCKED</code> thread waiting for the lock on <code>lock</code>. The other thread then acquires the lock on <code>lock</code>, prints the letter, notifies the previous thread which was waiting on <code>lock</code> object, and goes into <code>WAIT</code> condition, thus releasing the lock.</p>\n<pre><code>public class App2 implements Runnable {\n    char c;\n    Object lock;\n    boolean go;\n\n    public App2(char c, boolean go) {\n        this.c = c;\n        this.go = go;\n    }\n\n    public void setLock(Object lock) {\n        this.lock = lock;\n    }\n\n    public static void main(String[] args) {\n        App2 a = new App2('a', true);\n        App2 b = new App2('A', false);\n\n        Thread t1 = new Thread(a);\n        Thread t2 = new Thread(b);\n\n        Object lock = new Object();\n\n        a.setLock(lock);\n        b.setLock(lock);\n\n        t1.start();\n        t2.start();\n    }\n\n    @Override\n    public void run() {\n\n        for (char i = 0; i &lt; 26; i++) {\n            synchronized (lock) {\n                try {\n                    if (go) {\n                    \n                        System.out.println(c++);\n                        lock.wait();\n                        lock.notify();\n                    \n                    } else {\n                    \n                        System.out.println(c++);\n                        lock.notify();\n                        lock.wait();\n                    \n                    }\n                } catch (InterruptedException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<p><strong>UPDATE:</strong></p>\n<p>Above two approaches will work in most of the cases, but will not guarantee that <code>t1</code> will be executed before <code>t2</code> every time. Though <code>t1</code> is started before <code>t2</code>, but it does not mean that thread scheduler will always pick <code>t1</code> to execute before <code>t2</code>. To be sure that <code>t1</code> will execute before <code>t2</code> in every case, we need to ensure that <code>t2</code> gets started once <code>t1</code> is in <code>RUNNABLE</code> state (i.e. running). Below is the one of the way of how we can achieve it:</p>\n<pre><code>public class App3 implements Runnable {\n    char c;\n    App3 opponent;\n    boolean go;\n    boolean createOpponent = false;\n\n    public App3(char c, boolean go) {\n        this.c = c;\n        this.go = go;\n    }\n\n    public void setOpponent(App3 opponent) {\n        this.opponent = opponent;\n    }\n\n    public void setCreateOpponent(boolean createOpponent) {\n        this.createOpponent = createOpponent;\n    }\n\n    public static void main(String[] args) {\n        App3 a = new App3('a', true);\n        App3 b = new App3('A', false);\n\n        Thread t1 = new Thread(a);\n\n        a.setOpponent(b);\n        a.setCreateOpponent(true);\n\n        b.setOpponent(a);\n\n        t1.start();\n    }\n\n    @Override\n    public synchronized void run() {\n        if (createOpponent) {\n            setCreateOpponent(false);\n            new Thread(opponent).start();\n        }\n        for (char i = 0; i &lt; 26; i++) {\n\n            try {\n                if (go) {\n                    System.out.println(c++);\n                    this.wait();\n                    synchronized (opponent) {\n                        opponent.notify();\n                    }\n                } else {\n                    System.out.println(c++);\n                    synchronized (opponent) {\n                        opponent.notify();\n                    }\n                    this.wait();\n                }\n\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre>\n","answer_id":68761907,"question_id":68760729,"last_edit_date":1628930828},{"owner":{"profile_image":"https://lh3.googleusercontent.com/-2DggdTBjTSg/AAAAAAAAAAI/AAAAAAAAKRk/8QidWyLl7Xk/photo.jpg?sz=256","account_id":460635,"user_type":"registered","user_id":4807449,"link":"https://stackoverflow.com/users/4807449/ronnie-horo","reputation":11,"display_name":"Ronnie Horo"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1628796881,"creation_date":1628796420,"body":"<p>Hope this helps...</p>\n<pre><code>public class ABCThread implements Runnable {\n    char c;\n    boolean flag;\n\n    public ABCThread(char c, boolean flag) {\n        this.c = c;\n        this.flag = flag;\n    }\n\n    @Override\n    public synchronized void run() {\n        for (char i = 0; i &lt; 52; i++) {\n            try {\n                if (flag) {\n                    System.out.println(c++);\n                    notifyAll();\n                    flag = false;\n                    wait(100);\n                } else {\n                    flag = true;\n                    wait(100);\n                }\n\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n\n        Thread t1 = new Thread(new ABCThread('a', true));\n        Thread t2 = new Thread(new ABCThread('A', false));\n\n        t1.start();\n        t2.start();\n\n    }\n}\n</code></pre>\n<p>or you can define separate methods for printing small and capital letters and run them in two separate threads</p>\n<pre><code>public class ABCThread {\n\n    boolean flag;\n\n    public ABCThread(boolean flag) {\n        this.flag = flag;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n\n        ABCThread abc = new ABCThread(false);\n\n        Thread t1 = new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                try {\n                    abc.printSmallLetters();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n            }\n        });\n        Thread t2 = new Thread(new Runnable() {\n            public void run() {\n                try {\n                    abc.printCapitalLetters();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n\n        t1.start();\n        t2.start();\n\n    }\n\n    synchronized void printSmallLetters() throws InterruptedException {\n        for (char i = 'a'; i &lt; 'z'; i++) {\n            while (flag == true) {\n                wait();\n            }\n            System.out.println(i);\n            notifyAll();\n            flag = true;\n        }\n    }\n\n    synchronized void printCapitalLetters() throws InterruptedException {\n        for (char i = 'A'; i &lt; 'Z'; i++) {\n            while (flag == false) {\n                wait();\n            }\n            System.out.println(i);\n            notifyAll();\n            flag = false;\n        }\n    }\n}\n\n</code></pre>\n","answer_id":68763152,"question_id":68760729,"last_edit_date":1628796881},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b46fd0a429838cd67ea0650e953899be?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":22447688,"user_type":"registered","user_id":16651360,"link":"https://stackoverflow.com/users/16651360/marco","reputation":54,"display_name":"Marco"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1628795492,"creation_date":1628785297,"body":"<p><strong>Quick answer:</strong></p>\n<p>You can't force a thread to run at a certain moment. What you can do though is let those two run &quot;out of sync&quot; (not related to async coding).</p>\n<pre><code>Thread t1 = new Thread(new ABCThread('a'));\nThread.sleep(250);\nThread t2 = new Thread(new ABCThread('A'));\n</code></pre>\n<p>The 1st thread will print about every 500 ms and the 2nd thread will print at 250, 750, 1250, etc.\nNote that this would not be a correct way to solve this in real programs. But then again, you would also likely not add <code>Thread.sleep(500)</code> to the run method.</p>\n<p><strong>Better:</strong></p>\n<p>You need synchronization between the threads. Because you start two threads you can use a boolean.</p>\n<pre><code>public class ABCThread implements Runnable {\nchar c;\nstatic boolean synchronizer = false;\nboolean runOn;\n\npublic ABCThread(char c, boolean runOn) {\n    this.c = c;\n    this.runOn = runOn;\n}\n\n@Override\npublic synchronized void run() {\n    int count = 0;\n    while(count &lt; 26)\n    {\n        if(runOn != synchronizer) \n        {\n           Thread.sleep(100);\n           continue;\n        }\n        count++;\n        synchronizer = !synchronizer;\n        System.out.println(c++);\n        \n    }\n\n}\n\n    Thread t1 = new Thread(new ABCThread('a', false));\n    Thread t2 = new Thread(new ABCThread('A', true));\n</code></pre>\n<p>Just typing this out. It might not compile.\n<code>Thread.sleep(100)</code> is just some number. It could possibly be lower, but doesn't matter much for the question.</p>\n<p><strong>Even better</strong>\nThe previous code can run with only 2 threads! 1 will just stay stuck with synchronizer = false. If you add a third then the synchronizer won't work because it only has 2 states.\nYou could add an integer instead of the boolean and another integer amountOfThreads. The amountOfThreads will need to be set to the amount of threads you will start up. Then increase the atomic integer when the thread prints and if the synchronizer (the atomic int) is more than amountOfThreads, set it to 0.</p>\n","answer_id":68761029,"question_id":68760729,"last_edit_date":1628795492},{"owner":{"profile_image":"https://i.stack.imgur.com/PMmwr.jpg?s=256&g=1","account_id":4483794,"user_type":"registered","user_id":3647105,"link":"https://stackoverflow.com/users/3647105/liem-le","reputation":581,"display_name":"Liem Le"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1628788395,"creation_date":1628787663,"body":"<h1>What you need? A &quot;shared resource&quot; between threads.</h1>\n<h1>Further: A synchronous FSM (Finite state machine)</h1>\n<p>Below is code that demonstrated how to achieve that.</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class Main\n{\n    // The shared resource\n    public static class State {\n        \n        private int val;\n        private int nStates;\n\n        // Init value and number of states.\n        public State(int init, int nStates) {\n            this.val = init;\n            this.nStates = nStates;\n        }\n        \n        int get() {\n            return val;\n        }\n        // Define how to get to next state. For simple use case, just increase then modulo it. eg: 0, 1, 0, 1\n        // Avoid modulo in-case you need very very high performance.\n        void next() {\n            this.val = (this.val + 1) % nStates;\n        }\n    }\n    \n    public static class ABCThread implements Runnable{\n        private char c;\n        private State s;\n        private int type;\n        public ABCThread(char c, State s, int type) {\n            this.c = c;\n            this.s = s;\n            this.type = type;\n        }\n\n        @Override\n        public void run() {\n            try {\n            for (char i = 0; i &lt; 26; i++) {\n                // Do things synchronously\n                synchronized(s){\n                    while(s.get() != type) {\n                        // Wait for our turn.\n                        s.wait();\n                    }\n                    System.out.print(c++);\n                    // Update state\n                    s.next();\n                    // Notify to other threads to do their job.\n                    s.notifyAll();\n                }\n            }\n            }catch(Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n\n        // Define the state.\n        State s = new State(0, 2);\n\n\n        /* Uncomment this block to have 3 synchronous threads. Will print aA1bB2...\n        s = new State(0, 3);\n        Thread t3 = new Thread(new ABCThread('1', s, 2));\n        t3.start();\n        t3.join();\n        */\n        Thread t1 = new Thread(new ABCThread('a', s, 0));\n        Thread t2 = new Thread(new ABCThread('A', s, 1));\n\n\n        // Start threads\n        t1.start();\n        t2.start();\n        // Wait for these threads to finish before exit.\n        t1.join();\n        t2.join();\n    }\n}\n</code></pre>\n","answer_id":68761559,"question_id":68760729,"last_edit_date":1628788395},{"owner":{"profile_image":"https://www.gravatar.com/avatar/780a651189f64a2cbf4b7f62cf852005?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":7178634,"user_type":"registered","user_id":5483526,"link":"https://stackoverflow.com/users/5483526/matt-timmermans","reputation":55168,"display_name":"Matt Timmermans"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1628788097,"creation_date":1628787632,"body":"<p>You're supposed to use a <code>boolean</code> to control which thread prints:</p>\n<ol>\n<li>Thread 1 waits for the boolean to be false.  Then it prints and sets it true.</li>\n<li>Thread 2 waits for the boolean to be true.  Then it prints and sets it false.</li>\n</ol>\n<p>In this way, the threads will alternate.  Also, all of this will be much faster if you use signaling between threads instead of <code>sleep</code>:</p>\n<pre><code>import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class ABCThread implements Runnable {\n    static Object monitor = new Object();\n    static boolean turn = false;\n    \n    char c;\n    final boolean myTurn;\n\n    public ABCThread(char c, boolean myTurn) {\n        this.c = c;\n        this.myTurn = myTurn;\n    }\n\n    @Override\n    public void run() {\n\n        for (char i = 0; i &lt; 26; i++) {\n            synchronized(monitor) {\n                while (turn != myTurn) {\n                    try {\n                        // Note that the lock is release while I'm waiting,\n                        // So the other thread can claim it here.\n                        monitor.wait();\n                    } catch (Exception e) {\n                    }\n                }\n                System.out.println(c++);\n                turn = !myTurn;\n                monitor.notifyAll();\n            }\n        }\n\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n\n        Thread t1 = new Thread(new ABCThread('a', false));\n        Thread t2 = new Thread(new ABCThread('A', true));\n\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n\n    }\n}\n</code></pre>\n","answer_id":68761547,"question_id":68760729,"last_edit_date":1628788097},{"owner":{"profile_image":"https://lh3.googleusercontent.com/a-/AOh14GiYf8V11zSxXD852Bjjc3hlT1M4SpB5HMHFzJY5nw=k-s256","account_id":22446598,"user_type":"registered","user_id":16650432,"link":"https://stackoverflow.com/users/16650432/rakshith-b-s","reputation":45,"display_name":"Rakshith B S"},"content_license":"CC BY-SA 4.0","score":-1,"is_accepted":false,"last_activity_date":1628787861,"creation_date":1628784544,"body":"<p><img src=\"https://i.stack.imgur.com/qzP5C.png\" alt=\"output\" /></p>\n<p>just replace the println by print to get a series output like this\nother than that everything seems to be fine,\nyou can see the output i got in the screenshot above</p>\n","answer_id":68760859,"question_id":68760729,"last_edit_date":1628787861},{"owner":{"profile_image":"https://www.gravatar.com/avatar/3e4be83fe4b3ea871e3595d80172f118?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":19042414,"user_type":"registered","user_id":13902217,"link":"https://stackoverflow.com/users/13902217/jeka-fri","reputation":71,"display_name":"Jeka_FRI"},"content_license":"CC BY-SA 4.0","score":-2,"is_accepted":false,"last_activity_date":1628785755,"creation_date":1628784988,"body":"<p>No way. The order of execution of threads cannot be controlled).You can use Thread.yield(). But yield () - tries to tell the scheduler to execute the next thread, but it stays in the RUNNABLE state.</p>\n","answer_id":68760956,"question_id":68760729,"last_edit_date":1628785755},{"owner":{"profile_image":"https://www.gravatar.com/avatar/fed094516f56f32f79436c3bba9ff71b?s=256&d=identicon&r=PG","account_id":3087422,"user_type":"registered","user_id":2614310,"link":"https://stackoverflow.com/users/2614310/arvind-kumar","reputation":509,"display_name":"Arvind Kumar","accept_rate":14},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1627448454,"creation_date":1627448454,"body":"<p><strong>1st  Use case</strong> - Per thread context which gives thread safety as well as performance\nReal-time example in SpringFramework classes -</p>\n<ul>\n<li>LocaleContextHolder</li>\n<li>TransactionContextHolder</li>\n<li>RequestContextHolder</li>\n<li>DateTimeContextHolder</li>\n</ul>\n<p><strong>2nd Use case</strong> - When we don't want to share something among threads and at the same time don't want to use synchronize/lock due to performance cost\nexample - SimpleDateFormat to create the custom format for dates</p>\n<pre><code>import java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n/**\n * @author - GreenLearner(https://www.youtube.com/c/greenlearner)\n */\npublic class ThreadLocalDemo1 {\n    SimpleDateFormat sdf = new SimpleDateFormat(&quot;dd-mm-yyyy&quot;);//not thread safe\n    ThreadLocal&lt;SimpleDateFormat&gt; tdl1 = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(&quot;yyyy-dd-mm&quot;));\n\n    public static void main(String[] args) {\n        ThreadLocalDemo1 d1 = new ThreadLocalDemo1();\n\n        ExecutorService es = Executors.newFixedThreadPool(10);\n\n        for(int i=0; i&lt;100; i++) {\n            es.submit(() -&gt; System.out.println(d1.getDate(new Date())));\n        }\n        es.shutdown();\n    }\n\n    String getDate(Date date){\n\n//        String s = tsdf.get().format(date);\n        String s1 = tdl1.get().format(date);\n        return s1;\n    }\n}\n</code></pre>\n<p><strong>Usage Tips</strong></p>\n<ul>\n<li>Use local variables if possible. This way we can avoid using ThreadLocal</li>\n<li>Delegate the functionality to frameworks as and when possible</li>\n<li>If using ThreadLocal and setting the state into it then make sure to clean it after using otherwise it can become the major reason for <strong>OutOfMemoryError</strong></li>\n</ul>\n","answer_id":68554632,"question_id":817856},{"owner":{"profile_image":"https://i.stack.imgur.com/xvjto.png?s=256&g=1","account_id":6477138,"user_type":"registered","user_id":5015427,"link":"https://stackoverflow.com/users/5015427/ranojan","reputation":829,"display_name":"ranojan"},"content_license":"CC BY-SA 4.0","score":-1,"is_accepted":false,"last_activity_date":1624966050,"creation_date":1624966050,"body":"<p>Delete</p>\n<pre><code>&lt;style name=&quot;AppTheme.Launcher&quot;&gt;\n    &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/splashscreen&lt;/item&gt;\n&lt;/style&gt;\n</code></pre>\n<p>from style.xml file</p>\n","answer_id":68177787,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/1d80d2b74461600fd72673caebce4e24?s=256&d=identicon&r=PG","account_id":21829083,"user_type":"unregistered","user_id":16124211,"link":"https://stackoverflow.com/users/16124211/pluk","reputation":31,"display_name":"pluk"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1622783005,"creation_date":1622783005,"body":"<p>The <code>compute()</code> javadoc <a href=\"https://github.com/openjdk/jdk16u/blob/jdk16.0.1/src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java#L1876\" rel=\"nofollow noreferrer\">says</a> what this method does:</p>\n<blockquote>\n<p>Attempts to compute a mapping for the specified key and its current mapped value (or <code>null</code> if there is no current mapping).</p>\n</blockquote>\n<p>So <code>compute()</code> <strong>replaces</strong> a value for the key.</p>\n<p>To use <code>compute()</code> to modify the internal fields of some object (even the object is stored as a value in the map) is not what <code>compute()</code> was meant for.<br />\nTherefore, naturally, <code>compute()</code>'s specification/documentation guarantees (and even says) nothing about that.</p>\n<p>Regarding <code>happens-before</code>, there are multiple mentions in the documentation:</p>\n<ul>\n<li><a href=\"https://github.com/openjdk/jdk16u/blob/jdk16.0.1/src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java#L89\" rel=\"nofollow noreferrer\">ConcurrentHashMap</a>:\n<blockquote>\n<p>More formally, an update operation for a given key bears a <em>happens-before</em> relation with any (non-null) retrieval for that key reporting the updated value.</p>\n</blockquote>\n</li>\n<li><a href=\"https://github.com/openjdk/jdk16u/blob/jdk16.0.1/src/java.base/share/classes/java/util/concurrent/ConcurrentMap.java#L55\" rel=\"nofollow noreferrer\">ConcurrentMap</a>:\n<blockquote>\n<p>Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a <code>ConcurrentMap</code> as a key or value <em>happen-before</em> actions subsequent to the access or removal of that object from the <code>ConcurrentMap</code> in another thread.</p>\n</blockquote>\n</li>\n<li><a href=\"https://github.com/openjdk/jdk16u/blob/jdk16.0.1/src/java.base/share/classes/java/util/concurrent/package-info.java#L270\" rel=\"nofollow noreferrer\">java.util.concurrent</a>:\n<blockquote>\n<p>Actions in a thread prior to placing an object into any concurrent collection <em>happen-before</em> actions subsequent to the access or removal of that element from the collection in another thread.</p>\n</blockquote>\n</li>\n</ul>\n<p>The important thing is that the <code>happen-before</code> relation is only guaranteed between insertion/removal/retrieval of objects to/from the collection.<br />\nIn your case it is the same <code>State</code> object (only internal its fields are updated), so IMO according to documentation <code>ConcurrentHashMap</code> is even allowed to decide that nothing changed and skip the remaining synchronization steps.</p>\n","answer_id":67831727,"question_id":67825678},{"owner":{"profile_image":"https://www.gravatar.com/avatar/8cf8627c2f497949547cadc02c52b95f?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":4034876,"user_type":"registered","user_id":3319725,"link":"https://stackoverflow.com/users/3319725/anatolyg","reputation":1557,"display_name":"AnatolyG"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1621344860,"creation_date":1621330742,"body":"<p>This code has both of the classical concurrency problems: a race condition (a semantic problem) and a data race (a memory model related problem).</p>\n<ol>\n<li><code>Object.wait()</code> releases the object's monitor and another thread can enter into the synchronized block/method while the current one is waiting. Obviously, author's intention was to make the method atomic, but <code>Object.wait()</code> breaks the atomicity. As result, if we call <code>.increment()</code> from, let's say, 10 threads simultaneously and each thread calls the method 100_000 times, we get <code>count</code> &lt; 10 * 100_000 almost always, and this isn't what we'd like to. This is a race condition, a logical/semantic problem. We can rephrase the code... Since we release the monitor (this equals to the exit from the synchronized block), the code works as follows (like two separated synchronized parts):</li>\n</ol>\n<pre><code>    public void increment() { \n        int temp = incrementPart1(); \n        incrementPart2(temp); \n    }\n    \n    private synchronized int incrementPart1() {\n        int temp = count; \n        return temp; \n    }\n    \n    private synchronized void incrementPart2(int temp) {\n        count = temp + 1; \n    }\n</code></pre>\n<p>and, therefore, our <code>increment</code> increments the counter not atomically. Now, let's assume that 1st thread calls incrementPart1, then 2nd one calls incrementPart1, then 2nd one calls incrementPart2, and finally 1st one calls incrementPart2. We did 2 calls of the <code>increment()</code>, but the result is 1, not 2.</p>\n<ol start=\"2\">\n<li>Another problem is a data race. There is the Java Memory Model (JMM) described in the Java Language Specification (JLS). JMM introduces a Happens-before (HB) order between actions like volatile memory write/read, Object monitor's operations etc. <a href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4.5\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4.5</a> HB gives us guaranties that a value written by one thread will be visible by another one. Rules how to get these guaranties are also known as Safe Publication rules. The most common/useful ones are:</li>\n</ol>\n<ul>\n<li><p>Publish the value/reference via a volatile field (<a href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4.5\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4.5</a>), or as the consequence of this rule, via the AtomicX classes</p>\n</li>\n<li><p>Publish the value/reference through a properly locked field (<a href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4.5\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4.5</a>)</p>\n</li>\n<li><p>Use the static initializer to do the initializing stores\n(<a href=\"http://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html#jls-12.4\" rel=\"nofollow noreferrer\">http://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html#jls-12.4</a>)</p>\n</li>\n<li><p>Initialize the value/reference into a final field, which leads to the freeze action (<a href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.5\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.5</a>).</p>\n</li>\n</ul>\n<p>So, to have the counter correctly (as JMM has defined) visible, we must make it volatile</p>\n<pre><code>private volatile int count = 0;\n</code></pre>\n<p>or do the read over the same object monitor's synchronization</p>\n<pre><code>public synchronized int getCount() { return count; }\n</code></pre>\n<p>I'd say that in practice, on Intel processors, you read the correct value without any of these additional efforts, with just simple plain read, because of TSO (Total Store Ordering) implemented. But on a more relaxed architecture, like ARM, you get the problem. Follow JMM formally to be sure your code is really thread-safe and doesn't contain any data races.</p>\n","answer_id":67583683,"question_id":67576652,"last_edit_date":1621344860},{"owner":{"profile_image":"https://www.gravatar.com/avatar/45e3a1431bd08d4f8b1ce609c7924531?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":21225504,"user_type":"registered","user_id":15611270,"link":"https://stackoverflow.com/users/15611270/rocco","reputation":1108,"display_name":"Rocco"},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":true,"last_activity_date":1621333432,"creation_date":1621254735,"body":"<p>Actually you don't need to sleep, use proper queue classes instead, like <code>LinkedBlockingQueue</code>, I also remove the flags since you don't need them also, use <code>interrupt()</code> to stop a thread blocked waiting for a queue element:</p>\n<pre><code>private DatagramSocket socket;\nprivate byte[] buf = new byte[256];\nprivate List&lt;IUDPListener&gt; listeners = new ArrayList&lt;IUDPListener&gt;();\nprivate Thread runnerThread, listenerThread;\nprivate LinkedBlockingQueue&lt;MyObject&gt; list = new LinkedBlockingQueue&lt;MyObject&gt;();\n\npublic void init(int port) throws SocketException\n{\n    socket = new DatagramSocket(port);\n    \n    runnerThread = new Thread(this::listenLoopUDP);\n    runnerThread.setName(&quot;listenLoopUDP&quot;);\n    \n    listenerThread = new Thread(this::listenerThreadUDP);\n    listenerThread.setName(&quot;listenerThreadUDP&quot;);\n    \n    runnerThread.start();\n    listenerThread.start();\n}\n\nprivate void listenerThreadUDP() {\n    try {\n        while (true) {\n            MyObject info=list.take();\n            for (IUDPListener listener : listeners) {\n                listener.msgReceived(info);\n            }\n        }\n    } catch (InterruptedException ex) {\n        //Just quit\n    }\n}\n\npublic void listenLoopUDP() {\n    try {\n        while (true) {\n            DatagramPacket packet = new DatagramPacket(buf, buf.length);\n            socket.receive(packet);\n            String received = new String(packet.getData());\n            MyObject info = new MyObject(received);\n            list.put(info);\n        }\n    } catch (IOException e) {\n        Log.write(e);\n    } catch (InterruptedException e) {\n        Log.write(e);\n    } finally {\n        //Any exception above (or a runtime one) will activate this block where we do the cleanup and interrupt the other running thread\n        listenerThread.interrupt();\n        socket.close();\n    }\n}\n</code></pre>\n<p>I did a test with your 1ms client, printing both sent and received message and I have a perfect interleaving between the message, so the bottleneck is not in the receiving thread; with perfect interleaving I mean that in the console I get, as expected, the sent message from the client immediately followed from the received message.</p>\n","answer_id":67569728,"question_id":67566923,"last_edit_date":1621333432},{"owner":{"user_type":"does_not_exist","display_name":"user15793316"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1621287193,"creation_date":1621286439,"body":"<p>Why <code>int temp = count; wait(100); count = temp + 1;</code> is not thread-safe? One possible flow:</p>\n<ul>\n<li>First thread reads <code>count</code> (0), save it in <code>temp</code> for later, and waits, allowing second thread to run (lock released);<br/></li>\n<li>second thread reads <code>count</code> (also 0), saved in <code>temp</code>, and waits, eventually allowing first thread to continue;<br/></li>\n<li>first thread increments value from <code>temp</code> and saves in <code>count</code> (1);<br/></li>\n<li>but second thread still holds the old value of <code>count</code> (0) in <code>temp</code> - eventually it will run and store <code>temp+1</code> (1) into <code>count</code>, not incrementing its new value.</li>\n</ul>\n<p><sup>very simplified, just considering 2 threads</sup></p>\n<p>In short: <code>wait()</code> releases the lock allowing other (synchronized) method to run.</p>\n","answer_id":67577156,"question_id":67576652,"community_owned_date":1621286439,"last_edit_date":1621287193},{"owner":{"profile_image":"https://www.gravatar.com/avatar/d5eaa0398d86085f8751aae1bf3373fc?s=256&d=identicon&r=PG","account_id":369372,"user_type":"registered","user_id":716720,"link":"https://stackoverflow.com/users/716720/sergey-shcherbakov","reputation":4604,"display_name":"Sergey Shcherbakov","accept_rate":60},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1621279534,"creation_date":1621279534,"body":"<p>Check whether your use case allows solving the problem with keyboard interactive input. Instead of CoundDownLatch or Semaphore you could then expect manual input in System.in:</p>\n<pre><code>Scanner sc = new Scanner(System.in);\nsc.nextLine();\n</code></pre>\n<p>If you need that in unit tests, make sure that your environment is set up to read the user input, e.g. start the IntelliJ Idea with <code>-Deditable.java.test.console=true</code> option in Help -&gt; &quot;Edit Custom VM Options...&quot;</p>\n","answer_id":67575900,"question_id":27034958},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG","account_id":401843,"user_type":"registered","user_id":768644,"link":"https://stackoverflow.com/users/768644/rzwitserloot","reputation":89863,"display_name":"rzwitserloot"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1621271417,"creation_date":1621271417,"body":"<p>The Java Memory Model (JMM) is the relevant documentation here.</p>\n<blockquote>\n<p>t1 in the Main Method works as intended</p>\n</blockquote>\n<p>No, it doesn't. This is the first problem of the JMM: The JMM decrees areas where JVMs are free to do whatever they want. That means that the output of the JVM is <strong>non deterministic</strong> in effect: A JVM is free to always do A, or always do B, or flip a coin, or look at the phase of the moon, and more - and they still adhere to the spec. That's not just academic: The popular JVM impls out there all actually do this, because they can run far more efficiently that way.</p>\n<p>It means that effectively you can't test your code to detect that you messed up (by relying on the JVM's choice - which is bad), and if it seems to work right now, there's no guarantee it works tomorrow.</p>\n<p>Basically, the JMM allows the JVM to flip an evil coin sometimes: Evil in the sense that it will flip the same way every time during your dev and test cycle and then flips the other way just as you're giving that important demo.</p>\n<p>The only way to play the game, is <strong>to ensure the evil coin is never flipped in the first place</strong>.</p>\n<p>To do that, you need to remember the following rule:</p>\n<p><strong>All fields that are shared between threads must never be accessed unless HB/HA relationships are set up first, <em>OR</em> it is a read-only concept for the entirety of the concurrent process</strong>.</p>\n<p>In other words, here you have a field (<code>bookList</code>, or to be more specific, the backing array within the arraylist that bookList is pointing at) that is modified by one thread whilst another is running that also wants to read it, and  and thus, evil coinflips occur and this code is broken, whether your tests say so or not. You will 'randomly' observe some or all of the changes or not, or at least the JVM is free to let thread B see what thread A did or not in a haphazard fashion and you can't rely on any of it.</p>\n<p>HB/HA stands for 'happens-before/happens-after'. The JMM describes certain situations for which the JVM guarantees that it is not possible to observe the <em>lack</em> of change caused by the Happens-Before line in the Happens-After line.</p>\n<p>Without HB/HA, you get no such guarantee. To make that clear with an example:</p>\n<pre><code>class State {\n    static int a = 0, b = 0;\n}\n\nclass T1 implements Runnable {\n    public void run() {\n        Thread.sleep(randomAmount);\n        State.a = 10;\n        State.b = 20;\n    }\n}\n\nclass T2 implements Runnable {\n    public void run() {\n        Thread.sleep(randomAmount);\n        int myB = State.b;\n        int myA = State.a;\n        System.out.println(myA + &quot; &quot; + myB);\n    }\n}\n</code></pre>\n<p>If you run this code, fire up the two threads, then any of these outputs are all 'legal' - it is not a buggy JVM. Your code is the buggy code, and note that it is also legal for a JVM to never ever produce one or more of these answers. That should really sail home the point of that evil coin analogy - you just can't write software that doesn't solve HB/HA first, because it's a random clusterbomb otherwise:</p>\n<ul>\n<li><code>0 0</code></li>\n<li><code>10 20</code></li>\n<li><code>10 0</code></li>\n<li><code>0 20</code></li>\n</ul>\n<p>Note in particular that last one. That sure <strong>seems</strong> impossible. thread1 always writes a before it writes b, and thread 2 reads b before a, so can it possibly be that b does read 20, but somehow a is still 0? <strong>And yet, that is legal</strong>, and the reason is that the JVM likes to run quickly, and some JVM implementations (most, actually), will run code in parallel. The JVM merely guarantees that you can't observe things running in parallel unless you use timing to do so (and makes no guarantees on timing at all). If you wouldn't be able to observe it, it will run things in parallel for speed reasons.</p>\n<p>Thus, the JVM is free to run a=10 and b=20 in parallel.</p>\n<p>So, how do you establish HB/HA? That's quite a complicated topic; it involves the primitives <code>synchronized</code> and <code>volatile</code>, or using Java API that is thread-related, such as <code>AtomicLong</code>, <code>ConcurrentHashMap</code>, <code>someThread.start()</code>, etcetera. The docs will say (and the reason they establish HB/HA is generally because their implementations use synchronized/volatile under the hood).</p>\n<p>You're doing none of that, thus, no HB/HA relationships, thus this code is plain broken and not in a way that a test can ever reliably catch.</p>\n<p>In practice, though, trying to hand-manage this stuff is hard and error prone. Obviously it is: Just about any error you do make is by definition untestable.</p>\n<p>Use types that are much better suited to it. Peruse the <code>java.util.concurrent</code> package. For example, if you want one thread to be adding books and another to be removing them, you may want to look at <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/BlockingQueue.html\" rel=\"nofollow noreferrer\">BlockingQueue</a>.</p>\n<p>Removing a 'random' book is rather complicated and doesn't seem pragmatically solvable unless you go with a lock-the-world model. That works too, you'd just have to festoon all interaction with <code>bookList</code> in a synchronized block. But that mostly defeats the point of threads, as only one thread would ever actually be running (the other is waiting to acquire the synchronized lock).</p>\n<p>The takeaway lessons are:</p>\n<ul>\n<li>It is rocket science.</li>\n<li>Tests won't catch errors.</li>\n<li>Read the JMM if you really really want to do this. Learn about the ways to establish HB/HA and apply them. This requires knowing what <code>synchronized</code> and <code>volatile</code> actually do and is non-trivial to learn. If you misunderstood a few things but you don't realize you did, it is quite likely you'll never know until later when your code seems to randomly fail sometimes. This is not something a first-year java newbie should be tackling.</li>\n<li>Any concurrent access (interleaving reads/writes from different threads) on the same field are going to not work the way you want them to unless you pay extremely careful attention and set up HB/HA to make it reliable.</li>\n<li>Try to avoid concurrent access to fields, it's not that hard to do so:</li>\n<li>Peruse the j.u.concurrent package and use something from there, or</li>\n<li>arrange for communications between threads using a mechanism that's good at it, such as databases (which have transactions), or message queues such as RabbitMQ.</li>\n</ul>\n","answer_id":67574197,"question_id":67573852},{"owner":{"profile_image":"https://www.gravatar.com/avatar/9df50c377989a0a4a425884ce6ade1e9?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6426024,"user_type":"registered","user_id":4981150,"link":"https://stackoverflow.com/users/4981150/pieter12345","reputation":1723,"display_name":"Pieter12345"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1621266722,"creation_date":1621266722,"body":"<p>The <code>synchronized</code> keyword synchronizes access per object. Since you've created two <code>Arc</code> instances, both instances can execute the method at the same time. There are multiple solutions possible to synchronize execution of the loop within the <code>run</code> methods of your <code>Arc</code> instances:</p>\n<ul>\n<li>Only use a single instance of <code>Arc</code>. This might or might not be possible given your application.</li>\n<li>Enqueue runnable tasks instead of using an async executor. This makes most sense if your tasks should run on another thread, but not async.</li>\n<li>Use a <code>synchronized (LOCK_OBJ) {...code...}</code> block within the <code>run</code> method that synchronizes on some lock object that will be the same for both instances of <code>Arc</code> (i.e. <code>private static final Object LOCK_OBJ = new Object();</code>)</li>\n</ul>\n<p>Which decision is best really depends on your application, but at least this gives you some reasonable options.</p>\n","answer_id":67573072,"question_id":67572673},{"owner":{"profile_image":"https://www.gravatar.com/avatar/5cfe5f7d64f44be04f147295f5c7b88e?s=256&d=identicon&r=PG","account_id":71739,"user_type":"registered","user_id":207421,"link":"https://stackoverflow.com/users/207421/user207421","reputation":307163,"display_name":"user207421","accept_rate":82},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1621222152,"creation_date":1477188701,"body":"<blockquote>\n<p>I'd like a server to reject a connections after the number of connected clients reach a maximum value.</p>\n</blockquote>\n<p>Close the server socket.</p>\n<blockquote>\n<p>However, even though the server do not accept the connection, the socket on client side is created. Methods <code>socket.isBound</code> and <code>isConnected</code> both return true value.</p>\n</blockquote>\n<p>Correct. That's because TCP maintains a 'backlog queue' of incoming connections which have been completed but not yet accepted by the server application.</p>\n<blockquote>\n<p>So back to the main question. Do you have any ideas how could I reject the client from connecting when the ServerSocket will not be able to .accept() additional connection?</p>\n</blockquote>\n<p>Close the server socket while the number of connections is at its maximum.</p>\n<p>However due to the backlog this technique can never be perfect. There is no perfect solution. You could have the server immediately close excess connections, but the excess clients won't detect that until they try to send something. If you need perfection you will probably have to introduce an application protocol whereby the server sends something like 'ACCEPTED' or 'REJECTED' accordingly.</p>\n","answer_id":40198869,"question_id":40197514,"last_edit_date":1621222152},{"owner":{"profile_image":"https://i.stack.imgur.com/W6OMC.png?s=256&g=1","account_id":1056871,"user_type":"registered","user_id":1059372,"link":"https://stackoverflow.com/users/1059372/eugene","reputation":117749,"display_name":"Eugene","accept_rate":97},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1621218404,"creation_date":1621218053,"body":"<p>The explanation is really easy. What is the <em>default</em> value of <code>result.r1</code>? What type is <code>r1</code>? It's an <code>int</code>, and a <em>default</em> value for a <code>int</code> is <code>zero</code>. So when this <code>if (ta != null)</code> does not happen, meaning <code>ta</code> is <code>null</code>, your code will do nothing. That &quot;nothing&quot; translates into leaving <code>r1</code> to its default value - that is (you already know by now) <code>zero</code>. So when <code>ta == null</code> (and implicitly <code>a == null</code>), you leave <code>r1</code> to be <code>0</code>, though you do not do that <em>explicitly</em>.</p>\n<p>The solution is trivial:</p>\n<pre><code>@Actor\npublic void reader(I_Result result) {\n    A ta = a;\n    if (ta != null) {\n        result.r1 = ta.f;\n    } else {\n        result.r1 = -1;\n    }\n}\n</code></pre>\n<p>and:</p>\n<pre><code>@JCStressTest\n@State\n@Outcome(id = &quot;42&quot;, expect = Expect.ACCEPTABLE, desc = &quot;42 is OK&quot;)\n@Outcome(id = &quot;-1&quot;, expect = Expect.ACCEPTABLE, desc = &quot;-1 is OK too&quot;)\n</code></pre>\n<p>And now your code will never show <code>0</code>, if you read <code>a</code> to be non-null, you will always read <code>a.f</code> to be <code>42</code>. As far as your understanding goes, yes, all threads will see <code>42</code> once they see a reference to an instance of <code>A</code> - that is a <code>JLS</code> guarantee.</p>\n","answer_id":67563277,"question_id":67553393,"last_edit_date":1621218404},{"owner":{"profile_image":"https://www.gravatar.com/avatar/0f09e5543b8dba2d17370c2dc705fafe?s=256&d=identicon&r=PG","account_id":21618314,"user_type":"unregistered","user_id":15943754,"link":"https://stackoverflow.com/users/15943754/microbeast","reputation":11,"display_name":"microBeast"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1621187690,"creation_date":1621187690,"body":"<p>Another answer already explained why you have problems with <code>0</code> and <code>static</code>.<br />\nBut even with these problems fixed it could be difficult to reproduce partial initialization.<br />\nSo I would recommend you to take a look at the JCStress source code: it contains samples, and one of them (<a href=\"https://github.com/openjdk/jcstress/blob/master/jcstress-samples/src/main/java/org/openjdk/jcstress/samples/JMMSample_06_Finals.java\" rel=\"nofollow noreferrer\">JMMSample_06_Finals</a>) already does what you want.</p>\n","answer_id":67559880,"question_id":67553393},{"owner":{"profile_image":"https://www.gravatar.com/avatar/a4ff8881b435a054cae1f86bfb003958?s=256&d=identicon&r=PG","account_id":21615575,"user_type":"unregistered","user_id":15941436,"link":"https://stackoverflow.com/users/15941436/user","reputation":11,"display_name":"user"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1621165434,"creation_date":1621165434,"body":"<blockquote>\n<p>Now why is it that I see the value 0 in my output ?</p>\n</blockquote>\n<p>These is the case when <code>a == null</code> (and therefore <code>result.r1</code> remains <code>0</code>) in your <code>reader()</code> method.</p>\n<blockquote>\n<p>when I declare the field a as static. I get only 42 as my output, and why is that?</p>\n</blockquote>\n<p>You annotated <code>FinalField</code> with <code>@State</code>, therefore JCStress creates a new instance of <code>FinalField</code> for every execution.<br />\nIf <code>a</code> is an instance field in <code>FinalField</code>, then it is <code>null</code> initially in every execution.<br />\nIf <code>a</code> is a static field in <code>FinalField</code>, then it is shared across all executions and is <code>null</code> only in the first execution.</p>\n","answer_id":67556264,"question_id":67553393},{"owner":{"profile_image":"https://i.stack.imgur.com/V5sYj.jpg?s=256&g=1","account_id":4192718,"user_type":"registered","user_id":3434956,"link":"https://stackoverflow.com/users/3434956/mohsen-nour","reputation":1097,"display_name":"mohsen.nour","accept_rate":95},"content_license":"CC BY-SA 4.0","score":5,"is_accepted":false,"last_activity_date":1620072810,"creation_date":1538895637,"body":"<p>There are 3 scenarios for using a <strong>class helper</strong> like SimpleDateFormat in multithread code, which best one is use <strong>ThreadLocal</strong></p>\n<p>Scenarios</p>\n<p><strong>1-</strong> Using like <strong>share object</strong> by the help of <strong>lock or synchronization</strong> mechanism which makes the app <strong>slow</strong></p>\n<p><strong>Thread pool Scenarios</strong></p>\n<p><strong>2-</strong> Using as a <strong>local  object</strong> inside a method</p>\n<p>In thread pool, in this scenario, if we have <strong>4 thread</strong> each one has <strong>1000 task</strong> time  then we have<br />\n<strong>4000</strong> SimpleDateFormat <strong>object created</strong> and waiting for GC to erase them</p>\n<p><strong>3-</strong> Using <em><strong>ThreadLocal</strong></em></p>\n<p>In thread pool, if we have 4 thread and  we gave to <strong>each thread one SimpleDateFormat instance</strong><br />\nso we have <strong>4 threads</strong>, <strong>4 objects</strong> of SimpleDateFormat.</p>\n<p>There is no need of lock mechanism and object creation and destruction.  (Good time complexity and space complexity)</p>\n<p><a href=\"https://www.youtube.com/watch?v=sjMe9aecW_A\" rel=\"nofollow noreferrer\">https://www.youtube.com/watch?v=sjMe9aecW_A</a></p>\n","answer_id":52686202,"question_id":817856,"last_edit_date":1620072810},{"owner":{"profile_image":"https://www.gravatar.com/avatar/657174380e4f1bcadfffa53971e1c2e0?s=256&d=identicon&r=PG","account_id":8900272,"user_type":"registered","user_id":6643940,"link":"https://stackoverflow.com/users/6643940/h-a-h","reputation":2515,"display_name":"H.A.H."},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1615818656,"creation_date":1615818656,"body":"<p>First I want to point out that other answers are true.\nHowever, using the parameter in the constructor may not be the best idea for all of you.</p>\n<p>In many scenarios you will want to use &quot;Anonymous Inner Class&quot;, and override the <code>run()</code> method, because defining specific class for every use is painful.\n(<code>new MyRunnable(){...}</code>)</p>\n<p>And at the time you create that Runnable, the parameter may not be available to you to pass it in the constructor. If for example, you pass this object to a method, that will perform some work in separate thread and then call your runnable, applying the result from that work to it.</p>\n<p>In that case, using a method like this one:\n<code>public MyRunnable withParameter(Object parameter)</code>, may turn out to be far more useful choice.</p>\n<p>I do not claim that this is the best solution to the problem, but it will get the job done.</p>\n","answer_id":66639916,"question_id":877096},{"owner":{"profile_image":"https://graph.facebook.com/1447473648792894/picture?type=large","account_id":20871327,"user_type":"registered","user_id":15331210,"link":"https://stackoverflow.com/users/15331210/jorge-kasagian","reputation":11,"display_name":"Jorge Kasagian"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1614898390,"creation_date":1614876402,"body":"<p>There is the solution... I create rows into an array... and I use the array in the threads, Tu debes evitar use create rows into a thread because this method is monitored by thread safe</p>\n<p>Sorry, I dont speak english... I am trying too hard.</p>\n<pre><code>static int count=0;\n\n  \n\n    \n    XSSFWorkbook workbook = new XSSFWorkbook();\n    XSSFSheet sheet = workbook.createSheet(&quot;Products&quot;);\n    sheet.createFreezePane(0, 1); // this will freeze first five rows\n    \n    int rowCount = 0;\n    \n    rowCount = getExcelTittle(sucsCompetencia,sucsProveedor, sucsPuntoVenta, sheet, rowCount);  \n\n\n    // trucazo para multithread\n    List&lt;Row&gt; r = new ArrayList&lt;Row&gt;();\n    //List&lt;Drawing&gt; h = new ArrayList&lt;Drawing&gt;();\n    \n    //cell creation\n    for ( int j = 0 ; j &lt; ps.size() + 500 ; j++) {\n        r.add(sheet.createRow(j));\n        //h.add(sheet.createDrawingPatriarch());\n\n    }\n    // cells creation .. its a good idea do it \n    Map&lt;String,Cell&gt; cellMap = new HashMap&lt;String,Cell&gt;();\n    for (int j = 0 ; j &lt; r.size() ; j++) {\n        for ( int  i = 0 ; i &lt; 9 + sucsCompetencia.size() + sucsProveedor.size() + sucsPuntoVenta.size() ; i++) {\n            cellMap.put( j + &quot;-&quot; + i, r.get(j).createCell(i));\n        }\n\n\n    }       \n    \n    Stream&lt;Producto&gt; arrStream = ps.parallelStream();\n    arrStream.forEach(p-&gt;\n                        {   \n                            count++;\n        int contadorPropio = count;\n        \n        if (contadorPropio % 1000 == 0)  log.info(&quot;* Procesando Generacion Excel &quot; + contadorPropio + &quot; de &quot; + ps.size());\n        \n       // if (rowCount == 1000 ) break;\n        \n\n        \n        int columnCount = 0;\n        \n        \n        {\n            //IMPORTANTEEEEEEEE\n            Cell cell = cellMap.get(contadorPropio + &quot;-&quot; + columnCount++); \n            cell.setCellValue(p.getIdProducto());\n        }     \n</code></pre>\n","answer_id":66479401,"question_id":28626848,"last_edit_date":1614898390},{"owner":{"profile_image":"https://i.stack.imgur.com/jTteZ.jpg?s=256&g=1","account_id":6197622,"user_type":"registered","user_id":4828463,"link":"https://stackoverflow.com/users/4828463/faraz","reputation":6095,"display_name":"Faraz","accept_rate":91},"content_license":"CC BY-SA 4.0","score":10,"is_accepted":false,"last_activity_date":1614874382,"creation_date":1483076850,"body":"<p>From <a href=\"http://www.wrox.com/WileyCDA/WroxTitle/Professional-Java-for-Web-Applications.productCd-1118656466.html\" rel=\"nofollow noreferrer\"><em>Professional Java for Web Applications</em> by <em>Nicholas S. Williams</em></a></p>\n<blockquote>\n<p><strong>Using Threads for Transactions and Entity Managers</strong></p>\n</blockquote>\n<blockquote>\n<p>The transaction scope is limited to the thread the transaction begins in. The transaction manager then links the transaction to managed resources used in the same thread during the life of the transaction. When using the <a href=\"https://en.wikipedia.org/wiki/Java_Persistence_API\" rel=\"nofollow noreferrer\">Java Persistence API</a>, the resource you work with is the <a href=\"https://docs.oracle.com/javaee/7/api/javax/persistence/EntityManagerFactory.html\" rel=\"nofollow noreferrer\"><code>EntityManager</code></a>. It is the functional equivalent of Hibernate ORM’s <a href=\"https://docs.jboss.org/hibernate/orm/current/javadocs/org/hibernate/Session.html\" rel=\"nofollow noreferrer\"><code>Session</code></a> and JDBC’s <a href=\"https://docs.oracle.com/javase/8/docs/api/java/sql/Connection.html\" rel=\"nofollow noreferrer\"><code>Connection</code></a>. Normally, you would obtain an <code>EntityManager</code> from the <a href=\"https://docs.oracle.com/javaee/7/api/javax/persistence/EntityManagerFactory.html\" rel=\"nofollow noreferrer\"><code>EntityManagerFactory</code></a> before beginning a transaction and performing JPA actions. However, this does not work with the Spring Framework model of managing transactions on your behalf.\nThe solution to this problem is the <a href=\"https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/orm/jpa/support/SharedEntityManagerBean.html\" rel=\"nofollow noreferrer\"><code>org.springframework.orm.jpa.support.SharedEntityManagerBean</code></a>. When you configure JPA in Spring Framework, it creates a <code>SharedEntityManagerBean</code> that proxies the <code>EntityManager</code> interface. This proxy is then injected into your JPA repositories. When an <code>EntityManager</code> method is invoked on this proxy instance, the following happens in the background:</p>\n</blockquote>\n<blockquote>\n<p>➤➤ If the current thread already has a real <code>EntityManager</code> with an active transaction, it delegates the call to the method on that <code>EntityManager</code>.</p>\n</blockquote>\n<blockquote>\n<p>➤➤ Otherwise, Spring Framework obtains a new <code>EntityManager</code> from the\n<code>EntityManagerFactory</code>, starts a transaction, and binds both to the current thread. It then delegates the call to the method on that <code>EntityManager</code>. When the transaction is either committed or rolled back, Spring unbinds the transaction and the <code>EntityManager</code> from the thread and then closes the <code>EntityManager</code>. Future <code>@Transactional</code> actions on the same thread (even within the same request) start the process over again, obtaining a new <code>EntityManager</code> from the factory and beginning a new transaction. This way, no two threads use an <code>EntityManager</code> at the same time, and a given thread has only one transaction and one <code>EntityManager</code> active at any given time.</p>\n</blockquote>\n<p>(I paraphrased it a little the above piece)</p>\n<p>I think its self explanatory and answers your question. But I would like to add that, if you were not to use <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html\" rel=\"nofollow noreferrer\">Spring MVC</a> then you would have gotten the session using <code>SessionFactory</code> in Hibernate. Hibernate <code>Session</code>s represent the life of a transaction from start to finish. Depending on how your application is architected, that might be less than a second or several minutes; and in a web application, it could be one of several transactions in a request, a transaction lasting an entire request, or a transaction spanning multiple requests. A <code>Session</code>, which is not thread-safe and must be used <strong>only in one thread</strong> at a time, is responsible for managing the state of entities.</p>\n","answer_id":41391268,"question_id":41391209,"last_edit_date":1614874382},{"owner":{"profile_image":"https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG","account_id":47283,"user_type":"registered","user_id":139985,"link":"https://stackoverflow.com/users/139985/stephen-c","reputation":703927,"display_name":"Stephen C","accept_rate":69},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1614853894,"creation_date":1614853474,"body":"<blockquote>\n<p>How do they work.</p>\n</blockquote>\n<p>It is complicated.  There are whole books on this.</p>\n<blockquote>\n<p>do they share the same call stack,</p>\n</blockquote>\n<p>No.  Each thread has its own call stack.</p>\n<blockquote>\n<p>Can somebody please explain in detail how they work under the hook, and what is this parrarelism in multithreading</p>\n</blockquote>\n<p>Seriously, if you don't (yet) understand what parallelism is, you are not (yet) equipped to understand how multithreading works <em>under the hood</em>.</p>\n<p>I suggest that you start by reading the <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/\" rel=\"nofollow noreferrer\">Oracle Java tutorial on concurrency</a>.  Then if you need to understand threads more deeply, buy and read <a href=\"https://rads.stackoverflow.com/amzn/click/com/0321349601\" rel=\"nofollow noreferrer\" rel=\"nofollow noreferrer\">&quot;Java: Concurrency in Practice&quot; by Brian Goetz et al.</a></p>\n<p>When you have read ... and understood ... those things, you should be equipped to learn how threads work under the hood.  But the ability to read C and C++ code would also help, since that's what the JVM is implemented in <em>under the hood</em>.</p>\n","answer_id":66473102,"question_id":66472876,"last_edit_date":1614853894},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c13d09d5694714d174f87e89c18f8694?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6875198,"user_type":"registered","user_id":5283869,"link":"https://stackoverflow.com/users/5283869/gnupinguin","reputation":81,"display_name":"gnupinguin"},"content_license":"CC BY-SA 4.0","score":4,"is_accepted":false,"last_activity_date":1614845933,"creation_date":1614845933,"body":"<p>The bug was fixed for the 11.0.10 Java version.</p>\n","answer_id":66471075,"question_id":54485755},{"owner":{"profile_image":"https://lh3.googleusercontent.com/-3AdCEYHSZg4/AAAAAAAAAAI/AAAAAAAAAGU/_il24uqnDnY/photo.jpg?sz=256","account_id":15883826,"user_type":"registered","user_id":11460835,"link":"https://stackoverflow.com/users/11460835/vaibhav-jain","reputation":1,"display_name":"vaibhav jain"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1614834094,"creation_date":1614834094,"body":"<pre><code>Try this solution.....\n\npublic class Print1To20Using2Thread {\n    public static void main(String[] args) {\n        PrintNumber pn = new PrintNumber(new Object());\n        Thread t1 = new Thread(pn, &quot;First&quot;);\n        Thread t2 = new Thread(pn, &quot;Second&quot;);\n\n        t1.start();\n        t2.start();\n    }\n}\n\nclass PrintNumber implements Runnable {\n\n    Object lock;\n    int i = 0;\n    public PrintNumber(Object lock) {\n        this.lock = lock;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lock) {\n            for (; i &lt;= 20; i++) {\n                if (i == 11) {\n                    try {\n                        lock.wait(1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                System.out.print(&quot; &quot;+Thread.currentThread().getName() + &quot; &quot; + i);\n                lock.notifyAll();\n            }\n            System.out.println();\n        }\n    }\n}\n</code></pre>\n","answer_id":66468855,"question_id":24720849},{"owner":{"profile_image":"https://i.stack.imgur.com/6qIEl.png?s=256&g=1","account_id":330005,"user_type":"registered","user_id":653856,"link":"https://stackoverflow.com/users/653856/raghunandan","reputation":132780,"display_name":"Raghunandan","accept_rate":100},"content_license":"CC BY-SA 4.0","score":4,"is_accepted":true,"last_activity_date":1614821754,"creation_date":1364282387,"body":"<p>AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. <strong>AsyncTasks should ideally be used for short operations (a few seconds at the most.)</strong> If you need to keep <strong>threads running for long periods of time</strong>, it is <strong>highly recommended</strong> you use the various APIs provided by the java.util.concurrent pacakge such as <strong>Executor, ThreadPoolExecutor and FutureTask</strong>. (Straight from the doc).</p>\n<p><a href=\"http://developer.android.com/reference/android/os/AsyncTask.html\" rel=\"nofollow noreferrer\">http://developer.android.com/reference/android/os/AsyncTask.html</a>.</p>\n<p>An alternative to asynctask for long running operations is robospice.</p>\n<p><a href=\"https://github.com/octo-online/robospice\" rel=\"nofollow noreferrer\">https://github.com/octo-online/robospice</a></p>\n<p>Update:</p>\n<p>Asynctask is deprecated using coroutines or any other threading mechanism. Consider suing work manager for defferable jobs.</p>\n","answer_id":15631479,"question_id":15631304,"last_edit_date":1614821754},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b3ec9d9128a25ba6eae8a1d42c2eb04a?s=256&d=identicon&r=PG","account_id":1449510,"user_type":"registered","user_id":1366871,"link":"https://stackoverflow.com/users/1366871/dreamcrash","reputation":48192,"display_name":"dreamcrash","accept_rate":100},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1614793690,"creation_date":1541089673,"body":"<p>What you can do is to intercept the task parameter of the submit and enhanced that task to print what you want:</p>\n<pre><code>Object around(Runnable task) : call(* ExecutorService+.submit(Runnable, ..)) &amp;&amp; args( task)\n{\n    final long parentID = Thread.currentThread().getId();\n    Runnable newTask =  () -&gt; {\n            System.out.println(&quot;Parent Thread Id: &quot;+ parentID);\n            System.out.println(&quot;Child Thread Id: &quot;+Thread.currentThread().getId()); //?? - how to capture child thread id?\n            task.run();\n    };\n    return proceed(newTask);\n}\n</code></pre>\n<p>As soon as the asynchronous task is executed the id of the thread executing it will be print.</p>\n<p>A Running example:</p>\n<p><strong>Main.java:</strong></p>\n<pre><code>public class Main {\n    public static void main(String[] args) {\n        new Test().testExecutorService();\n    }\n}\n</code></pre>\n<p><strong>Test.java:</strong></p>\n<pre><code>public class Test {\n    public void testExecutorService() {\n        ExecutorService service = Executors.newSingleThreadExecutor();\n        service.submit(() -&gt;  System.out.println(&quot;working on the task&quot;));\n        try {\n            service.awaitTermination(2, TimeUnit.SECONDS);\n            service.shutdown();\n        }catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n</code></pre>\n<p><strong>Example.aj</strong></p>\n<pre><code>public aspect Example {\n     \n     Object around(Runnable task) : call(public Future&lt;?&gt; java.util.concurrent.ExecutorService+.submit(Runnable)) \n                        &amp;&amp; args(task)\n     {\n         final long parentID = Thread.currentThread().getId();\n         Runnable newTask =  () -&gt; {\n                 System.out.println(&quot;Parent Thread Id: &quot;+ parentID);\n                 System.out.println(&quot;Child Thread Id: &quot;+Thread.currentThread().getId()); \n                 task.run();\n         };\n         return proceed(newTask);\n     }\n}\n</code></pre>\n","answer_id":53105412,"question_id":53029722,"last_edit_date":1614793690},{"owner":{"profile_image":"https://i.stack.imgur.com/t2hoD.jpg?s=256&g=1","account_id":3211603,"user_type":"registered","user_id":2711488,"link":"https://stackoverflow.com/users/2711488/holger","reputation":289317,"display_name":"Holger"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":true,"last_activity_date":1614778466,"creation_date":1614778466,"body":"<p>When you set the thread local variable to an instance of <code>Bar</code>, the value has an implicit reference to its defining class loader, which is also the defining class loader of <code>Foo</code> and hence, has an implicit reference to its <code>static</code> variable <code>tl</code> holding the <code>ThreadLocal</code>.</p>\n<p>In contrast, the <code>String</code> class is defined by the bootstrap loader and has no implicit reference to the the <code>Foo</code> class.</p>\n<p>Now, a reference cycle is not preventing garbage collection per se. If only one object holds a reference to a member of the cycle and that object becomes unreachable, the entire cycle would become unreachable. The problem here is that the object still referencing the cycle is the <code>Thread</code> that is still alive.</p>\n<p>The specific value is associated with the combination of a <code>ThreadLocal</code> instance and a <code>Thread</code> instance and we’d wish that if <em>either</em> of them becomes unreachable, it would stop referencing the value. Unfortunately, no such feature exists. We can only associate a value with the reachability of one object, like with the key of a <code>WeakHashMap</code>, but not of two.</p>\n<p>In the OpenJDK implementation, the <code>Thread</code> is the owner of this construct, which makes it immune against values back-referencing the <code>Thread</code>. E.g.</p>\n<pre class=\"lang-java prettyprint-override\"><code>ThreadLocal&lt;Thread&gt; local = new ThreadLocal&lt;&gt;();\n\nReferenceQueue&lt;Thread&gt; q = new ReferenceQueue&lt;&gt;();\n\nSet&lt;Reference&lt;?&gt;&gt; refs = ConcurrentHashMap.newKeySet();\n\nnew Thread(() -&gt; {\n    Thread t = Thread.currentThread();\n    local.set(t);\n    refs.add(new WeakReference&lt;&gt;(t, q));\n}).start();\n\nReference&lt;?&gt; r;\nwhile((r = q.remove(2000)) == null) {\n    System.gc();\n}\n\nif(refs.remove(r)) System.out.println(&quot;Collected&quot;);\nelse System.out.println(&quot;Something very suspicuous is going on&quot;);\n</code></pre>\n<p>This will print <code>Collected</code>, indicating that the reference from the value to the <code>Thread</code> did not prevent the removal, unlike <code>put(t, t)</code> on a <code>WeakHashMap</code>.</p>\n<p>The price is that this construct is not immune against backreferences to the <code>ThreadLocal</code> instance.</p>\n<pre class=\"lang-java prettyprint-override\"><code>ReferenceQueue&lt;Object&gt; q = new ReferenceQueue&lt;&gt;();\n\nSet&lt;Reference&lt;?&gt;&gt; refs = ConcurrentHashMap.newKeySet();\n\ncreateThreadLocal(refs, q);\n\nReference&lt;?&gt; r;\nwhile((r = q.remove(2000)) == null) {\n    System.gc();\n}\n\nif(refs.remove(r)) System.out.println(&quot;Collected&quot;);\nelse System.out.println(&quot;Something very suspicuous is going on&quot;);\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>static void createThreadLocal(Set&lt;Reference&lt;?&gt;&gt; refs, ReferenceQueue&lt;Object&gt; q) {\n    ThreadLocal&lt;ThreadLocal&lt;?&gt;&gt; local = new ThreadLocal&lt;&gt;();\n    local.set(local);\n    refs.add(new WeakReference&lt;&gt;(local, q));\n}\n</code></pre>\n<p>This will hang forever, as the backreference from the <code>ThreadLocal</code> to itself prevents its garbage collection, as long as the associated thread is still alive.</p>\n<p>Your case is just a special variant of it, as the backreference is through the <code>Bar</code> instance, its defining loader, to <code>Foo</code>’s <code>static</code> variable. But the principle is the same.</p>\n<p>You only need to change the line</p>\n<pre class=\"lang-java prettyprint-override\"><code>loadClass();\n</code></pre>\n<p>to</p>\n<pre class=\"lang-java prettyprint-override\"><code>new Thread(new FutureTask(() -&gt; { loadClass(); return null; })).start();\n</code></pre>\n<p>to stop the value from being associated with the main thread. Then, the class loader and all associated classes and instances get garbage collected.</p>\n","answer_id":66458166,"question_id":66452567},{"owner":{"profile_image":"https://i.stack.imgur.com/SsTc7.jpg?s=256&g=1","account_id":2305297,"user_type":"registered","user_id":2024692,"link":"https://stackoverflow.com/users/2024692/cromax","reputation":1882,"display_name":"Cromax","accept_rate":100},"content_license":"CC BY-SA 4.0","score":34,"is_accepted":false,"last_activity_date":1610752470,"creation_date":1472503229,"body":"<p>This answer comes very late, but maybe someone will find it useful. It is about how to pass a parameter(s) to a <code>Runnable</code> without even declaring named class (handy for inliners):</p>\n<pre class=\"lang-java prettyprint-override\"><code>    String someValue = &quot;Just a demo, really...&quot;;\n\n    new Thread(new Runnable() {\n        private String myParam;\n\n        public Runnable init(String myParam) {\n            this.myParam = myParam;\n            return this;\n        }\n\n        @Override\n        public void run() {\n            System.out.println(&quot;This is called from another thread.&quot;);\n            System.out.println(this.myParam);\n        }\n    }.init(someValue)).start();\n</code></pre>\n<p>Of course you can postpone execution of <code>start</code> to some more convenient or appropriate moment. And it is up to you what will be the signature of <code>init</code> method (so it may take more and/or different arguments) and of course even its name, but basically you get an idea.</p>\n<p>In fact there is also another way of passing a parameter to an anonymous class, with the use of the initializer blocks. Consider this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>    String someValue = &quot;Another demo, no serious thing...&quot;;\n    int anotherValue = 42;\n\n    new Thread(new Runnable() {\n        private String myParam;\n        private int myOtherParam;\n        // instance initializer\n        {\n            this.myParam = someValue;\n            this.myOtherParam = anotherValue;\n        }\n\n        @Override\n        public void run() {\n            System.out.println(&quot;This comes from another thread.&quot;);\n            System.out.println(this.myParam + &quot;, &quot; + this.myOtherParam);\n        }\n    }).start();\n</code></pre>\n<p>So all happens inside of the initializer block.</p>\n","answer_id":39214833,"question_id":877096,"last_edit_date":1610752470},{"owner":{"profile_image":"https://www.gravatar.com/avatar/224c1fc80ce88c3e0f59f420ce575043?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":5378847,"user_type":"registered","user_id":4284764,"link":"https://stackoverflow.com/users/4284764/gerard-martinelli","reputation":39,"display_name":"Gerard Martinelli"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1608715032,"creation_date":1608715032,"body":"<p>I think I have resolved my concern.  In the JDialog ContenPane, I have created a JButton  with an actionListener, then before leaving the run method, I issue a doClic().  This execute what I want (for example return to the caller).  It works perfectly.</p>\n","answer_id":65421769,"question_id":65407356},{"owner":{"profile_image":"https://www.gravatar.com/avatar/8cf8627c2f497949547cadc02c52b95f?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":4034876,"user_type":"registered","user_id":3319725,"link":"https://stackoverflow.com/users/3319725/anatolyg","reputation":1557,"display_name":"AnatolyG"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1608649600,"creation_date":1608647818,"body":"<p>An ad-hock implementation of such step-by-step scenario may be based on CountDownLatch primitive like following:</p>\n<pre><code>import java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\n\npublic class FooOrchestration {\n    public static class Foo {\n        public void first() { print(&quot;first&quot;); }\n        public void second() { print(&quot;second&quot;); }\n        public void third() { print(&quot;third&quot;); }\n    }\n\n    static void print(String text) {\n        System.out.println(text);\n    }\n\n    static class Step extends Thread {\n        private final CountDownLatch starter = new CountDownLatch(1);\n        private final List&lt;Step&gt; nextSteps = new ArrayList&lt;&gt;();\n        private final Runnable action;\n\n        Step(final Runnable action) {\n            this.action = action;\n        }\n\n        @Override\n        public void run() {\n            try {\n                starter.await(); // wait until someone kicks the starter with countDown()\n                action.run();\n                for (Step s : nextSteps) { // let's start the following steps\n                    s.starter.countDown();\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                for (Step s : nextSteps) { // let's propagate \n                    s.interrupt(); // the interruption\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws Throwable {\n        Foo foo = new Foo();\n\n        Step firstStep = new Step(() -&gt; foo.first());\n        Step secondStep = new Step(() -&gt; foo.second());\n        Step thirdStep = new Step(() -&gt; foo.third());\n\n        firstStep.nextSteps.add(secondStep); // set sequence\n        secondStep.nextSteps.add(thirdStep); // of execution\n\n        thirdStep.start(); // order of start\n        secondStep.start(); // doesn't\n        firstStep.start(); // matter\n\n        firstStep.starter.countDown(); // kick the starterof the first step\n    }\n}\n</code></pre>\n<p>Also, the standard package java.concurrent provides more generic and flexible barrier Phaser <a href=\"https://www.baeldung.com/java-phaser\" rel=\"nofollow noreferrer\">https://www.baeldung.com/java-phaser</a> which allows to build different and complex scenarios of multi-threading executions easily.</p>\n","answer_id":65410571,"question_id":65382129,"last_edit_date":1608649600},{"owner":{"profile_image":"https://www.gravatar.com/avatar/ec430cc01ef4cf4ae63ebbe9e8596f72?s=256&d=identicon&r=PG","account_id":1547313,"user_type":"registered","user_id":1440565,"link":"https://stackoverflow.com/users/1440565/code-apprentice","reputation":82164,"display_name":"Code-Apprentice","accept_rate":59},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1608573471,"creation_date":1608569661,"body":"<p>You are correct. If two threads lock the same object, then one of the threads will block, which doesn't help with performance. If on the other hand, the two threads can run completely independently of each other, then there is a huge performance gain.</p>\n","answer_id":65396827,"question_id":65396228,"last_edit_date":1608573471},{"owner":{"profile_image":"https://i.stack.imgur.com/2VjzX.jpg?s=256&g=1","account_id":6696437,"user_type":"registered","user_id":5164318,"link":"https://stackoverflow.com/users/5164318/emandt","reputation":2557,"display_name":"emandt"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1608566738,"creation_date":1608566738,"body":"<p>You need something similar to:</p>\n<pre><code>/** Class for Synchronize two Threads */\nprivate static class SyncObj&lt;T&gt; {\n    @Nullable\n    private T mValue = null;\n    public SyncObj(@Nullable final T initValue) { this.mValue = initValue; }\n    public void set(@Nullable final T value) { this.mValue = value; }\n    @Nullable\n    public T get() { return this.mValue; }\n}\n\n/** A Thread is used instead of {@link AsyncPost} */\nprivate class AsyncPost extends Thread {\n    private Handler mAsyncPostHandler;\n    private final Handler mMainThreadHandler;\n    private boolean mOnPreExecuted = false;\n    public AsyncPost() {\n        mMainThreadHandler = new Handler(Looper.getMainLooper()) {\n            @UiThread @MainThread\n            @Override\n            public void handleMessage(@NonNull final Message message) {\n                switch (message.what) {\n                    case 111: {\n                        @Nullable\n                        final String cRequestText = (String)message.obj;\n                        if (cRequestText == null) break;\n                        dialog.setMessage(cRequestText);\n                        break;\n                    }\n                    default: { }    //all Runnables sent to &quot;mMainThreadHandler&quot; are executed &quot;here&quot;\n                }\n            }\n        };\n    }\n    @WorkerThread\n    @Override\n    public void run() {\n        Looper.prepare();\n        mAsyncPostHandler = new Handler(Looper.myLooper()) {\n            @Override\n            public void handleMessage(@NonNull final Message message) {\n                switch (message.what) {\n                    case -1: {\n                        final Looper cMyLooper = Looper.myLooper();\n                        if (cMyLooper != null) cMyLooper.quit();\n                        break;\n                    }\n                    case 555: {\n                        if (!mOnPreExecuted) {\n                                //esecuted on Main/UIThread at first API Request...\n                            OnMainThreadRun(new Runnable() {    //SAME AS &quot;onPreExecute()&quot;\n                                @Override\n                                public void run() { dialog = ProgressDialog.show(Sync_Bulk.this, &quot;&quot;, &quot;&quot;); }\n                            });\n                            mOnPreExecuted = true;\n                        }\n                        final List&lt;?&gt; cList = (List&lt;?&gt;)message.obj;\n                        if (cList == null) break;\n                        final SyncObj&lt;String&gt; cSyncObj = new SyncObj&lt;&gt;(null);\n                            //loop through the List\n                        @Nullable\n                        String cRequesteResult;\n                        for (final Object cItem : cList) {\n                                //call API Request for each item in the List...\n                            postRequest(cSyncObj, cItem);\n                            try {\n                                    //...wait until &quot;notify()&quot; is called\n                                synchronized (cSyncObj) {\n                                        //loop until &quot;SyncObj.set()&quot; was called with a valid Value\n                                    while ((cRequesteResult = cSyncObj.get()) == null) cSyncObj.wait();\n                                        //check SyncObj result\n                                    if (cRequesteResult.equals(&quot;OK&quot;)) {\n                                        Log.i(&quot;MainActivity&quot;, &quot;Request successfully&quot;);\n                                    } else {\n                                        Log.w(&quot;MainActivity&quot;, &quot;Request failed: &quot; + cRequesteResult);\n                                    }\n                                        //update the Dialog on Main/UIThread\n                                    OnProgressUpdate(cRequesteResult);\n                                }\n                            } catch (Exception e) {\n                                Log.e(&quot;MainActivity&quot;, &quot;Stopping all Request due to Exception: &quot; + e.getMessage());\n                            }\n                        }\n                            //terminate this Thread\n                        postToAsyncThread_Quit();\n                        break;\n                    }\n                }\n            }\n        };\n        Looper.loop();\n        this.OnMainThreadRun(new Runnable() {   //SAME AS &quot;OnPostExecute()&quot;\n            @Override\n            public void run() {\n                ..executed on Main/UIThread at the end of all..\n            }\n        });\n    }\n    /** Execute a {@link Runnable} on MainThread/UiThread */\n    @WorkerThread\n    private void OnMainThreadRun(@Nullable final Runnable runnable) {\n        if (runnable == null) return;\n        mMainThreadHandler.post(runnable);\n    }\n    @AnyThread\n    private void OnProgressUpdate(@Nullable final String text) { mMainThreadHandler.sendMessage(Message.obtain(mMainThreadHandler, 111, text)); }\n    /** Execute a {@link Runnable} on {@link AsyncPost} Thread */\n    @AnyThread\n    private void postToAsyncThread_DoRequests(@Nullable final List&lt;?&gt; list) { mAsyncPostHandler.sendMessage(Message.obtain(mAsyncPostHandler, 555, list)); }\n    /** Terminate {@link AsyncPost} Thread */\n    @AnyThread\n    private void postToAsyncThread_Quit() { mAsyncPostHandler.sendEmptyMessage(-1); }\n}\n\nprivate void postRequest(final SyncObj&lt;String&gt; syncObj, @NonNull final Object listItem) {\n        //execute API Request which will trigger one of Listener methods\n    doAsyncRequest(listItem, new ResponseListener() {\n        @Override\n        void onSuccess() {\n            synchronized (syncObj) {\n                syncObj.set(&quot;OK&quot;);\n                syncObj.notify();\n            }\n        }\n        @Override\n        void onFailed() {\n            synchronized (syncObj) {\n                syncObj.set(&quot;ERROR&quot;);\n                syncObj.notify();\n            }\n        }\n    });\n}\n\nprivate void doAllRequests(@Nullable final List&lt;?&gt; list) {\n    final AsyncPost cAsyncPost = new AsyncPost();\n    cAsyncPost.start();\n    cAsyncPost.postToAsyncThread_DoRequests(list);\n}\n</code></pre>\n<p>Just call &quot;doAllRequests(...)&quot; providing the appropriate List.\nA single &quot;OnPreExecute()&quot;-like will be executed at first API call and a single &quot;OnPostExecute()&quot;-like will be executed at the end of last APi call.\nAt each API Call (success or fail) &quot;case 111:&quot; will be called from the Main/UIThread.</p>\n","answer_id":65396071,"question_id":65393915},{"owner":{"profile_image":"https://i.stack.imgur.com/bh9Vd.png?s=256&g=1","account_id":16559,"user_type":"registered","user_id":36223,"link":"https://stackoverflow.com/users/36223/daveb","reputation":1856,"display_name":"DaveB"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1608564725,"creation_date":1608564725,"body":"<p>Using Platform.runLater() in a background thread is kind of a messy kludge that should probably be avoided.  JavaFX has mechanisms to handle this kind of thing which you should use.  Specifically, Task&lt;&gt; is designed to allow background threads to update data which is connected to JavaFX screen elements which need to be updated on the FXAT.</p>\n<p>You CAN do what you're trying to do with a JavaFX Task, but using  the Java Timer inside of it seems impossible, since there doesn't seem to be any way for a Java thread to wait on a Timer to complete.  So, instead I've used a &quot;for&quot; loop with a sleep to do the same thing.  It's clumsy, but it does demonstrate how to connect partial results from a Task to screen display:</p>\n<pre><code>public class Sample1 extends Application {\n\n    public static void main(String[] args) {\n        launch(args);\n    }\n\n    @Override\n    public void start(Stage primaryStage) {\n        Scene scene = new Scene(new Timer1(), 300, 200);\n        primaryStage.setScene(scene);\n        primaryStage.show();\n    }\n}\n\npublic class Timer1 extends VBox {\n\n    public Timer1() {\n        Text time = new Text();\n        Button startButton = new Button(&quot;Start&quot;);\n        Button stopButton = new Button(&quot;Stop&quot;);\n        getChildren().addAll(time, startButton, stopButton);\n        startButton.setOnAction(startEvt -&gt; {\n            Task&lt;Integer&gt; timerFxTask = new Task&lt;&gt;() {\n\n                {\n                    updateValue(0);\n                }\n\n                @Override\n                protected Integer call() throws Exception {\n                    for (int counter = 0; counter &lt;= 1000; counter++) {\n                        sleep(1000);\n                        updateValue(counter);\n                    }\n                    return 1000;\n                }\n            };\n            stopButton.setOnAction(stopEvt -&gt; timerFxTask.cancel());\n            time.textProperty().bind(Bindings.createStringBinding(() -&gt; timerFxTask.getValue().toString(),\n                    timerFxTask.valueProperty()));\n            Thread timerThread = new Thread(timerFxTask);\n            timerThread.start();\n        });\n    }\n}\n</code></pre>\n<p>But there is a better way to do what you're trying to do, which is essentially an animation - and JavaFX has a facility to do exactly this.  Usually, people use animations to morph the appearance of JavaFX screen elements, but you can also use it to animate the contents of a Text over time as well.  What I've done here is create an IntegerProperty which can be transitioned from a start value to an end value interpolated linearly over time and then bound that value to the TextProperty of a Text on the screen.  So you see it update once per second.</p>\n<pre><code>public class Sample1 extends Application {\n\n    public static void main(String[] args) {\n        launch(args);\n    }\n\n    @Override\n    public void start(Stage primaryStage) {\n        Scene scene = new Scene(new Timer2(), 300, 200);\n        primaryStage.setScene(scene);\n        primaryStage.show();\n    }\n}\n\npublic class Timer2 extends VBox {\n\n    public Timer2() {\n        Text time = new Text();\n        Button startButton = new Button(&quot;Start&quot;);\n        Button stopButton = new Button(&quot;Stop&quot;);\n        getChildren().addAll(time, startButton, stopButton);\n        startButton.setOnAction(startEvt -&gt; {\n            IntegerProperty counter = new SimpleIntegerProperty(0);\n            Timeline timeline = new Timeline(new KeyFrame(Duration.seconds(1000), new KeyValue(counter, 1000)));\n            stopButton.setOnAction(stopEvt -&gt; timeline.stop());\n            time.textProperty().bind(Bindings.createStringBinding(() -&gt; Integer.toString(counter.get()), counter));\n            timeline.play();\n        });\n    }\n}\n</code></pre>\n","answer_id":65395539,"question_id":65391501},{"owner":{"profile_image":"https://www.gravatar.com/avatar/6b2c535fac79e482b71f15de561f55ca?s=256&d=identicon&r=PG","account_id":60171,"user_type":"registered","user_id":179850,"link":"https://stackoverflow.com/users/179850/gray","reputation":115485,"display_name":"Gray","accept_rate":100},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1608555694,"creation_date":1608396600,"body":"<blockquote>\n<p>Does the value of AtomicReference will be set lazily if we assign a function to it which returns some array?</p>\n</blockquote>\n<p>First off, <code>AtomicReference.set()</code> is immediate and in no ways lazy.  If we look at your code, we see that <code>someFunc()</code> returns an <code>ArrayList</code> so this will be set immediately into <code>atomicStrings</code>.  Unfortunately, the strings are added to the list by another thread and there is no synchronization between the main thread, that is running <code>someFunc()</code> and creating the list, and the thread that is adding the strings to the list.  Anytime two different threads are accessing the same object, and especially mutating that object, you need to worry about mutex (race conditions) and memory synchronization.</p>\n<p>One thing you could use to fix your specific issue is to use a <code>BlockingQueue</code> which is a synchronized class instead of an <code>ArrayList</code>.  <code>BlockingQueue</code> take care of all of the memory synchronization and mutex locking to ensure that accesses from multiple threads are done appropriately.</p>\n<pre><code>BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;();\n</code></pre>\n<p>Then, when the inner thread calls <code>queue.add(&quot;a&quot;);</code> and then after the 10 seconds expire the main thread calls <code>queue.iterator()</code>, they will see the same collection of strings.  There is no need for the <code>AtomicReference</code> because the atomic class the main and the inner threads will be sharing is the <code>ArrayBlockingQueue </code>.</p>\n","answer_id":65372167,"question_id":65363568,"last_edit_date":1608555694},{"owner":{"profile_image":"https://www.gravatar.com/avatar/166994c436c6a1d69ee7af86f727d57f?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":14704600,"user_type":"registered","user_id":10619713,"link":"https://stackoverflow.com/users/10619713/jakob-tinhofer","reputation":345,"display_name":"Jakob Tinhofer"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1608551014,"creation_date":1608549117,"body":"<p>Ok, my comments are too long. This is how I would try to do it.</p>\n<ol>\n<li>Start the stopwatch on the application being loaded</li>\n<li>Create a new thread that launches itself every so often.</li>\n<li>Inside there, get the time from the Stopwatch in seconds (<code>sw.getTime(TimeUntis.seconds)</code>). Convert that to hours and minutes if you want <a href=\"https://stackoverflow.com/questions/6118922/convert-seconds-value-to-hours-minutes-seconds#:%7E:text=hours%20%3D%20totalSecs%20%2F%203600%3B%20minutes,%2C%20hours%2C%20minutes%2C%20seconds\">like shown in this SO post</a></li>\n<li>Then, write the time to the UI using <code>Platform.runLater(new Runnable(){ /* access ui element and write time here */ });</code></li>\n</ol>\n","answer_id":65391726,"question_id":65391501,"last_edit_date":1608551014},{"owner":{"profile_image":"https://www.gravatar.com/avatar/dd818daa34685a9be777abbadd91e4a1?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8666186,"user_type":"registered","user_id":6486622,"link":"https://stackoverflow.com/users/6486622/denis-zavedeev","reputation":7757,"display_name":"Denis Zavedeev"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1608485238,"creation_date":1608484458,"body":"<p>I guess, it is a problem from <a href=\"https://leetcode.com/problems/print-in-order/\" rel=\"nofollow noreferrer\">leetcode</a>.</p>\n<blockquote>\n<p>Currently I don't understand how to pass <code>Runnable</code> object to the synchronized methods (it's one the task conditions):</p>\n</blockquote>\n<p>The <code>runnable</code> could look like:</p>\n<pre><code>private static class PrintingRunnable implements Runnable {\n\n    private final String string;\n\n    public PrintingRunnable(String string) {\n        this.string = string;\n    }\n\n    @Override\n    public void run() {\n        System.out.print(string);\n    }\n}\n</code></pre>\n<p>and passed as:</p>\n<pre><code>foo.first(new PrintingRunnable(&quot;first&quot;));\nfoo.second(new PrintingRunnable(&quot;second&quot;));\nfoo.third(new PrintingRunnable(&quot;third&quot;));\n</code></pre>\n<hr />\n<p>Please note, that you are <strong>not required</strong> to supply your own <code>Runnable</code>s, or create <code>Thread</code>s to solve the problem, just implement the <code>first</code>, <code>second</code>, and <code>third</code> methods.</p>\n<hr />\n<p>In Java, <code>Runnable</code> is <em>nothing more</em> than some action that could be <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runnable.html#run()\" rel=\"nofollow noreferrer\"><code>run</code></a>. It may print something, or do anything else.</p>\n<p>It is possible that leetcode <strong>does not really print anything</strong>, but uses <em>something different to test submissions</em>. (And it does not matter for someone, who tries to solve the problem)</p>\n<p>But if you want to do it locally you can use the <code>PrintingRunnable</code> above:</p>\n<pre><code>public static void main(String[] args) throws InterruptedException {\n    Foo foo = new Foo();\n\n\n    new Thread(() -&gt; {\n        try {\n            foo.third(new PrintingRunnable(&quot;third&quot;));\n        } catch (InterruptedException exception) {\n            exception.printStackTrace();\n        }\n    }).start();\n    new Thread(() -&gt; {\n        try {\n            foo.first(new PrintingRunnable(&quot;first&quot;));\n        } catch (InterruptedException exception) {\n            exception.printStackTrace();\n        }\n    }).start();\n    new Thread(() -&gt; {\n        try {\n            foo.second(new PrintingRunnable(&quot;second&quot;));\n        } catch (InterruptedException exception) {\n            exception.printStackTrace();\n        }\n    }).start();\n}\n</code></pre>\n","answer_id":65382608,"question_id":65382129,"last_edit_date":1608485238},{"owner":{"profile_image":"https://i.stack.imgur.com/DLHqU.png?s=256&g=1","account_id":1223835,"user_type":"registered","user_id":1189885,"link":"https://stackoverflow.com/users/1189885/chrylis-cautiouslyoptimistic","reputation":75888,"display_name":"chrylis -cautiouslyoptimistic-","accept_rate":43},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":true,"last_activity_date":1608323859,"creation_date":1608323859,"body":"<p>You aren't &quot;assigning a function&quot; to it, you're <em>immediately evaluating</em> <code>someFunc</code> and placing the value (a reference to the list) in the <code>AtomicReference</code>.</p>\n<p>The atomic classes have special <em>happens-before</em> constraints, so anything that happens to the list in <code>someFunc</code> is guaranteed to be visible to anyone who retrieves the list from the reference, but your modifications to the list in your spawned thread have no <em>happens-before</em> relationship to the rest of your program. The behavior is undefined, up to and including <code>ConcurrentModificationException</code>.</p>\n","answer_id":65363616,"question_id":65363568},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG","account_id":2518243,"user_type":"registered","user_id":2189127,"link":"https://stackoverflow.com/users/2189127/james-d","reputation":203472,"display_name":"James_D"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1608232320,"creation_date":1608232320,"body":"<p>You can use a <a href=\"https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/CompletableFuture.html\" rel=\"nofollow noreferrer\"><code>CompletableFuture</code></a>:</p>\n<pre><code>public class USBDevice {\n    public Task&lt;Void&gt; readData() {\n        return new Task&lt;Void&gt;() {\n            @Override\n            protected Void call() throws Exception {\n\n                CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; {\n                    //read data through usb device and add it into array;\n                });\n                try {\n                    future.get(10, TimeUnit.SECONDS);\n                    // get here if read was successful\n                } catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                } catch (ExecutionException ee) {\n                    // exception was thrown by code reading usb device\n                } catch (TimeoutException te) {\n                    // timeout occurred\n                }\n                return null;\n            }\n        };\n    }\n}\n</code></pre>\n","answer_id":65346950,"question_id":65344341},{"owner":{"profile_image":"https://www.gravatar.com/avatar/2fe75f2132e516dbf8ee6de0097d765e?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":9374511,"user_type":"registered","user_id":8471807,"link":"https://stackoverflow.com/users/8471807/sachin-pete","reputation":21,"display_name":"Sachin Pete"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1603023508,"creation_date":1602962164,"body":"<pre><code>public class Print1To20 {\n\n    int couter=0;\n    static int N;\n\n    public void preven(){\n        synchronized (this) {\n            while(couter&lt;N) {\n                while(couter%2==0) {\n                    try {\n                        wait();\n                    } catch(Exception e) {\n                    }\n                    System.out.println(Thread.currentThread().getName()+&quot;:&quot;+couter);\n                }\n                couter++;\n                notify();\n            }\n        }\n    }\n    public void prodd(){\n        synchronized (this) {\n            while(couter&lt;N) {\n                while(couter%2==1) {\n                    try {\n                        wait();\n                    } catch(Exception e) {\n                    }\n                    System.out.println(Thread.currentThread().getName()+&quot;:&quot;+couter);\n                }\n                couter++;\n                notify();\n            }\n        }\n    }\n    \n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n\n        //  Thread t1= new Th;\n\n        //Thread t2= new Thread(new PrintOdd());\n\n        N=20;\n        Print1To20 pt= new Print1To20();\n        Thread t1= new Thread(new Runnable() {\n            @Override\n            public void run() {\n                // TODO Auto-generated method stub\n                pt.preven();\n            }\n        });\n\n        Thread t2= new Thread(new Runnable() {\n            @Override\n            public void run() {\n                // TODO Auto-generated method stub\n                pt.prodd();\n            }\n        });\n        t1.start();\n        t2.start();\n    }\n}\n</code></pre>\n<p>Ref: Reference taken from GeekforGeeks</p>\n","answer_id":64406380,"question_id":24720849,"last_edit_date":1603023508},{"owner":{"profile_image":"https://i.stack.imgur.com/o4wOg.jpg?s=256&g=1","account_id":3294086,"user_type":"registered","user_id":2771717,"link":"https://stackoverflow.com/users/2771717/autocrab","reputation":3607,"display_name":"Autocrab"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1602654131,"creation_date":1602654131,"body":"<p>It appears that your <code>runOnUiThread</code> code invokes after activity gets destroyed.</p>\n<p>You should check if activity is destroyed:</p>\n<pre><code>        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                final String folderSize = calculateFolderSize(); // my work\n                runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        if (!isDestroyed())\n                            textView.setText(folderSize + &quot; GB&quot;);\n                    }\n                });\n            }\n        });\n        thread.start();\n</code></pre>\n","answer_id":64347286,"question_id":64346783},{"owner":{"profile_image":"https://www.gravatar.com/avatar/54af3ad01b032767b05a7e98fede6d6e?s=256&d=identicon&r=PG","account_id":2360785,"user_type":"registered","user_id":2067492,"link":"https://stackoverflow.com/users/2067492/matt","reputation":11123,"display_name":"matt"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1601634137,"creation_date":1601630447,"body":"<p>Can we think of the arrow as a resource?</p>\n<pre><code>import java.util.concurrent.*;\n\n\npublic class Bowmen implements Runnable{\n    String name;\n    Bowmen target;\n    SynchronousQueue&lt;Object&gt; queue = new SynchronousQueue&lt;&gt;();\n    public Bowmen(String name){\n        this.name = name;\n    }\n    \n    public void shoot(String name, Object o) throws InterruptedException{\n        System.out.println(this.name + &quot; : &quot; + name + &quot; shot me.&quot;);\n        queue.put(o);\n    }\n    \n    public void run(){\n        try{\n            Object o = queue.take();\n            System.out.println(this.name + &quot; : I will shoot &quot; + target.name);\n            target.shoot(name, o);\n        } catch(InterruptedException e){\n            //just finish.\n        }\n    }\n    public void setTarget(Bowmen t){\n        target = t;\n    }\n    \n    public static void main(String[] args) throws Exception{\n        \n        Bowmen a = new Bowmen(&quot;a&quot;);\n        Bowmen b = new Bowmen(&quot;b&quot;);\n        \n        a.setTarget(b);\n        b.setTarget(a);\n        \n        for(int i = 0; i&lt;5; i++){\n            new Thread(a).start();\n            new Thread(b).start();\n        }\n        //all the threads are waiting because there is no resource to share yet.\n        a.shoot( null, new Object() );\n    }\n\n}\n</code></pre>\n<p>This will produce output</p>\n<blockquote>\n<p>a : null shot me.<br />\na : I will shoot b<br />\nb : a shot me.<br />\nb : I will shoot a<br />\n...</p>\n</blockquote>\n<p>It will end with &quot;a : b shot me.&quot; but the program will not finish because there isn't a thread taking from the queue to let the last call to shoot finish.</p>\n","answer_id":64169128,"question_id":64163535,"last_edit_date":1601634137},{"owner":{"profile_image":"https://www.gravatar.com/avatar/8a60e0393575feef649748f8f2e95c62?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6925906,"user_type":"registered","user_id":5317000,"link":"https://stackoverflow.com/users/5317000/suresh-mahalingam","reputation":95,"display_name":"Suresh Mahalingam"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1601563360,"creation_date":1600067590,"body":"<p>A round robin among N producers can be achieved using a PriorityBlockingQueue as follows.</p>\n<p>Maintain N AtomicInteger counters for each of the producers and a global counter as a tie breaker in case the producer counters are equal.</p>\n<p>When adding to the Q incement counter for the producer and also global counter and store into Q object. The comparator for Q will order based on Producer counter 1st and then the global counter value stored in the Q object.</p>\n<p>However when objects of one producer is empty for sometime in the Q the corresponding counter falls behind and it will start hogging the Q when objects start coming in.</p>\n<p>To avoid this maintain a volatile variable which is updated with the producer counter of the object when de-queued. After incrementing the producer counter during en-queue if the value is less than the last de-queued counter in volatile variable reset the counter to that value + 1.</p>\n","answer_id":63879647,"question_id":27737781,"last_edit_date":1601563360},{"owner":{"profile_image":"https://www.gravatar.com/avatar/16b7172bb346958c1b69e0229ba1ac4f?s=256&d=identicon&r=PG","account_id":1723085,"user_type":"registered","user_id":1578356,"link":"https://stackoverflow.com/users/1578356/newday","reputation":3842,"display_name":"newday","accept_rate":63},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1601527340,"creation_date":1601527340,"body":"<p>after using the get(1, TimeUnit.SECONDS); I started to see improvement on the server side as well (Reaching the threads less than 1 second) since we are not waiting more than 1 second on the client side.</p>\n<pre><code>while (true) {\n    clientMonitorServicesMap.forEach((k, v) -&gt; {\n      Future&lt;Boolean&gt; val = scheduledExecutorService.submit(new PollService(k));\n      try {\n        boolean result = val.get(1, TimeUnit.SECONDS);\n        System.out.println(&quot;service &quot; + k.getHost() + &quot;:&quot; + k.getPort() + &quot;status is &quot; + result);\n        if (result) {\n          List&lt;ClientMonitorService&gt; list = v.stream()\n                  //.filter(a -&gt; LocalDateTime.now().getSecond() % a.getServiceToMonitor().getFreqSec() == 0)\n                  .collect(Collectors.toList());\n          list.stream().forEach(a -&gt; System.out.println(a.getClientId()));\n        }\n\n      } catch (InterruptedException e) {\n       logger.log(Level.WARNING,&quot;Interrupted -&gt; &quot; + k.getHost()+&quot;:&quot;+k.getPort());\n      } catch (ExecutionException e) {\n        logger.log(Level.INFO,&quot;ExecutionException exception -&gt; &quot;+ k.getHost()+&quot;:&quot;+k.getPort());\n      } catch (TimeoutException e) {\n        logger.log(Level.INFO,&quot;TimeoutException exception -&gt; &quot;+ k.getHost()+&quot;:&quot;+k.getPort());\n      }\n\n    });\n  }\n</code></pre>\n","answer_id":64149186,"question_id":64112611},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG","account_id":401843,"user_type":"registered","user_id":768644,"link":"https://stackoverflow.com/users/768644/rzwitserloot","reputation":89863,"display_name":"rzwitserloot"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1601482101,"creation_date":1601482101,"body":"<p>The answer is non-trivial; the fact that there is a parent/child relationship between the threads is itself misleading. Threads don't as a rule care or get any special relationship with the thread that spawned it at all.</p>\n<p>Thus, the answer is a mix of: &quot;Parent/Child? I'm not sure those are appropriate terms to apply to the concept of 'a thread that is going to spawn another thread' and 'the thread that it spawned'&quot;, and &quot;the same way any two threads communicate with each other: Carefully, probably via things in the <code>java.util.concurrent</code> package, and really optimally threads should never communicate except through communication channels with built in transactional support, such as a database, or message queue libraries like rabbitMQ.</p>\n","answer_id":64141533,"question_id":64141492},{"owner":{"profile_image":"https://www.gravatar.com/avatar/8bea1f01a8f41b0714de4eddc3c93ce8?s=256&d=identicon&r=PG","account_id":11180480,"user_type":"registered","user_id":8207228,"link":"https://stackoverflow.com/users/8207228/ralf-kleberhoff","reputation":7021,"display_name":"Ralf Kleberhoff"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1601481197,"creation_date":1601481197,"body":"<p>From the code you posted, I see two places where you seem to get stuck:</p>\n<ul>\n<li>Filling out the <code>run()</code> method in the <code>ColumnCalculator</code>.</li>\n<li>Using threads with the <code>ColumnCalculator</code> to get the multiplication result.</li>\n</ul>\n<p>From the comment inside <code>ColumnCalculator</code> I deduce that its duty is to compute one specific column of the result matrix. So, for e.g. a 5-columns matrix, you need five <code>ColumnCalculator</code> instances to get the complete result.</p>\n<h2>ColumnCalculator.run()</h2>\n<p>Put in code that does the matrix multiplication, not for all columns, but only for the column <code>col_idx</code>. That means: copy the code from multiplyBy() and strip it down so that it doesn't loop over all result columns.</p>\n<h2>Matrix.multiplyByThreads()</h2>\n<p>Instead of using a fixed number of threads, I'd start with a simpler approach:</p>\n<p>For each column in the result, create one ColumnCalculator and one thread, and have that thread run that calculator.</p>\n<p>And then wait for all of them to finish.</p>\n<p>When you've mastered that approach and like to continue, then an optimization might be to limit the number of threads to e.g. 10 and have them compute result columns until they're all done, but I recommend to start with the simpler approach.</p>\n","answer_id":64141295,"question_id":64140757},{"owner":{"profile_image":"https://www.gravatar.com/avatar/cbf3044a40d8139345d51081d5fc4517?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6838496,"user_type":"registered","user_id":5259625,"link":"https://stackoverflow.com/users/5259625/gen","reputation":2450,"display_name":"Gen","accept_rate":56},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1601465970,"creation_date":1601465970,"body":"<p>if you need simultaneous execution and each time new thread you can find the solution here</p>\n<pre><code>public class SleepClass {\n    public static void main(String[] args) {\n        SleepClass s= new SleepClass();\n        s.m2(500);\n        s.m2(1000);\n    }\n    \n    public void m2(int time) {\n        SleepClass s= new SleepClass();\n        new Thread(() -&gt; {\n            s.m1(time);\n        }).start();\n    }\n    \n    public void m1(int time) {\n        \n        for(int i = 0; i&lt;= 10; i++) {\n            System.out.println(i);\n            try {\n                Thread.sleep(time);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        \n    }\n\n}\n</code></pre>\n","answer_id":64136807,"question_id":64134839},{"owner":{"profile_image":"https://www.gravatar.com/avatar/964b3f08a9f4f4b76d14b5eb33190038?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":4501201,"user_type":"registered","user_id":3659670,"link":"https://stackoverflow.com/users/3659670/conffusion","reputation":4375,"display_name":"Conffusion"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1601461731,"creation_date":1601461731,"body":"<p>You have to put your logic in a Runnable and launch it using new <code>Thread(runnable).start()</code>.\nTo pass parameters to each runnable define them as class variables so you can pass them via the constructor and use them in the <code>run</code> method:</p>\n<pre><code>public class SleepClass {\n\n    public static void main(String[] args) {\n        SleepClass s= new SleepClass();\n        s.m1(10000);\n        s.m1(20000);\n    }\n    \n    public void m1(int time) {\n        for(int i = 0; i&lt; 3; i++) {\n            new Thread(new Launcher(i,time)).start();\n        }\n    }\n\n    public class Launcher implements Runnable {\n        int i;\n        int time;\n        public Launcher(int i, int time) {\n            this.i=i;\n            this.time=time;\n        }\n        @Override\n        public void run() {\n            System.out.println(i);\n            try {\n                Thread.sleep(time);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }                   \n        }\n        \n    }\n}\n</code></pre>\n","answer_id":64135639,"question_id":64134839},{"owner":{"profile_image":"https://i.stack.imgur.com/HbwqU.jpg?s=256&g=1","account_id":4264857,"user_type":"registered","user_id":3488208,"link":"https://stackoverflow.com/users/3488208/surendar-d","reputation":5594,"display_name":"Surendar D","accept_rate":20},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1599478405,"creation_date":1563439626,"body":"<p>Please try this once.</p>\n<ol>\n<li>Create a drawable file splash_background.xml</li>\n</ol>\n\n<pre><code>&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;\n\n    &lt;item android:drawable=&quot;@color/{your color}&quot; /&gt;\n\n    &lt;item&gt;\n        &lt;bitmap\n            android:layout_width=&quot;@dimen/size_250&quot;\n            android:layout_height=&quot;@dimen/size_100&quot;\n            android:gravity=&quot;center&quot;\n            android:scaleType=&quot;fitXY&quot;\n            android:src=&quot;{your image}&quot;\n            android:tint=&quot;@color/colorPrimary&quot; /&gt;\n    &lt;/item&gt;\n\n&lt;/layer-list&gt;\n</code></pre>\n<ol start=\"2\">\n<li><p>Put this in styles.xml</p>\n<pre><code>  &lt;style name=&quot;SplashTheme&quot; parent=&quot;Theme.AppCompat.NoActionBar&quot;&gt;\n      &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/splash_background&lt;/item&gt;\n  &lt;/style&gt;\n</code></pre>\n</li>\n<li><p>In your AndroidMainfest.xml set the above theme to Launch activity.</p>\n<pre><code>    &lt;activity\n         android:name=&quot;.SplashScreenActivity&quot;\n         android:screenOrientation=&quot;portrait&quot;\n         android:theme=&quot;@style/SplashTheme&quot;\n         android:windowSoftInputMode=&quot;stateVisible|adjustResize&quot;&gt;\n         &lt;intent-filter&gt;\n             &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;\n\n             &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;\n         &lt;/intent-filter&gt;\n     &lt;/activity&gt;\n</code></pre>\n</li>\n</ol>\n","answer_id":57090517,"question_id":37437037,"last_edit_date":1599478405},{"owner":{"profile_image":"https://i.stack.imgur.com/jgnbc.jpg?s=256&g=1","account_id":2174289,"user_type":"registered","user_id":1925388,"link":"https://stackoverflow.com/users/1925388/anmol-singh-jaggi","reputation":8434,"display_name":"Anmol Singh Jaggi","accept_rate":81},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1597191007,"creation_date":1597176994,"body":"<p>We can create a DAG where each vertex of the graph is one of the tasks.<br />\nAfter that, we can compute its <a href=\"https://en.wikipedia.org/wiki/Topological_sorting#:%7E:text=In%20computer%20science%2C%20a%20topological,before%20v%20in%20the%20ordering.\" rel=\"nofollow noreferrer\">topological sorted</a> order.<br />\nWe can then decorate the Task class with a priority field and run the <code>ThreadPoolExecutor</code> with a <code>PriorityBlockingQueue</code> which compares Tasks using the priority field.</p>\n<p>The final trick is to override <code>run()</code> to first wait for all the dependent tasks to finish.</p>\n<p>Since each task waits indefinitely for its dependent tasks to finish, we cannot afford to let the thread-pool be completely occupied with tasks that are higher up in the topological sort order; the thread pool will get stuck forever.<br />\nTo avoid this, we just have to assign priorities to tasks according to the topological order.</p>\n<pre class=\"lang-java prettyprint-override\"><code>import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\nimport java.util.concurrent.PriorityBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\n\npublic class Testing {\n\n  private static Callable&lt;Void&gt; getCallable(String taskId){\n    return () -&gt; {\n      System.out.println(String.format(&quot;Task %s result&quot;, taskId));\n      Thread.sleep(100);\n      return null;\n    };\n  }\n\n  public static void main(String[] args) throws ExecutionException, InterruptedException {\n    Callable&lt;Void&gt; taskA = getCallable(&quot;A&quot;);\n    Callable&lt;Void&gt; taskB = getCallable(&quot;B&quot;);\n    Callable&lt;Void&gt; taskC = getCallable(&quot;C&quot;);\n    Callable&lt;Void&gt; taskD = getCallable(&quot;D&quot;);\n    Callable&lt;Void&gt; taskE = getCallable(&quot;E&quot;);\n    PrioritizedFutureTask&lt;Void&gt; pfTaskA = new PrioritizedFutureTask&lt;&gt;(taskA);\n    PrioritizedFutureTask&lt;Void&gt; pfTaskB = new PrioritizedFutureTask&lt;&gt;(taskB);\n    PrioritizedFutureTask&lt;Void&gt; pfTaskC = new PrioritizedFutureTask&lt;&gt;(taskC);\n    PrioritizedFutureTask&lt;Void&gt; pfTaskD = new PrioritizedFutureTask&lt;&gt;(taskD);\n    PrioritizedFutureTask&lt;Void&gt; pfTaskE = new PrioritizedFutureTask&lt;&gt;(taskE);\n    // Create a DAG graph.\n    pfTaskB.addDependency(pfTaskC).addDependency(pfTaskE);\n    pfTaskA.addDependency(pfTaskB).addDependency(pfTaskC).addDependency(pfTaskD);\n    // Now that we have a graph, we can just get its topological sorted order.\n    List&lt;PrioritizedFutureTask&lt;Void&gt;&gt; topological_sort = new ArrayList&lt;&gt;();\n    topological_sort.add(pfTaskE);\n    topological_sort.add(pfTaskC);\n    topological_sort.add(pfTaskB);\n    topological_sort.add(pfTaskD);\n    topological_sort.add(pfTaskA);\n    ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,\n        new PriorityBlockingQueue&lt;Runnable&gt;(1, new CustomRunnableComparator()));\n    // Its important to insert the tasks in the topological sorted order, otherwise its possible that the thread pool will be stuck forever.\n    for (int i = 0; i &lt; topological_sort.size(); i++) {\n      PrioritizedFutureTask&lt;Void&gt; pfTask = topological_sort.get(i);\n      pfTask.setPriority(i);\n      // The lower the priority, the sooner it will run.\n      executor.execute(pfTask);\n    }\n  }\n}\n\nclass PrioritizedFutureTask&lt;T&gt; extends FutureTask&lt;T&gt; implements Comparable&lt;PrioritizedFutureTask&lt;T&gt;&gt; {\n\n  private Integer _priority = 0;\n  private final Callable&lt;T&gt; callable;\n  private final List&lt;PrioritizedFutureTask&gt; _dependencies = new ArrayList&lt;&gt;();\n  ;\n\n  public PrioritizedFutureTask(Callable&lt;T&gt; callable) {\n    super(callable);\n    this.callable = callable;\n  }\n\n  public PrioritizedFutureTask(Callable&lt;T&gt; callable, Integer priority) {\n    this(callable);\n    _priority = priority;\n  }\n\n  public Integer getPriority() {\n    return _priority;\n  }\n\n  public PrioritizedFutureTask&lt;T&gt; setPriority(Integer priority) {\n    _priority = priority;\n    return this;\n  }\n\n  public PrioritizedFutureTask&lt;T&gt; addDependency(PrioritizedFutureTask dep) {\n    this._dependencies.add(dep);\n    return this;\n  }\n\n  @Override\n  public void run() {\n    for (PrioritizedFutureTask dep : _dependencies) {\n      try {\n        dep.get();\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n      } catch (ExecutionException e) {\n        e.printStackTrace();\n      }\n    }\n    super.run();\n  }\n\n  @Override\n  public int compareTo(PrioritizedFutureTask&lt;T&gt; other) {\n    if (other == null) {\n      throw new NullPointerException();\n    }\n    return getPriority().compareTo(other.getPriority());\n  }\n}\n\nclass CustomRunnableComparator implements Comparator&lt;Runnable&gt; {\n  @Override\n  public int compare(Runnable task1, Runnable task2) {\n    return ((PrioritizedFutureTask) task1).compareTo((PrioritizedFutureTask) task2);\n  }\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>Task E result\nTask C result\nTask B result\nTask D result\nTask A result\n</code></pre>\n<p>PS: <a href=\"https://github.com/Anmol-Singh-Jaggi/interview-notes/tree/master/notes/algo-ds-practice/problems/graph/standard/topo_sort\" rel=\"nofollow noreferrer\">Here</a> is a well-tested and simple implementation of topological sort in Python which you can easily port in Java.</p>\n","answer_id":63365785,"question_id":63354899,"last_edit_date":1597191007},{"owner":{"profile_image":"https://www.gravatar.com/avatar/901954b4bf4f56918ed39a925018c8d7?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":18497209,"user_type":"registered","user_id":13475352,"link":"https://stackoverflow.com/users/13475352/sergey-rymsha","reputation":91,"display_name":"Sergey Rymsha"},"content_license":"CC BY-SA 4.0","score":9,"is_accepted":false,"last_activity_date":1588799345,"creation_date":1588799345,"body":"<p>I run into the same issue and found the\n<a href=\"https://bugs.openjdk.java.net/browse/JDK-8241054\" rel=\"noreferrer\">bug report</a></p>\n\n<p>It is awaiting JDK 11.0.8 release.</p>\n","answer_id":61645456,"question_id":54485755},{"owner":{"profile_image":"https://www.gravatar.com/avatar/63f6b4cb480178c6809b5bbeae5a2429?s=256&d=identicon&r=PG","account_id":1242750,"user_type":"registered","user_id":1204940,"link":"https://stackoverflow.com/users/1204940/abhishek","reputation":642,"display_name":"Abhishek"},"content_license":"CC BY-SA 4.0","score":-1,"is_accepted":false,"last_activity_date":1588240348,"creation_date":1588240348,"body":"<p>I know this is very late to answer, but I think it will help many. \nYou can check for the existing socket if any by below code.</p>\n\n<pre><code>SocketAddress socketAddress = new InetSocketAddress(\"localhost\", 8091);\n    Socket socket = new Socket();\n    ServerSocket serverSocket = null;\n    try {\n        socket.connect(socketAddress);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    if(socket == null) {\n        try {\n            serverSocket = new ServerSocket(8091);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n</code></pre>\n\n<p>if not found a active socket on the same port and IP then it will start a new server socket or you can change it start socket only else you can connect to the existing socket.</p>\n","answer_id":61520614,"question_id":40197514},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c324bc64b1ba9913b27c9a89d9fc62c9?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8571883,"user_type":"registered","user_id":6422459,"link":"https://stackoverflow.com/users/6422459/digitshifter","reputation":821,"display_name":"DigitShifter"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1581801207,"creation_date":1581801207,"body":"<p><strong>Try this small example, to get a feel for ThreadLocal variable:</strong><br>\n<br></p>\n\n<pre><code>public class Book implements Runnable {\n    private static final ThreadLocal&lt;List&lt;String&gt;&gt; WORDS = ThreadLocal.withInitial(ArrayList::new);\n\n    private final String bookName; // It is also the thread's name\n    private final List&lt;String&gt; words;\n\n\n    public Book(String bookName, List&lt;String&gt; words) {\n        this.bookName = bookName;\n        this.words = Collections.unmodifiableList(words);\n    }\n\n    public void run() {\n        WORDS.get().addAll(words);\n        System.out.printf(\"Result %s: '%s'.%n\", bookName, String.join(\", \", WORDS.get()));\n    }\n\n    public static void main(String[] args) {\n        Thread t1 = new Thread(new Book(\"BookA\", Arrays.asList(\"wordA1\", \"wordA2\", \"wordA3\")));\n        Thread t2 = new Thread(new Book(\"BookB\", Arrays.asList(\"wordB1\", \"wordB2\")));\n        t1.start();\n        t2.start();\n    }\n}\n</code></pre>\n\n<p><br>\n<strong>Console output, if thread BookA is done first:</strong><br>\nResult BookA: 'wordA1, wordA2, wordA3'.<br>\nResult BookB: 'wordB1, wordB2'.<br>\n<br>\n<strong>Console output, if thread BookB is done first:</strong><br>\nResult BookB: 'wordB1, wordB2'.<br>\nResult BookA: 'wordA1, wordA2, wordA3'.<br>\n<br></p>\n","answer_id":60243198,"question_id":817856},{"owner":{"profile_image":"https://i.stack.imgur.com/X1Q3J.jpg?s=256&g=1","account_id":2593996,"user_type":"registered","user_id":2248045,"link":"https://stackoverflow.com/users/2248045/hitesh-singh","reputation":1971,"display_name":"Hitesh Singh"},"content_license":"CC BY-SA 4.0","score":126,"is_accepted":false,"last_activity_date":1575439237,"creation_date":1465455372,"body":"<p>please add this line into your app theme </p>\n\n<pre><code>&lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;\n</code></pre>\n\n<p>for more information : <a href=\"https://developer.android.com/topic/performance/vitals/launch-time#themed\" rel=\"noreferrer\">https://developer.android.com/topic/performance/vitals/launch-time#themed</a></p>\n","answer_id":37718830,"question_id":37437037,"last_edit_date":1575439237},{"owner":{"profile_image":"https://i.stack.imgur.com/K5WPD.jpg?s=256&g=1","account_id":1298254,"user_type":"registered","user_id":1248724,"link":"https://stackoverflow.com/users/1248724/zarathustra","reputation":2903,"display_name":"Zarathustra","accept_rate":67},"content_license":"CC BY-SA 4.0","score":10,"is_accepted":true,"last_activity_date":1569863738,"creation_date":1549993709,"body":"<p>As @jspcal said before disable TLS 1.3.</p>\n\n<p><strong>tl;dr</strong>: disable tlsv1.3 via extending/overwriting </p>\n\n<p><code>&lt;java_home&gt;/conf/security/java.security</code> the <code>jdk.tls.disabledAlgorithms</code> property</p>\n\n<p>Since my application is running in a docker container I changed the base image to disable tls1.3</p>\n\n<pre><code>FROM openjdk:11-jre\n...\n\nRUN sed -i \"/jdk.tls.disabledAlgorithms=/ s/=.*/=TLSv1.3, SSLv3, RC4, MD5withRSA, DH keySize &lt; 1024, EC keySize &lt; 224, DES40_CBC, RC4_40, 3DES_EDE_CBC/\" $(readlink -f /usr/bin/java | sed \"s:bin/java::\")/conf/security/java.security\n</code></pre>\n\n<p>As far as I know there is no way of setting this (security) property via a system property! See also <code>sun.security.util.DisabledAlgorithmConstraints#PROPERTY_TLS_DISABLED_ALGS</code> which actually ready the property.</p>\n\n<p><strong>Update</strong>: Bug is still present in 11.0.2</p>\n","answer_id":54655885,"question_id":54485755,"last_edit_date":1569863738},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c2aa0c3f639d473d15b08c2cafc9188c?s=256&d=identicon&r=PG","account_id":174482,"user_type":"registered","user_id":403872,"link":"https://stackoverflow.com/users/403872/abhijit-gaikwad","reputation":3102,"display_name":"Abhijit Gaikwad","accept_rate":83},"content_license":"CC BY-SA 4.0","score":15,"is_accepted":false,"last_activity_date":1557882823,"creation_date":1372659023,"body":"<ol>\n<li><p>ThreadLocal in Java had been introduced on JDK 1.2 but was later generified in JDK 1.5 to introduce type safety on ThreadLocal variable.</p></li>\n<li><p>ThreadLocal can be associated with Thread scope, all the code which is executed by Thread has access to ThreadLocal variables but two thread can not see each others ThreadLocal variable.</p></li>\n<li><p>Each thread holds an exclusive copy of ThreadLocal variable which becomes eligible to Garbage collection after thread finished or died, normally or due to any Exception, Given those ThreadLocal variable doesn't have any other live references.</p></li>\n<li><p>ThreadLocal variables in Java are generally private static fields in Classes and maintain its state inside Thread.</p></li>\n</ol>\n\n<p>Read more: <a href=\"https://javarevisited.blogspot.com/2012/05/how-to-use-threadlocal-in-java-benefits.html#ixzz2XltgbHTK\" rel=\"noreferrer\">ThreadLocal in Java - Example Program and Tutorial</a></p>\n","answer_id":17398338,"question_id":817856,"last_edit_date":1557882823},{"owner":{"profile_image":"https://www.gravatar.com/avatar/72641170cc9abff008d21ac50894803b?s=256&d=identicon&r=PG","account_id":20470,"user_type":"registered","user_id":48933,"link":"https://stackoverflow.com/users/48933/neil-coffey","reputation":21695,"display_name":"Neil Coffey","accept_rate":90},"content_license":"CC BY-SA 4.0","score":20,"is_accepted":false,"last_activity_date":1557882784,"creation_date":1241394605,"body":"<p>Essentially, when you need a <strong>variable's value to depend on the current thread</strong> and it <strong>isn't convenient for you to attach the value to the thread in some other way</strong> (for example, subclassing thread).</p>\n\n<p>A typical case is where <strong>some other framework has created the thread</strong> that your code is running in, e.g. a servlet container, or where it just makes more sense to use ThreadLocal because your variable is then \"in its logical place\" (rather than a variable hanging from a Thread subclass or in some other hash map).</p>\n\n<p>On my web site, I have some further <a href=\"https://www.javamex.com/tutorials/synchronization_concurrency_thread_local3.shtml\" rel=\"noreferrer\">discussion and examples of when to use ThreadLocal</a> that may also be of interest.</p>\n\n<p>Some people advocate using ThreadLocal as a way to attach a \"thread ID\" to each thread in certain concurrent algorithms where you need a thread number (see e.g. Herlihy &amp; Shavit). In such cases, check that you're really getting a benefit!</p>\n","answer_id":818364,"question_id":817856,"last_edit_date":1557882784},{"owner":{"profile_image":"https://www.gravatar.com/avatar/520c9c078b8d25980de17b8d4fe0ceba?s=256&d=identicon&r=PG","account_id":24436,"user_type":"registered","user_id":62130,"link":"https://stackoverflow.com/users/62130/esko-luontola","reputation":73314,"display_name":"Esko Luontola","accept_rate":39},"content_license":"CC BY-SA 4.0","score":200,"is_accepted":false,"last_activity_date":1557882754,"creation_date":1241444172,"body":"<p>Many frameworks use ThreadLocals to maintain some context related to the current thread. For example when the current transaction is stored in a ThreadLocal, you don't need to pass it as a parameter through every method call, in case someone down the stack needs access to it. Web applications might store information about the current request and session in a ThreadLocal, so that the application has easy access to them. With Guice you can use ThreadLocals when implementing <a href=\"https://github.com/google/guice/wiki/CustomScopes\" rel=\"noreferrer\">custom scopes</a> for the injected objects (Guice's default <a href=\"https://github.com/google/guice/wiki/Scopes\" rel=\"noreferrer\">servlet scopes</a> most probably use them as well).</p>\n\n<p>ThreadLocals are one sort of global variables (although slightly less evil because they are restricted to one thread), so you should be careful when using them to avoid unwanted side-effects and memory leaks. Design your APIs so that the ThreadLocal values will always be automatically cleared when they are not needed anymore and that incorrect use of the API won't be possible (for example <a href=\"https://github.com/orfjackal/dimdwarf/blob/453f7aee9efc364ebad80531c05081e255323c07/dimdwarf-core/src/main/java/net/orfjackal/dimdwarf/context/ThreadContext.java#L48-55\" rel=\"noreferrer\">like this</a>). ThreadLocals can be used to make the code cleaner, and in some rare cases they are the only way to make something work (my current project had two such cases; they are documented <a href=\"https://github.com/orfjackal/dimdwarf/wiki/Design-Guidelines\" rel=\"noreferrer\">here</a> under \"Static Fields and Global Variables\").</p>\n","answer_id":820131,"question_id":817856,"last_edit_date":1557882754},{"owner":{"profile_image":"https://www.gravatar.com/avatar/7ccd45f17734f7d050a186468bdc38eb?s=256&d=identicon&r=PG","account_id":25274,"user_type":"registered","user_id":64881,"link":"https://stackoverflow.com/users/64881/phil-m","reputation":6653,"display_name":"Phil M"},"content_license":"CC BY-SA 4.0","score":458,"is_accepted":false,"last_activity_date":1557882643,"creation_date":1241388129,"body":"<p>Since a <code>ThreadLocal</code> is a reference to data within a given <code>Thread</code>, you can end up with classloading leaks when using <code>ThreadLocal</code>s in application servers using thread pools. You need to be very careful about cleaning up any <code>ThreadLocal</code>s you <code>get()</code> or <code>set()</code> by using the <code>ThreadLocal</code>'s <code>remove()</code> method.</p>\n\n<p>If you do not clean up when you're done, any references it holds to classes loaded as part of a deployed webapp will remain in the <a href=\"https://web.archive.org/web/20070104122432/http://www.brokenbuild.com/blog/2006/08/04/java-jvm-gc-permgen-and-memory-options/\" rel=\"noreferrer\">permanent heap</a> and will never get garbage collected. Redeploying/undeploying the webapp will not clean up each <code>Thread</code>'s reference to your webapp's class(es) since the <code>Thread</code> is not something owned by your webapp. Each successive deployment will create a new instance of the class which will never be garbage collected.</p>\n\n<p>You will end up with out of memory exceptions due to <code>java.lang.OutOfMemoryError: PermGen space</code> and after some googling will probably just increase <code>-XX:MaxPermSize</code> instead of fixing the bug.</p>\n\n<p>If you do end up experiencing these problems, you can determine which thread and class is retaining these references by using <a href=\"http://www.eclipse.org/mat/\" rel=\"noreferrer\">Eclipse's Memory Analyzer</a> and/or by following <a href=\"http://frankkieviet.blogspot.com/2006/10/classloader-leaks-dreaded-permgen-space.html\" rel=\"noreferrer\">Frank Kieviet's guide</a> and <a href=\"http://frankkieviet.blogspot.com/2006/10/how-to-fix-dreaded-permgen-space.html\" rel=\"noreferrer\">followup</a>.</p>\n\n<p>Update: Re-discovered <a href=\"http://avasseur.blogspot.com/2003/11/threadlocal-and-memory-leaks.html\" rel=\"noreferrer\">Alex Vasseur's blog entry</a> that helped me track down some <code>ThreadLocal</code> issues I was having.</p>\n","answer_id":818120,"question_id":817856,"last_edit_date":1557882643},{"owner":{"profile_image":"https://i.stack.imgur.com/RDWxl.png?s=256&g=1","account_id":4342327,"user_type":"registered","user_id":3545273,"link":"https://stackoverflow.com/users/3545273/serge-ballesta","reputation":145474,"display_name":"Serge Ballesta","accept_rate":100},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1551107156,"creation_date":1405248589,"body":"<p>You are misusing <code>synchronized</code> and <code>wait</code> by calling wait on the object you used in <code>synchronized</code>, immediately, without having a check <em>inside</em> the synchronized block in a loop. <strong>NEVER DO THAT AGAIN</strong>. </p>\n\n<p>In fact here's what happen :</p>\n\n<ul>\n<li>at <code>synchronized</code> line you get a lock on <code>Constants.lock</code></li>\n<li>at <code>wait</code> line, you <strong>release</strong> the lock on <code>Constants.lock</code> and wait for a notify from another thread.</li>\n</ul>\n\n<p>So what is happening in your prog :</p>\n\n<ul>\n<li>first thread (no matter what it is) reaches <code>synchronized</code> and proceed blocking the second</li>\n<li>first thread releases the synchonizing lock and put itself in a wait state for a notify</li>\n<li>second thread goes through <code>synchronized</code> because first has released the lock</li>\n<li>both thread are now waiting for a notify that will never occur</li>\n</ul>\n","answer_id":24721873,"question_id":24720849,"last_edit_date":1551107156},{"owner":{"profile_image":"https://lh3.googleusercontent.com/-wzV0pRRmQn4/AAAAAAAAAAI/AAAAAAAAG9E/XR0AzCzVUSg/photo.jpg?sz=256","account_id":13384743,"user_type":"registered","user_id":9658981,"link":"https://stackoverflow.com/users/9658981/manav-sharma","reputation":11,"display_name":"Manav Sharma"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1551105690,"creation_date":1551105167,"body":"<p>Everyone on the Stack Overflow tried the same solution. Checkout a different implementation for the same.</p>\n\n<pre><code>public class PrintSequenceUsingTwo {\n\n    public static void main(String[] args) {\n        ThreadSequence sequence = new ThreadSequence();\n        Thread t1 = new Thread(()-&gt; {try {\n            sequence.print();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }},\"t1\");\n        Thread t2 = new Thread(()-&gt; {try {\n            sequence.print();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }},\"t2\");\n\n        t1.start();\n        t2.start();\n        try {\n            t1.join();\n            t2.join();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>\n\n<hr>\n\n<pre><code>class ThreadSequence {\n\n    private static int var = 0; \n    private int limit = 10;     //set the variable value upto which you want to print\n\n    public synchronized void print() throws InterruptedException {\n        while (var&lt;limit) {\n            notify();\n            System.out.println(\"Current Thread \"+Thread.currentThread().getName()+\" Value : \"+(++var));\n            wait();\n        }\n        notify();\n    }\n}\n</code></pre>\n","answer_id":54868462,"question_id":24720849,"last_edit_date":1551105690},{"owner":{"profile_image":"https://i.stack.imgur.com/VoV9s.jpg?s=256&g=1","account_id":485625,"user_type":"registered","user_id":902036,"link":"https://stackoverflow.com/users/902036/dz902","reputation":5104,"display_name":"dz902","accept_rate":60},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1550734743,"creation_date":1550734743,"body":"<p>This is interesting as the name \"readlock\" or \"reader-lock\" is probably a bit misleading.</p>\n\n<p>I found it easier to think it as a <strong>mode switch</strong>, you switch to <em>read-only mode</em>, or <em>write-only mode</em>. You switch mode by acquiring corresponding locks.</p>\n","answer_id":54801639,"question_id":33384822},{"owner":{"profile_image":"https://i.stack.imgur.com/vTEma.jpg?s=256&g=1","account_id":4208732,"user_type":"registered","user_id":3447032,"link":"https://stackoverflow.com/users/3447032/gokareless","reputation":1205,"display_name":"gokareless"},"content_license":"CC BY-SA 4.0","score":7,"is_accepted":false,"last_activity_date":1549897683,"creation_date":1549897683,"body":"<p>Duplicating <strong>@Solomon Slow</strong> comment here, as it helped me personally:</p>\n\n<blockquote>\n  <p>Read locks and write locks come in pairs: If thread <strong>R</strong> holds a <em>read lock</em>, it <strong>blocks</strong> thread <strong>W</strong> from obtaining the corresponding <em>write lock</em>, but it <strong>does not block</strong> thread <strong>S</strong> from getting the same <em>read lock</em>. A reader/writer lock pair allows any number of readers to \"own\" the read lock at the same time, OR it allows one writer to own the write lock, but it never allows a reader and a writer at the same time, and it never allows more than one writer at the same time.</p>\n</blockquote>\n","answer_id":54633486,"question_id":33384822},{"owner":{"profile_image":"https://www.gravatar.com/avatar/097d761861529df52a6800744f1074d2?s=256&d=identicon&r=PG","account_id":84127,"user_type":"registered","user_id":235354,"link":"https://stackoverflow.com/users/235354/jspcal","reputation":51115,"display_name":"jspcal"},"content_license":"CC BY-SA 4.0","score":9,"is_accepted":false,"last_activity_date":1549048805,"creation_date":1549048805,"body":"<p>Try disabling <code>TLSv1.3</code> or <code>SSLv3</code> to see if that helps.</p>\n\n<p>Set the system property on the command line: <code>-Djdk.tls.disabledAlgorithms=TLSv1.3</code></p>\n\n<p>Or define the property in <code>&lt;java_home&gt;/conf/security/java.security</code></p>\n\n<p>If you think it's an implementation bug, you may want to open an issue.</p>\n","answer_id":54485918,"question_id":54485755},{"owner":{"profile_image":"https://lh5.googleusercontent.com/-vTTwbpau6o4/AAAAAAAAAAI/AAAAAAAABbA/nMg4jej0wtY/photo.jpg?sz=256","account_id":8047963,"user_type":"registered","user_id":6067590,"link":"https://stackoverflow.com/users/6067590/akanshi-srivastava","reputation":1160,"display_name":"Akanshi Srivastava"},"content_license":"CC BY-SA 4.0","score":17,"is_accepted":false,"last_activity_date":1548662806,"creation_date":1548662806,"body":"<p>I added the following two lines in my theme\nunder styles.xml</p>\n\n<pre><code>    &lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;\n    &lt;item name=\"android:windowBackground\"&gt;@null&lt;/item&gt;\n</code></pre>\n\n<p>Worked like a charm</p>\n","answer_id":54397744,"question_id":37437037},{"owner":{"profile_image":"https://i.stack.imgur.com/9Q2UB.png?s=256&g=1","account_id":13184766,"user_type":"registered","user_id":9523162,"link":"https://stackoverflow.com/users/9523162/meyi","reputation":7674,"display_name":"meyi"},"content_license":"CC BY-SA 4.0","score":12,"is_accepted":false,"last_activity_date":1547777884,"creation_date":1547745165,"body":"<p>I know that I'm a few years late, but I came across this issue and took an unorthodox approach. I wanted to do it without making a new class, so this is what I came up with: </p>\n\n<pre><code>int x = 0;\nnew Thread((new Runnable() {\n     int x;\n     public void run() {\n        // stuff with x and whatever else you want\n     }\n     public Runnable pass(int x) {\n           this.x = x;\n           return this;\n     }\n}).pass(x)).start();\n</code></pre>\n","answer_id":54241038,"question_id":877096,"last_edit_date":1547777884},{"owner":{"profile_image":"https://www.gravatar.com/avatar/117cb4789d68e0d8c0ca17fd09948a1a?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":14685618,"user_type":"registered","user_id":10605704,"link":"https://stackoverflow.com/users/10605704/young","reputation":31,"display_name":"Young"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1541428261,"creation_date":1541428261,"body":"<p>[For Reference]ThreadLocal cannot solve update problems of shared object. It is recommended to use a staticThreadLocal object which is shared by all operations in the same thread.\n[Mandatory]remove() method must be implemented by ThreadLocal variables, especially when using thread pools in which threads are often reused. Otherwise, it may affect subsequent business logic and cause unexpected problems such as memory leak.</p>\n","answer_id":53156397,"question_id":817856},{"owner":{"profile_image":"https://www.gravatar.com/avatar/263ca357f9cf115f409fd3d8fe697503?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":2975624,"user_type":"registered","user_id":2526714,"link":"https://stackoverflow.com/users/2526714/v0ld3m0rt","reputation":874,"display_name":"v0ld3m0rt","accept_rate":95},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1539494359,"creation_date":1539494359,"body":"<p>You can find the explanation in the site mentioned in package declaraion:\nHere's the working code:</p>\n\n<pre><code>public class MultipleThreading {\n    int count = 1;\n    int MAX = 20;\n\n    public void printOdd() {\n    synchronized (this) {\n        while (count &lt; MAX) {\n        while (count % 2 == 0) {\n            try {\n            wait();\n            } catch (InterruptedException e) {\n            e.printStackTrace();\n            }\n        }\n        System.out.print(count + \" \");\n        count++;\n        notify();\n        }\n    }\n    }\n\n    public void printEven() {\n    synchronized (this) {\n        while (count &lt; MAX) {\n        while (count % 2 == 1) {\n            try {\n            wait();\n            } catch (InterruptedException e) {\n            e.printStackTrace();\n            }\n        }\n        System.out.print(count + \" \");\n        count++;\n        notify();\n        }\n    }\n    }\n\n    public static void main(String[] args) {\n    MultipleThreading mt = new MultipleThreading();\n    Thread t1 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n        mt.printEven();\n        }\n    });\n    Thread t2 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n        mt.printOdd();\n        }\n    });\n    t1.start();\n    t2.start();\n    }\n}\n</code></pre>\n","answer_id":52799710,"question_id":24720849},{"owner":{"profile_image":"https://i.stack.imgur.com/eNviq.png?s=256&g=1","account_id":5243963,"user_type":"registered","user_id":4190267,"link":"https://stackoverflow.com/users/4190267/indian","reputation":130,"display_name":"indian"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1538390322,"creation_date":1415353577,"body":"<p>The first difference is that <code>yield()</code> is a <code>Thread</code> method , <code>wait()</code> is at the origins <code>Object</code> method inheritid in <code>thread</code> as for all classes , that in the shape, in the background (using java doc) </p>\n\n<pre><code>wait()\n</code></pre>\n\n<p>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. In other words, this method behaves exactly as if it simply performs the call wait(0).</p>\n\n<pre><code>yield()\n</code></pre>\n\n<p>A hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint.</p>\n\n<p>and here you can see the <a href=\"http://javarevisited.blogspot.fr/2011/12/difference-between-wait-sleep-yield.html\" rel=\"nofollow noreferrer\">difference</a> between <a href=\"http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#yield()\" rel=\"nofollow noreferrer\">yield()</a> and <a href=\"http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#wait()\" rel=\"nofollow noreferrer\">wait()</a></p>\n","answer_id":26798351,"question_id":26798073,"last_edit_date":1538390322},{"owner":{"profile_image":"https://i.stack.imgur.com/QN0a6.jpg?s=256&g=1","account_id":6198641,"user_type":"registered","user_id":4829218,"link":"https://stackoverflow.com/users/4829218/calvin-k","reputation":114,"display_name":"Calvin K"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1537363352,"creation_date":1537363352,"body":"<p>Create a local variable in your class that <code>extends Thread</code> or <code>implements Runnable</code>.</p>\n\n<pre><code>public class Extractor extends Thread {\n    public String webpage = \"\";\n    public Extractor(String w){\n        webpage = w;\n    }\n    public void setWebpage(String l){\n        webpage = l;\n    }\n\n    @Override\n    public void run() {// l is link\n        System.out.println(webpage);\n    }\n    public String toString(){\n        return \"Page: \"+webpage;\n    }}\n</code></pre>\n\n<p>This way, you can pass a variable when you run it.</p>\n\n<pre><code>Extractor e = new Extractor(\"www.google.com\");\ne.start();\n</code></pre>\n\n<p>The output:</p>\n\n<pre><code>\"www.google.com\"\n</code></pre>\n","answer_id":52406906,"question_id":877096},{"owner":{"profile_image":"https://i.stack.imgur.com/63g7E.jpg?s=256&g=1","account_id":1252022,"user_type":"registered","user_id":6730571,"link":"https://stackoverflow.com/users/6730571/hugues-m","reputation":19996,"display_name":"Hugues M."},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1531412347,"creation_date":1531412347,"body":"<p>I've had the same issue on Ubuntu, with <code>openjdk-9-jdk-headless</code> installed, <code>jstack</code> alone would work fine but <code>jstack -m</code> would fail with same error as you.</p>\n\n<p>Installing <code>openjdk-9-dbg</code> (package that brings debug symbols) solved it.</p>\n","answer_id":51310395,"question_id":49516601},{"owner":{"profile_image":"https://i.stack.imgur.com/wOpca.jpg?s=256&g=1","account_id":1901420,"user_type":"registered","user_id":1717210,"link":"https://stackoverflow.com/users/1717210/tachedechoco","reputation":3763,"display_name":"TacheDeChoco"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1531397535,"creation_date":1531397535,"body":"<p>The same user is fine, but make also sure you are using the jstack that is bundled the <strong>exact same</strong> JVM as the one that is running the process 7219.</p>\n","answer_id":51305417,"question_id":49516601},{"owner":{"profile_image":"https://i.stack.imgur.com/SoIAb.jpg?s=256&g=1","account_id":8324600,"user_type":"registered","user_id":6255036,"link":"https://stackoverflow.com/users/6255036/krishna","reputation":1566,"display_name":"Krishna"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1530860546,"creation_date":1530860546,"body":"<pre><code>Style :- \n&lt;style name=\"SplashViewTheme\" parent=\"Theme.AppCompat.NoActionBar\"&gt;\n    &lt;item name=\"android:windowBackground\"&gt;@drawable/splash&lt;/item&gt;\n    &lt;item name=\"windowActionBar\"&gt;false&lt;/item&gt;\n    &lt;item name=\"windowNoTitle\"&gt;true&lt;/item&gt;\n&lt;/style&gt;\n\nIn Manifest :- \n&lt;activity android:name=\".SplashActivity\"\n        android:theme=\"@style/SplashViewTheme\"&gt;\n        &lt;intent-filter&gt;\n            &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n\n            &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n        &lt;/intent-filter&gt;\n    &lt;/activity&gt;\n</code></pre>\n","answer_id":51204730,"question_id":37437037},{"owner":{"profile_image":"https://i.stack.imgur.com/f4hTe.jpg?s=256&g=1","account_id":13723126,"user_type":"registered","user_id":9902575,"link":"https://stackoverflow.com/users/9902575/david-studer","reputation":105,"display_name":"David Studer"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1530190098,"creation_date":1530190098,"body":"<p>The issue is indeed not caused by the multithreading logic itself, it is caused by <strong>Eclipse</strong> and the respective <strong>JVM</strong>. Running the exact same code in <strong>Netbeans</strong> or on an <strong>Tomcat 8 Server</strong> did not lead to any problems. A reinstallation of Eclipse did not solve the malfunction within the Eclipse framework, but having the certainty that the issue does not cause any trouble on a server is sufficient for me to close the case. </p>\n\n<p>Thanks to <a href=\"https://stackoverflow.com/users/2563754/seelenvirtuose\">Seelenvirtuose</a> for the hints and his effort.</p>\n","answer_id":51083358,"question_id":51055780},{"owner":{"profile_image":"https://www.gravatar.com/avatar/7d4357beb6de2712b6b2171ebe4c499b?s=256&d=identicon&r=PG","account_id":3023214,"user_type":"registered","user_id":2563754,"link":"https://stackoverflow.com/users/2563754/seelenvirtuose","reputation":20361,"display_name":"Seelenvirtuose"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1530081892,"creation_date":1530081892,"body":"<blockquote>\n  <p>But every time I start running my own thread class as a new thread, the main class thread does not terminate anymore by itself.</p>\n</blockquote>\n\n<p>This is somewhat wrong. Your program does not terminate because there exists at least one non-daemon thread that still is running. The rule is: A Java program is terminated if all non-daemon threads are terminated.</p>\n\n<p>I modified your program to make this behavior clear:</p>\n\n<pre><code>public class OwnThread implements Runnable {\n    @Override\n    public void run() {\n        runForever();\n    }\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(new OwnThread());\n        thread.start();\n        runForever();\n    }\n\n    private static void runForever() {\n        while (true) {}\n    }\n}\n</code></pre>\n\n<p>Running that will create two threads that will run forever. One is the main thread which is started by running the program, and the other is the thread started inside the main method:</p>\n\n<p><a href=\"https://i.stack.imgur.com/kc9Qy.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/kc9Qy.png\" alt=\"enter image description here\"></a></p>\n\n<p>Modifying the above code by removing the call to <em>runForever</em> in the main method ...</p>\n\n<pre><code>public static void main(String[] args) {\n    Thread thread = new Thread(new OwnThread());\n    thread.start();\n}\n</code></pre>\n\n<p>... will result in a different thread picture:</p>\n\n<p><a href=\"https://i.stack.imgur.com/d86FX.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/d86FX.png\" alt=\"enter image description here\"></a></p>\n\n<p>Here the main thread is gone because it is terminated. But the other started thread is still running.</p>\n\n<p>Side note: Suddenly another thread appears - <code>DestroyJavaVM</code>. Have a look at the post <a href=\"https://stackoverflow.com/questions/34433267/destroyjavavm-thread-always-running\">DestroyJavaVM thread ALWAYS running</a> for more information.</p>\n","answer_id":51056168,"question_id":51055780},{"owner":{"profile_image":"https://i.stack.imgur.com/MUmw0.jpg?s=256&g=1","account_id":2629067,"user_type":"registered","user_id":2275474,"link":"https://stackoverflow.com/users/2275474/pritesh-patel","reputation":688,"display_name":"Pritesh Patel","accept_rate":100},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1528118288,"creation_date":1528118288,"body":"<p>The <strong>ThreadLocal</strong> class in Java enables you to create variables that can only be read and written by the same thread. Thus, even if two threads are executing the same code, and the code has a reference to a ThreadLocal variable, then the two threads cannot see each other's ThreadLocal variables.</p>\n\n<p><a href=\"http://tutorials.jenkov.com/java-concurrency/threadlocal.html\" rel=\"nofollow noreferrer\">Read more</a></p>\n","answer_id":50681599,"question_id":817856},{"owner":{"profile_image":"https://www.gravatar.com/avatar/4c1cbfeb8f960be43b662f976c47ca6b?s=256&d=identicon&r=PG","account_id":26685,"user_type":"registered","user_id":69689,"link":"https://stackoverflow.com/users/69689/overthink","reputation":24085,"display_name":"overthink","accept_rate":85},"content_license":"CC BY-SA 3.0","score":916,"is_accepted":true,"last_activity_date":1524678699,"creation_date":1241382377,"body":"<p>One possible (and common) use is when you have some object that is not thread-safe, but you want to avoid <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html\" rel=\"noreferrer\">synchronizing</a> access to that object (I'm looking at you, <a href=\"https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html\" rel=\"noreferrer\">SimpleDateFormat</a>).  Instead, give each thread its own instance of the object.</p>\n\n<p>For example:</p>\n\n<pre><code>public class Foo\n{\n    // SimpleDateFormat is not thread-safe, so give one to each thread\n    private static final ThreadLocal&lt;SimpleDateFormat&gt; formatter = new ThreadLocal&lt;SimpleDateFormat&gt;(){\n        @Override\n        protected SimpleDateFormat initialValue()\n        {\n            return new SimpleDateFormat(\"yyyyMMdd HHmm\");\n        }\n    };\n\n    public String formatIt(Date date)\n    {\n        return formatter.get().format(date);\n    }\n}\n</code></pre>\n\n<p><a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html\" rel=\"noreferrer\">Documentation</a>.</p>\n","answer_id":817926,"question_id":817856,"last_edit_date":1524678699},{"owner":{"profile_image":"https://www.gravatar.com/avatar/8ef359acdee98b1513720480264b6eac?s=256&d=identicon&r=PG","account_id":2849643,"user_type":"registered","user_id":2447120,"link":"https://stackoverflow.com/users/2447120/rakesh-chauhan","reputation":423,"display_name":"Rakesh Chauhan"},"content_license":"CC BY-SA 4.0","score":32,"is_accepted":false,"last_activity_date":1522247318,"creation_date":1443950915,"body":"<p>There is very good example in book <strong>Java Concurrency in Practice</strong>. Where author (<a href=\"https://en.wikipedia.org/wiki/Joshua_Bloch\" rel=\"noreferrer\">Joshua Bloch</a>) explains how Thread confinement is one of the simplest ways to achieve thread safety and <strong>ThreadLocal</strong> is more formal means of maintaining thread confinement. In the end he also explain how people can abuse it by using it as global variables.</p>\n<p>I have copied the text from the mentioned book but code 3.10 is missing as it is not much important to understand where ThreadLocal should be use.</p>\n<blockquote>\n<p>Thread-local variables are often used to prevent sharing in designs based on mutable Singletons or global variables. For example, a single-threaded application might maintain a global database connection that is initialized at startup to avoid having to pass a Connection to every method. Since JDBC connections may not be thread-safe, a multithreaded application that uses a global connection without additional coordination is not thread-safe either. By using a ThreadLocal to store the JDBC connection, as in ConnectionHolder in Listing 3.10, each thread will have its own connection.<br/></p>\n<p>ThreadLocal is widely used in implementing application frameworks. For example, J2EE containers associate a transaction context with an executing thread for the duration of an EJB call. This is easily implemented using a static Thread-Local holding the transaction context: when framework code needs to determine what transaction is currently running, it fetches the transaction context from this ThreadLocal. This is convenient in that it reduces the need to pass execution context information into every method, but couples any code that uses this mechanism to the framework.</p>\n<p>It is easy to abuse ThreadLocal by treating its thread confinement property as a license to use global variables or as a means of creating “hidden” method arguments. Like global variables, thread-local variables can detract from reusability and introduce hidden couplings among classes, and should therefore be used with care.</p>\n</blockquote>\n","answer_id":32931978,"question_id":817856,"last_edit_date":1592644375},{"owner":{"profile_image":"https://lh5.googleusercontent.com/-yRGGcWHl23g/AAAAAAAAAAI/AAAAAAAAAE8/rs-zYQv-l9I/photo.jpg?sz=256","account_id":9240608,"user_type":"registered","user_id":6864013,"link":"https://stackoverflow.com/users/6864013/prasad-reddy","reputation":399,"display_name":"prasad reddy"},"content_license":"CC BY-SA 3.0","score":38,"is_accepted":false,"last_activity_date":1521183452,"creation_date":1521183452,"body":"<p>Please copy and paste these two lines in your manifest app theme i.e res/styles/AppTheme. then it will work like charm..</p>\n\n<pre><code>&lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;\n&lt;item name=\"android:windowIsTranslucent\"&gt;true&lt;/item&gt;\n</code></pre>\n","answer_id":49314844,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b7e983bc66ab99bac7d0891527628145?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":3244300,"user_type":"registered","user_id":2736367,"link":"https://stackoverflow.com/users/2736367/sam","reputation":2975,"display_name":"Sam","accept_rate":75},"content_license":"CC BY-SA 3.0","score":40,"is_accepted":false,"last_activity_date":1520938475,"creation_date":1520938475,"body":"<p>Recommended way of solving this problem is missing in the answers. So I am adding my answer here. The white-screen-at-startup problem occurs because of the initial blank screen that the system process draws when launching the app. A common way to solve this is by turning off this initial screen by adding this to your <code>styles.xml</code> file.</p>\n\n<pre><code>&lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;\n</code></pre>\n\n<p>But according to android documentation this can result in longer startup time. Recommended way of avoiding this initial white screen according to google is to use activity's <code>windowBackground</code> theme attribute and provide a simple custom drawable for the starting activity.  </p>\n\n<p>Like this:</p>\n\n<p>Drawable Layout file, <code>my_drawable.xml</code></p>\n\n<pre><code>&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:opacity=\"opaque\"&gt;\n  &lt;!-- The background color, preferably the same as your normal theme --&gt;\n  &lt;item android:drawable=\"@android:color/white\"/&gt;\n  &lt;!-- Your product logo - 144dp color version of your app icon --&gt;\n  &lt;item&gt;\n    &lt;bitmap\n      android:src=\"@drawable/product_logo_144dp\"\n      android:gravity=\"center\"/&gt;\n  &lt;/item&gt;\n&lt;/layer-list&gt;\n</code></pre>\n\n<p>Create a new style in your <code>styles.xml</code></p>\n\n<pre><code>&lt;!-- Base application theme. --&gt;\n&lt;style name=\"AppTheme\"&gt;\n    &lt;!-- Customize your theme here. --&gt;               \n&lt;/style&gt;\n\n&lt;!-- Starting activity theme --&gt;\n&lt;style name=\"AppTheme.Launcher\"&gt;\n    &lt;item name=\"android:windowBackground\"&gt;@drawable/my_drawable&lt;/item&gt;\n&lt;/style&gt;\n</code></pre>\n\n<p>Add this theme to your starting activity in the Manifest file </p>\n\n<pre><code>&lt;activity ...\nandroid:theme=\"@style/AppTheme.Launcher\" /&gt;\n</code></pre>\n\n<p>And when you want to transition back to your normal theme call <code>setTheme(R.style.Apptheme)</code> before calling <code>super.onCreate()</code> and <code>setContentView()</code> </p>\n\n<pre><code>public class MainActivity extends AppCompatActivity {\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    // Make sure this is before calling super.onCreate\n    setTheme(R.style.Theme_MyApp);\n    super.onCreate(savedInstanceState);\n    // ...\n  }\n}\n</code></pre>\n\n<p>This is the recommended way to solve the problem and this is from google <a href=\"https://material.io/guidelines/patterns/launch-screens.html#\" rel=\"noreferrer\">Material Design</a> patterns.</p>\n","answer_id":49254344,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/dc8c4ddd99b446c28d2e1546c457e508?s=256&d=identicon&r=PG","account_id":4495,"user_type":"registered","user_id":6782,"link":"https://stackoverflow.com/users/6782/alnitak","reputation":335863,"display_name":"Alnitak","accept_rate":78},"content_license":"CC BY-SA 3.0","score":421,"is_accepted":true,"last_activity_date":1518710716,"creation_date":1242643303,"body":"<p>You need to pass the parameter in the constructor to the Runnable object:</p>\n\n<pre><code>public class MyRunnable implements Runnable {\n\n   public MyRunnable(Object parameter) {\n       // store parameter for later user\n   }\n\n   public void run() {\n   }\n}\n</code></pre>\n\n<p>and invoke it thus:</p>\n\n<pre><code>Runnable r = new MyRunnable(param_value);\nnew Thread(r).start();\n</code></pre>\n","answer_id":877113,"question_id":877096,"last_edit_date":1518710716},{"owner":{"profile_image":"https://www.gravatar.com/avatar/92649572223f7fa0485d3e87805159b4?s=256&d=identicon&r=PG","account_id":267334,"user_type":"registered","user_id":555451,"link":"https://stackoverflow.com/users/555451/stuart-cardall","reputation":2179,"display_name":"Stuart Cardall"},"content_license":"CC BY-SA 3.0","score":7,"is_accepted":false,"last_activity_date":1514541231,"creation_date":1514541231,"body":"<p>In Java 8 you can use <code>lambda</code> expressions with the <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html\" rel=\"noreferrer\">Concurrency API</a> &amp; the <code>ExecutorService</code> as a higher level replacement for working with threads directly:</p>\n\n<blockquote>\n  <p><code>newCachedThreadPool()</code> Creates a thread pool that creates new threads\n  as needed, but will reuse previously constructed threads when they are\n  available. These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks.</p>\n</blockquote>\n\n<pre><code>    private static final ExecutorService executor = Executors.newCachedThreadPool();\n\n    executor.submit(() -&gt; {\n        myFunction(myParam1, myParam2);\n    });\n</code></pre>\n\n<p>See also <code>executors</code> <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html\" rel=\"noreferrer\">javadocs</a>.</p>\n","answer_id":48020642,"question_id":877096},{"owner":{"profile_image":"https://www.gravatar.com/avatar/3f3a232ec46927a08f59d4d4e59c6802?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":3401111,"user_type":"registered","user_id":2853221,"link":"https://stackoverflow.com/users/2853221/dev-amitabh","reputation":185,"display_name":"Dev Amitabh"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1513047641,"creation_date":1513047641,"body":"<p>Threadlocal provides a very easy way to achieve objects reusability with zero cost.</p>\n\n<p>I had a situation where multiple threads were creating an image of mutable cache, on each update notification.</p>\n\n<p>I used a Threadlocal on each thread, and then each thread would just need to reset old image and then update it again from the cache on each update notification.</p>\n\n<p>Usual reusable objects from object pools have thread safety cost associated with them, while this approach has none. </p>\n","answer_id":47764719,"question_id":817856},{"owner":{"profile_image":"https://www.gravatar.com/avatar/ddb4a32b3d7306760349340e46fd078d?s=256&d=identicon&r=PG","account_id":3750936,"user_type":"registered","user_id":3148734,"link":"https://stackoverflow.com/users/3148734/bpjoshi","reputation":1111,"display_name":"bpjoshi","accept_rate":75},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1512028724,"creation_date":1511992191,"body":"<p>Thread-local variables are often used to prevent sharing in designs based on\nmutable Singletons or global variables. </p>\n\n<p>It can be used in scenarios like making seperate JDBC connection for each thread when you are not using a Connection Pool.</p>\n\n<pre><code>private static ThreadLocal&lt;Connection&gt; connectionHolder\n           = new ThreadLocal&lt;Connection&gt;() {\n      public Connection initialValue() {\n           return DriverManager.getConnection(DB_URL);\n          }\n     };\n\npublic static Connection getConnection() {\n      return connectionHolder.get();\n} \n</code></pre>\n\n<p>When you call getConnection, it will return a connection associated with that thread.The same can be done with other properties like dateformat, transaction context that you don't want to share between threads. </p>\n\n<p>You could have also used local variables for the same, but these resource usually take up time in creation,so you don't want to create them again and again whenever you perform some business logic with them. However, ThreadLocal values are stored in the thread object itself and as soon as the thread is garbage collected, these values are gone too.</p>\n\n<p>This <a href=\"https://howtodoinjava.com/core-java/multi-threading/when-and-how-to-use-thread-local-variables/\" rel=\"nofollow noreferrer\">link</a> explains use of ThreadLocal very well.</p>\n","answer_id":47562423,"question_id":817856,"last_edit_date":1512028724},{"owner":{"profile_image":"https://i.stack.imgur.com/miNqr.jpg?s=256&g=1","account_id":4324639,"user_type":"registered","user_id":3531794,"link":"https://stackoverflow.com/users/3531794/dimos","reputation":8470,"display_name":"Dimos"},"content_license":"CC BY-SA 3.0","score":5,"is_accepted":false,"last_activity_date":1505561291,"creation_date":1505561291,"body":"<p><code>ThreadLocal</code> is useful, when you want to have some state that should not be shared amongst different threads, but it should be accessible from each thread during its whole lifetime.</p>\n\n<p>As an example, imagine a web application, where each request is served by a different thread. Imagine that for each request you need a piece of data multiple times, which is quite expensive to compute. However, that data might have changed for each incoming request, which means that you can't use a plain cache. A simple, quick solution to this problem would be to have a <code>ThreadLocal</code> variable holding access to this data, so that you have to calculate it only once for each request. Of course, this problem can also be solved without the use of <code>ThreadLocal</code>, but I devised it for illustration purposes. </p>\n\n<p>That said, have in mind that <code>ThreadLocal</code>s are essentially a form of global state. As a result, it has many other implications and should be used only after considering all the other possible solutions. </p>\n","answer_id":46253405,"question_id":817856},{"owner":{"profile_image":"https://i.stack.imgur.com/Auh5P.png?s=256&g=1","account_id":2075948,"user_type":"registered","user_id":4233197,"link":"https://stackoverflow.com/users/4233197/hiren-patel","reputation":52334,"display_name":"Hiren Patel","accept_rate":55},"content_license":"CC BY-SA 3.0","score":11,"is_accepted":false,"last_activity_date":1496909476,"creation_date":1496909476,"body":"<p>I had same issue, you have to update your style.</p>\n\n<p><strong>style.xml</strong></p>\n\n<pre><code>&lt;!-- Base application theme. --&gt;\n &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt;\n\n        &lt;!-- Customize your theme here. --&gt;\n        &lt;item name=\"drawerArrowStyle\"&gt;@style/DrawerArrowStyle&lt;/item&gt;\n        &lt;item name=\"android:windowNoTitle\"&gt;true&lt;/item&gt;\n        &lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;\n        &lt;item name=\"android:windowBackground\"&gt;@null&lt;/item&gt;\n        &lt;item name=\"android:windowIsTranslucent\"&gt;true&lt;/item&gt;\n\n &lt;/style&gt;\n</code></pre>\n\n<p>Your manifest file should looks like below.</p>\n\n<pre><code>&lt;application\n        android:name=\".MyApplication\"\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:theme=\"@style/AppTheme\"&gt;\n     // Other stuff\n&lt;/application&gt;\n</code></pre>\n\n<p><strong>Outout:</strong></p>\n\n<p><a href=\"https://i.stack.imgur.com/78a5r.gif\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/78a5r.gif\" alt=\"enter image description here\"></a></p>\n\n<p>Hope this would help you.</p>\n","answer_id":44430166,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/52f323891e5e487c80d4034887c31f1b?s=256&d=identicon&r=PG","account_id":3178228,"user_type":"registered","user_id":2685581,"link":"https://stackoverflow.com/users/2685581/ajay-kumar","reputation":4984,"display_name":"Ajay Kumar"},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1496153397,"creation_date":1496139866,"body":"<p>ThreadLocal is a specially provisioned functionality by JVM to provide an isolated storage space for threads only. like the value of instance scoped variable are bound to a given instance of a class only. each object has its only values and they can not see each other value. so is the concept of ThreadLocal variables, they are local to the thread in the sense of object instances other thread except for the one which created it, can not see it. <a href=\"https://itexpertsconsultant.wordpress.com/2017/05/29/threadlocal-example-with-java-8/\" rel=\"nofollow noreferrer\">See Here</a></p>\n\n<pre><code>import java.util.concurrent.atomic.AtomicInteger;\nimport java.util.stream.IntStream;\n\n\npublic class ThreadId {\nprivate static final AtomicInteger nextId = new AtomicInteger(1000);\n\n// Thread local variable containing each thread's ID\nprivate static final ThreadLocal&lt;Integer&gt; threadId = ThreadLocal.withInitial(() -&gt; nextId.getAndIncrement());\n\n\n// Returns the current thread's unique ID, assigning it if necessary\npublic static int get() {\n    return threadId.get();\n}\n\npublic static void main(String[] args) {\n\n    new Thread(() -&gt; IntStream.range(1, 3).forEach(i -&gt; {\n        System.out.println(Thread.currentThread().getName() + \" &gt;&gt; \" + new ThreadId().get());\n    })).start();\n\n    new Thread(() -&gt; IntStream.range(1, 3).forEach(i -&gt; {\n        System.out.println(Thread.currentThread().getName() + \" &gt;&gt; \" + new ThreadId().get());\n    })).start();\n\n    new Thread(() -&gt; IntStream.range(1, 3).forEach(i -&gt; {\n        System.out.println(Thread.currentThread().getName() + \" &gt;&gt; \" + new ThreadId().get());\n    })).start();\n\n}\n}\n</code></pre>\n","answer_id":44259643,"question_id":817856,"last_edit_date":1496153397},{"owner":{"profile_image":"https://i.stack.imgur.com/zw18i.png?s=256&g=1","account_id":1663234,"user_type":"registered","user_id":1531124,"link":"https://stackoverflow.com/users/1531124/ghostcat","reputation":138406,"display_name":"GhostCat","accept_rate":96},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":true,"last_activity_date":1493199636,"creation_date":1493199636,"body":"<p>What can be said so far: you use the ExecutorService to pass in tasks:</p>\n\n<pre><code>new StatusMultiThreading(id, username, psLog, connSTORY, connCF, mongoDatabase)\n</code></pre>\n\n<p>Later on, when you call <code>get()</code> the corresponding task is triggered. So that exception takes place inside that class of yours. </p>\n","answer_id":43630459,"question_id":43630406},{"owner":{"profile_image":"https://lh5.googleusercontent.com/-zJQot7cFQ8g/AAAAAAAAAAI/AAAAAAAAC8w/mLSR34VdUxk/photo.jpg?sz=256","account_id":9419272,"user_type":"registered","user_id":7803889,"link":"https://stackoverflow.com/users/7803889/javier-reinoso","reputation":11,"display_name":"Javier Reinoso"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1491120410,"creation_date":1491118425,"body":"<p>Just write the item in values/styles.xml:</p>\n\n<pre><code>&lt;item name=\"android:windowBackground\"&gt;@android:color/black&lt;/item&gt;\n</code></pre>\n\n<p>For example, in the AppTheme:</p>\n\n<pre><code>&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"&gt;\n    &lt;item name=\"windowNoTitle\"&gt;true&lt;/item&gt;\n    &lt;item name=\"windowActionBar\"&gt;false&lt;/item&gt;\n    &lt;item name=\"android:windowFullscreen\"&gt;true&lt;/item&gt;\n    &lt;item name=\"android:windowContentOverlay\"&gt;@null&lt;/item&gt;\n\n    &lt;item name=\"android:windowBackground\"&gt;@android:color/black&lt;/item&gt;\n\n    &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt;\n    &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt;\n    &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt;\n&lt;/style&gt;\n</code></pre>\n","answer_id":43165801,"question_id":37437037,"last_edit_date":1491120410},{"owner":{"profile_image":"https://i.stack.imgur.com/GGyFL.jpg?s=256&g=1","account_id":7201903,"user_type":"registered","user_id":5498855,"link":"https://stackoverflow.com/users/5498855/ivan-milisavljevic","reputation":2058,"display_name":"Ivan Milisavljevic"},"content_license":"CC BY-SA 3.0","score":102,"is_accepted":true,"last_activity_date":1490998158,"creation_date":1465301471,"body":"<p>The problem with white background is caused because of android's cold start while the app loads to memory, and it can be avoided with this:</p>\n\n<pre><code>public class OnboardingWithCenterAnimationActivity extends AppCompatActivity {\npublic static final int STARTUP_DELAY = 300;\npublic static final int ANIM_ITEM_DURATION = 1000;\npublic static final int ITEM_DELAY = 300;\n\nprivate boolean animationStarted = false;\n\n@Override\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    setTheme(R.style.AppTheme);\n    getWindow().getDecorView().setSystemUiVisibility(\n            View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_onboarding_center);\n}\n\n@Override\npublic void onWindowFocusChanged(boolean hasFocus) {\n\n    if (!hasFocus || animationStarted) {\n        return;\n    }\n\n    animate();\n\n    super.onWindowFocusChanged(hasFocus);\n}\n\nprivate void animate() {\n    ImageView logoImageView = (ImageView) findViewById(R.id.img_logo);\n    ViewGroup container = (ViewGroup) findViewById(R.id.container);\n\n    ViewCompat.animate(logoImageView)\n        .translationY(-250)\n        .setStartDelay(STARTUP_DELAY)\n        .setDuration(ANIM_ITEM_DURATION).setInterpolator(\n            new DecelerateInterpolator(1.2f)).start();\n\n    for (int i = 0; i &lt; container.getChildCount(); i++) {\n        View v = container.getChildAt(i);\n        ViewPropertyAnimatorCompat viewAnimator;\n\n        if (!(v instanceof Button)) {\n            viewAnimator = ViewCompat.animate(v)\n                    .translationY(50).alpha(1)\n                    .setStartDelay((ITEM_DELAY * i) + 500)\n                    .setDuration(1000);\n        } else {\n            viewAnimator = ViewCompat.animate(v)\n                    .scaleY(1).scaleX(1)\n                    .setStartDelay((ITEM_DELAY * i) + 500)\n                    .setDuration(500);\n        }\n\n        viewAnimator.setInterpolator(new DecelerateInterpolator()).start();\n    }\n}\n}\n</code></pre>\n\n<p>layout</p>\n\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;FrameLayout\nxmlns:android=\"http://schemas.android.com/apk/res/android\"\nxmlns:tools=\"http://schemas.android.com/tools\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\"\nandroid:background=\"?colorPrimary\"\nandroid:orientation=\"vertical\"\n&gt;\n\n&lt;LinearLayout\n    android:id=\"@+id/container\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:layout_gravity=\"center\"\n    android:gravity=\"center\"\n    android:orientation=\"vertical\"\n    android:paddingTop=\"144dp\"\n    tools:ignore=\"HardcodedText\"\n    &gt;\n\n    &lt;TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center_horizontal\"\n        android:layout_marginTop=\"16dp\"\n        android:alpha=\"0\"\n        android:text=\"Hello world\"         android:textAppearance=\"@style/TextAppearance.AppCompat.Widget.ActionBar.Title.Inverse\"\n        android:textColor=\"@android:color/white\"\n        android:textSize=\"22sp\"\n        tools:alpha=\"1\"\n        /&gt;\n\n    &lt;TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center_horizontal\"\n        android:layout_marginTop=\"8dp\"\n        android:alpha=\"0\"\n        android:gravity=\"center\"\n        android:text=\"This a nice text\"\n      android:textAppearance=\"@style/TextAppearance.AppCompat.Widget.ActionBar.Subtitle.Inverse\"\n        android:textSize=\"20sp\"\n        tools:alpha=\"1\"\n        /&gt;\n\n    &lt;Button\n        android:id=\"@+id/btn_choice1\"\n        android:layout_width=\"200dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginTop=\"48dp\"\n        android:scaleX=\"0\"\n        android:scaleY=\"0\"\n        android:text=\"A nice choice\"\n        android:theme=\"@style/Button\"\n        /&gt;\n\n    &lt;Button\n        android:id=\"@+id/btn_choice2\"\n        android:layout_width=\"200dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginTop=\"4dp\"\n        android:scaleX=\"0\"\n        android:scaleY=\"0\"\n        android:text=\"Far better!\"\n        android:theme=\"@style/Button\"\n        /&gt;\n\n&lt;/LinearLayout&gt;\n\n&lt;ImageView\n    android:id=\"@+id/img_logo\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:layout_gravity=\"center\"\n    android:src=\"@drawable/img_face\"\n    tools:visibility=\"gone\"\n    /&gt;\n&lt;/FrameLayout&gt;\n</code></pre>\n\n<p>img face</p>\n\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:opacity=\"opaque\"&gt;\n\n&lt;item android:drawable=\"?colorPrimary\"/&gt;\n&lt;item&gt;\n    &lt;bitmap\n        android:gravity=\"center\"\n        android:src=\"@drawable/img_face\"/&gt;\n&lt;/item&gt;\n</code></pre>\n\n<p></p>\n\n<p>Add this theme to your splashscreen in the manifest</p>\n\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;resources&gt;\n&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt;\n    &lt;!-- Customize your theme here. --&gt;\n    &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt;\n    &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt;\n    &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt;\n    &lt;item name=\"android:windowBackground\"&gt;@null&lt;/item&gt;\n&lt;/style&gt;\n\n&lt;style name=\"AppTheme.CenterAnimation\"&gt;\n    &lt;item name=\"android:windowBackground\"&gt;@drawable/ll_face_logo&lt;/item&gt;\n&lt;/style&gt;\n</code></pre>\n\n<p></p>\n\n<p>which will produce efect like this</p>\n\n<p><img src=\"https://raw.githubusercontent.com/saulmm/onboarding-examples-android/master/art/center.gif\" alt=\"a busy cat\"></p>\n\n<p>for more details and more solutions you can check this\n<a href=\"http://saulmm.github.io/avoding-android-cold-starts\" rel=\"noreferrer\">BlogPost</a></p>\n","answer_id":37679026,"question_id":37437037,"last_edit_date":1490998158},{"owner":{"profile_image":"https://i.stack.imgur.com/oZ1UM.gif?s=256&g=1","account_id":930090,"user_type":"registered","user_id":960115,"link":"https://stackoverflow.com/users/960115/jeff-g","reputation":4490,"display_name":"Jeff G","accept_rate":92},"content_license":"CC BY-SA 3.0","score":7,"is_accepted":false,"last_activity_date":1489186173,"creation_date":1489186173,"body":"<p>As of Java 8, you can use a lambda to capture parameters that are <a href=\"https://stackoverflow.com/a/20938132/960115\">effectively final</a>.  For example:</p>\n\n<pre><code>final String param1 = \"First param\";\nfinal int param2 = 2;\nnew Thread(() -&gt; {\n    // Do whatever you want here: param1 and param2 are in-scope!\n    System.out.println(param1);\n    System.out.println(param2);\n}).start();\n</code></pre>\n","answer_id":42729024,"question_id":877096,"last_edit_date":1495540988},{"owner":{"profile_image":"https://www.gravatar.com/avatar/6e4992cc0a3d78db161a3a1170148520?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6236104,"user_type":"registered","user_id":4851359,"link":"https://stackoverflow.com/users/4851359/infoj","reputation":681,"display_name":"infoj"},"content_license":"CC BY-SA 3.0","score":8,"is_accepted":false,"last_activity_date":1485703285,"creation_date":1440086295,"body":"<p>Two use cases where threadlocal variable can be used - <br/>\n1- When we have a requirement to associate state with a thread (e.g., a user ID or Transaction ID). That usually happens with a web application that every request going to a servlet has a unique transactionID associated with it.</p>\n\n<pre><code>// This class will provide a thread local variable which\n// will provide a unique ID for each thread\nclass ThreadId {\n    // Atomic integer containing the next thread ID to be assigned\n    private static final AtomicInteger nextId = new AtomicInteger(0);\n\n    // Thread local variable containing each thread's ID\n    private static final ThreadLocal&lt;Integer&gt; threadId =\n        ThreadLocal.&lt;Integer&gt;withInitial(()-&gt; {return nextId.getAndIncrement();});\n\n    // Returns the current thread's unique ID, assigning it if necessary\n    public static int get() {\n        return threadId.get();\n    }\n}\n</code></pre>\n\n<p>Note that here the method withInitial is implemented using lambda expression.<br/>\n2- Another use case is when we want to have a thread safe instance and we don't want to use synchronization as the performance cost with synchronization is more. One such case is when SimpleDateFormat is used. Since SimpleDateFormat is not thread safe so we have to provide mechanism to make it thread safe. </p>\n\n<pre><code>public class ThreadLocalDemo1 implements Runnable {\n    // threadlocal variable is created\n    private static final ThreadLocal&lt;SimpleDateFormat&gt; dateFormat = new ThreadLocal&lt;SimpleDateFormat&gt;(){\n        @Override\n        protected SimpleDateFormat initialValue(){\n            System.out.println(\"Initializing SimpleDateFormat for - \" + Thread.currentThread().getName() );\n            return new SimpleDateFormat(\"dd/MM/yyyy\");\n        }\n    };\n\n    public static void main(String[] args) {\n        ThreadLocalDemo1 td = new ThreadLocalDemo1();\n        // Two threads are created\n        Thread t1 = new Thread(td, \"Thread-1\");\n        Thread t2 = new Thread(td, \"Thread-2\");\n        t1.start();\n        t2.start();\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"Thread run execution started for \" + Thread.currentThread().getName());\n        System.out.println(\"Date formatter pattern is  \" + dateFormat.get().toPattern());\n        System.out.println(\"Formatted date is \" + dateFormat.get().format(new Date()));\n    } \n\n}\n</code></pre>\n","answer_id":32122972,"question_id":817856,"last_edit_date":1485703285},{"owner":{"profile_image":"https://www.gravatar.com/avatar/ee889ac6797f1f23ebb955164162bd39?s=256&d=identicon&r=PG","account_id":2019478,"user_type":"registered","user_id":1806005,"link":"https://stackoverflow.com/users/1806005/hi-my-name-is","reputation":4894,"display_name":"hi_my_name_is","accept_rate":56},"content_license":"CC BY-SA 3.0","score":5,"is_accepted":true,"last_activity_date":1483083594,"creation_date":1483083594,"body":"<p>you may want to play with <code>isolation</code> parameter of<code>@Transactional</code> annotation. Spring by default uses.. hm.. <code>DEFAULT</code> which is set by database, so may be different. You can try to use: <code>READ_UNCOMMITTED</code>. More info: <a href=\"http://www.byteslounge.com/tutorials/spring-transaction-isolation-tutorial\" rel=\"noreferrer\">http://www.byteslounge.com/tutorials/spring-transaction-isolation-tutorial</a></p>\n","answer_id":41392530,"question_id":41391209},{"owner":{"profile_image":"https://www.gravatar.com/avatar/7dfb3c6fe5d0c1f5121d7d6d311fa8ff?s=256&d=identicon&r=PG","account_id":1056981,"user_type":"registered","user_id":1059465,"link":"https://stackoverflow.com/users/1059465/znlyj","reputation":1109,"display_name":"znlyj","accept_rate":43},"content_license":"CC BY-SA 3.0","score":10,"is_accepted":false,"last_activity_date":1480420693,"creation_date":1367162549,"body":"<p>Webapp server may keep a thread pool, and a <code>ThreadLocal</code> var should be removed before response to the client, thus current thread may be reused by next request.</p>\n","answer_id":16264385,"question_id":817856,"last_edit_date":1480420693},{"owner":{"profile_image":"https://www.gravatar.com/avatar/4301e2847b861058706df775f913e02d?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8829249,"user_type":"registered","user_id":6596346,"link":"https://stackoverflow.com/users/6596346/paul","reputation":96,"display_name":"paul","accept_rate":40},"content_license":"CC BY-SA 3.0","score":-1,"is_accepted":false,"last_activity_date":1477174238,"creation_date":1477174238,"body":"<p>Instead of while true in you waitForClient method try this</p>\n\n<pre><code>private final int allowedClients = 10;\nprivate int connectedClients = 0;\npublic void waitForClient () {\n\nboolean isLogPrinted = false;\n\nwhile (connectedClients &lt;= allowedClients){\n    try {\n       if (clientCount &lt; serverThread.length){\n           System.out.println (\"Waiting for connection...\");\n           isLogPrinted = false;\n           addThread (serverSocket.accept());\n           connectedClients++;\n           System.out.println(\"Client count: \" + clientCount);\n       }\n       else {\n           if (!isLogPrinted){\n                System.out.println(\"MAXIMUM NUMBER OF CLIENTS REACHED! (\" + clientCount + \").\");\n                isLogPrinted = true;\n           }\n       }\n   } catch (IOException e) {\n       System.out.println(\"Error while waiting for new clients to connect: \" + e.getMessage());\n        }\n</code></pre>\n\n<p>}\n}</p>\n","answer_id":40197569,"question_id":40197514},{"owner":{"profile_image":"https://i.stack.imgur.com/oJtcB.jpg?s=256&g=1","account_id":6080415,"user_type":"registered","user_id":4746376,"link":"https://stackoverflow.com/users/4746376/sohail-zahid","reputation":8109,"display_name":"Sohail Zahid","accept_rate":73},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1471511197,"creation_date":1471511197,"body":"<p>Both properties works</p>\n\n<pre><code>    &lt;style name=\"AppBaseThemeDark\" parent=\"@style/Theme.AppCompat\"&gt;\n            &lt;!--your other properties --&gt;\n            &lt;!--&lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;--&gt;\n            &lt;item name=\"android:windowBackground\"&gt;@null&lt;/item&gt;\n            &lt;!--your other properties --&gt;\n    &lt;/style&gt;\n</code></pre>\n","answer_id":39014103,"question_id":37437037},{"owner":{"profile_image":"https://i.stack.imgur.com/XiFZh.jpg?s=256&g=1","account_id":1542133,"user_type":"registered","user_id":1955871,"link":"https://stackoverflow.com/users/1955871/rob","reputation":6317,"display_name":"Rob","accept_rate":75},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1469460315,"creation_date":1469460315,"body":"<p>While I am not familiar with Eclipse MAT and what it is showing you, it is proper behavior for some objects to go through the Finalizer queue.</p>\n\n<p>Under normal circumstances, any object that overrides the <code>finalize</code> method will be queued for finalization (which consists of calling the <code>finalize</code> method). The general idea is that when the garbage collector identifies an object as unreachable, it looks to see if the <code>finalize</code> method is overridden and has not yet been called. If <code>finalize</code> is defined and has not yet been called, then the object is queued for finalization, otherwise the memory is collected.</p>\n\n<p>The finalizer appears to be implemented as a queue that is serviced by a single thread. The thread processes each object in the queue by calling <code>finalize</code>. After the call to <code>finalize</code> completes, the object is removed from the queue.</p>\n\n<p>Subsequently, when the garbage collector again determines that the object is unreachable, it will find that <code>finalize</code> is overridden, but has already been called. The member is collected.</p>\n\n<p>Note that using this feature delays collection of garbage. And while it is a convenient way to clean up an object, the JVM does not guarantee when or even if the <code>finalize</code> method will be called.</p>\n\n<p>One related risk is \"finalizer starvation.\" You mention \"growing\" so perhaps this is an issue you are facing. If you create enough garbage that requires finalization and if that finalization takes too long, you can actually run out of memory because the single finalizer queue cannot keep up. There are a number of ways to deal with this situation:</p>\n\n<ul>\n<li>Make execution of <code>finalize</code> complete (infinite loops are bad) and quickly.</li>\n<li>Avoid synchronization in <code>finalize</code>.</li>\n<li>Make the Finalizer thread have the highest execution priority. This can be accomplished by creating a garbage instance that changes the thread priority in the finalizer - create one of these during app initialization.</li>\n</ul>\n\n<p>If you are seeing starvation, use a thread dump to see what the Finalizer thread is working on.</p>\n","answer_id":38571742,"question_id":38570732},{"owner":{"profile_image":"https://www.gravatar.com/avatar/4656523cbdc8a8a57fd218f93f035418?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6441501,"user_type":"registered","user_id":4991382,"link":"https://stackoverflow.com/users/4991382/mihir-patel","reputation":402,"display_name":"Mihir Patel"},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1468411201,"creation_date":1468409804,"body":"<p>No you can't pass parameters to the <code>run()</code> method. The signature tells you that (it has no parameters). Probably the easiest way to do this would be to use a purpose-built object that takes a parameter in the constructor and stores it in a final variable: </p>\n\n<pre><code>public class WorkingTask implements Runnable\n{\n    private final Object toWorkWith;\n\n    public WorkingTask(Object workOnMe)\n    {\n        toWorkWith = workOnMe;\n    }\n\n    public void run()\n    {\n        //do work\n    }\n}\n\n//...\nThread t = new Thread(new WorkingTask(theData));\nt.start();\n</code></pre>\n\n<p>Once you do that - you have to be careful of the data integrity of the object you pass into the 'WorkingTask'. The data will now exist in two different threads so you have to make sure it is Thread Safe.</p>\n","answer_id":38350646,"question_id":877096,"last_edit_date":1468411201},{"owner":{"profile_image":"https://www.gravatar.com/avatar/0d2acc7b8704bde598db2397d141d88f?s=256&d=identicon&r=PG","account_id":139857,"user_type":"registered","user_id":345718,"link":"https://stackoverflow.com/users/345718/patrick","reputation":799,"display_name":"Patrick"},"content_license":"CC BY-SA 3.0","score":8,"is_accepted":false,"last_activity_date":1468386642,"creation_date":1468386642,"body":"<p>Since this issue is still open at the time of writing (version 3.0.X) <a href=\"https://issues.jboss.org/browse/RESTEASY-1357\" rel=\"noreferrer\">RESTEASY: deprecated Apache classes cleanup</a></p>\n\n<p>You can go deeper to use the newer, non-deprecated classes instead to create you resteasy client. You will also have more control over how you want the pool to be etc.</p>\n\n<p>Here is what I did:</p>\n\n<pre><code>// This will create a threadsafe JAX-RS client using pooled connections.\n// Per default this implementation will create no more than than 2\n// concurrent connections per given route and no more 20 connections in\n// total. (see javadoc of PoolingHttpClientConnectionManager)\nPoolingHttpClientConnectionManager cm =\n        new PoolingHttpClientConnectionManager();\n\nCloseableHttpClient closeableHttpClient =\n        HttpClientBuilder.create().setConnectionManager(cm).build();\nApacheHttpClient4Engine engine =\n        new ApacheHttpClient4Engine(closeableHttpClient);\nreturn new ResteasyClientBuilder().httpEngine(engine).build();\n</code></pre>\n\n<p>Also <strong>make sure you release the connection</strong> after making a call. Calling response.close() will do that for you so probably put that in a finally block.</p>\n","answer_id":38343094,"question_id":33097230},{"owner":{"profile_image":"https://www.gravatar.com/avatar/bffea7de598020c514bdca3b0239d865?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8509289,"user_type":"registered","user_id":6379785,"link":"https://stackoverflow.com/users/6379785/gmetal","reputation":2918,"display_name":"gmetal"},"content_license":"CC BY-SA 3.0","score":21,"is_accepted":false,"last_activity_date":1465307102,"creation_date":1465307102,"body":"<p>Have you tried setting the<code>android:windowBackground</code> attribute in the theme of your launcher activity, to either a color or a drawable?</p>\n\n<p>For example this: </p>\n\n<pre><code>&lt;item name=\"android:windowBackground\"&gt;@android:color/black&lt;/item&gt;\n</code></pre>\n\n<p>when added to the Launcher activity theme will show a black color (rather than the white color) on startup. This is an easy trick to hide long initialisation, while showing your users something, <strong>and it works fine</strong> even if you subclass the Application object.</p>\n\n<p>Avoid using other constructs (even Threads) for doing long initialisation tasks, because you may end up not being able to control the lifecycle of such constructs. The Application object is the correct place for doing exactly this type of actions. </p>\n","answer_id":37681189,"question_id":37437037},{"owner":{"profile_image":"https://i.stack.imgur.com/eCkiz.jpg?s=256&g=1","account_id":3251487,"user_type":"registered","user_id":2741598,"link":"https://stackoverflow.com/users/2741598/vickyexpert","reputation":3147,"display_name":"Vickyexpert","accept_rate":50},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1464861962,"creation_date":1464861962,"body":"<p>As you are already aware why this white screen is there, as due to background processes or application initialization or large files, so just check below idea for overcome from this.</p>\n\n<p>To prevent this white screen on beginning of the app, one way is splash screen, this is just a way not final and you must have to use.</p>\n\n<p>When you will show splash screen from your splash.xml file, then also this issue will be remain same,</p>\n\n<p>So you have to create ont style in style.xml file for splash screen and there you have to set window background as your splash image and then apply that theme to your splash activity from manifest file. So now when you will run app, first it will set theme and by this way user will be able to see directly splash image instead of white screen.</p>\n","answer_id":37588748,"question_id":37437037},{"owner":{"profile_image":"https://i.stack.imgur.com/Q57nx.jpg?s=256&g=1","account_id":3016236,"user_type":"registered","user_id":4969827,"link":"https://stackoverflow.com/users/4969827/sergey-shustikov","reputation":15507,"display_name":"Sergey Shustikov"},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1464861958,"creation_date":1464861958,"body":"<p>Did you try to put initialization to <code>onActivityCreated</code>?</p>\n\n<p>Inside <code>Application</code> class :</p>\n\n<pre><code> registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() {\n            @Override\n            public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n                if(activity.getClass().equals(FirstActivity.class) {\n                    // try without runOnUiThread if it will not help\n                    activity.runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            new InitializatioTask().execute();\n                        }\n                    });\n                }\n            }\n\n            @Override\n            public void onActivityStarted(Activity activity) {\n\n            }\n\n            @Override\n            public void onActivityResumed(Activity activity) {\n\n            }\n\n            @Override\n            public void onActivityPaused(Activity activity) {\n\n            }\n\n            @Override\n            public void onActivityStopped(Activity activity) {\n\n            }\n\n            @Override\n            public void onActivitySaveInstanceState(Activity activity, Bundle outState) {\n\n            }\n\n            @Override\n            public void onActivityDestroyed(Activity activity) {\n\n            }\n        });\n</code></pre>\n","answer_id":37588747,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c039fcc583a7df47d9b415dcccd343a4?s=256&d=identicon&r=PG","account_id":1963159,"user_type":"registered","user_id":1764080,"link":"https://stackoverflow.com/users/1764080/shmuel","reputation":3916,"display_name":"Shmuel","accept_rate":65},"content_license":"CC BY-SA 3.0","score":21,"is_accepted":false,"last_activity_date":1464179937,"creation_date":1464179937,"body":"<p>First of all, to remove the white screen read this - <a href=\"https://www.bignerdranch.com/blog/splash-screens-the-right-way/\" rel=\"noreferrer\">https://www.bignerdranch.com/blog/splash-screens-the-right-way/</a></p>\n\n<p>But more importantly, optimize your initial load and defer any heavy work to when you have time to run it. Post your application class here if you want us to take a look at it.</p>\n","answer_id":37437432,"question_id":37437037},{"owner":{"profile_image":"https://www.gravatar.com/avatar/7ca54b3b9ddb5fa296fa19ac520294ae?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":7265641,"user_type":"registered","user_id":6259238,"link":"https://stackoverflow.com/users/6259238/limestone","reputation":51,"display_name":"Limestone"},"content_license":"CC BY-SA 3.0","score":5,"is_accepted":false,"last_activity_date":1461726649,"creation_date":1461726649,"body":"<p>when?</p>\n\n<p>When an object is not thread-safe, instead of synchronization which hampers the scalability, give one object to every thread and keep it thread scope, which is ThreadLocal. One of most often used but not thread-safe objects are database Connection and JMSConnection. </p>\n\n<p>How ?</p>\n\n<p>One example is Spring framework uses ThreadLocal heavily for managing transactions behind the scenes by keeping these connection objects in ThreadLocal variables. At high level, when a transaction is started it gets the connection ( and disables the auto commit ) and keeps it in ThreadLocal. on further db calls it uses same connection to communicate with db. At the end, it takes the connection from ThreadLocal and commits ( or rollback ) the transaction and releases the connection. </p>\n\n<p>I think log4j also uses ThreadLocal for maintaining MDC.</p>\n","answer_id":36879565,"question_id":817856},{"owner":{"profile_image":"https://www.gravatar.com/avatar/077e85b58e7d2f715ce377c558d3b4ec?s=256&d=identicon&r=PG","account_id":179293,"user_type":"registered","user_id":411846,"link":"https://stackoverflow.com/users/411846/centic","reputation":15713,"display_name":"centic","accept_rate":80},"content_license":"CC BY-SA 3.0","score":13,"is_accepted":false,"last_activity_date":1459849119,"creation_date":1459846446,"body":"<p>Be aware: Apache POI explicitly does not support multi-threading access to the same workbook-object! This is because there are structures that are handled on a workbook-level, e.g. Styles, Comments, ...</p>\n\n<p>You will run into obscure errors and corrupted documents if you try to do this naively. </p>\n\n<p>The only guarantee that it makes is that separate workbooks in different threads will work fine, i.e. there is no thread-unsafe global state kept anywhere.</p>\n\n<p>The only way that should work would be to synchronize every access to the workbook via a synchronized block:</p>\n\n<pre><code>synchronized (workbook) {\n    ... access the sheet and the contents\n}\n</code></pre>\n\n<p>Read-only access might work, but again Apache POI does not make guarantees that concurrent read-access to the same workbook will work.</p>\n\n<p>Update: There is now a corresponding <a href=\"http://poi.apache.org/faq.html#faq-N101BC\" rel=\"noreferrer\">FAQ entry</a> stating this as well.</p>\n","answer_id":36421529,"question_id":28626848,"last_edit_date":1459849119},{"owner":{"profile_image":"https://www.gravatar.com/avatar/99266f63196c82aaeb18e36727424c07?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":3869264,"user_type":"registered","user_id":3204950,"link":"https://stackoverflow.com/users/3204950/rameshvanka","reputation":51,"display_name":"rameshvanka"},"content_license":"CC BY-SA 3.0","score":-1,"is_accepted":false,"last_activity_date":1459845993,"creation_date":1459844383,"body":"<p>Inside the main thread create the workbook, workbook create the sheets and distribute the sheets to worker thread. main thread should wait until all the worker thread completes. main thread workbook the flush the data into stream. then stream into file.</p>\n\n<p>If you want source code with example, send a mail to me. I will share ramesh.niwas@gmail.com</p>\n","answer_id":36420786,"question_id":28626848,"last_edit_date":1459845993},{"owner":{"profile_image":"https://www.gravatar.com/avatar/07a4fda1c1cd6f2a3168d7fbb72dcc16?s=256&d=identicon&r=PG","account_id":7882823,"user_type":"registered","user_id":5956116,"link":"https://stackoverflow.com/users/5956116/pavel-pscheidl","reputation":344,"display_name":"Pavel Pscheidl"},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1458491585,"creation_date":1458491585,"body":"<p>First, do not reuse WebTarget. For simplicity, you can always create new WebTarget.</p>\n\n<p>Second, if you're using Resteasy, you can add provided dependency for Resteasy client to your project. Example in Gradle:</p>\n\n<pre><code>    provided 'org.jboss.resteasy:resteasy-client:3.0.14.Final'\n</code></pre>\n\n<p>Then, you can create your connection like this:</p>\n\n<pre><code>        ResteasyClientBuilder builder = new ResteasyClientBuilder();\n        builder.connectionPoolSize(200);\n</code></pre>\n\n<p>There is no need to set maxPooledPerRoute, this is set automatically by RestEasy (can be found in RestEasyClientBuilder class source code).</p>\n\n<p>When you set connectionPoolSize, you will no longer get error when Client is reused and you can happily re-use them all across the application. I've tried this solution on many projects and it actually works well. But when you deploy your application to a non-resteasy container (like Glassfish), your code won't work and you will have to use ClientBuilder class again.</p>\n","answer_id":36116402,"question_id":33097230},{"owner":{"profile_image":"https://i.stack.imgur.com/xpNqK.jpg?s=256&g=1","account_id":426109,"user_type":"registered","user_id":807126,"link":"https://stackoverflow.com/users/807126/doug-stevenson","reputation":302042,"display_name":"Doug Stevenson"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":true,"last_activity_date":1457491340,"creation_date":1457491340,"body":"<p>You can remove previously posted Runnables using the <a href=\"http://developer.android.com/reference/android/os/Handler.html#removeCallbacks(java.lang.Runnable)\" rel=\"nofollow\">removeCallbacks()</a> method on the Handler used to post them.  You will need to have the <em>exact</em> reference to the Runnable posted.</p>\n\n<p>In your code, you post a Runnable while declaring it anonymously inline.  If you do that, won't retain a reference to that Runnable.  Instead, you can store the reference to that new Runnable in a member variable or something that won't be forgotten by the time you want to remove it.</p>\n\n<pre><code>private Runnable r;  // assign before use\nprivate Handler h;   // assign before use\n\nprivate void schedule() {\n    h.postDelayed(r, 99999);\n}\n\nprivate void cancel() {\n    h.removeCallbacks(r);\n}\n</code></pre>\n","answer_id":35881920,"question_id":35881814},{"owner":{"profile_image":"https://i.stack.imgur.com/7H9TF.png?s=256&g=1","account_id":2994830,"user_type":"registered","user_id":2541560,"link":"https://stackoverflow.com/users/2541560/kayaman","reputation":1,"display_name":"Kayaman"},"content_license":"CC BY-SA 3.0","score":3,"is_accepted":false,"last_activity_date":1456390979,"creation_date":1456390979,"body":"<p>Unless you call <code>p.waitFor();</code> your process will happily run concurrently alongside the process that it spawned (<code>p</code>).</p>\n","answer_id":35622631,"question_id":35622593},{"owner":{"profile_image":"https://www.gravatar.com/avatar/bb15dcf43c8fe4a01b9d16e93690e118?s=256&d=identicon&r=PG","account_id":543250,"user_type":"registered","user_id":912319,"link":"https://stackoverflow.com/users/912319/kanagavelu-sugumar","reputation":18874,"display_name":"Kanagavelu Sugumar","accept_rate":62},"content_license":"CC BY-SA 3.0","score":5,"is_accepted":false,"last_activity_date":1452144546,"creation_date":1449058064,"body":"<blockquote>\n  <p>ThreadLocal will ensure accessing the mutable object by the multiple\n  threads in the non synchronized method is synchronized, means making\n  the mutable object to be immutable within the method. <BR> <BR> This\n  is achieved by giving new instance of mutable object for each thread\n  try accessing it. So It is local copy to the each thread. This is some\n  hack on making instance variable in a method to be accessed like a\n  local variable. As you aware method local variable is only available\n  to the thread, one difference is; method local variables will not\n  available to the thread once method execution is over where as mutable\n  object shared with threadlocal will be available across multiple\n  methods till we clean it up.</p>\n</blockquote>\n\n<p><strong>By Definition:</strong></p>\n\n<blockquote>\n  <p>The ThreadLocal class in Java enables you to create variables that can\n  only be read and written by the same thread. Thus, even if two threads\n  are executing the same code, and the code has a reference to a\n  ThreadLocal variable, then the two threads cannot see each other's\n  ThreadLocal variables.</p>\n</blockquote>\n\n<p>Each <code>Thread</code> in java contains <code>ThreadLocalMap</code> in it. <BR>\nWhere <BR></p>\n\n<pre><code>Key = One ThreadLocal object shared across threads.\nvalue = Mutable object which has to be used synchronously, this will be instantiated for each thread.\n</code></pre>\n\n<p><strong>Achieving the ThreadLocal:</strong> </p>\n\n<p>Now create a wrapper class for ThreadLocal which is going to hold the mutable object like below (with or without <code>initialValue()</code>). <BR> Now getter and setter of this wrapper will work on threadlocal instance instead of mutable object.</p>\n\n<p>If getter() of threadlocal didn't find any value with in the threadlocalmap of the <code>Thread</code>; then it will invoke the initialValue() to get its private copy with respect to the thread.</p>\n\n<pre><code>class SimpleDateFormatInstancePerThread {\n\n    private static final ThreadLocal&lt;SimpleDateFormat&gt; dateFormatHolder = new ThreadLocal&lt;SimpleDateFormat&gt;() {\n\n        @Override\n        protected SimpleDateFormat initialValue() {\n            SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\") {\n                UUID id = UUID.randomUUID();\n                @Override\n                public String toString() {\n                    return id.toString();\n                };\n            };\n            System.out.println(\"Creating SimpleDateFormat instance \" + dateFormat +\" for Thread : \" + Thread.currentThread().getName());\n            return dateFormat;\n        }\n    };\n\n    /*\n     * Every time there is a call for DateFormat, ThreadLocal will return calling\n     * Thread's copy of SimpleDateFormat\n     */\n    public static DateFormat getDateFormatter() {\n        return dateFormatHolder.get();\n    }\n\n    public static void cleanup() {\n        dateFormatHolder.remove();\n    }\n}\n</code></pre>\n\n<p>Now <code>wrapper.getDateFormatter()</code> will call <code>threadlocal.get()</code> and that will check the <code>currentThread.threadLocalMap</code> contains <strong>this</strong> (threadlocal) instance.<BR>\nIf yes return the value (SimpleDateFormat) for corresponding threadlocal instance <BR>\nelse add the map with this threadlocal instance, initialValue(). <BR></p>\n\n<p>Herewith thread safety achieved on this mutable class; by each thread is working with its own mutable instance but with same ThreadLocal instance. Means All the thread will share the same ThreadLocal instance as key, but different SimpleDateFormat instance as value.</p>\n\n<p><a href=\"https://github.com/skanagavelu/yt.tech/blob/master/src/ThreadLocalTest.java\" rel=\"noreferrer\">https://github.com/skanagavelu/yt.tech/blob/master/src/ThreadLocalTest.java</a></p>\n","answer_id":34042362,"question_id":817856,"last_edit_date":1452144546},{"owner":{"profile_image":"https://i.stack.imgur.com/lwpFY.png?s=256&g=1","account_id":6764092,"user_type":"registered","user_id":5264490,"link":"https://stackoverflow.com/users/5264490/chromium","reputation":517,"display_name":"Chromium","accept_rate":100},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1452136702,"creation_date":1452136702,"body":"<p>There is a simple way of passing parameters into runnables.\nCode:</p>\n\n<pre><code>public void Function(final type variable) {\n    Runnable runnable = new Runnable() {\n        public void run() {\n            //Code adding here...\n        }\n    };\n    new Thread(runnable).start();\n}\n</code></pre>\n","answer_id":34646813,"question_id":877096},{"owner":{"profile_image":"https://www.gravatar.com/avatar/3e83e511e401770207ffbb0d31b8ffb4?s=256&d=identicon&r=PG","account_id":916980,"user_type":"registered","user_id":2580516,"link":"https://stackoverflow.com/users/2580516/warren-dew","reputation":8820,"display_name":"Warren Dew"},"content_license":"CC BY-SA 3.0","score":8,"is_accepted":false,"last_activity_date":1446016175,"creation_date":1446016175,"body":"<p>In the case of multithreaded code with both reads and writes, if a thread neglects to obtain a lock while reading, it risks reading inconsistent or garbage data due to a simultaneous write.  For example, it could read a long variable just as that long variable was being written, and it could read the high half of the old value and the low half of the new value, which means the value it read would be complete garbage, something that was never actually written.</p>\n\n<p>If a thread with a read lock writes without the write lock, it could cause other reading threads to read garbage data in a similar manner.</p>\n","answer_id":33384952,"question_id":33384822},{"owner":{"profile_image":"https://i.stack.imgur.com/XpMUU.jpg?s=256&g=1","account_id":1431364,"user_type":"registered","user_id":1353722,"link":"https://stackoverflow.com/users/1353722/lefloh","reputation":10713,"display_name":"lefloh","accept_rate":81},"content_license":"CC BY-SA 3.0","score":9,"is_accepted":false,"last_activity_date":1444797794,"creation_date":1444797794,"body":"<p>Your implementation is not thread-safe. When two threads access <code>someMethod</code> at the same time they are sharing the same <code>Client</code> and one will try to make a second request while the first one is not finished. </p>\n\n<p>You have two choices:</p>\n\n<ul>\n<li>Synchronize the access to the <code>Client</code> and <code>WebTarget</code> manually.</li>\n<li>Let the container manage concurrency by annotating the enclosing type with <code>@javax.ejb.Singleton</code> which guarantees thread safety. (see chapter 4.8.5 of the <a href=\"http://download.oracle.com/otn-pub/jcp/ejb-3.1-pfd-oth-JSpec/ejb-3_1-pfd-spec.pdf\" rel=\"noreferrer\">EJB specification</a>)</li>\n</ul>\n\n<p>If <code>someMethod</code> in a container managed environment I would use the second approach.</p>\n","answer_id":33116773,"question_id":33097230},{"owner":{"profile_image":"https://i.stack.imgur.com/rHVf5.jpg?s=256&g=1","account_id":2353205,"user_type":"registered","user_id":2061604,"link":"https://stackoverflow.com/users/2061604/andrei","reputation":43254,"display_name":"Andrei","accept_rate":73},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1441713166,"creation_date":1441712019,"body":"<h2>Specially for Android</h2>\n\n<p>For callback purposes I usually implement my own generic <code>Runnable</code> with input parameter(s):</p>\n\n<pre><code>public interface Runnable&lt;TResult&gt; {\n    void run(TResult result);\n}\n</code></pre>\n\n<p>Usage is simple:</p>\n\n<pre><code>myManager.doCallbackOperation(new Runnable&lt;MyResult&gt;() {\n    @Override\n    public void run(MyResult result) {\n        // do something with the result\n    }\n});\n</code></pre>\n\n<p>In manager:</p>\n\n<pre><code>public void doCallbackOperation(Runnable&lt;MyResult&gt; runnable) {\n    new AsyncTask&lt;Void, Void, MyResult&gt;() {\n        @Override\n        protected MyResult doInBackground(Void... params) {\n            // do background operation\n            return new MyResult(); // return resulting object\n        }\n\n        @Override\n        protected void onPostExecute(MyResult result) {\n            // execute runnable passing the result when operation has finished\n            runnable.run(result);\n        }\n    }.execute();\n}\n</code></pre>\n","answer_id":32456728,"question_id":877096,"last_edit_date":1441713166},{"owner":{"profile_image":"https://www.gravatar.com/avatar/1768cce8ccf2dffe3483b0ab5d7cfd74?s=256&d=identicon&r=PG","account_id":10987,"user_type":"registered","user_id":21005,"link":"https://stackoverflow.com/users/21005/mnementh","reputation":50685,"display_name":"Mnementh","accept_rate":78},"content_license":"CC BY-SA 3.0","score":9,"is_accepted":false,"last_activity_date":1440141330,"creation_date":1242643320,"body":"<p>To create a thread you normally create your own implementation of Runnable. Pass the parameters to the thread in the constructor of this class.</p>\n\n<pre><code>class MyThread implements Runnable{\n   private int a;\n   private String b;\n   private double c;\n\n   public MyThread(int a, String b, double c){\n      this.a = a;\n      this.b = b;\n      this.c = c;\n   }\n\n   public void run(){\n      doSomething(a, b, c);\n   }\n}\n</code></pre>\n","answer_id":877116,"question_id":877096,"last_edit_date":1440141330},{"owner":{"profile_image":"https://www.gravatar.com/avatar/699a9b2caefb52530d1c872bb2932d21?s=256&d=identicon&r=PG","account_id":22965,"user_type":"registered","user_id":57159,"link":"https://stackoverflow.com/users/57159/ian-ringrose","reputation":51428,"display_name":"Ian Ringrose","accept_rate":89},"content_license":"CC BY-SA 3.0","score":3,"is_accepted":false,"last_activity_date":1434388741,"creation_date":1434388741,"body":"<p>Caching, sometime you have to calculate the same value lots of time so by storing the last set of inputs to a method and the result you can speed the code up.    By using Thread Local Storage you avoid having to think about locking.</p>\n","answer_id":30851175,"question_id":817856},{"owner":{"profile_image":"https://i.stack.imgur.com/vpL92.jpg?s=256&g=1","account_id":1487826,"user_type":"registered","user_id":1404798,"link":"https://stackoverflow.com/users/1404798/thirumalvalavan","reputation":2690,"display_name":"Thirumalvalavan"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1426175165,"creation_date":1426175165,"body":"<p>Below code will help to someone,</p>\n\n<pre><code>public class MyClass {\n\nprivate static Object lock = new Object();\n\npublic static void main(String args[]){\n\n    Runnable runnable1 = new Runnable() {\n        @Override\n        public void run() {\n            for(int i=1; i&lt;20; i=i+2){\n                synchronized (lock) {\n                    System.out.println(\"Thread 1: \"+i);\n                    try {\n                        lock.notifyAll();\n                        lock.wait();\n                    } catch (InterruptedException e) {\n                        System.out.println(\"Error in Thread 1: \"+e.getMessage());\n                    }\n                }\n            }\n        }\n    };\n\n\n    Runnable runnable2 = new Runnable() {\n        @Override\n        public void run() {\n            for(int i=2; i&lt;=20; i=i+2){\n                synchronized (lock) {\n                    System.out.println(\"Thread 2: \"+i);\n                    try {\n                        lock.notifyAll();\n                        lock.wait();\n                    } catch (InterruptedException e) {\n                        System.out.println(\"Error in Thread 2: \"+e.getMessage());\n                    }\n                }\n            }\n        }\n    };\n\n    Thread thread1 = new Thread(runnable1);\n    Thread thread2 = new Thread(runnable2);\n\n    System.out.println(\"Thread Start: \");\n    thread1.start();\n    thread2.start();               \n}\n\n}\n</code></pre>\n","answer_id":29014237,"question_id":24720849},{"owner":{"profile_image":"https://www.gravatar.com/avatar/6196764c912dbcdd37f80cccf20d73b0?s=256&d=identicon&r=PG","account_id":5733087,"user_type":"registered","user_id":4528039,"link":"https://stackoverflow.com/users/4528039/t-gounelle","reputation":6013,"display_name":"T.Gounelle"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1424432344,"creation_date":1424432344,"body":"<p>You create a <code>XSSFWorkbook</code> by reading the file <code>C:/Test.xlsx</code> ; the constructor called is <a href=\"http://poi.apache.org/apidocs/org/apache/poi/xssf/usermodel/XSSFWorkbook.html#XSSFWorkbook(java.io.InputStream)\" rel=\"nofollow\"><code>XSSFWorkbook(InputStream)</code></a>, which constructs a <code>OPCPackage</code>. \nThis <code>C:/Test.xlsx</code> file has to be valid, i.e. not corrupted, not empty.</p>\n\n<p>If you want to create a <em>new</em> workbook, you should not read an empty file, but rather use the appropriate constructor.</p>\n\n<p>Regarding multi-threading, I haven't tested it but there are constraints on what the different threads can do (e.g. one per <code>XSSheet</code>). Look at this <a href=\"https://mail-archives.apache.org/mod_mbox/poi-user/201109.mbox/%3C1314859350817-4757295.post@n5.nabble.com%3E\" rel=\"nofollow\">mail archive</a>.</p>\n","answer_id":28628085,"question_id":28626848},{"owner":{"profile_image":"https://www.gravatar.com/avatar/0f72a37ab8103ebfa12561218367ec3a?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":395357,"user_type":"registered","user_id":758280,"link":"https://stackoverflow.com/users/758280/jeffrey","reputation":44547,"display_name":"Jeffrey","accept_rate":100},"content_license":"CC BY-SA 3.0","score":3,"is_accepted":true,"last_activity_date":1420236923,"creation_date":1420179624,"body":"<p>I feel like it's more straightforward to implement this with one <code>Queue</code> for each producer. One thread can't wait on multiple <code>Queue</code>s, but you could combine all of the <code>Queue</code>s into one helper class so that it doesn't need to.</p>\n\n<pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Queue;\nimport java.util.concurrent.PriorityBlockingQueue;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nimport javax.annotation.concurrent.GuardedBy;\n\npublic class RoundRobin&lt;P, E&gt; {\n    private final Lock lock = new ReentrantLock();\n    private final Condition added = lock.newCondition();\n\n    @GuardedBy(\"lock\") private final Map&lt;P, Queue&lt;E&gt;&gt; queues = new LinkedHashMap&lt;&gt;();\n\n    public boolean add(P producer, E item) {\n        lock.lock();\n        try {\n            if (!queues.containsKey(producer)) {\n                queues.put(producer, new PriorityBlockingQueue&lt;&gt;());\n            }\n\n            added.signalAll();\n            return queues.get(producer).add(item);\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public Iterator&lt;E&gt; roundRobinIterator() {\n        return new Iterator&lt;E&gt;() {\n            private Iterator&lt;? extends Queue&lt;E&gt;&gt; i = null;\n            private boolean singlePass = true;\n\n            @Override\n            public boolean hasNext() {\n                return true;\n            }\n\n            @Override\n            public E next() {\n                lock.lock();\n                try {\n                    while (true) {\n                        if (i == null || !i.hasNext()) {\n                            i = queues.values().iterator();\n                            singlePass = true;\n                        }\n\n                        while (i.hasNext()) {\n                            Queue&lt;E&gt; q = i.next();\n                            if (!q.isEmpty()) {\n                                if (singlePass) {\n                                    // copy the iterator to prevent\n                                    // ConcurrentModificationExceptions\n                                    singlePass = false;\n                                    i = copy(i);\n                                }\n                                return q.poll();\n                            }\n                        }\n\n                        if (singlePass) {\n                            // If singlePass is true then we just checked every\n                            // queue and they were all empty.\n                            // Wait for another element to be added.\n                            added.await();\n                        }\n                    }\n                } catch (InterruptedException e) {\n                    throw new NoSuchElementException(e.getMessage());\n                } finally {\n                    lock.unlock();\n                }\n            }\n\n            private &lt;T&gt; Iterator&lt;? extends T&gt; copy(Iterator&lt;? extends T&gt; i) {\n                List&lt;T&gt; copy = new ArrayList&lt;&gt;();\n                while (i.hasNext()) {\n                    copy.add(i.next());\n                }\n                return copy.iterator();\n            }\n        };\n    }\n}\n</code></pre>\n","answer_id":27738182,"question_id":27737781,"last_edit_date":1420236923},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b5daee5ebc4e63ae694a4a68c902c2e8?s=256&d=identicon&r=PG","account_id":27505,"user_type":"registered","user_id":72673,"link":"https://stackoverflow.com/users/72673/maurice-perry","reputation":32693,"display_name":"Maurice Perry","accept_rate":72},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1420186136,"creation_date":1420186136,"body":"<p>I think I would do something like that:</p>\n\n<pre><code>import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class RRQueue&lt;M&gt; {\n    private final ThreadLocal&lt;Queue&lt;M&gt;&gt; threadQueue = new ThreadLocal&lt;&gt;();\n    private final List&lt;Queue&lt;M&gt;&gt; queues;\n    private int current = 0;\n\n    public RRQueue() {\n        this.queues = new ArrayList&lt;&gt;();\n    }\n\n    public synchronized void add(M msg) {\n        Queue&lt;M&gt; queue = threadQueue.get();\n        if (queue == null) {\n            queue = new LinkedList&lt;&gt;(); // or whatever\n            queues.add(queue);\n            threadQueue.set(queue);\n        }\n        queue.add(msg);\n        notify();\n    }\n\n    public synchronized M get() throws InterruptedException {\n        while (true) {\n            for (int i = 0; i &lt; queues.size(); ++i) {\n                Queue&lt;M&gt; queue = queues.get(current);\n                current = (current+1)%queues.size();\n                if (!queue.isEmpty()) {\n                    return queue.remove();\n                }\n            }\n            wait();\n        }\n    }\n}\n</code></pre>\n","answer_id":27739235,"question_id":27737781},{"owner":{"profile_image":"https://www.gravatar.com/avatar/5cfe5f7d64f44be04f147295f5c7b88e?s=256&d=identicon&r=PG","account_id":71739,"user_type":"registered","user_id":207421,"link":"https://stackoverflow.com/users/207421/user207421","reputation":307163,"display_name":"user207421","accept_rate":82},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1420181770,"creation_date":1420181770,"body":"<p>It's all in how you allocate the IDs. Allocate them <em>N</em> apart, where <em>N</em> is the number of producers, and add each producer's index to that. Then reading them sequentially will yield a round-robin order. You'll have a tiny bit of bookkeeping to do to know when to increment the underlying ID, which will happen when you reach <em>Nx-1</em> for any <em>x</em>.</p>\n","answer_id":27738534,"question_id":27737781},{"owner":{"profile_image":"https://www.gravatar.com/avatar/d3c9a4e663c77df1fe4888da3ba85bcc?s=256&d=identicon&r=PG","account_id":37853,"user_type":"registered","user_id":108350,"link":"https://stackoverflow.com/users/108350/will","reputation":4899,"display_name":"will","accept_rate":32},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1419286796,"creation_date":1419286796,"body":"<p>One further option; this approach lets you use the Runnable item like an asynchronous function call.  If your task does not need to return a result, e.g. it just performs some action you don't need to worry about how you pass back an \"outcome\".</p>\n\n<p>This pattern lets you reuse an item, where you need some kind of internal state.  When not passing  parameter(s) in the constructor care is needed to mediate the programs access to parameters.  You may need more checks if your use-case involves different callers, etc.</p>\n\n<pre><code>public class MyRunnable implements Runnable \n{\n  private final Boolean PARAMETER_LOCK  = false;\n  private X parameter;\n\n  public MyRunnable(X parameter) {\n     this.parameter = parameter;\n  }\n\n  public void setParameter( final X newParameter ){\n\n      boolean done = false;\n      synchronize( PARAMETER_LOCK )\n      {\n          if( null == parameter )\n          {\n              parameter = newParameter;\n              done = true;\n          }\n      }\n      if( ! done )\n      {\n          throw new RuntimeException(\"MyRunnable - Parameter not cleared.\" );\n      }\n  }\n\n\n  public void clearParameter(){\n\n      synchronize( PARAMETER_LOCK )\n      {\n          parameter = null;\n      }\n  }\n\n\n  public void run() {\n\n      X localParameter;\n\n      synchronize( PARAMETER_LOCK )\n      {\n          localParameter = parameter;\n      }\n\n      if( null != localParameter )\n      {\n         clearParameter();   //-- could clear now, or later, or not at all ...\n         doSomeStuff( localParameter );\n      }\n\n  }\n</code></pre>\n\n<p>}</p>\n\n<p>Thread t = new Thread(new MyRunnable(parameter));\n   t.start();</p>\n\n<p>If you need a result of processing, you will also need to coordinate completion of MyRunnable when the sub-task finishes.  You could pass a call back or just wait on the Thread 't', etc.</p>\n","answer_id":27611318,"question_id":877096},{"owner":{"profile_image":"https://www.gravatar.com/avatar/293f86043bc0fb6dba1190ad388c9d27?s=256&d=identicon&r=PG","account_id":279913,"user_type":"registered","user_id":575338,"link":"https://stackoverflow.com/users/575338/mavarazy","reputation":7622,"display_name":"mavarazy","accept_rate":59},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1416477893,"creation_date":1416472636,"body":"<p>Why not just use await with timeout?</p>\n\n<pre><code>boolean await(long timeout, TimeUnit unit);\n</code></pre>\n\n<p>If the specified waiting time elapses then the value false is returned, otherwise true is returned on await completion.</p>\n\n<p><a href=\"https://stackoverflow.com/questions/15245629/abort-countdownlatch-await-after-time-out\">Abort countDownLatch.await() after time out</a></p>\n\n<p>If you want to stop execution of other threads, if any thread fails - you'll need some additional communication layer.</p>\n\n<p>For example:</p>\n\n<pre><code>AtomicBoolean kill = new AtomicBoolean(false);\nCountDownLatch latch = new CountDownLatch(SOME_NUM);\n\nclass Task extends Runnable {\n     public void run() {\n         try {\n              ....\n              if (kill.get())\n                  throw new Exception();\n              ....\n         } catch (Throwable throwable) {\n            kill.set(true);\n         } finally {\n            countDownLatch.countDown();\n         }\n     }\n}\n</code></pre>\n\n<p>If you just want to release count down on Throwable, regardless of other processes, you can do countDown in loop on Exception</p>\n\n<pre><code>class Task extends Runnable {\n     public void run() {\n         try {\n              ....\n         } catch (Throwable throwable) {\n            while(countDownLatch.getCount() != 0)\n               countDownLatch.countDown();\n         } finally {\n            countDownLatch.countDown();\n         }\n     }\n}\n</code></pre>\n\n<p>You can combine 2 countDown tasks</p>\n\n<pre><code>CountDownLatch A = new CountDownLatch(1);\nCountDownLatch B = new CountDownLatch(1);\n\nclass CountDownTracker extend Runnable {\n     public void run() {\n         B.await();\n         A.countDown();\n     }\n}\n\nclass Task extends Runnable {\n     public void run() {\n         try {\n              ....\n         } catch (Throwable throwable) {\n            A.countDown();\n         } finally {\n            B.countDown();\n         }\n     }\n}\n</code></pre>\n\n<p>in this case A will finish after completion, or any Task failure.</p>\n\n<p>And so on...</p>\n","answer_id":27035047,"question_id":27034958,"last_edit_date":1495542446},{"owner":{"profile_image":"https://i.stack.imgur.com/KQO5i.png?s=256&g=1","account_id":3359040,"user_type":"registered","user_id":2821298,"link":"https://stackoverflow.com/users/2821298/andreas-aumayr","reputation":1006,"display_name":"Andreas Aumayr"},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1416474230,"creation_date":1416474230,"body":"<p>In addition to the other answers:</p>\n\n<p>it depends on what \"but if something fails\" means, but if failing means you catch an Exception in a worker thread, you may count down the latch within the catch clause as well. This of course changes the meaning of countDown from \"Successfully processed\" to \"processing complete\" - so your code has to handle this..</p>\n","answer_id":27035517,"question_id":27034958},{"owner":{"profile_image":"https://www.gravatar.com/avatar/f61fbcc7c59e134d888f2e34cd216658?s=256&d=identicon&r=PG","account_id":1390639,"user_type":"registered","user_id":1321564,"link":"https://stackoverflow.com/users/1321564/benjamin-m","reputation":23879,"display_name":"Benjamin M","accept_rate":71},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1416472443,"creation_date":1416472443,"body":"<p>You could use a <code>Semaphore</code>, which is close to a <code>CountDownLatch</code> and it's impl has methods for manipulating it: <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html\" rel=\"nofollow\">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html</a></p>\n","answer_id":27034992,"question_id":27034958},{"owner":{"profile_image":"https://i.stack.imgur.com/tr7wR.jpg?s=256&g=1","account_id":2524075,"user_type":"registered","user_id":2193767,"link":"https://stackoverflow.com/users/2193767/thelostmind","reputation":36076,"display_name":"TheLostMind","accept_rate":78},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1416472433,"creation_date":1416472433,"body":"<p>The <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html\" rel=\"nofollow\">CountDownLatch</a> has an overloaded <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html#await(long,%20java.util.concurrent.TimeUnit)\" rel=\"nofollow\">await()</a> method which takes <em>time</em> and <em>time unit</em> as inputs and releases the lock once the given time elapses</p>\n","answer_id":27034988,"question_id":27034958},{"owner":{"profile_image":"https://www.gravatar.com/avatar/67f2ccd17aa6fd622152ad88fc2ae784?s=256&d=identicon&r=PG","account_id":422870,"user_type":"registered","user_id":801894,"link":"https://stackoverflow.com/users/801894/solomon-slow","reputation":25925,"display_name":"Solomon Slow"},"content_license":"CC BY-SA 3.0","score":31,"is_accepted":true,"last_activity_date":1415369583,"creation_date":1415369124,"body":"<blockquote>\n  <p>aren't they both doing the same task - waiting so that other threads can execute?</p>\n</blockquote>\n\n<p>Not even close, because <code>yield()</code> does not <em>wait</em> for anything.</p>\n\n<p>Every thread can be in one of a number of different states:  <em>Running</em> means that the thread is actually running on a CPU, <em>Runnable</em> means that nothing is preventing the thread from running except, maybe the availability of a CPU for it to run on.  All of the other states can be lumped into a category called <em>blocked</em>.  A blocked thread is a thread that is waiting for something to happen before it can become runnable.</p>\n\n<p>The operating system <em>preempts</em> running threads on a regular basis:  Every so often (between 10 times per second and 100 times per second on most operating systems) the OS tags each running thread and says, \"your turn is up, go to the back of the run queue' (i.e., change state from running to runnable).  Then it lets whatever thread is at the head of the run queue use that CPU (i.e., become running again).</p>\n\n<p>When your program calls <code>Thread.yield()</code>, it's saying to the operating system, \"I still have work to do, but it might not be as important as the work that some other thread is doing.  Please send me to the back of the run queue right now.\"  If there is an available CPU for the thread to run on though, then it effectively will just keep running (i.e., the yield() call will immediately return).</p>\n\n<p>When your program calls <code>foobar.wait()</code> on the other hand, it's saying to the operating system, \"Block me until some other thread calls <code>foobar.notify()</code>.</p>\n\n<p>Yielding was first implemented on non-preemptive operating systems and, in non-preemptive threading libraries.  On a computer with only one CPU, the <em>only</em> way that more than one thread ever got to run was when the threads explicitly yielded to one another.</p>\n\n<p>Yielding also was useful for <em>busy waiting</em>.  That's where a thread waits for something to happen by sitting in a tight loop, testing the same condition over and over again.  If the condition depended on some other thread to do some work, the waiting thread would yield() each time around the loop in order to let the other thread do its work.</p>\n\n<p>Now that we have preemption and multiprocessor systems and libraries that provide us with higher-level synchronization objects, there is basically no reason why an application programs would need to call <code>yield()</code> anymore.</p>\n","answer_id":26803040,"question_id":26798073,"last_edit_date":1415369583},{"owner":{"profile_image":"https://i.stack.imgur.com/t2hoD.jpg?s=256&g=1","account_id":3211603,"user_type":"registered","user_id":2711488,"link":"https://stackoverflow.com/users/2711488/holger","reputation":289317,"display_name":"Holger"},"content_license":"CC BY-SA 3.0","score":8,"is_accepted":false,"last_activity_date":1415354856,"creation_date":1415354856,"body":"<p><code>wait</code> is for <em>waiting</em> on a condition. This might not jump into the eye when looking at the method as it is entirely up to you to define what kind of condition it is. But the API tries to force you to use it correctly by requiring that you own the monitor of the object on which you are waiting, which is necessary for a correct condition check in a multi-threaded environment.</p>\n\n<p>So a correct use of <code>wait</code> looks like:</p>\n\n<pre><code>synchronized(object) {\n  while( ! /* your defined condition */)\n    object.wait();\n  /* execute other critical actions if needed */\n}\n</code></pre>\n\n<p>And it must be paired with another thread executing code like:</p>\n\n<pre><code>synchronized(object) {\n  /* make your defined condition true */)\n  object.notify();\n}\n</code></pre>\n\n<hr>\n\n<p>In contrast <code>Thread.yield()</code> is just a <em>hint</em> that your thread might release the CPU at this point of time. It’s not specified whether it actually does anything and, regardless of whether the CPU has been released or not, it has no impact on the semantics in respect to the memory model. In other words, it does not create any relationship to other threads which would be required for accessing shared variables correctly.</p>\n\n<p>For example the following loop accessing <code>sharedVariable</code> (which is not declared <code>volatile</code>) might run forever without ever noticing updates made by other threads:</p>\n\n<pre><code>while(sharedVariable != expectedValue) Thread.yield();\n</code></pre>\n\n<p>While <code>Thread.yield</code> might help other threads to run (they will run anyway on most systems), it does <em>not</em> enforce re-reading the value of <code>sharedVariable</code> from the shared memory. Thus, without other constructs enforcing memory visibility, e.g. decaring <code>sharedVariable</code> as <code>volatile</code>, this loop is broken.</p>\n","answer_id":26798737,"question_id":26798073},{"owner":{"profile_image":"https://www.gravatar.com/avatar/38750c50c11e6054c2123073b17b18fc?s=256&d=identicon&r=PG","account_id":11369,"user_type":"registered","user_id":21886,"link":"https://stackoverflow.com/users/21886/richiehindle","reputation":274348,"display_name":"RichieHindle","accept_rate":88},"content_license":"CC BY-SA 3.0","score":11,"is_accepted":false,"last_activity_date":1393507894,"creation_date":1241381121,"body":"<p><a href=\"http://docs.oracle.com/javase/7/docs/api/java/lang/ThreadLocal.html\" rel=\"noreferrer\">The documentation</a> says it very well: \"each thread that accesses [a thread-local variable] (via its get or set method) has its own, independently initialized copy of the variable\".</p>\n\n<p>You use one when each thread must have its own copy of something.  By default, data is shared between threads.</p>\n","answer_id":817864,"question_id":817856,"last_edit_date":1393507894},{"owner":{"profile_image":"https://www.gravatar.com/avatar/33feea54e02fb1147b41d2edb88659dd?s=256&d=identicon&r=PG","account_id":3684,"user_type":"registered","user_id":5346,"link":"https://stackoverflow.com/users/5346/nick-fortescue","reputation":43315,"display_name":"Nick Fortescue","accept_rate":84},"content_license":"CC BY-SA 3.0","score":128,"is_accepted":false,"last_activity_date":1371901005,"creation_date":1242643307,"body":"<h3>For Anonymous classes:</h3>\n\n<p>In response to question edits here is how it works for Anonymous classes</p>\n\n<pre><code>   final X parameter = ...; // the final is important\n   Thread t = new Thread(new Runnable() {\n       p = parameter;\n       public void run() { \n         ...\n       };\n   t.start();\n</code></pre>\n\n<hr>\n\n<h3>Named classes:</h3>\n\n<p>You have a class that extends Thread (or implements Runnable) and a constructor with the parameters you'd like to pass. Then, when you create the new thread, you have to pass in the arguments, and then start the thread, something like this:</p>\n\n<pre><code>Thread t = new MyThread(args...);\nt.start();\n</code></pre>\n\n<p>Runnable is a much better solution than Thread BTW. So I'd prefer:</p>\n\n<pre><code>   public class MyRunnable implements Runnable {\n      private X parameter;\n      public MyRunnable(X parameter) {\n         this.parameter = parameter;\n      }\n\n      public void run() {\n      }\n   }\n   Thread t = new Thread(new MyRunnable(parameter));\n   t.start();\n</code></pre>\n\n<p>This answer is basically the same as this similar question: <a href=\"https://stackoverflow.com/questions/705037/how-to-pass-parameters-to-a-thread-object\">How to pass parameters to a Thread object</a></p>\n","answer_id":877115,"question_id":877096,"last_edit_date":1495542393},{"owner":{"profile_image":"https://www.gravatar.com/avatar/8be4691d697474170946184567d36814?s=256&d=identicon&r=PG","account_id":11385,"user_type":"registered","user_id":21925,"link":"https://stackoverflow.com/users/21925/robin","reputation":24062,"display_name":"Robin","accept_rate":62},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1367050373,"creation_date":1241442624,"body":"<p>As was mentioned by @unknown (google), it's usage is to define a global variable in which the value referenced can be unique in each thread.  It's usages typically entails storing some sort of contextual information that is linked to the current thread of execution.  </p>\n\n<p>We use it in a Java EE environment to pass user identity to classes that are not Java EE aware (don't have access to HttpSession, or the EJB SessionContext).  This way the code, which makes usage of identity for security based operations, can access the identity from anywhere, without having to explicitly pass it in every method call.</p>\n\n<p>The request/response cycle of operations in most Java EE calls makes this type of usage easy since it gives well defined entry and exit points to set and unset the ThreadLocal.</p>\n","answer_id":820028,"question_id":817856,"last_edit_date":1367050373},{"owner":{"profile_image":"https://i.stack.imgur.com/Y985l.jpg?s=256&g=1","account_id":259304,"user_type":"registered","user_id":542091,"link":"https://stackoverflow.com/users/542091/ovidiu-latcu","reputation":71887,"display_name":"Ovidiu Latcu","accept_rate":92},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1364282279,"creation_date":1364282279,"body":"<p>Actually the best way would be to use <a href=\"http://developer.android.com/guide/components/loaders.html\" rel=\"nofollow\"><code>Loaders</code></a>. More specific a <a href=\"http://developer.android.com/reference/android/content/CursorLoader.html\" rel=\"nofollow\"><code>CursorLoader</code></a>. The advantage of the <code>Loaders</code> compared to <code>AsyncTasks</code> and <code>Threads</code> is that the <code>Cursors</code> will be tied to your <code>Activity</code> or <code>Fragment</code> lifecycle. So you will not end up in trobule if your <code>AsyncTask</code> or <code>Thread</code> finishes after your <code>Activity</code> or <code>Fragment</code> are stopped, and try to notify a component that is no longer present.</p>\n\n<p>You can find some examples for <code>Loaders</code> here <a href=\"http://www.grokkingandroid.com/using-loaders-in-android/\" rel=\"nofollow\">How to Use Loaders</a>, and here <a href=\"http://www.androiddesignpatterns.com/2012/07/loaders-and-loadermanager-background.html\" rel=\"nofollow\">Life Before Loaders</a>.</p>\n","answer_id":15631449,"question_id":15631304},{"owner":{"profile_image":"https://www.gravatar.com/avatar/f214a9dce3ad4cadfcb376e7c7528b02?s=256&d=identicon&r=PG","account_id":1548782,"user_type":"registered","user_id":1441666,"link":"https://stackoverflow.com/users/1441666/nirali","reputation":13681,"display_name":"Nirali","accept_rate":100},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1364282075,"creation_date":1364282075,"body":"<p>AsyncTask is better compared to Thread</p>\n\n<p><strong>AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers.</strong></p>\n\n<p>And go through this <a href=\"https://stackoverflow.com/questions/6964011/handler-vs-asynctask-vs-thread?rq=1\"><strong>Handler vs AsyncTask vs Thread</strong></a></p>\n","answer_id":15631381,"question_id":15631304,"last_edit_date":1495535524},{"owner":{"profile_image":"https://www.gravatar.com/avatar/74674ffbf8adf72c0398a64d0615f128?s=256&d=identicon&r=PG","account_id":872021,"user_type":"registered","user_id":922653,"link":"https://stackoverflow.com/users/922653/colselaw","reputation":1069,"display_name":"Colselaw","accept_rate":60},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1359596255,"creation_date":1359596255,"body":"<p>Nothing really new here, but I discovered today that <code>ThreadLocal</code> is very useful when using Bean Validation in a web application. Validation messages are localized, but by default use <code>Locale.getDefault()</code>. You can configure the <code>Validator</code> with a different <code>MessageInterpolator</code>, but there's no way to specify the <code>Locale</code> when you call <code>validate</code>. So you could create a static <code>ThreadLocal&lt;Locale&gt;</code> (or better yet, a general container with other things you might need to be <code>ThreadLocal</code> and then have your custom <code>MessageInterpolator</code> pick the <code>Locale</code> from that. Next step is to write a <code>ServletFilter</code> which uses a session value or <code>request.getLocale()</code> to pick the locale and store it in your <code>ThreadLocal</code> reference.</p>\n","answer_id":14617072,"question_id":817856},{"owner":{"profile_image":"https://i.stack.imgur.com/hlWHy.jpg?s=256&g=1","account_id":1151383,"user_type":"registered","user_id":1133011,"link":"https://stackoverflow.com/users/1133011/david-kroukamp","reputation":36217,"display_name":"David Kroukamp","accept_rate":96},"content_license":"CC BY-SA 3.0","score":13,"is_accepted":true,"last_activity_date":1356721293,"creation_date":1356714034,"body":"<p>Its hard to tell what you are doing,</p>\n\n<p>but seems like you are trying to override <code>paint()</code> of a <code>Runnable</code> from within its <code>run()</code> method.</p>\n\n<p>This can surely not be done.</p>\n\n<p>The logic is </p>\n\n<ul>\n<li>Take a component</li>\n<li>Override its paint method to draw what we need</li>\n<li>Call method to update co-ordinates of rectangle (or in this case timer will do that)</li>\n<li>Than call <code>repaint()</code> on the component so paint method may be called again and redraw the rectangle with its new co-ordinates (Timer would also take care of repainting after changing co-ordinates of Rectangle)</li>\n<li>repeat last 2 steps as many times as needed/wanted</li>\n</ul>\n\n<p>(when I say <em>component</em> I actually mean <code>JPanel</code>, <em>paint method</em> refers to overridden <code>paintComponent(..)</code> of <code>JPanel</code> as this is best practice.)</p>\n\n<p><strong>Some suggestions:</strong></p>\n\n<p>1) Dont override <code>paint</code> rather use <code>JPanel</code> and override <code>paintComponent</code>. </p>\n\n<p>2) Dont forget to honor the <em>paint chain</em> and call <code>super.XXX</code> implementation of overridden <code>paintComponent(Graphics g)</code> (or any overridden method for that fact) unless purposefully leaving it out. i.e</p>\n\n<pre><code>class MyPanel extends JPanel {\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n\n         //do drawings here\n    }\n}\n</code></pre>\n\n<p>3) If drawing in <code>paintComponent</code> it is usually needed to override <code>getPreferredSize()</code> and return <code>Dimension</code>s which fit the contents/drawings of <code>JPanel</code>, i.e:</p>\n\n<pre><code>class MyPanel extends JPanel {\n    @Override\n    public Dimension getPreferredSize() {\n         return new Dimension(300,300);\n    }\n}\n</code></pre>\n\n<p>3) Look at <a href=\"http://docs.oracle.com/javase/tutorial/uiswing/misc/timer.html\"><code>Swing Timer</code></a> instead of <code>Thread.sleep(..)</code> as <code>sleep</code> will block GUI thread and make it seem to be frozen. i.e</p>\n\n<pre><code>Timer t = new Timer(10, new AbstractAction() {\n    int count = 20;\n    @Override\n    public void actionPerformed(ActionEvent ae) {\n        if (count &lt; 1000) {\n            //increment rectangles y position\n            //now repaint container so we can see changes in co-ordinates (unless you have a timer which repaints for you too)\n            count++;\n        } else {//counter is at 1000 stop the timer\n            ((Timer) ae.getSource()).stop();\n        }\n    }\n});\nt.start();\n</code></pre>\n\n<p>4) An alternative (because I see for now you are only moving a <code>Rectangle</code> which is not a Swing component) to Swing timer is <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/TimerTask.html\"><code>TimerTask</code></a>, and this can be used as long as no Swing components will be created/manipulated from within its <code>run()</code> method (as <code>TimerTask</code> does not run on EDT like Swing Timer). Note <code>revalidate()</code> and <code>repaint()</code> are <em>Thread-safe</em> so it can be used within <code>TimerTask</code>.</p>\n\n<p>The advantage of the above is unnecessary code is kept of EDT (i.e moving AWT rectangle by changing co-ords) i.e</p>\n\n<pre><code>    final TimerTask tt = new TimerTask() {\n        @Override\n        public void run() {\n            if (count &lt; 1000) {\n               //increment rectangles y position\n                //now repaint container so we can see changes in co-ordinates (unless you have a timer which repaints for you too)\n            count++;\n            } else {//counter is at 1000 stop the timer\n                cancel();\n            }\n        }\n    };\n\n    new Timer().scheduleAtFixedRate(tt, 0, 10);//start in 0milis and call run every 10 milis\n</code></pre>\n","answer_id":14072987,"question_id":14072940,"last_edit_date":1356721293},{"owner":{"profile_image":"https://www.gravatar.com/avatar/72fd1ca57aa0094fd5b9d0430f95c98e?s=256&d=identicon&r=PG","account_id":1640346,"user_type":"registered","user_id":1512926,"link":"https://stackoverflow.com/users/1512926/jeff-richley","reputation":1,"display_name":"Jeff Richley"},"content_license":"CC BY-SA 3.0","score":5,"is_accepted":false,"last_activity_date":1351018209,"creation_date":1351018209,"body":"<p>You have to be very careful with the ThreadLocal pattern.  There are some major down sides like Phil mentioned, but one that wasn't mentioned is to make sure that the code that sets up the ThreadLocal context isn't \"re-entrant.\"</p>\n\n<p>Bad things can happen when the code that sets the information gets run a second or third time because information on your thread can start to mutate when you didn't expect it.  So take care to make sure the ThreadLocal information hasn't been set before you set it again.</p>\n","answer_id":13037170,"question_id":817856},{"owner":{"profile_image":"https://i.stack.imgur.com/7auRa.png?s=256&g=1","account_id":1300215,"user_type":"registered","user_id":1250303,"link":"https://stackoverflow.com/users/1250303/java42","reputation":7638,"display_name":"Java42"},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1331499712,"creation_date":1330967720,"body":"<p>Parameter passing via the start() and run() methods:</p>\n\n<pre><code>// Tester\npublic static void main(String... args) throws Exception {\n    ThreadType2 t = new ThreadType2(new RunnableType2(){\n        public void run(Object object) {\n            System.out.println(\"Parameter=\"+object);\n        }});\n    t.start(\"the parameter\");\n}\n\n// New class 1 of 2\npublic class ThreadType2 {\n    final private Thread thread;\n    private Object objectIn = null;\n    ThreadType2(final RunnableType2 runnableType2) {\n        thread = new Thread(new Runnable() {\n            public void run() {\n                runnableType2.run(objectIn);\n            }});\n    }\n    public void start(final Object object) {\n        this.objectIn = object;\n        thread.start();\n    }\n    // If you want to do things like setDaemon(true); \n    public Thread getThread() {\n        return thread;\n    }\n}\n\n// New class 2 of 2\npublic interface RunnableType2 {\n    public void run(Object object);\n}\n</code></pre>\n","answer_id":9570940,"question_id":877096,"last_edit_date":1331499712},{"owner":{"profile_image":"https://www.gravatar.com/avatar/1738dc801b47a9191702b57447f3392c?s=256&d=identicon&r=PG","account_id":95724,"user_type":"registered","user_id":260541,"link":"https://stackoverflow.com/users/260541/rhu","reputation":963,"display_name":"rhu"},"content_license":"CC BY-SA 2.5","score":4,"is_accepted":true,"last_activity_date":1301871559,"creation_date":1301871559,"body":"<p>If you use Log4j, there is a specific mechanism for handling this type of logging pattern, split between two classes <a href=\"http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/NDC.html\" rel=\"nofollow\">org.apache.log4j.NDC</a> and <a href=\"http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/NDC.html\" rel=\"nofollow\">org.apache.log4j.MDC</a> ('Nested and Mapped Diagnostic Contexts').</p>\n\n<p>Have a browse at <a href=\"http://wiki.apache.org/logging-log4j/NDCvsMDC\" rel=\"nofollow\">NDC vs MDC - Which one should I use?</a> to see which is the best to use for your particular situation.</p>\n\n<p>Here's another link which describes MDC use in a bit more practical detail: <a href=\"http://onjava.com/pub/a/onjava/2002/08/07/log4j.html?page=3\" rel=\"nofollow\">Build Flexible Logs With log4j - O'Reilly Media</a></p>\n\n<p>Note that underlying storage mechanism MDC/NDC uses (I believe) is ThreadLocal anyway.</p>\n","answer_id":5533107,"question_id":5532864},{"owner":{"profile_image":"https://www.gravatar.com/avatar/087489aab3f24970d7a04fa604455df6?s=256&d=identicon&r=PG","account_id":289607,"user_type":"registered","user_id":590689,"link":"https://stackoverflow.com/users/590689/m-genova","reputation":377,"display_name":"m.genova"},"content_license":"CC BY-SA 2.5","score":1,"is_accepted":false,"last_activity_date":1301869686,"creation_date":1301869686,"body":"<p>I use your second approach in developed software (printserver), but threads have a long run so \"setName()\" don't add latency in processing.\nThe logging phase is very good showing thread name.</p>\n\n<p>I think \"setName()\" is a problema in two case:</p>\n\n<ol>\n<li>very short run;</li>\n<li>thread used by more actors with different id (but this is not your context, or not?).</li>\n</ol>\n\n<p>bye.</p>\n","answer_id":5532975,"question_id":5532864},{"owner":{"profile_image":"https://www.gravatar.com/avatar/48c0da7b99e8558e7180f5621573eac2?s=256&d=identicon&r=PG","account_id":37202,"user_type":"registered","user_id":106315,"link":"https://stackoverflow.com/users/106315/jwoolard","reputation":6114,"display_name":"jwoolard","accept_rate":93},"content_license":"CC BY-SA 2.5","score":18,"is_accepted":false,"last_activity_date":1242643876,"creation_date":1242643393,"body":"<p>When you create a thread, you need an instance of <code>Runnable</code>. The easiest way to pass in a parameter would be to pass it in as an argument to the constructor:</p>\n\n<pre><code>public class MyRunnable implements Runnable {\n\n    private volatile String myParam;\n\n    public MyRunnable(String myParam){\n        this.myParam = myParam;\n        ...\n    }\n\n    public void run(){\n        // do something with myParam here\n        ...\n    }\n\n}\n\nMyRunnable myRunnable = new myRunnable(\"Hello World\");\nnew Thread(myRunnable).start();\n</code></pre>\n\n<p>If you then want to change the parameter while the thread is running, you can simply add a setter method to your runnable class:</p>\n\n<pre><code>public void setMyParam(String value){\n    this.myParam = value;\n}\n</code></pre>\n\n<p>Once you have this, you can change the value of the parameter by calling like this:</p>\n\n<pre><code>myRunnable.setMyParam(\"Goodbye World\");\n</code></pre>\n\n<p>Of course, if you want to trigger an action when the parameter is changed, you will have to use locks, which makes things considerably more complex.</p>\n","answer_id":877118,"question_id":877096,"last_edit_date":1242643876},{"owner":{"profile_image":"https://i.stack.imgur.com/DVUwx.jpg?s=256&g=1","account_id":32251,"user_type":"registered","user_id":89266,"link":"https://stackoverflow.com/users/89266/dfa","reputation":114942,"display_name":"dfa","accept_rate":91},"content_license":"CC BY-SA 2.5","score":57,"is_accepted":false,"last_activity_date":1242643645,"creation_date":1242643248,"body":"<p>via constructor of a Runnable or Thread class</p>\n\n<pre><code>class MyThread extends Thread {\n\n    private String to;\n\n    public MyThread(String to) {\n        this.to = to;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"hello \" + to);\n    }\n}\n\npublic static void main(String[] args) {\n    new MyThread(\"world!\").start();\n}\n</code></pre>\n","answer_id":877104,"question_id":877096,"last_edit_date":1242643645},{"owner":{"profile_image":"https://www.gravatar.com/avatar/2c4d219e169610bd0ab7a4bcf5762e3a?s=256&d=identicon&r=PG","account_id":14954,"user_type":"registered","user_id":31136,"link":"https://stackoverflow.com/users/31136/bruno-conde","reputation":47917,"display_name":"bruno conde","accept_rate":50},"content_license":"CC BY-SA 2.5","score":10,"is_accepted":false,"last_activity_date":1242643598,"creation_date":1242643598,"body":"<p>You can either extend the <a href=\"http://java.sun.com/javase/6/docs/api/java/lang/Thread.html?is-external=true\" rel=\"noreferrer\"><code>Thread</code></a> <code>class</code> or the <a href=\"http://java.sun.com/javase/6/docs/api/java/lang/Runnable.html\" rel=\"noreferrer\"><code>Runnable</code></a> <code>class</code> and provide parameters as you want. There are simple examples in the <a href=\"http://java.sun.com/javase/6/docs/api/java/lang/Thread.html?is-external=true\" rel=\"noreferrer\">docs</a>. I'll port them here:</p>\n\n<pre><code> class PrimeThread extends Thread {\n     long minPrime;\n     PrimeThread(long minPrime) {\n         this.minPrime = minPrime;\n     }\n\n     public void run() {\n         // compute primes larger than minPrime\n          . . .\n     }\n }\n\n PrimeThread p = new PrimeThread(143);\n p.start();\n\n class PrimeRun implements Runnable {\n     long minPrime;\n     PrimeRun(long minPrime) {\n         this.minPrime = minPrime;\n     }\n\n     public void run() {\n         // compute primes larger than minPrime\n          . . .\n     }\n }\n\n\n PrimeRun p = new PrimeRun(143);\n new Thread(p).start();\n</code></pre>\n","answer_id":877132,"question_id":877096},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c53d539b59c19087182f0b1c53bb52de?s=256&d=identicon&r=PG","account_id":7450,"user_type":"registered","user_id":12960,"link":"https://stackoverflow.com/users/12960/brian-agnew","reputation":269220,"display_name":"Brian Agnew"},"content_license":"CC BY-SA 2.5","score":3,"is_accepted":false,"last_activity_date":1242643301,"creation_date":1242643301,"body":"<p>You can derive a class from Runnable, and during the construction (say) pass the parameter in.</p>\n\n<p>Then launch it using Thread.start(Runnable r);</p>\n\n<p>If you mean <em>whilst</em> the thread is running, then simply hold a reference to your derived object in the calling thread, and call the appropriate setter methods (synchronising where appropriate)</p>\n","answer_id":877112,"question_id":877096},{"owner":{"profile_image":"https://www.gravatar.com/avatar/1bf160a6e7f3d51d74f4f3d25982b75b?s=256&d=identicon&r=PG","account_id":27166,"user_type":"registered","user_id":71399,"link":"https://stackoverflow.com/users/71399/pauljwilliams","reputation":19089,"display_name":"pauljwilliams","accept_rate":65},"content_license":"CC BY-SA 2.5","score":7,"is_accepted":false,"last_activity_date":1242643262,"creation_date":1242643262,"body":"<p>Either write a class that implements Runnable, and pass whatever you need in a suitably defined constructor, or write a class that extends Thread with a suitably defined constructor that calls super() with appropriate parameters.</p>\n","answer_id":877106,"question_id":877096},{"owner":{"profile_image":"https://www.gravatar.com/avatar/e9f9bb459497b506ded2b14cf67ba30d?s=256&d=identicon&r=PG","account_id":35470,"user_type":"registered","user_id":100464,"link":"https://stackoverflow.com/users/100464/user100464","reputation":17531,"display_name":"user100464","accept_rate":91},"content_license":"CC BY-SA 2.5","score":55,"is_accepted":false,"last_activity_date":1241382039,"creation_date":1241382039,"body":"<p>In Java, if you have a datum that can vary per-thread, your choices are to pass that datum around to every method that needs (or may need) it, or to associate the datum with the thread.  Passing the datum around everywhere may be workable if all your methods already need to pass around a common \"context\" variable.  </p>\n\n<p>If that's not the case, you may not want to clutter up your method signatures with an additional parameter.  In a non-threaded world, you could solve the problem with the Java equivalent of a global variable.  In a threaded word, the equivalent of a global variable is a thread-local variable.</p>\n","answer_id":817911,"question_id":817856}]