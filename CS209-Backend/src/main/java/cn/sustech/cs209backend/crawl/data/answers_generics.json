[{"owner":{"profile_image":"https://i.stack.imgur.com/KzMc4.jpg?s=256&g=1","account_id":320962,"user_type":"registered","user_id":639520,"link":"https://stackoverflow.com/users/639520/e-riz","reputation":31681,"display_name":"E-Riz","accept_rate":72},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1660667395,"creation_date":1660667395,"body":"<p>You can eliminate the unchecked cast by declaring the interface itself with a type parameter (instead of the method). Like this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>interface Service&lt;T&gt; {\n    List&lt;T&gt; list(String location, String type );\n}\n\nclass LocalService implements Service&lt;MyConcreteClass&gt; {\n    @Override\n    public List&lt;MyConcreteClass&gt; list(String location, String type ) {\n        // Some logic to retrieve, alter and return a list\n        return null;\n    }\n}\n\nclass StringService implements Service&lt;String&gt; {\n    @Override\n    public List&lt;String&gt; list(String location, String type) {\n        // TODO Auto-generated method stub\n        return null;\n    }\n}\n\nclass MyConcreteClass {\n    /// ...\n}\n</code></pre>\n<p>(I changed a couple of things to make it compile, not relevant to the answer).</p>\n","answer_id":73377291,"question_id":73376182},{"owner":{"profile_image":"https://www.gravatar.com/avatar/d99204bcce923f40f5c72b7f80121644?s=256&d=identicon&r=PG","account_id":2139538,"user_type":"registered","user_id":1898563,"link":"https://stackoverflow.com/users/1898563/michael","reputation":42521,"display_name":"Michael","accept_rate":78},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":true,"last_activity_date":1660579652,"creation_date":1660579652,"body":"<p>Isn't your problem just here?</p>\n<pre><code>public &lt;T extends specialComparable&lt;T&gt;&gt; userClass(List&lt;specialComparable&lt;T&gt;&gt; comparables) {\n</code></pre>\n<p>You have a <code>List&lt;specialComparable&lt;specialComparable&lt;?&gt;&gt;&gt;</code>. That double nesting is presumably not the intention.</p>\n<p>Your signature should just be</p>\n<pre><code>public &lt;T extends specialComparable&lt;T&gt;&gt; userClass(List&lt;T&gt; comparables) {\n</code></pre>\n<p>FWIW, this interface seems useless since it adds no methods to the regular <code>Comparable</code>. The method is also fairly redundant. You can simply call this on any list of <code>Comparable</code>s.</p>\n<pre><code>listOfComparables.sort(Comparator.naturalOrder());\n</code></pre>\n","answer_id":73363594,"question_id":73363223,"community_owned_date":1660579652},{"owner":{"profile_image":"https://www.gravatar.com/avatar/f8c60eb5f46783d753e86238a9c18cd9?s=256&d=identicon&r=PG","account_id":265649,"user_type":"registered","user_id":552759,"link":"https://stackoverflow.com/users/552759/jtahlborn","reputation":53086,"display_name":"jtahlborn"},"content_license":"CC BY-SA 4.0","score":15,"is_accepted":true,"last_activity_date":1660410228,"creation_date":1425776992,"body":"<p>Others have described the problem, here is the solution with cleaner test:</p>\n<pre><code>if (type.isInstance(next)) {\n    return type.cast(next);\n}\n</code></pre>\n","answer_id":28921986,"question_id":28921833,"last_edit_date":1660410228},{"owner":{"profile_image":"https://i.stack.imgur.com/BBLLR.jpg?s=256&g=1","account_id":268201,"user_type":"registered","user_id":1573368,"link":"https://stackoverflow.com/users/1573368/sheel-prabhakar","reputation":419,"display_name":"Sheel Prabhakar"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1660408185,"creation_date":1660393641,"body":"<p><code>&lt;T extends BaseCommand&gt;</code> means at the calling side Type T <em>can</em> be BaseCommand OR derived from BaseCommand class/interface.</p>\n<p><code>Class&lt;T&gt;</code> type means the first argument should be the type of Class T.</p>\n<pre><code>class Command extends BaseCommand{ \n}\n</code></pre>\n<p>then you can call like this</p>\n<pre><code>registerHandle( Command.class, ...);\n</code></pre>\n<p>So that inside implementation one can create instance of Type Command.</p>\n","answer_id":73344263,"question_id":73344126,"last_edit_date":1660408185},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG","account_id":401843,"user_type":"registered","user_id":768644,"link":"https://stackoverflow.com/users/768644/rzwitserloot","reputation":89873,"display_name":"rzwitserloot"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1660277009,"creation_date":1660277009,"body":"<p>The warning is unavoidable. Isolate it in a helper method and toss the appropriate <code>@SuppressWarnings</code> at it. Or, refactor how this thing works. In general, the generics of <code>Class&lt;?&gt;</code> are weird and don't work well; if you try to write code that relies on the generics part to make it work, it's likely to result in many situations where you can't avoid these warnings, and the API is suboptimal.<sup>1</sup></p>\n<p>One tricky way to do what you're trying to do here in a one-size-fits-all way is so-called Super Type Tokens. You can search the web for this concept, because for what you're specifically doing here, STTs are overkill. What you are looking for, is a <em>supplier</em>.</p>\n<p>You want the caller not to pass you the type of a set. No. You want the caller to pass you a piece of code that, if executed, creates the set.</p>\n<p>While we're at it, let's get rid of the array, you're shifting the elements through that array for absolutely no sensible reason.</p>\n<pre><code>public &lt;S extends Set&lt;String&gt;&gt; S decodeStringSet(String key, @Nullable Set&lt;String&gt; defaultValue, Supplier&lt;S&gt; setMaker) {\n    Set&lt;String&gt; result = sp.getStringSet(key, defaultValue);\n    if(result == null) return defaultValue;\n\n    S a = setMaker.get();\n    a.addAll(result);\n    return a;\n}\n</code></pre>\n<p>This code can be used as follows:</p>\n<pre><code>LinkedHashSet&lt;String&gt; mySet = decodeStringSet(&quot;myKey&quot;, null, LinkedHashSet::new);\n</code></pre>\n<p>Perhaps you're unfamiliar with this syntax. <code>new LinkedHashSet()</code> will, when you run that code, create a LinkedHashSet. In contrast, <code>LinkedHashSet::new</code> will, when you run that code, produce an object that can be asked to create a LinkedHashSet, by invoking its <code>get()</code> method. One does the act right this very moment. The other wraps 'do the act' into a little machine. You can hand the machine to other code, or press the button on the machine to make it do the act, and you can press the button as often as you feel like.</p>\n<hr />\n<p>[1] Need some more explanations as to why relying on the generics of <code>j.l.Class</code> is awkward and not a good idea?</p>\n<p>A class object simply <strong>cannot</strong>, itself, represent generics, whereas generics can represent generics. That is: <code>List&lt;List&lt;String&gt;&gt;</code> is perfectly fine. However, <code>Class&lt;List&lt;String&gt;&gt;</code> does not make sense. You can write it, (j.l.Class does not have hardcoded rules to keep sanity alive in the langspec), but it doesn't represent anything: There's just one class object that represents the type <code>j.u.List</code>. This one object cannot therefore represent the generics; you can't have one class object representing <code>List&lt;String&gt;</code> and another representing <code>List&lt;Integer&gt;</code>. Less important, but still annoying - there are things class objects can represent that generics cannot. <code>int.class</code> is types as <code>Class&lt;Integer&gt;</code> but this isn't quite right.</p>\n<p>Hence, in your example, the compiler consider <code>Class&lt;? extends Set&gt;</code> as problematic; it's got a raw type <em>inside</em> the generics. However, it is technically correct, in that it is not possible to represent e.g. a <code>Set&lt;T&gt;</code>, merely 'a Set, whose generics are unknown, given that j.l.Class objects cannot represent them'.</p>\n<p>Lastly, classes basically only produce (the P in PECS - which explains what the difference is between <code>&lt;Number&gt;</code>, <code>&lt;? extends Number&gt;</code>, and <code>&lt;? super Number&gt;</code>); it is mentally difficult to fathom the difference between <code>Class&lt;? extends String&gt;</code> and <code>Class&lt;String&gt;</code>, because it's an irrelevant difference, given that j.l.Class only produces. And yet, often you really do need to write <code>Class&lt;? extends String&gt;</code> because if you don't, the compiler refuses to compile your code for imaginary, irrelevant reasons. That's because, again, j.l.Class is not hardcoded in the lang spec: The compiler does not <em>know</em> that there is no effective distinction between <code>Class&lt;T&gt;</code> and <code>Class&lt;? extends T&gt;</code>, and java does not have a way to mark off a given generics param as forced Produces-only or some such.</p>\n","answer_id":73329135,"question_id":73328558},{"owner":{"profile_image":"https://lh3.googleusercontent.com/a-/AOh14GjMpYukQ5aYVFfZyOxY8TIuB55KTzeCeZdLaaK5Ag=k-s256","account_id":23667337,"user_type":"registered","user_id":17694626,"link":"https://stackoverflow.com/users/17694626/cheng-thao","reputation":1467,"display_name":"Cheng Thao"},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1660230348,"creation_date":1660230348,"body":"<p>Your sub interface inherits the method <code>assign</code> from <code>Assigner</code>.  All you need to do in the sub interface is pass the types to the super interface.</p>\n<pre><code>interface Assigner&lt;S, T&gt; { S assign(T type);}\ninterface PlayerAssigner&lt;S&gt; extends Assigner&lt;S,Player&gt; {}\ninterface ManagerAssigner&lt;S&gt; extends Assigner&lt;S,Manager&gt; {}\ninterface CityBasedAssigner&lt;T&gt; extends Assigner&lt;City,T&gt; {}\n</code></pre>\n","answer_id":73322961,"question_id":73319233},{"owner":{"profile_image":"https://i.stack.imgur.com/v58O6.jpg?s=256&g=1","account_id":4181375,"user_type":"registered","user_id":3426309,"link":"https://stackoverflow.com/users/3426309/andrey-b-panfilov","reputation":5121,"display_name":"Andrey B. Panfilov"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1660176633,"creation_date":1660176633,"body":"<p>If I properly understood requirements...</p>\n<pre class=\"lang-java prettyprint-override\"><code>@FunctionalInterface\ninterface MapFilter {\n\n    &lt;T&gt; Map&lt;String, T&gt; filter(Map&lt;String, T&gt; map);\n\n}\n\npublic void setNewMapAttribute(MapFilter mapConsumer) {\n    this.setIdToRatings(mapConsumer.filter(this.getIdToRatings()));\n    this.setIdToNames(mapConsumer.filter(this.getIdToNames()));\n}\n</code></pre>\n","answer_id":73313972,"question_id":73313839},{"owner":{"profile_image":"https://i.stack.imgur.com/1bP9c.png?s=256&g=1","account_id":2538731,"user_type":"registered","user_id":2205089,"link":"https://stackoverflow.com/users/2205089/alin-gabriel-arhip","reputation":2578,"display_name":"Alin Gabriel Arhip"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":true,"last_activity_date":1660148049,"creation_date":1660147026,"body":"<p>peterz detailed exactly what happens under the hood.</p>\n<p>Sounds like what you need is an explicit conversion from the primitive <code>double</code> Java predicate (<code>java.util.function.DoublePredicate</code>) to the <code>scala.Double</code> Scala predicate (<code>Double =&gt; Boolean</code>).</p>\n<p>Scala actually offers one such conversion called <code>FromJavaDoublePredicate</code>.\nThe code does not require explicit <code>Double</code> cast anymore:</p>\n<pre><code>  /* some scala file */\n  def hasCompleteness(\n      x: Double,\n      f: Double =&gt; Boolean\n  ): Unit = println(f(x))\n\n  /* some java file */\n  public static FromJavaDoublePredicate atLeast(double thresholdPercentage) {\n      return new scala.compat.java8.functionConverterImpls.FromJavaDoublePredicate(\n        actualPercentage -&gt; actualPercentage &gt;= thresholdPercentage);\n  }\n\n  FromJavaDoublePredicate f = atLeast(3.0);\n  Test.hasCompleteness(5, f);  // true\n</code></pre>\n<p>PS. From what I saw, you chose <a href=\"https://github.com/scala/scala-java8-compat\" rel=\"nofollow noreferrer\">scala-java8-compat</a>, so I assumed you use an earlier version of Scala. Their maintainers state:</p>\n<blockquote>\n<p>If you are using Scala 2.13 or newer only, then don't use this\nlibrary! Use the classes under <code>scala.jdk</code> instead; they were added to\nthe standard library in 2.13.</p>\n</blockquote>\n<p>So for Scala 2.13.x I recommend using the <a href=\"https://www.scala-lang.org/api/2.13.8/scala/jdk/FunctionWrappers$$FromJavaDoublePredicate.html\" rel=\"nofollow noreferrer\">FromJavaDoublePredicate</a> case class in the <code>FunctionWrappers</code> object instead.</p>\n","answer_id":73309330,"question_id":73298883,"last_edit_date":1660148049},{"owner":{"profile_image":"https://www.gravatar.com/avatar/80ae1a555585070d3fba444b79e350e2?s=256&d=identicon&r=PG","account_id":19896468,"user_type":"registered","user_id":14577465,"link":"https://stackoverflow.com/users/14577465/liunix","reputation":11,"display_name":"liunix"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1660117318,"creation_date":1660117318,"body":"<p>what abt this</p>\n<pre><code>import java.util.function.BinaryOperator;\npublic class GenericArithmetic {\n\n    public static &lt;T extends Number&gt; BinaryOperator&lt;T&gt; get_multiplier(T t1){\n        BinaryOperator&lt;Integer&gt; intMultiper = (i1, i2) -&gt; i1 * i2;\n        BinaryOperator&lt;Float&gt; floatMultiper = (i1, i2) -&gt; i1 * i2;\n\n        // should cache\n        switch (t1.getClass().getName()) {\n            case &quot;java.lang.Integer&quot;:\n                return (BinaryOperator&lt;T&gt;) intMultiper;\n            case &quot;java.lang.Float&quot;:\n                return (BinaryOperator&lt;T&gt;) floatMultiper;\n            default:\n                return null;\n        }\n    }\n\n    public static &lt;T extends Number&gt; Number multiply(T x, T y) throws Exception{\n        var multiplier = get_multiplier(x);\n        var res = multiplier.apply(x, y);\n        return res;\n    }\n\n\n    public static void main(String[] args) throws Exception{\n        var a1 = 3;\n        var a2 = 5;\n\n        var res = multiply(a1, a2);\n        System.out.println(res);\n\n        var b1 = 2.0f;\n        var b2 = 3.0f;\n        var res2 = multiply(b1,b2);\n        System.out.println(res2);   \n    }\n}\n\n</code></pre>\n","answer_id":73302497,"question_id":20819824},{"owner":{"profile_image":"https://i.stack.imgur.com/W3DFb.jpg?s=256&g=1","account_id":23020603,"user_type":"registered","user_id":17141716,"link":"https://stackoverflow.com/users/17141716/peterz","reputation":341,"display_name":"peterz"},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1660115038,"creation_date":1660115038,"body":"<p>That seems how Scala compiler translates &quot;primitive&quot; Scala types (remember, <code>Double</code> here is <code>scala.Double</code> and not <code>java.lang.Double</code>). E.g. Scala declarations</p>\n<pre><code>  var d: Double =&gt; Boolean;\n  var s: String =&gt; String;\n</code></pre>\n<p>produce (as shown by javap):</p>\n<pre><code>  public abstract scala.Function1&lt;java.lang.Object, java.lang.Object&gt; d();\n  public abstract scala.Function1&lt;java.lang.String, java.lang.String&gt; s();\n</code></pre>\n<p>Note how <code>Double</code> and <code>Boolean</code> both translate to <code>Object</code>, but <code>String</code> is preserved</p>\n","answer_id":73301988,"question_id":73298883},{"owner":{"profile_image":"https://graph.facebook.com/10210973455051695/picture?type=large","account_id":15988209,"user_type":"registered","user_id":11538031,"link":"https://stackoverflow.com/users/11538031/%d0%95%d0%bc%d0%b8%d0%bb%d0%b8%d1%8f%d0%bd-%d0%99%d0%be%d1%80%d0%b4%d0%b0%d0%bd%d0%be%d0%b2","reputation":150,"display_name":"Емилиян Йорданов"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1660111090,"creation_date":1660111090,"body":"<p>Because your interface is defined as <code>T extends AbstractPoiSearchData</code>,\nThen <code>List&lt;PoiSearchDataProvider&lt;AbstractPoiSearchData&gt;&gt;</code> it is declared as single <code>AbstractPoiSearchData</code> which doesn't extend itself.</p>\n<p>I think that in your case :</p>\n<pre><code>public interface PoiSearchDataProvider&lt;AbstractPoiSearchData&gt; {\n\n    AbstractPoiSearchData fetch(PoiSearchRequest poiSearchRequest) throws Exception;\n\n}\n</code></pre>\n<p>Will be enough and you can use magic of the polymorphism</p>\n","answer_id":73301283,"question_id":73300740},{"owner":{"profile_image":"https://i.stack.imgur.com/dVLIh.jpg?s=256&g=1","account_id":5281408,"user_type":"registered","user_id":4216641,"link":"https://stackoverflow.com/users/4216641/turing85","reputation":18797,"display_name":"Turing85"},"content_license":"CC BY-SA 4.0","score":4,"is_accepted":true,"last_activity_date":1641583272,"creation_date":1641580019,"body":"<h2>Problem</h2>\n<p>In the code presented, we declare:</p>\n<pre><code>HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\n</code></pre>\n<p>and</p>\n<pre><code>public static &lt;K,V&gt; Map&lt;K,V&gt; fillMap(Map&lt;K,V&gt; map, K[] keys, V[] values)\n</code></pre>\n<p>Hence, if we call</p>\n<pre><code>map = MyUtil.fillMap(map, keys, values);\n</code></pre>\n<p>we try to assing a <code>Map&lt;...&gt;</code> (returned by <code>MyUtil::fillMap</code>) to a <code>HashMap&lt;...&gt;</code>. This cannot work since a <code>Map</code> is not a <code>HashMap</code>.</p>\n<hr />\n<h2>Possible solutions</h2>\n<p>There are two ways that come to my mind to fix this issue:</p>\n<ol>\n<li>either change the type of <code>map</code>,</li>\n<li>or make the return-type of <code>MyUtil::fillMap</code> generic.</li>\n</ol>\n<h3>1. change the type of <code>map</code>:</h3>\n<p>We can change the type of <code>map</code> from <code>HashMap&lt;...&gt;</code> to <code>Map&lt;...&gt;</code>:</p>\n<pre><code>Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\n...\nmap = MyUtil.fillMap(map, keys, values);\n</code></pre>\n<p><a href=\"https://ideone.com/Etxw9r\" rel=\"nofollow noreferrer\"><kbd>Ideone demo</kbd></a></p>\n<h3>2. Make the return-type of <code>MyUtil::fillMap</code> generic:</h3>\n<p>By adding an additional generic parameter, we can make the concrete implementation of the return type generic as well:</p>\n<pre><code>public static void main(String[] args) {\n  HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\n  final Integer[] keys = IntStream.range(0, 12).boxed().toArray(Integer[]::new);\n  final String[] values = new String[] {&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;Mai&quot;, &quot;Jun&quot;,\n      &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Okt&quot;, &quot;Nov&quot;, &quot;Dez&quot;};\n  map = MyUtil.fillMap(map, keys, values);\n  System.out.println(map);\n}\n\npublic static &lt;K, V, M extends Map&lt;K, V&gt;&gt; M fillMap(M map, K[] keys, V[] values) {\n  final int l = keys.length;\n  for (int i = 0; i &lt; l; i++) {\n    map.put(keys[i], values[i]);\n  }\n  return map;\n}\n</code></pre>\n<p><a href=\"https://ideone.com/ILKQQy\" rel=\"nofollow noreferrer\"><kbd>Ideone demo</kbd></a></p>\n<hr />\n<h3>Bonus: state-free construction of the return-value</h3>\n<p>If it is not necessary to pass-in the concrete implementation of the map used to the method, I would propose a third option that creates the map to return within the method:</p>\n<pre><code>public static &lt;K, V&gt; Map&lt;K, V&gt; fillMap(K[] keys, V[] values) {\n  return IntStream.range(0, keys.length)\n      .boxed()\n      .collect(Collectors.toMap(\n          index -&gt; keys[index],\n          index -&gt; values[index]));\n}\n</code></pre>\n<p><a href=\"https://ideone.com/dgXgcj\" rel=\"nofollow noreferrer\"><kbd>Ideone demo</kbd></a></p>\n","answer_id":70625645,"question_id":70625495,"last_edit_date":1641583272},{"owner":{"profile_image":"https://www.gravatar.com/avatar/7a46f8c7e87a67455586b285c91c57ac?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":6948309,"user_type":"registered","user_id":8819319,"link":"https://stackoverflow.com/users/8819319/shivam","reputation":79,"display_name":"Shivam"},"content_license":"CC BY-SA 4.0","score":4,"is_accepted":false,"last_activity_date":1641574705,"creation_date":1641574705,"body":"<p>The get-max operation on a queue can be implemented in amortized O(1) time by maintaining the candidates for the max value in a separate double-ended queue (<code>Deque</code>).</p>\n<ul>\n<li>On enqueue (or <code>offer</code>) operation, we check whether there are any elements at the back of the <code>Deque</code> which are lesser in value than the element being enqueued. These values can simply be removed – for these can never be the maximum value going forward.</li>\n<li>On dequeue (or <code>poll</code>) operation, we check whether the first element in the <code>Deque</code> is equal to the first element in the regular queue and if yes, remove it too.</li>\n<li>The max element is simply the first element of the <code>Deque</code>.</li>\n</ul>\n<p>All operations have amortized O(1) time complexity.</p>\n<p>Here's an implementation in Java:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class QueueWithMax&lt;T extends Comparable&lt;T&gt;&gt; {\n    Queue&lt;T&gt; queue;\n    Deque&lt;T&gt; cMax; // candidates for Max value\n\n    public QueueWithMax() {\n        queue = new LinkedList&lt;&gt;();\n        cMax = new LinkedList&lt;&gt;();\n    }\n\n    public void offer(T element) {\n        queue.offer(element);\n        while (!cMax.isEmpty() &amp;&amp; element.compareTo(cMax.peekLast()) &gt; 0) {\n            cMax.pollLast();\n        }\n        cMax.offerLast(element);\n    }\n\n    public T poll() {\n        if (cMax.peekFirst().equals(queue.peek()))\n            cMax.pollFirst();\n        return queue.poll();\n    }\n\n    public T getMax() {\n        return cMax.peekFirst();\n    }\n}\n</code></pre>\n","answer_id":70624675,"question_id":40877146},{"owner":{"profile_image":"https://lh3.googleusercontent.com/-9JmWKNYVrkA/AAAAAAAAAAI/AAAAAAAAACI/eTrny6Lo14Q/photo.jpg?sz=256","account_id":9508774,"user_type":"registered","user_id":7067337,"link":"https://stackoverflow.com/users/7067337/roy-alilin","reputation":107,"display_name":"Roy Alilin"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1641544923,"creation_date":1641544923,"body":"<p>In terms of List functionality differences, the other responses already answered this question. In terms of applicable rules of Java generics, it's a complicated topic. I wrote an in-depth article about Java generics rules, this is the link: <a href=\"https://medium.com/@royalilin/java-generics-rules-1d05de86e9cb\" rel=\"nofollow noreferrer\">https://medium.com/@royalilin/java-generics-rules-1d05de86e9cb</a></p>\n","answer_id":70618634,"question_id":490091},{"owner":{"profile_image":"https://i.stack.imgur.com/dfqcw.png?s=256&g=1","account_id":6651855,"user_type":"registered","user_id":5133585,"link":"https://stackoverflow.com/users/5133585/sweeper","reputation":224850,"display_name":"Sweeper","accept_rate":96},"content_license":"CC BY-SA 4.0","score":5,"is_accepted":true,"last_activity_date":1641543284,"creation_date":1641474746,"body":"<p>The reason why your <code>test</code> methods produce an error is because they have totally unrelated, different signatures. Note that the <a href=\"https://docs.oracle.com/javase/specs/jls/se17/html/jls-8.html#jls-8.4.2\" rel=\"nofollow noreferrer\">signature</a> of a method consists of its name, parameter list, <em>and type parameters</em>.</p>\n<p>Quote from the Java Language Specification:</p>\n<blockquote>\n<p>Two methods or constructors, M and N, have the same signature if they have the same name, the same type parameters (if any) (§8.4.4), and, after adapting the formal parameter types of N to the type parameters of M, the same formal parameter types.</p>\n</blockquote>\n<p>Crucially, your two <code>test</code> methods do not have the <a href=\"https://docs.oracle.com/javase/specs/jls/se17/html/jls-8.html#jls-8.4.4\" rel=\"nofollow noreferrer\">same type parameters</a>, because <code>U</code> in <code>A.test</code> has a different <em>bound</em> from <code>U</code> in <code>B.test</code>.</p>\n<blockquote>\n<p>Two methods or constructors M and N have the same type parameters if both of the following are true:</p>\n<ul>\n<li><p>M and N have same number of type parameters (possibly zero).</p>\n</li>\n<li><p>Where A1, ..., An are the type parameters of M and B1, ..., Bn are the type parameters of N, let θ=[B1:=A1, ..., Bn:=An]. Then, for all i (1 ≤ i ≤ n), the bound of Ai is the same type as θ applied to the bound of Bi.</p>\n</li>\n</ul>\n</blockquote>\n<p>Think about what would happen if <code>B.test</code> actually overrode <code>A.test</code>. You could pass a type to the type parameter <code>U</code> that is out of its bounds!</p>\n<pre><code>A a = new B();\n// This will call B.test, and U is Double, T is Integer\n// but U should extends Integer!\nDouble x = a.test((Integer)0); \n</code></pre>\n<p>For more info, <a href=\"https://docs.oracle.com/javase/specs/jls/se17/html/jls-8.html#jls-8.4.8.1\" rel=\"nofollow noreferrer\">here</a> are the precise rules for when overriding happens. Note that criteria #4 and #5 on your list are not actually considered. They are just additional requirements that make your code not compile if you break them. One method is still &quot;defined&quot; to override another even if you break those requirements. They are listed <a href=\"https://docs.oracle.com/javase/specs/jls/se17/html/jls-8.html#jls-8.4.8.3\" rel=\"nofollow noreferrer\">here</a> in the JLS.</p>\n","answer_id":70607642,"question_id":70607154,"last_edit_date":1641543284},{"owner":{"profile_image":"https://i.stack.imgur.com/qDozH.jpg?s=256&g=1","account_id":5126886,"user_type":"registered","user_id":4108590,"link":"https://stackoverflow.com/users/4108590/ravindra-ranwala","reputation":20904,"display_name":"Ravindra Ranwala","accept_rate":57},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":true,"last_activity_date":1641524179,"creation_date":1641254379,"body":"<p>You can't create a generic array in Java. Arrays are reifiable types, and carry their type information at runtime whereas generics are non reifiable, and their type information is erased after the compile time due to erasure. This is due to the implementation of the type system in java and even though this causes some rough edges and corner cases, it eases the evolution of code into generics. Since generic type information is erased, you don't have them at runtime and that's why you can't create a generic array in java.</p>\n<p>There are two solutions to circumvent the issue you are facing. You can either create an Object array and cast it to the generic type you need.</p>\n<pre><code>final T[] arr = (T[]) new Object[n]\n</code></pre>\n<p>or else</p>\n<pre><code>final Object[] arr = new Object[]\n</code></pre>\n<p>You can do the cast when you get the items from this array like this</p>\n<pre><code>T itm = (T) arr[1];\n</code></pre>\n<p>Both of the above approaches work if you don't return this internal array.</p>\n<p>However, if you are returning the internal array, you need to create it reflectively, since you need to maintain the proper reifiable type.</p>\n<pre><code>static &lt;T&gt; T[] createArr(Class&lt;T&gt; clz) {\n    return (T[]) Array.newInstance(clz, 5);\n}\n</code></pre>\n","answer_id":70572715,"question_id":70572512,"last_edit_date":1641524179},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b0615f9d8910677c053724488c8e5240?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":14529138,"user_type":"registered","user_id":14367481,"link":"https://stackoverflow.com/users/14367481/mr-proper","reputation":33,"display_name":"Mr. Proper"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1641519580,"creation_date":1641518648,"body":"<p>Given that I find the relevant JLS rules (cited in Sweeper's answer above) quite confusing, it's useful to mention the rules, as formulated by the great people at Enthuware (<a href=\"https://enthuware.com/\" rel=\"nofollow noreferrer\">https://enthuware.com/</a>).\nThey don't mention the visibility and exceptions rules, but they go in detail with Generics. And they seem to explain my two cases, mentioned in  the comments above. I'll just state the cases again here:</p>\n<pre><code>class A {\n    public &lt;T,U&gt; U test(T test) {\n        return null;\n    }\n}\n\nclass B extends A {\n    //Successful override even though type parameters do not match\n    //This method even has none.\n    @Override\n    public Number test(Object test) {\n        return null;\n    }\n}\n\nclass C {\n    public Object test(Object test) {\n        return null;\n    }\n}\n\nclass D extends C {\n    //Same situation as A and B, but with places being exchanged.\n    //Now the generic method overrides non-generic. \n    //And we have error. \n    @Override\n    public &lt;T,U&gt; U test(T test) {\n        return null;\n    }\n}\n</code></pre>\n<p>Now the steps, as formulated by Enthuware:</p>\n<p><em><strong>Steps to check for valid override:</strong></em></p>\n<p><strong>First</strong>, check the method signature (i.e. method name and the parameter list). If the signature of the method in the subclass matches the signature of the method in the super class, then it could be a valid override, otherwise it is just an overloaded method. <strong>Note that signature does not include parameter names and parameter's generic type specification.</strong></p>\n<p><em>NOTE: I think they mean for us to replace the type parameter with its bound and then compare both methods.</em></p>\n<p><strong>Second</strong>, if it is a potential override, check the generic type specification of the parameters. <strong>If the overriding method does not use a generic type specification for the parameter type, then it is valid. The reverse is not valid i.e. the overriding method is allowed to erase the generic type specification but is not allowed to add a generic type specification if the overridden method does not have it. If both the methods have a generic type specification, then the specification must match exactly.</strong> For example, if the overridden method has Set&lt;Integer&gt;, then the overriding method can use Set or Set&lt;Integer&gt;. But if overridden method has Set, then the overriding method must also have Set for a valid override.</p>\n<p><strong>Third</strong>, if it is a potential override, check the return type. Java allows &quot;covariant&quot; returns, which means, the return type of the overriding method must be the same or be a subtype of the return type mentioned in the overridden method. Check the two return types without the generic type specification. If return type of the overriding method is covariant with respect to the return type of the overriding method (for example, ArrayList is covariant with List), then perform the same check including the generic type specification (for example, ArrayList&lt;CharSequence&gt; is covariant with List&lt;? extends CharSequence&gt;).  Don't get confused by the presence of &lt;T&gt; in the code. The same rules of overriding still apply. The T in &lt;T&gt; is called as the &quot;type&quot; parameter. It is used as a place holder for whatever type is actually used while invoking the method. For example, if you call the method &lt;T&gt; List&lt;T&gt; transform(List&lt;T&gt; list) with List&lt;String&gt;, T will be typed to String. Thus, it will return List&lt;String&gt;. If, in another place, you call the same method with Integer, T will be typed to Integer and therefore, the return type of the method for that invocation will be List&lt;Integer&gt;</p>\n","answer_id":70615556,"question_id":70607154,"last_edit_date":1641519580},{"owner":{"profile_image":"https://i.stack.imgur.com/dJrV3.jpg?s=256&g=1","account_id":1888343,"user_type":"registered","user_id":1707091,"link":"https://stackoverflow.com/users/1707091/rgettman","reputation":176617,"display_name":"rgettman"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1641491487,"creation_date":1641491487,"body":"<p>Java doesn't allow this because a <code>List&lt;Car&gt;</code> is not a <code>List&lt;Object&gt;</code> even though a <code>Car</code> is an <code>Object</code>.</p>\n<p>It's not necessary to declare a type parameter, because we don't care what the type actually is.  Every reference type descends from <code>Object</code> which has a <code>toString</code> method, so we can just replace <code>List&lt;Object&gt;</code> with <code>List&lt;?&gt;</code>:</p>\n<pre><code>public static String formatList(List&lt;?&gt; listToFormat, int indentationSize) {\n</code></pre>\n","answer_id":70611427,"question_id":70610873},{"owner":{"profile_image":"https://www.gravatar.com/avatar/6a6909762e756d3ba9c521f334824e79?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":22450291,"user_type":"registered","user_id":16653700,"link":"https://stackoverflow.com/users/16653700/alias-cartellano","reputation":364,"display_name":"Alias Cartellano"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1641491060,"creation_date":1641491060,"body":"<p>You use <code>public static &lt;T&gt; String formatList(List&lt;T&gt; listToFormat,int indentationSize){</code> to accept objects instead.</p>\n<h3>Code:</h3>\n<pre><code>public static &lt;T&gt; String formatList(List&lt;T&gt; listToFormat,int indentationSize){\n        String indentation = Stream.generate(()-&gt;&quot;\\t&quot;).limit(indentationSize).collect(Collectors.joining());\n        String newIndentedLine = &quot;\\n&quot;+indentation;\n        return newIndentedLine+listToFormat.stream()\n                .map(Object::toString)\n                .collect(Collectors.joining(newIndentedLine));\n    }\n</code></pre>\n","answer_id":70611341,"question_id":70610873},{"owner":{"profile_image":"https://i.stack.imgur.com/QZvw8.jpg?s=256&g=1","account_id":4564492,"user_type":"registered","user_id":3705861,"link":"https://stackoverflow.com/users/3705861/younes-el-ouarti","reputation":2199,"display_name":"Younes El Ouarti"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1641477790,"creation_date":1641477790,"body":"<p>As an alternative, your <code>OpponentListAdapter</code> could have a <code>public static</code> &quot;creator&quot;-methods. This would look like this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class OpponentListAdapter {\n\n  // A constructor is not necessary but you could have one if you want\n  public OpponentListAdapter(Context c, ArrayList&lt;String&gt; l){\n    ...\n  }\n\n  //now the creator method\n  public static OpponentListAdapter create(Context c, ArrayList&lt;MyCustomObject&gt; l){\n     // implement the creation here and return it\n  }\n\n}\n</code></pre>\n<p>This way you have still type safety. This pattern is used fairly often and names for the methods are usually something like:</p>\n<ul>\n<li><code>create()</code></li>\n<li><code>of()</code>  // popular example is <code>List.of()</code> from Java 9+</li>\n<li><code>from()</code></li>\n</ul>\n<p>In your case you could have e.g. 2 different static functions:</p>\n<ul>\n<li><code>createFromString(Context c, List&lt;String&gt; l)</code></li>\n<li><code>createFromMyCustomObject(Context c, List&lt;MyCustomObject&gt; l)</code></li>\n</ul>\n<p>Calling it would look something like this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>...\n  List&lt;String&gt; ls = ...\n  List&lt;MyCustomObject&gt; lo = ...\n\n  OpponentListAdapter adapterFromStrings = OpponentListAdapter.createFromStrings(c, ls);\n  OpponentListAdapter adapterFromMyObject = OpponentListAdapter.createFromObjects(c, lo);\n...\n</code></pre>\n","answer_id":70608308,"question_id":21556925},{"owner":{"profile_image":"https://www.gravatar.com/avatar/ba0c264a341dfc252b07c87c8f958c0a?s=256&d=identicon&r=PG","account_id":23845919,"user_type":"unregistered","user_id":17850414,"link":"https://stackoverflow.com/users/17850414/sanjay","reputation":1,"display_name":"Sanjay"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1641472510,"creation_date":1641472510,"body":"<pre><code>List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);        \nsort(list, Comparable::&lt;String&gt;compareTo);\n</code></pre>\n<p>The <code>int compareTo (T o)</code> is not a generic method invocation. Although <code>Comparable&lt;T&gt;</code> is an interface with a type. Even if <code>compareTo</code> had returned <code>T</code>, i.e. <code>T compareTo (T o)</code> it still is not a generic method. For it to be a generic method, it needs to include a list of <code>type parameters</code>, i.e. <code>&lt;T&gt; T compareTo (T o)</code>.</p>\n","answer_id":70607179,"question_id":22588518},{"owner":{"profile_image":"https://i.stack.imgur.com/UPTah.jpg?s=256&g=1","account_id":17725449,"user_type":"registered","user_id":12869305,"link":"https://stackoverflow.com/users/12869305/alex-a","reputation":51,"display_name":"Alex A"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1641443191,"creation_date":1641442628,"body":"<p>Recently I implemented an abstract DAO (Repository) in Spring Data style and reactive manner with WebFlux for AWS DynamoDB. Not the ideal, but works fine and as I assume it can fit to your case:</p>\n<p>The first part is the abstract DAO. The common interface looks like this:</p>\n<pre><code>public interface DynamoDbRepository&lt;T&gt; {\n\n  /** Constant prefix for logging purposes */\n  String SN = &quot;[DynamoDbRepository]&quot;;\n\n  Mono&lt;PutItemEnhancedResponse&lt;T&gt;&gt; insert(final T object);\n\n  Mono&lt;T&gt; getById(final String id);\n\n  Flux&lt;T&gt; getAll();\n}\n</code></pre>\n<p>Logic implementation class which extends <strong>DynamoDbRepository</strong>:</p>\n<pre><code>@Log4j2\n@Repository\npublic abstract class EntityDynamoDbRepository&lt;T&gt; implements DynamoDbRepository&lt;T&gt; {\n\n  private final Class&lt;T&gt; clazz;\n  private DynamoDbAsyncTable&lt;T&gt; dynamoDbAsyncTable;\n\n  @Autowired\n  @SneakyThrows\n  public final void setAsyncClient(DynamoDbEnhancedAsyncClient asyncClient) {\n    DynamoDbTable tableName = AnnotationUtils.getAnnotation(clazz, DynamoDbTable.class);\n    this.dynamoDbAsyncTable =\n        asyncClient.table(tableName.value(), TableSchema.fromBean(this.clazz));\n  }\n\n  @SuppressWarnings(&quot;unchecked&quot;)\n  @SneakyThrows\n  public EntityDynamoDbRepository() {\n    clazz =\n        (Class&lt;T&gt;) GenericTypeResolver.resolveTypeArgument(getClass(), DynamoDbRepository.class);\n    if (clazz == null) {\n      throw new Exception(&quot;Not possible to resolve generic type&quot;);\n    }\n  }\n\n  @Override\n  public Mono&lt;PutItemEnhancedResponse&lt;T&gt;&gt; insert(final T object) {\n    final PutItemEnhancedRequest&lt;T&gt; putItemEnhancedRequest =\n        PutItemEnhancedRequest.builder(this.clazz)\n            .item(object)\n            .build();\n    return Mono.fromFuture(dynamoDbAsyncTable.putItemWithResponse(putItemEnhancedRequest));\n  }\n\n  public Mono&lt;T&gt; getById(final String id) {\n    return Mono.fromFuture(dynamoDbAsyncTable.getItem(getKeyBuild(id)));\n  }\n\n  public Flux&lt;T&gt; getAll() {\n    return Flux.from(dynamoDbAsyncTable.scan().items());\n  }\n\n  private Key getKeyBuild(final String id) {\n    return Key.builder().partitionValue(id).build();\n  }\n}\n</code></pre>\n<p>And finally to implement a concrete Repository:</p>\n<pre><code>@Repository\n@Log4j2\npublic class ConcreteRepository extends EntityDynamoDbRepository&lt;ConcreteEntity&gt; {}\n</code></pre>\n<p>You might noticed <strong>setAsyncClient</strong> method which defines <strong>dynamoDbAsyncTable</strong>. Due to @DynamoDbBean using the entity class name as a DynamoDB table name, I put custom annotation to assign custom table name there:</p>\n<pre><code>@Retention(RetentionPolicy.RUNTIME)\n@DynamoDbBean\npublic @interface DynamoDbTable {\n  String value();\n}\n</code></pre>\n<p>Answering your question: you can add/call whatever you want inside the <strong>EntityDynamoDbRepository</strong> constructor to wrap your &lt;POJO&gt; with any possible logic.</p>\n<p>p.s.: I didn't paste the DynamoDbEnhancedAsyncClient bean but there are a lot of samples on a GitHub</p>\n","answer_id":70602411,"question_id":67275241,"last_edit_date":1641443191},{"owner":{"profile_image":"https://www.gravatar.com/avatar/bedab8d59cdd9ca2366251c11df4795e?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":7595189,"user_type":"registered","user_id":5761558,"link":"https://stackoverflow.com/users/5761558/ernest-k","reputation":44576,"display_name":"ernest_k"},"content_license":"CC BY-SA 4.0","score":8,"is_accepted":true,"last_activity_date":1640096068,"creation_date":1640082162,"body":"<p>Compatibility with the return type <code>Stream&lt;Optional&lt;? extends Number&gt;&gt;</code> in the first case is not obtained by virtue of <code>numbers.map(Optional::of)</code> returning a <code>Stream&lt;Optional&lt;? extends Number&gt;&gt;</code> on its own; it's the compiler inferring the return type of <code>numbers.map(...)</code> due to  it being a generic method:</p>\n<pre><code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);\n</code></pre>\n<p>while <code>Stream.filter()</code> is not:</p>\n<pre><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);\n</code></pre>\n<p>Therefore, in the first case the compiler can take into account the return statement's context (<code>getNumbers</code>'s type) when inferring type of <code>numbers.map(...)</code>.<br />\nCompiler cannot do the same for <code>numbers.map(...)</code> in the second case,  as there are subsequent chained calls, that may further change the type, so it would be very hard to guess what the right inferring should be at this stage. As a result, the most specific possible type is assumed for <code>numbers.map(...)</code> (<code>Stream&lt;Optional&lt;Number&gt;&gt;</code>) and further carried on by <code>filter(...)</code>.</p>\n<p>As a different example to illustrate that, please figure out why both of these compile (<code>List.of()</code> is the same code, after all):</p>\n<pre><code>static List&lt;String&gt; stringList() {\n    return List.of();\n}\nstatic List&lt;Integer&gt; intList() {\n    return List.of();\n}\n</code></pre>\n<p>Now, why does this fail:</p>\n<pre><code>static List&lt;String&gt; stringList() {\n    return List.of().subList(0, 0);\n}\n</code></pre>\n<p>That's because <code>List.subList(...)</code> does not infer the returned list's <code>E</code> type in context (i.e., the method is not generic), it carries the <code>List</code> instance's <code>E</code> type, which, with <code>List.of()</code> in that case gets defaulted to <code>Object</code> (yes, when you have <code>return List.of();</code>, return type inference kicks in, forcing the compiler to figure out that the intent is to make <code>E</code> match <code>String</code>, the type argument in the method's return type). <i>Please note that this gets more complex than that, there are corners where inference doesn't work as wished/expected.</i></p>\n<hr />\n<p><strong>Short answer</strong>: <code>return numbers.map(Optional::of)</code> takes advantage of type inference as <code>map()</code> is generic, and <code>filter()</code> does not, expecting the <code>E</code> of <code>Stream&lt;E&gt;</code> to be carried. And with <code>numbers.map(Optional::of)</code>, <code>E</code> is <code>Optional&lt;Number&gt;</code>, not <code>Optional&lt;? extends Number&gt;</code>, and <code>filter</code> carries that.</p>\n","answer_id":70433906,"question_id":70433519,"last_edit_date":1640096068},{"owner":{"profile_image":"https://i.stack.imgur.com/uAEcW.jpg?s=256&g=1","account_id":1689973,"user_type":"registered","user_id":1552534,"link":"https://stackoverflow.com/users/1552534/wjs","reputation":37330,"display_name":"WJS"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1624035689,"creation_date":1624035689,"body":"<p>Here is how I would do it.  I'm using the Stack that's part of the API but as long as a stack has push and pop, any implementation should work.</p>\n<ul>\n<li>create a new stack in the reverse method.</li>\n<li>and as you pop one value from the original stack, push it on to the new stack.</li>\n<li>return the new stack</li>\n</ul>\n<pre><code>Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();\nfor (int i = 1; i &lt; 6; i++) {\n    stack.push(i);\n}\n\nSystem.out.println(stack);\nstack = reverse(stack);\nSystem.out.println(stack);\n    \n    \npublic static &lt;T&gt; Stack&lt;T&gt; reverse(Stack&lt;T&gt; stack) {\n    Stack&lt;T&gt; reversed = new Stack&lt;&gt;();\n    while (!stack.isEmpty()) {\n        reversed.push(stack.pop());\n    }\n    return reversed;\n}\n</code></pre>\n<p>Prints</p>\n<pre><code>[1, 2, 3, 4, 5]\n[5, 4, 3, 2, 1]\n</code></pre>\n","answer_id":68038986,"question_id":68038527},{"owner":{"profile_image":"https://www.gravatar.com/avatar/96c5736faea666b5204770aa7810c4f1?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8803777,"user_type":"registered","user_id":6579116,"link":"https://stackoverflow.com/users/6579116/pirate","reputation":2955,"display_name":"Pirate","accept_rate":27},"content_license":"CC BY-SA 4.0","score":-2,"is_accepted":true,"last_activity_date":1624034405,"creation_date":1624033414,"body":"<p>Use another stack to reverse the stack.</p>\n<pre><code>public static &lt;E&gt; Stack&lt;E&gt; reverse(Stack&lt;E&gt; s) {\n    Stack&lt;E&gt; reversedStack = new Stack&lt;E&gt;(null, null);\n    while(!Stack.&lt;E&gt;isEmpty(s) {\n        Stack.&lt;E&gt;push(reversedStack, s.value);\n        s = Stack.&lt;E&gt;pop(s));\n    }\n    return reversedStack;\n}\n</code></pre>\n","answer_id":68038541,"question_id":68038527,"last_edit_date":1624034405},{"owner":{"profile_image":"https://www.gravatar.com/avatar/7686280776045b6d5250c0762c92ffd5?s=256&d=identicon&r=PG","account_id":135067,"user_type":"registered","user_id":337621,"link":"https://stackoverflow.com/users/337621/g%c3%a1bor-lipt%c3%a1k","reputation":9676,"display_name":"G&#225;bor Lipt&#225;k","accept_rate":70},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1623918736,"creation_date":1623918736,"body":"<p>I came up with this solution:</p>\n<pre><code>public interface SerializableList&lt;T&gt; extends List&lt;T&gt;, Serializable {\n}\n\npublic class SerializableArrayList&lt;T&gt; extends ArrayList&lt;T&gt; implements SerializableList&lt;T&gt; {\n    public SerializableArrayList(int initialCapacity) {\n        super(initialCapacity);\n    }\n\n    public SerializableArrayList() {\n    }\n\n    public SerializableArrayList(Collection&lt;? extends T&gt; c) {\n        super(c);\n    }\n}\n</code></pre>\n<p>Then whenever I need a <code>Serializable</code> <code>List</code> type, I can use the <code>SerializableList</code> interface and its implementation <code>SerializableArrayList</code></p>\n","answer_id":68015730,"question_id":68014704},{"owner":{"profile_image":"https://i.stack.imgur.com/uJhj3.jpg?s=256&g=1","account_id":4647011,"user_type":"registered","user_id":3764965,"link":"https://stackoverflow.com/users/3764965/nikolas-charalambidis","reputation":41835,"display_name":"Nikolas Charalambidis","accept_rate":94},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1623898489,"creation_date":1623898489,"body":"<p>Use generic type, not the raw type. Try to use the narrowest type possible (ex. <code>Speak</code> instead of <code>Dog</code> because you call only methods from that interface).</p>\n<pre><code>List&lt;Speak&gt; dogs = new ArrayList&lt;&gt;();\ndogs.add(new Dog(&quot;Fred&quot;));\ndogs.add(new Dog(&quot;Wanda&quot;));\nfor (Speak e: dogs) {\n    e.speak();\n}\n</code></pre>\n","answer_id":68012279,"question_id":68012208},{"owner":{"profile_image":"https://i.stack.imgur.com/PO7Uz.jpg?s=256&g=1","account_id":2673407,"user_type":"registered","user_id":2310289,"link":"https://stackoverflow.com/users/2310289/scary-wombat","reputation":44640,"display_name":"Scary Wombat"},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1623898483,"creation_date":1623898483,"body":"<p>ArrayList can / should take a type</p>\n<pre><code>ArrayList&lt;Dog&gt; dogs= new ArrayList&lt;&gt;();\ndogs.add(new Dog(&quot;Fred&quot;));\ndogs.add(new Dog(&quot;Wanda&quot;));\nfor (Dog e: dogs)\n{\n    e.speak();\n}\n</code></pre>\n","answer_id":68012278,"question_id":68012208},{"owner":{"profile_image":"https://i.stack.imgur.com/JF1RF.jpg?s=256&g=1","account_id":8423897,"user_type":"registered","user_id":7505687,"link":"https://stackoverflow.com/users/7505687/dilermando-lima","reputation":1034,"display_name":"Dilermando Lima"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1623897988,"creation_date":1623897537,"body":"<p>When you return a String you don't need to use generics and you can receive only an Object on methods</p>\n<pre class=\"lang-java prettyprint-override\"><code>// you can treate try and catch inside them as you prefer\n\npublic static &lt;T&gt; T fromJson(String json, Class&lt;T&gt; classToReturn) throws Exception{\n    return  new ObjectMapper().readValue(json, classToReturn);\n}\n\npublic static String toJson(Object obj) throws Exception{\n    return new ObjectMapper().writeValueAsString(obj);\n}\n\npublic static String toJsonPrettyNonNullTreatingDateTypes(Object obj) throws Exception{\n    return  new ObjectMapper()\n            .setSerializationInclusion(Include.NON_NULL)\n            .setSerializationInclusion(Include.NON_EMPTY)\n            .registerModule(new JavaTimeModule() );\n            .writerWithDefaultPrettyPrinter()\n            .writeValueAsString(obj);\n}\n\n\n</code></pre>\n<p>using them</p>\n<pre class=\"lang-java prettyprint-override\"><code>MyObject obj = fromJson(jsonString, MyObject.class );\n\nString json = toJson(new MyObject()); //  Object can accept any types\n\nString json = toJsonPrettyNonNullTreatingDateTypes(new MyObject());\n\n</code></pre>\n","answer_id":68012167,"question_id":67961312,"last_edit_date":1623897988},{"owner":{"profile_image":"https://i.stack.imgur.com/W6OMC.png?s=256&g=1","account_id":1056871,"user_type":"registered","user_id":1059372,"link":"https://stackoverflow.com/users/1059372/eugene","reputation":117749,"display_name":"Eugene","accept_rate":97},"content_license":"CC BY-SA 4.0","score":5,"is_accepted":true,"last_activity_date":1623786523,"creation_date":1623786523,"body":"<p>change the type and the constructor:</p>\n<pre><code>private final Class&lt;T&gt; enumClass;\n\npublic EnumSimplesConverter(Class&lt;T&gt; enumClass) {\n    this.enumClass = enumClass;\n}\n</code></pre>\n<p>you already enforce the <code>T</code> via <code>T extends Enum&lt;T&gt;</code></p>\n","answer_id":67992612,"question_id":67992546},{"owner":{"profile_image":"https://i.stack.imgur.com/W6A8i.jpg?s=256&g=1","account_id":14429973,"user_type":"registered","user_id":10423604,"link":"https://stackoverflow.com/users/10423604/volodya-lombrozo","reputation":2483,"display_name":"Volodya Lombrozo"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1623785809,"creation_date":1623785809,"body":"<p>You could use <code>&lt;? super RunnableRule&lt;?,?&gt;&gt;</code> in this case:</p>\n<pre class=\"lang-java prettyprint-override\"><code> List&lt;? super RunnableRule&lt;?,?&gt;&gt; list = new ArrayList&lt;&gt;();\n list.add(new AcksTermsSignUpRule());\n list.add(new RunnableRule&lt;String, Double&gt;() {});\n</code></pre>\n<p>You could read docs right <a href=\"https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html\" rel=\"nofollow noreferrer\">there</a></p>\n<blockquote>\n<p>Collection&lt;?&gt; (pronounced &quot;collection of unknown&quot;), that is, a\ncollection whose element type matches anything</p>\n<p>A lower bounded wildcard restricts the unknown type to be a specific\ntype or a super type of that type. A lower bounded wildcard is\nexpressed using the wildcard character ('?'), following by the super\nkeyword, followed by its lower bound: &lt;? super A&gt;.</p>\n</blockquote>\n","answer_id":67992459,"question_id":67988538},{"owner":{"profile_image":"https://i.stack.imgur.com/jXcg4.png?s=256&g=1","account_id":1263831,"user_type":"registered","user_id":1221571,"link":"https://stackoverflow.com/users/1221571/eran","reputation":388998,"display_name":"Eran","accept_rate":67},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1609919832,"creation_date":1609919832,"body":"<p>If you change</p>\n<pre><code>public static &lt;T extends InstanceClass&lt;Integer&gt;&gt; void prt(T q)\n</code></pre>\n<p>to</p>\n<pre><code>public static &lt;T&gt; void prt(T q)\n</code></pre>\n<p>the compiler wouldn't know that the type parameter <code>T</code> must be an <code>InstanceClass</code>, and therefore it wouldn't know that it has <code>getNum()</code> and <code>calculate()</code> methods, which you are trying to call from <code>prt</code>.</p>\n<p>In fact, the compiler would allow you to pass to the <code>prt</code> method any argument, including instances of classes unrelated to <code>InstanceClass</code>, which don't have the methods you are trying to call inside <code>prt</code>.</p>\n","answer_id":65592093,"question_id":65592052},{"owner":{"profile_image":"https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG","account_id":401843,"user_type":"registered","user_id":768644,"link":"https://stackoverflow.com/users/768644/rzwitserloot","reputation":89873,"display_name":"rzwitserloot"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1609904070,"creation_date":1609904070,"body":"<blockquote>\n<p><code>assertEquals(new GenericInterfaceImpl&lt;String&gt;().getGenericType(), String.class, &quot;Type should resolve to String.class&quot;);</code></p>\n</blockquote>\n<p>impossible.</p>\n<blockquote>\n<p><code>assertEquals(new TypedInterfaceImpl().getGenericType(), String.class, &quot;Type should resolve to String.class&quot;);</code></p>\n</blockquote>\n<p>Possible, but a bad idea; it would require you to document your interface with 'when implementing this interface, you <strong>must</strong> pick a concrete, non-type-parameterized type for <code>T</code> or nothing works right.', which is a weird caveat.</p>\n<blockquote>\n<p><code>Class&lt;T&gt; getGenericType() {</code></p>\n</blockquote>\n<p>Bad idea; the thing in the <code>&lt;&gt;</code> does not have to be a <code>Class</code> - for example, it could be <code>List&lt;String&gt;</code>, which is not representable as a class object (only <code>List</code> is, there is one object that represents all lists, there's no way to have an instance of j.l.Class that represents <code>List&lt;String&gt;</code>).</p>\n<blockquote>\n<p>The Javadocs for getGenericInterfaces</p>\n</blockquote>\n<p><code>getGenericInterfaces</code> is a reflective tool, but it reflects on the definition of the type only. Given <code>class Foo&lt;T&gt; implements Thingie&lt;T&gt;</code>, <code>getGenericInterfaces</code> can only be executed on the entire <code>Foo</code> class, and you get back an object that presents <code>Thingie&lt;T&gt;</code>. Given an instance such as <code>new Foo&lt;String&gt;()</code> it is <strong>not possible</strong> to derive String.</p>\n<blockquote>\n<p>Is there a way to solve this problem at all or is this a &quot;core limitation&quot; of the Java language?</p>\n</blockquote>\n<p>It's a core limitation, so, no. Not directly.</p>\n<p>One trick is to add a method:</p>\n<pre><code>public interface Foo&lt;T&gt; {\n   public Class&lt;T&gt; getType();\n}\n</code></pre>\n<p>and let implementers worry about the problem. This is still a bad idea, for example, a <code>Class</code> object cannot represent <code>List&lt;String&gt;</code>, so you've effectively made it impossible for Foo to properly represent anything where you want the <code>T</code> to be anything that has type params.</p>\n<p>Take a step back instead. What are you <em>actually</em> trying to do? Nobody wakes up and goes: I know! I'll build an interface that can report its own type parameter but reified! What did you want to build? A chat app? A plugin system for photoshop?</p>\n<p><code>java.lang.Class</code>, with the intent to invoke <code>.newInstance()</code> on it, is a piss poor factory. Thus, if that is what you intend to do, use factories instead.</p>\n<p>Anotehr solution, but you probably don't want this, and before you got all excited, it's got plenty of limitations, are a concept called Super Type Tokens; you can search the web if you must know.</p>\n","answer_id":65589852,"question_id":65589741},{"owner":{"profile_image":"https://i.stack.imgur.com/s4qlq.png?s=256&g=1","account_id":6780825,"user_type":"registered","user_id":5221149,"link":"https://stackoverflow.com/users/5221149/andreas","reputation":155680,"display_name":"Andreas"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":true,"last_activity_date":1609867103,"creation_date":1609867103,"body":"<p>Read the <em>documentation</em>, i.e. the javadoc of <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass--\" rel=\"nofollow noreferrer\"><code>getClass()</code></a> in class <code>Object</code>:</p>\n<blockquote>\n<p><strong>The actual result type is <code>Class&lt;? extends |X|&gt;</code> where <code>|X|</code> is the erasure of the static type of the expression on which <code>getClass</code> is called.</strong> For example, no cast is required in this code fragment:</p>\n<pre class=\"lang-java prettyprint-override\"><code>Number n = 0;\nClass&lt;? extends Number&gt; c = n.getClass();\n</code></pre>\n</blockquote>\n<p><sup><em>The bolding is from the javadoc, not added by me.</em></sup></p>\n<p>For class <code>Object</code> itself, it means that the return type is <code>Class&lt;? extends Object&gt;</code>, but since <code>Class&lt;?&gt;</code> is shorthand for <code>Class&lt;? extends Object&gt;</code>, the javadoc simply shows the shorthand.</p>\n<p>Quoting the Java Language Specification, section <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1\" rel=\"nofollow noreferrer\">4.5.1. Type Arguments of Parameterized Types</a>:</p>\n<blockquote>\n<p>The wildcard <code>? extends Object</code> is equivalent to the unbounded wildcard <code>?</code>.</p>\n</blockquote>\n","answer_id":65583567,"question_id":65583228},{"owner":{"profile_image":"https://www.gravatar.com/avatar/44c841338e1646af9a977f1fa0e23948?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":162699,"user_type":"registered","user_id":3788176,"link":"https://stackoverflow.com/users/3788176/andy-turner","reputation":138060,"display_name":"Andy Turner","accept_rate":54},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":false,"last_activity_date":1609865860,"creation_date":1609865860,"body":"<blockquote>\n<p>But why does the return type of the getClass method is just<code>Class&lt;?&gt;</code> in the Object class</p>\n</blockquote>\n<p><code>Class&lt;?&gt;</code> is the same as <code>Class&lt;? extends Object&gt;</code>, because all classes (except <code>Object</code>) have <code>Object</code> as a superclass. There's no reason to include that bound explicitly.</p>\n","answer_id":65583280,"question_id":65583228},{"owner":{"profile_image":"https://www.gravatar.com/avatar/0cff99aaf31098275563ea9924cb05cf?s=256&d=identicon&r=PG","account_id":1539741,"user_type":"registered","user_id":1434678,"link":"https://stackoverflow.com/users/1434678/soroosh-sarabadani","reputation":439,"display_name":"Soroosh Sarabadani"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1609864514,"creation_date":1609864514,"body":"<p>Your class has several unknown types for Quarkus and as the result, it cannot make an object out of it.</p>\n<p>You can define producer for DaoManagers with your interested entity, then Quarkus is able to create objects.</p>\n","answer_id":65582916,"question_id":65505831},{"owner":{"profile_image":"https://i.stack.imgur.com/eR09c.jpg?s=256&g=1","account_id":13177411,"user_type":"registered","user_id":9517937,"link":"https://stackoverflow.com/users/9517937/sdindiver","reputation":501,"display_name":"sdindiver"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1609843174,"creation_date":1609843174,"body":"<p>I am giving the answer to my posted question that I found more accurate.</p>\n<pre><code>public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) {\n        list.sort(c);\n}\n</code></pre>\n<p>and</p>\n<pre><code>public static &lt;T&gt; void sort(List&lt;? extends T&gt; list, Comparator&lt;? super T&gt; c) {\n        list.sort(c);\n}\n</code></pre>\n<p>are same. Because we are calling above methods either this way</p>\n<pre><code>ArrayList&lt;Employee&gt; list = new ArrayList&lt;&gt;();\nlist.add(new Manager(106,true));\nlist.add(new Manager(102,true));\nsort(list, (p1, p2) -&gt; \np1.getEmployeeId().compareTo(p2.getEmployeeId()));\n\n`T` argument in `sort()` will be considered as Manager in this case\n</code></pre>\n<p>or</p>\n<pre><code> ArrayList&lt;Employee&gt; list = new ArrayList&lt;&gt;();\n list.add(new Employee(106,true));\n list.add(new Employee(102,true));\n sort(list, (p1, p2) -&gt; \n p1.getEmployeeId().compareTo(p2.getEmployeeId()));\n\n`T` argument in `sort()` will be Employee in this case.\n</code></pre>\n<p>We do not gain anything writing <code>List&lt;? extends T&gt;</code> in <code>sort()</code>. A real word example if have two balls, then we can use either only one terms, first ball is bigger than second or first ball is smaller than second. Only one thing is possible either bigger or smaller\nif we have three balls, we can say, first ball is smaller than second and third ball is bigger than second, then two terms can be used smaller and bigger.</p>\n<p>We need some base <code>T</code> then we can use either  <code>? extends T</code> or  <code>? super T</code> or both for example binary search method signature that I have posted above.</p>\n<p>JDK also provided sort method with three signature also but in different way</p>\n<pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {\n    public ArrayList(Collection&lt;? extends E&gt; c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n\n@Override\n    @SuppressWarnings(&quot;unchecked&quot;)\n    public void sort(Comparator&lt;? super E&gt; c) {\n        final int expectedModCount = modCount;\n        Arrays.sort((E[]) elementData, 0, size, c);\n        if (modCount != expectedModCount) {\n            throw new ConcurrentModificationException();\n        }\n        modCount++;\n    }\n</code></pre>\n<p>Above <code>ArrayList&lt;E&gt;</code> can be of <code>E</code> type, It can accept <code>Collection&lt;? extends E&gt; c</code> and can be sorted using <code>Comparator&lt;? super E&gt; c</code>. So as per explain we also have three balls</p>\n<ul>\n<li>E type of element It can be</li>\n<li>Collection&lt;? extends E&gt; It can accept list</li>\n<li>Comparator&lt;? super E&gt; c It can be sorted by such comparator</li>\n</ul>\n","answer_id":65577279,"question_id":65414023},{"owner":{"profile_image":"https://i.stack.imgur.com/3KaJD.jpg?s=256&g=1","account_id":461282,"user_type":"registered","user_id":1249225,"link":"https://stackoverflow.com/users/1249225/krushna","reputation":5319,"display_name":"Krushna","accept_rate":81},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":true,"last_activity_date":1609779027,"creation_date":1376637528,"body":"<p>You can not do var-arg generic but you can do something like below</p>\n<pre><code>import java.util.Collection;\nimport java.util.Set;\n\npublic interface NKeyMap&lt;K, V&gt; {\n    public void clear();\n    public boolean containsKey(K... k );\n    public boolean containsValue(V value);\n    public V get(K... k);\n    public boolean isEmpty();\n    public V put(V value, K...k);\n    public V remove(V value, K... k);\n    public int size();\n    public Collection&lt;V&gt; values();\n    public Set&lt;K&gt; keys();\n}\n</code></pre>\n","answer_id":18267879,"question_id":18267714,"last_edit_date":1609779027},{"owner":{"profile_image":"https://www.gravatar.com/avatar/4c16849c5f9444a685f62cdc2a15c3ac?s=256&d=identicon&r=PG","account_id":1119690,"user_type":"registered","user_id":1108305,"link":"https://stackoverflow.com/users/1108305/m-justin","reputation":15787,"display_name":"M. Justin","accept_rate":47},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1609743949,"creation_date":1609743949,"body":"<p>In Scheme, list equivalence is based completely on the structure of the items.</p>\n<p>In Java by comparison, equality is context-dependent depending on the type of object, and may use some or all of the internal structure in its equivalence calculation.  What it means for two objects of the same type to be &quot;equal&quot; is up to the object type to determine, so long as the <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)\" rel=\"nofollow noreferrer\">general contract for equals</a> is met (most notably that it forms an <a href=\"https://en.wikipedia.org/wiki/Equivalence_relation\" rel=\"nofollow noreferrer\">equivalence relation</a> with all other objects).</p>\n<p>Assuming all types used in a program have a reasonable <code>equals</code> definition, they <em>should</em> have a &quot;reliable&quot; value comparison, at least in the sense of the object oriented paradigm.</p>\n<p>Returning to the analogous Java <code>equal?</code> implementation.  It's a bit hard to piece together from the question's phrasing, but from context clues it appears that this is also attempting to operate on lists of items.  The <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/List.html#equals(java.lang.Object)\" rel=\"nofollow noreferrer\"><code>equals</code></a> method on Java's <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/List.html\" rel=\"nofollow noreferrer\"><code>List</code></a> type already implements behavior directly analogous to Scheme's <code>equals?</code> operation:</p>\n<blockquote>\n<p>Compares the specified object with this list for equality. Returns <code>true</code> if and only if the specified object is also a list, both lists have the same size, and all corresponding pairs of elements in the two lists are <em>equal</em>. (Two elements e1 and e2 are <em>equal</em> if <code>Objects.equals(e1, e2)</code>.) In other words, two lists are defined to be equal if they contain the same elements in the same order.</p>\n</blockquote>\n<p>This definition also means that recursive list structures also work in a similar manner as Scheme's <code>equals?</code> operation.</p>\n<p>Note that the <code>List</code> behavior is notably different from that of Java's array type (which you mention in your question).  Arrays in Java are a fairly low-level type, and do not support much of the typical object-oriented functionality one might expect.  Of particular note, for equality, arrays are compared by object reference rather than by a structural comparison of the items in the array.  There are ways to do sensible equality comparison on arrays using methods in the <code>Arrays</code> class (e.g. <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#equals(java.lang.Object%5B%5D,java.lang.Object%5B%5D)\" rel=\"nofollow noreferrer\"><code>Arrays.equals</code></a> and <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#deepEquals(java.lang.Object%5B%5D,java.lang.Object%5B%5D)\" rel=\"nofollow noreferrer\"><code>Arrays.deepEquals</code></a>).</p>\n<hr />\n<p>As an aside, to address your postscript about the equality of two bare <code>Object</code>s.</p>\n<pre class=\"lang-java prettyprint-override\"><code>assert !(new Object().equals(new Object()))\n</code></pre>\n<p>From an object-oriented perspective, it is sensible that two bare objects be equal only if they're the same reference.  First, as mentioned above, there is not a direct relation between an object's internal structure and its equality, so there's no <em>need</em> for them to be equal.  There is virtually no context as to what two different instances of <code>Object</code> represent from a object modeling perspective, so there's no inherent conceptual way to tell that these two objects are logically the &quot;same&quot; thing.</p>\n<hr />\n<p>In summary, assuming all the types in your list have a <em>sensible</em> version of <code>equals()</code> defined per their object's type, Java's <code>List.equals()</code> behaves directly analogously to Scheme's <code>equals?</code> operation.</p>\n","answer_id":65558844,"question_id":19051021},{"owner":{"profile_image":"https://graph.facebook.com/2006365462920236/picture?type=large","account_id":13055145,"user_type":"registered","user_id":9434244,"link":"https://stackoverflow.com/users/9434244/martin-clever","reputation":147,"display_name":"Martin Clever"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1609665056,"creation_date":1609665056,"body":"<p>As long as @JohannesKuhn doesn't post his comment as an answer:<br />\nThe solution is <code>class B&lt;T extends SomeClass, R extends SomeClass, S extends A&lt;T, R&gt;&gt;</code></p>\n","answer_id":65548194,"question_id":65541924},{"owner":{"profile_image":"https://i.stack.imgur.com/a6vMO.jpg?s=256&g=1","account_id":11119792,"user_type":"registered","user_id":8163025,"link":"https://stackoverflow.com/users/8163025/saver","reputation":2581,"display_name":"saver"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1609634511,"creation_date":1609634511,"body":"<p>The main issue is inside of <code>BasicComboBoxRenderer</code>, because that class hasn't generic parameter for <code>ListCellRenderer</code> interface, but <code>JComboBox</code> class expects generalized <code>aRenderer</code> variable, see snippet:</p>\n<pre><code>    public void setRenderer(ListCellRenderer&lt;? super E&gt; aRenderer) {\n        ListCellRenderer&lt;? super E&gt; oldRenderer = renderer;\n        renderer = aRenderer;\n        firePropertyChange( &quot;renderer&quot;, oldRenderer, renderer );\n        invalidate();\n    }\n</code></pre>\n<p>As workaround I can propose to copy all logic from <code>BasicComboBoxRenderer</code> to you own custom class and add generic type for <code>ListCellRenderer</code>, and that approcu will solve warning during compilation process.</p>\n","answer_id":65545601,"question_id":64888934},{"owner":{"profile_image":"https://lh4.googleusercontent.com/--0W1SyomlMg/AAAAAAAAAAI/AAAAAAAAAGY/w5Ja9a3U4zE/photo.jpg?sz=256","account_id":9127082,"user_type":"registered","user_id":6790326,"link":"https://stackoverflow.com/users/6790326/dorian-gray","reputation":2952,"display_name":"Dorian Gray"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1608667264,"creation_date":1608667264,"body":"<p>In the sort function, you only have two different types: The type of the list and the type of the comparator. <code>T</code> is the type of the elements in the <code>List</code>, and <code>? super T</code> is the type of the <code>Comparator</code>. You do not gain anything by adding\n<code>List&lt;? extends T&gt;</code> there.</p>\n<p>In <code>binarySearch</code> you have three types: <code>T</code>denotes the type of the <code>key</code> to be searched, <code>? extends T</code> is the type of the list and <code>? super T</code> is the type of the comparator.</p>\n","answer_id":65415114,"question_id":65414023},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c17dd9cf3e2322be19639e96da9f3eb3?s=256&d=identicon&r=PG","account_id":1082858,"user_type":"registered","user_id":1079354,"link":"https://stackoverflow.com/users/1079354/makoto","reputation":104688,"display_name":"Makoto","accept_rate":93},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1608662204,"creation_date":1608662204,"body":"<p>Sorting a list only makes sense only if the list is homogeneous; if one is sorting a pile of papers, it suddenly breaks down if you introduce a whole book in the mix.</p>\n<p>Searching a list makes sense if each item is comparable to each other.  If you can define a relationship between a piece of A4 paper and a novel, then you can search between them.</p>\n","answer_id":65414091,"question_id":65414023},{"owner":{"profile_image":"https://i.stack.imgur.com/mOJf7.jpg?s=256&g=1","account_id":18536445,"user_type":"registered","user_id":13506001,"link":"https://stackoverflow.com/users/13506001/rohith-v","reputation":1099,"display_name":"Rohith V"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1606552774,"creation_date":1606552774,"body":"<p>I think you can also make use of\n<code>Collections.max(queue)</code> in case of queue</p>\n","answer_id":65047840,"question_id":40877146},{"owner":{"profile_image":"https://www.gravatar.com/avatar/23e44feadef4ec70940f7dde38bf772e?s=256&d=identicon&r=PG","account_id":2197912,"user_type":"registered","user_id":1943126,"link":"https://stackoverflow.com/users/1943126/michail-alexakis","reputation":1425,"display_name":"Michail Alexakis"},"content_license":"CC BY-SA 4.0","score":5,"is_accepted":false,"last_activity_date":1597606010,"creation_date":1597606010,"body":"<p>If you are willing to convert to an unmodifiable <code>List&lt;Object&gt;</code>, you can simply wrap your list with <code>Collections.unmodifiableList</code>. This works because this static method has a proper wildcard type <code>? extends T</code> for the element type of the wrapped list (where <code>T</code> is the type of the result list).</p>\n<p>Note that, in most cases, creating an unmodifiable view is what you <em>should</em> do, otherwise objects of different types (other than <code>String</code>) may be added in the original list (which should only hold <code>String</code>s).</p>\n","answer_id":63441108,"question_id":4288084},{"owner":{"profile_image":"https://i.stack.imgur.com/zNAXD.jpg?s=256&g=1","account_id":7666017,"user_type":"registered","user_id":5809720,"link":"https://stackoverflow.com/users/5809720/sagar-gangwal","reputation":7604,"display_name":"Sagar Gangwal"},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":true,"last_activity_date":1597600350,"creation_date":1597595898,"body":"<p>You can try below code.</p>\n<p>For getting that User class you can use <strong><code>fieldElement.getEnclosingElement()</code></strong>, it will give you class name with full package name.</p>\n<p>Now if you want only name of that class you can use <strong><code>enclosingElement.getSimpleName()</code></strong>.</p>\n<p>And to get enclosedByElement you can use <a href=\"https://javadoc.io/doc/org.kohsuke.sorcerer/sorcerer-javac/latest/com/sun/tools/javac/code/Symbol.TypeSymbol.html\" rel=\"nofollow noreferrer\">TypeSymbol</a>.Simply cast fieldElement.asType() to <strong><code>Type</code></strong> and get <strong><code>tsym</code></strong> attribute.</p>\n<pre><code>        VariableElement fieldElement;\n\n        Symbol.TypeSymbol containerForEnclosingElement=((Type)fieldElement.asType()).tsym;\n        Element enclosingElement=fieldElement.getEnclosingElement();\n\n        System.out.println(&quot;containerForEnclosingElement:- &quot; +  containerForEnclosingElement);\n        System.out.println(&quot;enclosingElement:- &quot; +  enclosingElement);\n        System.out.println(&quot;enclosingElement Name:- &quot; +  enclosingElement.getSimpleName());\n        System.out.println(&quot;fieldElement without root Type:- &quot;+((Type) fieldElement.asType()).getTypeArguments().get(0));\n</code></pre>\n<p>Above code will print output as below.</p>\n<pre><code>containerForEnclosingElement:- java.util.Set\nenclosingElement:- com.example.demo.test.model.User.\nenclosingElement Name:- User\nfieldElement without root Type:- com.example.demo.test.model.User\n</code></pre>\n<p>You can also create one Utility method to get this two values.</p>\n<p>This will help you.</p>\n","answer_id":63439432,"question_id":63437899,"last_edit_date":1597600350},{"owner":{"profile_image":"https://lh5.googleusercontent.com/-gCJ9KuZ_-mA/AAAAAAAAAAI/AAAAAAAAAF8/rloa0hwh82Q/photo.jpg?sz=256","account_id":6183412,"user_type":"registered","user_id":4818195,"link":"https://stackoverflow.com/users/4818195/hatem-mohamed","reputation":220,"display_name":"Hatem Mohamed"},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1597435712,"creation_date":1597434966,"body":"<p>In your case, you don't need to use generics as the basic polymorphism will be sufficient</p>\n<pre><code> public String translateBar(Foo pojo){\n    //return translated string\n}\n</code></pre>\n<p>And this will solve the issue if you just want to call the <code>getFoo()</code></p>\n","answer_id":63419287,"question_id":63419194,"last_edit_date":1597435712},{"owner":{"profile_image":"https://www.gravatar.com/avatar/a1254dabbec32d7cbc502dfd2fd0438d?s=256&d=identicon&r=PG","account_id":990530,"user_type":"registered","user_id":1007991,"link":"https://stackoverflow.com/users/1007991/renato","reputation":13072,"display_name":"Renato","accept_rate":82},"content_license":"CC BY-SA 4.0","score":3,"is_accepted":true,"last_activity_date":1597435055,"creation_date":1597435055,"body":"<p>In Java, a method that accepts a certain type, say <code>Foo</code>, will accept also any sub-type of <code>Foo</code>. There's no need to use generics in such case.</p>\n<p>Here's how your code should look like:</p>\n<pre><code>public interface Foo {\n    String getFoo();\n}\n\npublic class Bar1 implements Foo {\n    final String foo = &quot;foobar&quot;;\n    @Override\n    public String getFoo(){\n        return foo;\n    }\n}\n\npublic class TranslateBar {\n    public String translateBar(Foo pojo) {\n        //return translated string\n    }\n}\n</code></pre>\n<p>Now you can call <code>translateBar</code> with any implementation of <code>Foo</code> including <code>Bar1</code>:</p>\n<pre><code>new TranslateBar().translateBar(new Bar1());\n</code></pre>\n<p>You would use generic for different cases... for example, where the type returned by the <code>getFoo</code> method depended on the implementation.</p>\n<pre><code>// the type T is generic and depends on the implementation\npublic interface Foo&lt;T&gt; {\n    T getFoo();\n}\n\npublic class Bar1 implements Foo&lt;String&gt; {\n    final String foo = &quot;foobar&quot;;\n    @Override\n    public String getFoo(){\n        return foo;\n    }\n}\n\npublic class TranslateBar {\n    public String translateBar(Foo&lt;?&gt; pojo) {\n        //return translated string\n    }\n}\n</code></pre>\n","answer_id":63419297,"question_id":63419194},{"owner":{"profile_image":"https://i.stack.imgur.com/7ghSp.jpg?s=256&g=1","account_id":238684,"user_type":"registered","user_id":507738,"link":"https://stackoverflow.com/users/507738/mc-emperor","reputation":22543,"display_name":"MC Emperor","accept_rate":71},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":false,"last_activity_date":1597421664,"creation_date":1597335436,"body":"<p>I think that this is not a bug, but a consequence of type inference. OP already mentioned it. The compiler will not try to match an exact type, but <em>the most specific one</em>.</p>\n<p>Let us analyse how type inference works with the example provided by OP.</p>\n<pre><code>public static &lt;F, T&gt; Predicate&lt;F&gt; isEquals(Function&lt;F, T&gt; func, T expValue) {\n    return actual -&gt; Objects.equals(func.apply(actual), expValue);\n}\n</code></pre>\n<pre><code>Predicate&lt;String&gt; lLengthIs20 = isEquals(String::length, &quot;Whud?&quot;);\n</code></pre>\n<p>Here the target type is <code>Predicate&lt;String&gt;</code>, and according to the return type of the method, which is <code>Predicate&lt;F&gt;</code> (where <code>F</code> is a generic type), <code>F</code> is bound to a <code>String</code>. Then the method reference <code>String::length</code> is checked whether it fits into the method parameter <code>Function&lt;F, T&gt;</code>, where <code>F</code> is <code>String</code> and <code>T</code> some unbounded type. And this is important: while the method reference <code>String::length</code> looks like its target type is <code>Integer</code>, it is also compatible to <code>Object</code>. Similarly, <code>Object obj = &quot;Hello&quot;.length()</code> is valid. It is not <em>required</em> to be an <code>Integer</code>. Likewise, both <code>Function&lt;String, Object&gt; func = String::length</code> and <code>Function&lt;String, Object&gt; func = str -&gt; str.length()</code> are valid and do not emit a compiler warning.</p>\n<h2>What exactly is inference?</h2>\n<p>Inference is to defer the job of selecting the appropriate type to the compiler. You ask the compiler: &quot;Please, could you fill in appropriate types, so that it'll work?&quot; And then the compiler answers: &quot;Okay, but I follow certain rules when selecting the type.&quot;</p>\n<p>The compiler selects the most specific type. In the case of <code>isEquals(String::length, 20)</code>, both the target type of <code>String::length</code> and <code>20</code> is <code>Integer</code>, so the compiler infers it as such.</p>\n<p>However, in the case of <code>isEquals(String::length, &quot;Whud?&quot;)</code> the compiler first tries to infer <code>T</code> to an <code>Integer</code> because of the type of <code>String::length</code>, but it fails to do so because of the type of the second argument. The compiler then tries to find the closest intersection of <code>Integer</code> and <code>String</code>.</p>\n<h2>Can I aid or bypass the compiler?</h2>\n<p>Bypass? No, not really. Well, sometimes typecasting is a way of bypassing, like in the following example:</p>\n<pre><code>Object o = 23; // Runtime type is integer\nString str = (String) o; // Will throw a ClassCastException\n</code></pre>\n<p>The typecast here is a potentially unsafe operation, because <code>o</code> may or may not be a <code>String</code>. With this typecast, you say to the compiler: &quot;In this specific case, I know better than you&quot; – with the risk of getting an exception during runtime.</p>\n<p>Still, not all typecast operations are permitted:</p>\n<pre><code>Integer o = 23;\nString str = (String) o;\n// Results in a compiler error: &quot;incompatible types: Integer cannot be converted to String&quot;\n</code></pre>\n<p>But you can certainly aid the compiler.</p>\n<h3>Type witness</h3>\n<p>One option may be to <strong>use a <em>type witness</em></strong>:</p>\n<pre><code>Predicate&lt;String&gt; lLengthIs20 = YourClass.&lt;String, Integer&gt;isEquals(String::length, &quot;what?&quot;);\n</code></pre>\n<p>This code will emit a compiler error:</p>\n<blockquote>\n<p>incompatible types: String cannot be converted to Integer</p>\n</blockquote>\n<h3>Add a <code>Class&lt;T&gt;</code> parameter to <code>isEquals</code></h3>\n<p>Another option would be to <strong>add a parameter</strong> to <code>isEquals</code>:</p>\n<pre><code>public static &lt;F, T&gt; Predicate&lt;F&gt; isEquals(Class&lt;T&gt; type, Function&lt;F, T&gt; func, T expValue) {\n    return actual -&gt; Objects.equals(func.apply(actual), expValue);\n}\n</code></pre>\n<pre><code>// This will succeed:\nPredicate&lt;String&gt; lLengthIs20 = isEquals(Integer.class, String::length, 20);\n// This will fail:\nPredicate&lt;String&gt; lLengthIs20 = isEquals(Integer.class, String::length, &quot;Whud?&quot;);\n</code></pre>\n<h3>Typecasting</h3>\n<p>A third option may be <em><strong>typecasting</strong></em>. Here you cast <code>String::length</code> to a <code>Function&lt;String, Integer&gt;</code>, and now the compiler is restricted to <code>F = String, T = Integer</code>. Now the usage of <code>&quot;Whud?&quot;</code> causes trouble.</p>\n<pre><code>Predicate&lt;String&gt; predicate = isEquals((Function&lt;String, Integer&gt;) String::length, &quot;Whud?&quot;);\n</code></pre>\n","answer_id":63399216,"question_id":63384914,"last_edit_date":1597421664},{"owner":{"profile_image":"https://i.stack.imgur.com/7bZhz.png?s=256&g=1","account_id":5640884,"user_type":"registered","user_id":4465539,"link":"https://stackoverflow.com/users/4465539/deduper","reputation":1954,"display_name":"deduper","accept_rate":33},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1597411987,"creation_date":1597411987,"body":"<p><em><strong>TL;DR</strong></em>: Not trying to snipe @MAnouti's points that you've earmarked for him/her. But for the sake of completeness, OP, I wanted to share what I observed in <a href=\"https://www.browxy.com#USER_307436\" rel=\"nofollow noreferrer\"><em>my attempt to reproduce your error</em></a>.</p>\n<hr />\n<blockquote>\n<p>„<em>This results in the following error:</em>“</p>\n<pre><code>Type mismatch: cannot convert from Class&lt;Integer&gt; to Integer\n</code></pre>\n</blockquote>\n<p>The original example code in your question fails to compile (<a href=\"https://www.browxy.com#USER_307436\" rel=\"nofollow noreferrer\"><em>as confirmed by my failed attempt to reproduce the same error</em></a>) with these <em>different</em> compilation errors…</p>\n<pre><code>...\nincompatible types: IntegerTransformer cannot be converted to Transformer&lt;T&gt;\n...\nincompatible types: ByteTransformer cannot be converted to Transformer&lt;T&gt;\n...\n</code></pre>\n<p>…Notice those are not the same as the error you reported in your question.</p>\n<p>And even if you did follow the advice of the other answers/comments and replaced <em><code>T</code></em> with <em><code>Class&lt;T&gt;</code></em> as the second formal parameter of your method, you would still get the above <em><code>cannot be converted to Transformer&lt;T&gt;</code></em> compilation errors.</p>\n<blockquote>\n<p>„<em>…Is there any way I can do that without modifying the generic structure of interface and factory?</em>“</p>\n</blockquote>\n<p>I have <a href=\"https://www.browxy.com#USER_307438\" rel=\"nofollow noreferrer\"><em>confirmed by a simple experiment</em></a> that this meets that criteria. <em><strong>And</strong></em> it successfully compiles and runs as expected…</p>\n<pre><code>    public &lt; T, U extends Transformer&lt; T &gt; &gt; U getTransformer( SomeEnum eNum, Class&lt; T &gt; type ){ \n    \n    switch( eNum ){ \n        case FOO:\n            return (U)new IntegerTransformer( );\n        case BAR:\n            return (U)new ByteTransformer( );\n        default:\n            throw new RuntimeException( &quot;Detected Decepticons Among Us!&quot; );\n    }\n}\n</code></pre>\n<p>…It fixes both the error you reported in your question, <em><strong>and</strong></em> the <em><code>cannot be converted to Transformer&lt;T&gt;</code></em> errors you'd get if the only thing you changed was the parameter to <em><code>Class&lt;T&gt;</code></em>.</p>\n","answer_id":63413798,"question_id":63411281},{"owner":{"profile_image":"https://lh6.googleusercontent.com/-CLisJv2LfKw/AAAAAAAAAAI/AAAAAAAAAAA/lqE6eNyd2RY/photo.jpg?sz=256","account_id":15284776,"user_type":"registered","user_id":11028099,"link":"https://stackoverflow.com/users/11028099/luis-i%c3%b1esta","reputation":401,"display_name":"Luis I&#241;esta"},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":false,"last_activity_date":1597402374,"creation_date":1597402374,"body":"<p>The signature of <code>getTransformer(final SomeEnum enum, final T type)</code> expects an actual objet of type <code>T</code>. What you want is pass a instance of <code>class</code>, so it should be:\n<code>getTransformer(final SomeEnum enum, final Class&lt;T&gt; type)</code></p>\n<p>In addition, since Java 8 there is no need for declaring such simple interfaces. Using the generic <code>Function&lt;String,T&gt;</code> would serve you perfectly.</p>\n","answer_id":63411379,"question_id":63411281},{"owner":{"profile_image":"https://www.gravatar.com/avatar/44c841338e1646af9a977f1fa0e23948?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":162699,"user_type":"registered","user_id":3788176,"link":"https://stackoverflow.com/users/3788176/andy-turner","reputation":138060,"display_name":"Andy Turner","accept_rate":54},"content_license":"CC BY-SA 4.0","score":14,"is_accepted":true,"last_activity_date":1597392756,"creation_date":1475740270,"body":"<p>Remember that <code>...</code> is just syntactic sugar for an array parameter. You can call a method with a variadic parameter <code>foo(Object...)</code> either using</p>\n<pre><code>foo(&quot;hello&quot;, 1);\n</code></pre>\n<p>or</p>\n<pre><code>foo(new Object[]{&quot;hello&quot;, 1});\n</code></pre>\n<p>since the compiler constructs the second form anyway.</p>\n<p>Because the receiver type isn't considered when the compiler infers types, it looks at <code>Arrays.asList(new Object[]{&quot;bar&quot;, 286})</code> and thinks that you mean to create a list of <code>Object</code>, not a singleton list of <code>Object[]</code>.</p>\n<p>The easiest way with your existing syntax is just to add an explicit type parameter:</p>\n<pre><code>List&lt;Object[]&gt; bar = Arrays.&lt;Object[]&gt;asList(new Object[]{&quot;bar&quot;, 286});\n</code></pre>\n<p>Adding the <code>&lt;Object[]&gt;</code> tells the compiler what T should be.</p>\n<p>Or, if you don't need the list to be mutable:</p>\n<pre><code>List&lt;Object[]&gt; bar = Collections.singletonList(new Object[]{&quot;bar&quot;, 286});\n</code></pre>\n","answer_id":39890475,"question_id":39889498,"last_edit_date":1597392756},{"owner":{"user_type":"does_not_exist","display_name":"user14089698"},"content_license":"CC BY-SA 4.0","score":5,"is_accepted":false,"last_activity_date":1597377088,"creation_date":1597317239,"body":"<p>Java does not support &quot;optional&quot; or gradual typing. You can try creating a subclass that defaults metadata to <code>null</code>, i.e. <code>NoMetadataTriple&lt;K,V&gt;</code>, or give <code>Void</code> for M instead as mentioned in the other answer.</p>\n<p>The <a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/Void.html\" rel=\"nofollow noreferrer\"><code>Void</code></a> &quot;type&quot; cannot be instantiated. It's basically <code>void</code> (the output parameter) as a <code>Class</code>.</p>\n","answer_id":63393932,"question_id":63393807,"last_edit_date":1597377088},{"owner":{"profile_image":"https://i.stack.imgur.com/7bZhz.png?s=256&g=1","account_id":5640884,"user_type":"registered","user_id":4465539,"link":"https://stackoverflow.com/users/4465539/deduper","reputation":1954,"display_name":"deduper","accept_rate":33},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1597334132,"creation_date":1597279864,"body":"<blockquote>\n<p>„<em>…is there a way for me to tell Java to not use the Object version…</em>“</p>\n</blockquote>\n<p>Yes. And the term — <em>in the context of Generics</em> — for telling Java to not use <code>Object</code> is called: „<em>Specifying a bound</em>“.</p>\n<p><a href=\"https://jdoodle.com/ia/fw\" rel=\"nofollow noreferrer\">My experiment confirmed</a> that calling the following method as <code>isEquals(String::hashCode, &quot;What the theoretical fuck!&amp;?*!?@!&quot;)</code> will produce <code>error: no suitable method found for isEquals(String::hashCode,String)</code>...</p>\n<pre><code>public static &lt;F extends String, T extends Number&gt; Predicate&lt;F&gt; isEquals(Function&lt;F, T&gt; aFunction, T aValue)\n{\n    return input -&gt; Objects.equals(aFunction.apply(input), aValue);\n}  \n</code></pre>\n<p>If you have both, the above method, and the following one in the same class, then this version is called for <code>isEquals(String::length, 20)</code>...</p>\n<pre><code>public static &lt;F&gt; Predicate&lt;F&gt; isEquals(ToIntFunction&lt;F&gt; aFunction, int aValue)\n{\n    return input -&gt; aFunction.applyAsInt(input) == aValue;\n}\n</code></pre>\n<p>...But the first one is called for <code>isEquals(String::length, Integer.valueOf(42))</code>.</p>\n<p>Click the blue <em>Execute</em> button <a href=\"https://jdoodle.com/ia/fw\" rel=\"nofollow noreferrer\"><em>in this demo</em></a> to see it working.</p>\n","answer_id":63386541,"question_id":63384914,"last_edit_date":1597334132},{"owner":{"profile_image":"https://www.gravatar.com/avatar/da698e0f6137f881e120ba96344c72a1?s=256&d=identicon&r=PG","account_id":2190376,"user_type":"registered","user_id":1937593,"link":"https://stackoverflow.com/users/1937593/paranoidandroid","reputation":533,"display_name":"paranoidAndroid"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1597333440,"creation_date":1597333440,"body":"<p>As far as I'm concerned, this smells like a real java compiler bug to me..Compiler should be able to infer arguments without assignment to a variable, since we have <code>Function&lt;F, T&gt; aInMapFunction</code> which should enforce T, as the compiler &quot;knows&quot; that <code>String::length</code> returns an Integer.\nHowever I came up with a sort of solution for you:</p>\n<pre><code>public class PredicateBuilder&lt;F,T&gt;\n{\n    public Predicate&lt;F&gt; isEquals(\n            Function&lt;F, T&gt; aInMapFunction, T aInExpectedValue)\n    {\n        return aInActual -&gt; Objects.equals(\n                aInMapFunction.apply(aInActual), aInExpectedValue);\n    }\n}\n</code></pre>\n<p>and usage:</p>\n<pre><code>new PredicateBuilder&lt;String, Integer&gt;().isEquals(String::length, 5);\n</code></pre>\n<p>Won't compile with other argument types, won't compile either if you try this:</p>\n<pre><code>new PredicateBuilder&lt;&gt;().isEquals(String::length, 5);\n</code></pre>\n","answer_id":63398639,"question_id":63384914},{"owner":{"profile_image":"https://www.gravatar.com/avatar/9e462b11b46069ee682e1ce8bc5f5825?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":1063012,"user_type":"registered","user_id":1064245,"link":"https://stackoverflow.com/users/1064245/m-a","reputation":71986,"display_name":"M A","accept_rate":82},"content_license":"CC BY-SA 4.0","score":5,"is_accepted":false,"last_activity_date":1597317162,"creation_date":1597317162,"body":"<p>I would argue that if you determine that the third parameter is not present (as intended by using <code>null</code>), then it's no longer a triplet, but a pair. Just keep things simple and use a <code>Pair</code> class instead.</p>\n","answer_id":63393915,"question_id":63393807},{"owner":{"profile_image":"https://i.stack.imgur.com/H3QRx.jpg?s=256&g=1","account_id":5644665,"user_type":"registered","user_id":4467208,"link":"https://stackoverflow.com/users/4467208/murat-karag%c3%b6z","reputation":35951,"display_name":"Murat Karag&#246;z","accept_rate":51},"content_license":"CC BY-SA 4.0","score":9,"is_accepted":false,"last_activity_date":1597316932,"creation_date":1597316932,"body":"<p>You can use <code>Void</code> e.g.</p>\n<pre><code>Triplet&lt;Integer, String, Void&gt; t2 = new Triplet&lt;&gt;();\n</code></pre>\n","answer_id":63393854,"question_id":63393807},{"owner":{"profile_image":"https://i.stack.imgur.com/fYFFP.jpg?s=256&g=1","account_id":3306670,"user_type":"registered","user_id":2781271,"link":"https://stackoverflow.com/users/2781271/crosp","reputation":4539,"display_name":"CROSP","accept_rate":58},"content_license":"CC BY-SA 4.0","score":1,"is_accepted":true,"last_activity_date":1578325414,"creation_date":1449239905,"body":"<p>I end up with following solution. It is not as good as I wanted, but it works and better than duplicating code.    </p>\n\n<p>My base request class.</p>\n\n<pre><code>public abstract class BaseGetRequest&lt;L extends List&lt;T&gt;, T, V&gt; extends RetrofitSpiceRequest&lt;L, V&gt; implements FilterableRequest {\n    // Context\n    protected Context mContext;\n    // Filter used in request and in queries\n    protected Map&lt;Property, String&gt; mFilterMap;\n    // Session provided Singletone\n    protected DaoSessionProvider mSessionProvider;\n\n    public BaseGetRequest(Class&lt;L&gt; clazz, Class&lt;V&gt; retrofitedInterfaceClass, Context context, Map&lt;Property, String&gt; filterMap) {\n        super(clazz, retrofitedInterfaceClass);\n        mContext = context;\n        mFilterMap = filterMap;\n        mSessionProvider = ((DaoSessionProvider) mContext.getApplicationContext());\n        // TODO determine required retry count\n        setRetryPolicy(new RetryPolicy() {\n            @Override\n            public int getRetryCount() {\n                return 0;\n            }\n\n            @Override\n            public void retry(SpiceException e) {\n\n            }\n\n            @Override\n            public long getDelayBeforeRetry() {\n                return 0;\n            }\n        });\n    }\n\n    protected WhereCondition[] getWhereConditions() {\n        return QueryUtils.convertPropertyMapToConditionalArray(mFilterMap);\n    }\n\n    public BaseGetRequestV2(Class&lt;L&gt; clazz, Class&lt;V&gt; retrofitedInterfaceClass, Context context) {\n        this(clazz, retrofitedInterfaceClass, context, null);\n    }\n\n    public abstract AbstractDao&lt;T, Long&gt; getDao();\n\n    public abstract L createDataList(List&lt;T&gt; list);\n\n    public L getCachedData() {\n        if (mFilterMap != null &amp;&amp; mFilterMap.size() &gt; 0) {\n            WhereCondition[] whereConditions = getWhereConditions();\n            return createDataList(getDao().queryBuilder().where(whereConditions[0], Arrays.copyOfRange(whereConditions, 1, whereConditions.length)).list());\n        } else {\n            return createDataList(getDao().loadAll());\n        }\n    }\n\n    public abstract L getData();\n\n    @Override\n    public Map&lt;Property, String&gt; getFilterMap() {\n        return mFilterMap;\n    }\n\n    public Map&lt;String, String&gt; getStringMap() {\n        return QueryUtils.convertPropertyMapToString(mFilterMap);\n    }\n\n    @Override\n    public L loadDataFromNetwork() throws Exception {\n        L receivedData = null;\n        try {\n            receivedData = getData();\n            WhereCondition[] conditions = getWhereConditions();\n            getDao().queryBuilder().where(conditions[0],Arrays.copyOfRange(conditions, 1, conditions.length)).buildDelete().executeDeleteWithoutDetachingEntities();\n            getDao().insertOrReplaceInTx(receivedData);\n        } catch (Exception ex) {\n            receivedData = getCachedData();\n        }\n        return receivedData;\n    }\n}\n</code></pre>\n\n<p>And I can extend this class like so:   </p>\n\n<pre><code>public class NewsRequest extends BaseGetRequest&lt;NewsArticle.List, NewsArticle, API&gt; {\n\n    public static final String TARGET_URL = \"/news\";\n    NewsArticleDao mNewsArticleDao;\n\n    public NewsRequest(Context context) {\n        this(context, null);\n    }\n\n    public NewsRequest(Context context, Map&lt;Property, String&gt; filterMap) {\n        super(NewsArticle.List.class, API.class, context, filterMap);\n        mNewsArticleDao = mSessionProvider.getDaoSession().getNewsArticleDao();\n    }\n\n    @Override\n    public AbstractDao&lt;NewsArticle, Long&gt; getDao() {\n        return mNewsArticleDao;\n    }\n\n    @Override\n    public NewsArticle.List createDataList(List&lt;NewsArticle&gt; list) {\n       return new NewsArticle.List(list);\n    }\n\n    @Override\n    public NewsArticle.List getData() {\n        return getService().getNews(getStringMap());\n    }\n}\n</code></pre>\n","answer_id":34090759,"question_id":33754844,"last_edit_date":1578325414},{"owner":{"profile_image":"https://www.gravatar.com/avatar/2f0d9dec16bae1e06552af55ddefc11f?s=256&d=identicon&r=PG","account_id":277416,"user_type":"registered","user_id":571407,"link":"https://stackoverflow.com/users/571407/jb-nizet","reputation":681888,"display_name":"JB Nizet","accept_rate":100},"content_license":"CC BY-SA 4.0","score":2,"is_accepted":true,"last_activity_date":1576332781,"creation_date":1576332781,"body":"<p>Make your base class generic (with generic type T), and make <code>show()</code> accept a <code>Consumer&lt;T&gt;</code> (or a <code>Consumer&lt;? super T&gt;</code>. Make the subclass extend <code>BaseClass&lt;Protection&gt;</code>.</p>\n\n<pre><code>class BaseClass&lt;T&gt; {\n    public void show(Consumer&lt;T&gt; validationHandler) { //  or Consumer&lt;? super T&gt;\n    }\n}\n\nclass SubClass extends BaseClass&lt;Protection&gt; {\n    @Override\n    public void show(Consumer&lt;Protection&gt; validationHandler) { //  or Consumer&lt;? super Protection&gt;\n        super.show(validationHandler);\n    }\n}\n\nclass Protection {}\n</code></pre>\n","answer_id":59335900,"question_id":59335819},{"owner":{"profile_image":"https://www.gravatar.com/avatar/7ffdb6cd7dee86394ef625ad9c1d2c93?s=256&d=identicon&r=PG","account_id":9035,"user_type":"registered","user_id":16513,"link":"https://stackoverflow.com/users/16513/jjohn","reputation":9796,"display_name":"jjohn"},"content_license":"CC BY-SA 4.0","score":107,"is_accepted":false,"last_activity_date":1565228778,"creation_date":1233193952,"body":"<p>As the other posts have noted, you are asking about a Java feature called generics.  In C++, this is called templates.  This feature in Java is usually easier to work with than the that found in C++.</p>\n\n<p>Let me answer your questions functionally (if that's not a naughty word for OO discussions).</p>\n\n<p>Before generics, there were concrete classes like Vector.  </p>\n\n<pre><code>Vector V = new Vector();\n</code></pre>\n\n<p>Vectors hold any object you give them.  </p>\n\n<pre><code>V.add(\"This is an element\");\nV.add(new Integer(2));\nv.add(new Hashtable());\n</code></pre>\n\n<p>They do this by casting all values given to it into an Object (the root of all Java classes).  When you attempt to retrieve the values stored in your Vector, you need to cast the value back into the <em>original</em> class (if you want to do anything meaningful with it).</p>\n\n<pre><code>String s = (String) v.get(0);\nInteger i = (Integer) v.get(1);\nHashtable h = (Hashtable) v.get(2);\n</code></pre>\n\n<p>Casting gets old fast.  More than that, the compiler complains to you about unchecked casts.   The most urgent problem with casting like this is that consumers of your Vector have to know the classes of its values at <em>compile time</em> in order to cast correctly.  In cases where the producer of the Vector and the consumer of the same are completely isolated from each other (think RPC messages), this can be a fatal issue. </p>\n\n<p>Enter generics.  Generics attempt to create strongly typed classes to do generic operations. </p>\n\n<pre><code>ArrayList&lt;String&gt; aList = new ArrayList&lt;String&gt;();\naList.add(\"One\");\nString element = aList.get(0); // no cast needed\nSystem.out.println(\"Got one: \" + element); \n</code></pre>\n\n<p>The <em>Design Patterns</em> book encourages the reader to think in terms of contracts, not concrete types. There is wisdom (and code re-use) in divorcing variables from their implementing class.</p>\n\n<p>With this in mind, you might think that all implementations List objects should do the same set of things: <code>add()</code>, <code>get()</code>, <code>size()</code>, etc.  With a little reflection, you can imagine many implementations of List operations that obey the List contract in various ways (e.g. <code>ArrayList</code>).  However, the type of data these objects deal with is orthogonal to the actions performed on them.</p>\n\n<p>Put it all together and you'll see the following kinds of code frequently:</p>\n\n<pre><code>List&lt;String&gt; L = new ArrayList&lt;String&gt;();\n</code></pre>\n\n<p>You should read that as \"L is a kind of List that deals with String objects\".  When you start dealing with Factory classes, it is critical to deal with contracts rather than specific implementations.  Factories produce objects of various types at runtime.  </p>\n\n<p>Using generics is pretty easy (most of the time).  </p>\n\n<p>One day you may decide you want to implement your own generic class.  Perhaps you want to write a new database abstraction interface that elides the differencesbetween various data stores.  When you define that generic class, you will use <code>&lt;t&gt;</code> as a placeholder for the kind of object that will be manipulated by the methods.</p>\n\n<p>If you are still confused, use the generic classes for List until you are comfortable.  Later, you can dive into the implementation with a bit more confidence.  Or you can look at the source code for the various List classes that ship with the JRE.  Open source is great that way.</p>\n\n<p>Have a look at the Oracle/Sun <a href=\"http://www.oracle.com/technetwork/articles/javase/generics-136597.html\" rel=\"noreferrer\">docs about generics</a>.\nCheers.</p>\n","answer_id":490225,"question_id":490091,"last_edit_date":1565228778},{"owner":{"profile_image":"https://i.stack.imgur.com/9bcVI.jpg?s=256&g=1","account_id":14963506,"user_type":"registered","user_id":10802531,"link":"https://stackoverflow.com/users/10802531/mosayeb-masoumi","reputation":513,"display_name":"Mosayeb Masoumi"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1562528610,"creation_date":1562528610,"body":"<h2>model.class</h2>\n\n<p>public class Model {</p>\n\n<pre><code>private List&lt;String&gt; stringList = new ArrayList&lt;&gt;();\n\npublic List&lt;String&gt; getStringList() {\n    return stringList;\n}\n\npublic void setStringList(List&lt;String&gt; stringList) {\n    this.stringList = stringList;\n}\n</code></pre>\n\n<h2>}</h2>\n\n<h2>MainActivity</h2>\n\n<p>public class MainActivity extends AppCompatActivity {</p>\n\n<pre><code>Model model = new Model();\nSpinner spinner;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n\n    spinner=findViewById(R.id.spinner);\n\n    List&lt;String&gt; itemList = new ArrayList&lt;String&gt;();\n    itemList.add(\"item1\");\n    itemList.add(\"item2\");\n    itemList.add(\"item3\");\n\n\n   model.setStringList(itemList);\n\n\n    ArrayAdapter&lt;String&gt; dataAdapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_spinner_item, model.getStringList());\n    dataAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n\n    spinner.setAdapter(dataAdapter);\n\n}\n</code></pre>\n\n<p>}</p>\n","answer_id":56925557,"question_id":4288084},{"owner":{"profile_image":"https://lh5.googleusercontent.com/-Jz13IVvb0TQ/AAAAAAAAAAI/AAAAAAAAAAA/APUIFaM7cVAzDpHSI9CDxjyRWoumzVxyoA/mo/photo.jpg?sz=256","account_id":14385234,"user_type":"registered","user_id":10391432,"link":"https://stackoverflow.com/users/10391432/ale%d1%87","reputation":85,"display_name":"Aleч"},"content_license":"CC BY-SA 4.0","score":5,"is_accepted":false,"last_activity_date":1537447650,"creation_date":1537447650,"body":"<p>Just point compiler the proper version of generic Comparator with\n<code>(Comparator&lt;String&gt;)</code></p>\n\n<p>So the answer will be </p>\n\n<p><code>sort(list, (Comparator&lt;String&gt;)(a, b) -&gt; a.compareTo(b));</code></p>\n","answer_id":52425521,"question_id":22588518},{"owner":{"profile_image":"https://www.gravatar.com/avatar/49aa114f503078d86733fba209b753b0?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":4386848,"user_type":"registered","user_id":3576723,"link":"https://stackoverflow.com/users/3576723/iconfly","reputation":158,"display_name":"iconfly"},"content_license":"CC BY-SA 4.0","score":0,"is_accepted":false,"last_activity_date":1534593247,"creation_date":1534593247,"body":"<p>You mean something like this?:</p>\n\n<pre><code>&lt;T,S&gt;(T t, S s)-&gt;...\n</code></pre>\n\n<p>Of what type is this lambda? You couldn't express that in Java and therefore cannot compose this expression in a function application and expressions have to be composable.</p>\n\n<p>For this need to be work you would need support for <a href=\"https://prime.haskell.org/wiki/Rank2Types\" rel=\"nofollow noreferrer\">Rank2 Types</a> in Java.</p>\n\n<p>Methods are allowed to be generic but therefore you couldn't use them as expressions. They can, however be reduced to lambda expression by specializing all necessary generic types before you can pass them: <code>ClassName::&lt;TypeName&gt;methodName</code> </p>\n","answer_id":51908366,"question_id":22588518},{"owner":{"profile_image":"https://www.gravatar.com/avatar/7342b1a54fabea2e83217791500597b0?s=256&d=identicon&r=PG","account_id":873510,"user_type":"registered","user_id":923837,"link":"https://stackoverflow.com/users/923837/eric-lindauer","reputation":1813,"display_name":"Eric Lindauer","accept_rate":90},"content_license":"CC BY-SA 3.0","score":16,"is_accepted":false,"last_activity_date":1503581914,"creation_date":1331339605,"body":"<p>To add to the already good answers here:</p>\n\n<p><strong>Method arguments:</strong></p>\n\n<p><code>List&lt;? extends Foo&gt;</code></p>\n\n<p>good choice if you don't intend to alter the list, and only care that everything in the list is assignable to type 'Foo'.  This way, the caller can pass in a List&lt;FooSubclass&gt; and your method works. Usually the best choice.</p>\n\n<p><code>List&lt;Foo&gt;</code></p>\n\n<p>good choice if you intend to add Foo objects to the list in your method.  The caller may not pass in a List&lt;FooSubclass&gt;, as you intend to add a Foo to the List.</p>\n\n<p><code>List&lt;? super Foo&gt;</code></p>\n\n<p>good choice if you intend to add Foo objects to the list, and it's not important what else is in the list (ie, you are ok getting a List&lt;Object&gt; that contains a 'Dog' that has nothing to do with Foo).</p>\n\n<p><strong>Method return values</strong></p>\n\n<p>just like method arguments, but with the benefits reversed.  </p>\n\n<p><code>List&lt;? extends Foo&gt;</code> </p>\n\n<p>Guarantees that everything in the returned List has type 'Foo'.  It might be List&lt;FooSubclass&gt; though.  Caller cannot add to the List.  This is your go-to choice and the most common case by far.</p>\n\n<p><code>List&lt;Foo&gt;</code></p>\n\n<p>Just like List&lt;? extends Foo&gt; but also allows the caller to add to the List.  Less common.</p>\n\n<p><code>List&lt;? super Foo&gt;</code></p>\n\n<p>allows the caller to add Foo objects to the List, but does not guarantee what will be returned from list.get(0)... it could be anything from Foo to Object.  The only guarantee is that this won't be a list of 'Dog' or some other choice that would prevent list.add(foo) from being legal.  Very rare use case.</p>\n\n<p>I hope that helps.  Good luck!</p>\n\n<p>ps. To sum up... two questions... </p>\n\n<blockquote>\n  <p>do you need to add to the List?  Do you care what is in the list?</p>\n  \n  <p>yes yes - use List&lt;Foo&gt;.</p>\n  \n  <p>yes no - use List&lt;? super Foo&gt;.</p>\n  \n  <p>no yes - use &lt;? extends Foo&gt; --- most common.</p>\n  \n  <p>no no - use &lt;?&gt;.</p>\n</blockquote>\n","answer_id":9642824,"question_id":490091,"last_edit_date":1503581914},{"owner":{"profile_image":"https://lh6.googleusercontent.com/-KU9_wg3JofI/AAAAAAAAAAI/AAAAAAAAAfw/pczsB09dPnk/photo.jpg?sz=256","account_id":10669087,"user_type":"registered","user_id":7854661,"link":"https://stackoverflow.com/users/7854661/meepo","reputation":368,"display_name":"Meepo","accept_rate":100},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1492061810,"creation_date":1492061810,"body":"<p>I'm taking a computer science class, and we aren't allowed to use the for each loop. I'm not sure if it's the same with you. Note that the for each loop kind of defeats the purpose of a Queue since you want to only be handling the front and end of a queue. In my class specifically, we also want to have the queue be at it's original state before it was passed into the method without using an extra auxiliary data structure. Here's how I would go about it on a test:</p>\n\n<pre><code>public E findMaxQueueElement(Queue&lt;e&gt; queue) { //my test would ask me to return the max value\n    E max = queue.remove();\n    queue.add(max); //add it back to the end\n    for(int i=0; i&lt;queue.size()-1; i++) {\n        E current = queue.remove();\n        if (current.compareTo(max) &gt; 0) {\n            max = current;\n        }\n        queue.add(current);\n    }\n    return max;\n}\n</code></pre>\n\n<p>With the limitations I provided, this should work. I hope this helps.</p>\n","answer_id":43384296,"question_id":40877146},{"owner":{"profile_image":"https://www.gravatar.com/avatar/a42f8ff287eb5abf432ce696bf7c653b?s=256&d=identicon&r=PG","account_id":115767,"user_type":"registered","user_id":303810,"link":"https://stackoverflow.com/users/303810/lexicore","reputation":42976,"display_name":"lexicore","accept_rate":84},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1480460689,"creation_date":1480460689,"body":"<p>Unless the queue is not some special sorted queue like <code>PriorityQueue</code>, from the algorithmic point of view there is no better way. Since the queue does not have any intrinsic sorting properties, you have to check all the elements of the queue before you find one.</p>\n\n<p>The code is more or less OK. It will fail if the queue contains <code>null</code>. This is normally not the case, but may happen.<br>\nThe <code>MaxQueueElement</code> construct is somewhat strange.</p>\n","answer_id":40877414,"question_id":40877146},{"owner":{"profile_image":"https://i.stack.imgur.com/Mo0at.jpg?s=256&g=1","account_id":1135699,"user_type":"registered","user_id":1120793,"link":"https://stackoverflow.com/users/1120793/darshan-mehta","reputation":30287,"display_name":"Darshan Mehta","accept_rate":35},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1480460464,"creation_date":1480460464,"body":"<p>You can use Java 8's stream to sort the Queue, it internally uses the same algorithm but will result in less noisy code, e.g.:</p>\n\n<pre><code>public void MaxQueueElement(Queue&lt;E&gt; queue){\n    Optional&lt;E&gt; max = queue.stream()\n        .max(Comparable::compareTo);\n\n    if(max.isPresent()){\n        System.out.println(max.get());\n    }\n}\n</code></pre>\n\n<p>Another approach would be to use <code>PriorityQueue</code> with comparator and get the first element from it. e.g.:</p>\n\n<pre><code>public void MaxQueueElement2(Queue&lt;E&gt; queue){\n    PriorityQueue&lt;E&gt; pQueue = new PriorityQueue&lt;&gt;((E e1, E e2)-&gt;e1.compareTo(e2));\n    pQueue.addAll(queue);\n    System.out.println(pQueue.peek());\n\n}\n</code></pre>\n","answer_id":40877364,"question_id":40877146},{"owner":{"profile_image":"https://www.gravatar.com/avatar/44c841338e1646af9a977f1fa0e23948?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":162699,"user_type":"registered","user_id":3788176,"link":"https://stackoverflow.com/users/3788176/andy-turner","reputation":138060,"display_name":"Andy Turner","accept_rate":54},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1480460237,"creation_date":1480459864,"body":"<p>The only way to access all elements in a <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html\" rel=\"nofollow noreferrer\"><code>Queue</code></a> is to use the <code>iterator()</code> method - you can't (generally) access the elements by index (as in, some implementations might, but <code>Queue</code> doesn't inherently).</p>\n\n<p>As such, all you can do is to iterate the elements one at a time, storing the current maximum element. This is exactly what you're doing here. </p>\n\n<p>There is nothing wrong with your algorithm - but the way you've implemented it could be improved:</p>\n\n<ul>\n<li>Don't do this in the constructor of a class - you don't need to construct a new instance of anything, as the maximum value already exists. Do it in a (static) method.</li>\n<li>Don't print out the result - that's of no use to man or beast. Return it to the caller.</li>\n<li>Handle the cases where the queue is empty and may contain nulls. (Look at the Javadoc of <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#max(java.util.Collection)\" rel=\"nofollow noreferrer\"><code>Collections.max</code></a> for ideas)</li>\n</ul>\n","answer_id":40877245,"question_id":40877146,"last_edit_date":1480460237},{"owner":{"profile_image":"https://i.stack.imgur.com/t2hoD.jpg?s=256&g=1","account_id":3211603,"user_type":"registered","user_id":2711488,"link":"https://stackoverflow.com/users/2711488/holger","reputation":289317,"display_name":"Holger"},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1475745979,"creation_date":1475745979,"body":"<p>The problem is that <code>Arrays.asList</code> is a varargs method which technically receives an array containing the arguments and due to compatibility with pre-generics code still accepts an array instead of an argument list. When passing a single array, the call is ambiguous and will be handled like a pre-varargs method invocation.</p>\n\n<p>The problem disappears when you have more than one argument:</p>\n\n<pre><code>List&lt;Object[]&gt; bar = Arrays.asList(new Object[]{\"bar\", 286}, new Object[]{\"baz\", 123});\n</code></pre>\n\n<p>If you have only one argument you can aid the compiler by inserting an explicit list element type:</p>\n\n<pre><code>List&lt;Object[]&gt; bar = Arrays.&lt;Object[]&gt;asList(new Object[]{\"bar\", 286});\n</code></pre>\n\n<p>Alternatively, you can use</p>\n\n<pre><code>List&lt;Object[]&gt; bar = Collections.singletonList(new Object[]{\"bar\", 286});\n</code></pre>\n\n<p>to create an immutable list of size one. Note that this differs from <code>Arrays.asList</code>, as the latter returns a list of fixed size but still mutable via <code>set</code>.</p>\n","answer_id":39892304,"question_id":39889498},{"owner":{"profile_image":"https://i.stack.imgur.com/EPKBc.jpg?s=256&g=1","account_id":3825349,"user_type":"registered","user_id":3172288,"link":"https://stackoverflow.com/users/3172288/george-cristian","reputation":59,"display_name":"George Cristian","accept_rate":75},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1475739751,"creation_date":1475739751,"body":"<p>When you use <code>List&lt;Object[]&gt; bar = Arrays.asList(new Object[]{\"bar\", 286});</code> you actually have a two dimensional Array and you cand resolve that problem by doing <code>List&lt;Object[]&gt; bar = Arrays.asList(new Object[][]{new Object[]{\"bar\",\"asd\",123}});\n</code></p>\n","answer_id":39890306,"question_id":39889498},{"owner":{"profile_image":"https://www.gravatar.com/avatar/35dbc3b24ca0fe1e2ea162b0648440aa?s=256&d=identicon&r=PG","account_id":4989128,"user_type":"registered","user_id":4011890,"link":"https://stackoverflow.com/users/4011890/noixes","reputation":1168,"display_name":"Noixes"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1475739263,"creation_date":1475739263,"body":"<p>Your call:</p>\n\n<pre><code>Arrays.asList(new Object[]{\"bar\", 286});\n</code></pre>\n\n<p>creates a list out of the <code>Object[]</code>. So the data is convertet into a new <code>List&lt;Object&gt;</code>.</p>\n\n<p>So <code>Arrays.asList(new Object[]{\"bar\", 286}).get(0);</code> will return \"bar\".</p>\n\n<p>In this call:</p>\n\n<pre><code>List&lt;Object[]&gt; foo = new ArrayList&lt;&gt;();\nfoo.add(new Object[]{816, \"foo\", 2.6});\n</code></pre>\n\n<p>you are creating a <code>List&lt;Object[]&gt;</code> (2Dimensional) and add one element after it: <code>foo.add(..);</code>.\nTherefore you are adding one element consisting of an <code>Object[]</code>.\nif you now call <code>foo.get(0);</code> you will get a <code>Object[]</code> consisting of:\n816, \"foo\", 2.6</p>\n\n<p>I think you wanted to do:</p>\n\n<pre><code>Object[] oa = new Object[]{\"\"};\nObject[] ob = new Object[]{\"\"};\nList&lt;Object[]&gt; list = Arrays.asList(oa, ob);\n</code></pre>\n\n<p>If you have questions, feel free to ask me :)</p>\n","answer_id":39890152,"question_id":39889498},{"owner":{"profile_image":"https://i.stack.imgur.com/IF9uS.png?s=256&g=1","account_id":1924671,"user_type":"registered","user_id":1735406,"link":"https://stackoverflow.com/users/1735406/maroun","reputation":94541,"display_name":"Maroun","accept_rate":95},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1475737738,"creation_date":1475737738,"body":"<p><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-\" rel=\"nofollow\"><code>Arrays#asList</code></a> signature:</p>\n\n<pre><code>public static &lt;T&gt; List&lt;T&gt; asList(T... a)\n</code></pre>\n\n<p>The return type is <code>List&lt;T&gt;</code>. Now you should ask yourself what is <code>T</code>?</p>\n\n<p><code>T</code> is <code>Object</code>, so the return type will be <code>List&lt;Object&gt;</code>, and not <code>List&lt;Object[]&gt;</code>.</p>\n","answer_id":39889662,"question_id":39889498},{"owner":{"profile_image":"https://www.gravatar.com/avatar/22b05e50077230ba919b240af4bc13cd?s=256&d=identicon&r=PG","account_id":43861,"user_type":"registered","user_id":128397,"link":"https://stackoverflow.com/users/128397/daniel-pryden","reputation":59786,"display_name":"Daniel Pryden","accept_rate":82},"content_license":"CC BY-SA 3.0","score":7,"is_accepted":false,"last_activity_date":1475737380,"creation_date":1475737380,"body":"<p>If your list only has one element in it, <code>Collections.singletonList(new Object[] {...})</code> is a better choice, as it avoids varargs and makes the behavior more obvious at the call site.</p>\n","answer_id":39889558,"question_id":39889498},{"owner":{"profile_image":"https://i.stack.imgur.com/jXcg4.png?s=256&g=1","account_id":1263831,"user_type":"registered","user_id":1221571,"link":"https://stackoverflow.com/users/1221571/eran","reputation":388998,"display_name":"Eran","accept_rate":67},"content_license":"CC BY-SA 3.0","score":13,"is_accepted":false,"last_activity_date":1475737309,"creation_date":1475737309,"body":"<p>When you pass an array of reference types to <code>Arrays.asList</code> you get a <code>List</code> of that reference type.</p>\n\n<p>Therefore <code>Arrays.asList(new Object[]{\"bar\", 286})</code> returns a <code>List&lt;Object&gt;</code>, not a <code>List&lt;Object[]&gt;</code>.</p>\n","answer_id":39889542,"question_id":39889498},{"owner":{"profile_image":"https://i.stack.imgur.com/gX53v.jpg?s=256&g=1","account_id":1257650,"user_type":"registered","user_id":1216775,"link":"https://stackoverflow.com/users/1216775/akhil-mittal","reputation":23489,"display_name":"akhil_mittal","accept_rate":54},"content_license":"CC BY-SA 3.0","score":6,"is_accepted":false,"last_activity_date":1469773660,"creation_date":1445925085,"body":"<p>I will try to answer this in detail. Before generics we were having only <code>List</code> (a raw list) and it can hold almost anything we can think of.</p>\n\n<pre><code>List rawList = new ArrayList();\nrawList.add(\"String Item\");\nrawList.add(new Car(\"VW\"));\nrawList.add(new Runnable() {\n            @Override\n            public void run() {\n               // do some work.\n            }\n        });\n</code></pre>\n\n<p>The major problem with the raw list is when we want to get any element out of such list it can only guarantee that it would be <code>Object</code> and for that reason we need to use casting as:</p>\n\n<pre><code>   Object item = rawList.get(0); // we get object without casting.\n   String sameItem = (String) rawList.get(0); // we can use casting which may fail at runtime.\n</code></pre>\n\n<p>So conclusion is a <code>List</code> can store Object (almost everything is Object in Java) and always returns an Object.</p>\n\n<h2>Generics</h2>\n\n<p>Now lets talk about generics. Consider the following example:</p>\n\n<pre><code>List&lt;String&gt; stringsList = new ArrayList&lt;&gt;();\nstringsList.add(\"Apple\");\nstringsList.add(\"Ball\");\nstringsList.add(new Car(\"Fiat\")); //error\nString stringItem = stringsList.get(0);\n</code></pre>\n\n<p>In the above case we cannot insert anything other than <code>String</code> in <code>stringsList</code> as Java compiler applies strong type checking to generic code and issues errors if the code violates type safety. And we get error when we try to insert a <code>Car</code> instance in it. Also it eliminates cast as you can check when we <code>invoke</code> get method. Check this link for understanding <a href=\"https://docs.oracle.com/javase/tutorial/java/generics/why.html\" rel=\"nofollow noreferrer\">why we should use generics</a>.</p>\n\n<h2><code>List&lt;Object&gt;</code></h2>\n\n<p>If you read about type erasure then you will understand that <code>List&lt;String&gt;, List&lt;Long&gt;, List&lt;Animal&gt;</code> etc. will be having different static types at compile time but will have same dynamic type <code>List</code> at run time.</p>\n\n<p>If we have <code>List&lt;Object&gt;</code> then it can store only <code>Object</code> in it and almost everything is <code>Object</code> in Java. So we can have:</p>\n\n<pre><code> List&lt;Object&gt; objectList = new ArrayList&lt;Object&gt;();\n objectList.add(\"String Item\");\n objectList.add(new Car(\"VW\"));\n objectList.add(new Runnable() {\n        @Override\n        public void run() {\n\n        }\n });\n Object item = objectList.get(0); // we get object without casting as list contains Object\n String sameItem = (String) objectList.get(0); // we can use casting which may fail at runtime.\n</code></pre>\n\n<p><strong>It seems <code>List&lt;Object&gt;</code> and <code>List</code> are same but actually they are not.</strong> Consider the following case:</p>\n\n<pre><code>List&lt;String&gt; tempStringList = new ArrayList&lt;&gt;();\nrawList = tempStringList; // Ok as we can assign any list to raw list.\nobjectList = tempStringList; // error as List&lt;String&gt; is not subtype of List&lt;Obejct&gt; becuase generics are not convariant.\n</code></pre>\n\n<p>You can see we can assign any list to raw list and major reason for that is to allow backward compatibility. Also <code>List&lt;String&gt;</code> will be converted to <code>List</code> at run time due to type erasure and assignment will be fine anyways.</p>\n\n<p>But <code>List&lt;Object&gt;</code> means it can only refer to a list of objects and can also store objects only. Even though <code>String</code> is subtype of <code>Object</code> we cannot assign <code>List&lt;String&gt;</code> to <code>List&lt;Object&gt;</code> as generics are not covariant like arrays. They are invariant. Also check this <a href=\"https://docs.oracle.com/javase/tutorial/java/generics/inheritance.html\" rel=\"nofollow noreferrer\">link</a> for more. Also check the difference between <code>List</code> and <code>List&lt;Object&gt;</code> in this <a href=\"https://stackoverflow.com/questions/6783316/list-vs-listobject\">question</a>.</p>\n\n<h2><code>List&lt;?&gt;</code></h2>\n\n<p>Now we are left with <code>List&lt;?&gt;</code> which basically means list of unknown type and can refer to any list. </p>\n\n<pre><code>List&lt;?&gt; crazyList = new ArrayList&lt;String&gt;();\n List&lt;String&gt; stringsList = new ArrayList&lt;&gt;();\n stringsList.add(\"Apple\");\n stringsList.add(\"Ball\");\n crazyList = stringsList; // fine\n</code></pre>\n\n<p>The character <code>?</code> is known as wildcard and <code>List&lt;?&gt;</code> is a list of unbounded wildcard. There are certain points to observe now. </p>\n\n<p>We cannot instantiate this list as the following code will not compile:</p>\n\n<pre><code>List&lt;?&gt; crazyList = new ArrayList&lt;?&gt;(); // any list.\n</code></pre>\n\n<p>We can say a wildcard parameterized type is more like an interface type as we can use it to refer to an object of compatible type but not for itself. </p>\n\n<pre><code>List&lt;?&gt; crazyList2 = new ArrayList&lt;String&gt;();\n</code></pre>\n\n<p>We cannot insert any item to it as we don't know what actually the type would be.</p>\n\n<pre><code>crazyList2.add(\"Apple\"); // error as you dont actually know what is that type.\n</code></pre>\n\n<p><strong>Now question arises When would I want to use <code>List&lt;?&gt;</code>?</strong></p>\n\n<p>You can think of this as a read-only list where you don't care about the type of the items. You can use it to invoke methods like returning the length of the list, printing it etc.</p>\n\n<pre><code> public static void print(List&lt;?&gt; list){\n        System.out.println(list);\n    }\n</code></pre>\n\n<p>You can also check the difference between <code>List, List&lt;?&gt;, List&lt;T&gt;, List&lt;E&gt;, and List&lt;Object&gt;</code> <a href=\"https://stackoverflow.com/questions/6231973/difference-between-list-list-listt-liste-and-listobject\">here</a>.</p>\n","answer_id":33360761,"question_id":490091,"last_edit_date":1495540493},{"owner":{"profile_image":"https://graph.facebook.com/100007829376909/picture?type=large","account_id":4763924,"user_type":"registered","user_id":3850595,"link":"https://stackoverflow.com/users/3850595/jordi-castilla","reputation":26697,"display_name":"Jordi Castilla","accept_rate":86},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1467112900,"creation_date":1467109918,"body":"<p><strong>Short answer:</strong></p>\n\n<blockquote>\n  <p>Why is it legal to create <code>new Box();</code> and  <code>new Box&lt;Integer&gt;();</code> ? Is it because <code>Box</code> is comparable?</p>\n</blockquote>\n\n<p>No, it is because <code>Integer</code> or raw types in <code>new Box();</code> <strong>are comparable</strong>.</p>\n","answer_id":38073758,"question_id":38073420,"last_edit_date":1467112900},{"owner":{"profile_image":"https://www.gravatar.com/avatar/031c92b95555e2f4d080bbbfd5d8c3f2?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":8525882,"user_type":"registered","user_id":6391367,"link":"https://stackoverflow.com/users/6391367/explv","reputation":2719,"display_name":"explv"},"content_license":"CC BY-SA 3.0","score":5,"is_accepted":true,"last_activity_date":1467110540,"creation_date":1467109212,"body":"<p>You have declared the class with a generic type parameter. This is not the same as implementing the Comparable interface:</p>\n\n<pre><code>public class Box&lt;Comparable&gt; {\n\n}\n</code></pre>\n\n<p>Is the same as:</p>\n\n<pre><code>public class Box&lt;T&gt; {\n\n}\n</code></pre>\n\n<p>Which is not the same as:</p>\n\n<pre><code>public class Box&lt;T&gt; implements Comparable&lt;T&gt; {\n\n    @Override\n    public int compareTo(final T o) {\n        return 0;\n    }\n}\n</code></pre>\n\n<p>Because the type parameter is unbounded, it will accept any type. So you can use an <code>Integer</code> or a <code>String</code>:</p>\n\n<pre><code>public class Box&lt;T&gt; {\n\n    public static void main(String[] args) {\n        Box a = new Box();\n        Box b = new Box&lt;&gt;();\n        Box c = new Box&lt;Integer&gt;();\n        Box d = new Box&lt;String&gt;();\n    }\n}\n</code></pre>\n\n<p>The reason why you can create a new <code>Box</code> without specifying the type is because of backwards compatibility. The new <code>Box</code> would have the raw type <code>Box&lt;T&gt;</code>. It is <strong>bad practice</strong> and should be avoided.</p>\n\n<p>You can read more about Raw Types <a href=\"https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html\" rel=\"nofollow\">here</a></p>\n\n<p>If you wanted to enforce that the type parameter implements Comparable, then you can do:</p>\n\n<pre><code>import java.awt.*;\n\npublic class Box&lt;T extends Comparable&lt;T&gt;&gt; {\n\n    public static void main(String[] args) {\n        Box a = new Box();\n        Box b = new Box&lt;&gt;();\n        Box c = new Box&lt;Integer&gt;();\n        Box d = new Box&lt;String&gt;();\n\n        // This one will not work as Rectangle does not implement Comparable!\n        Box e = new Box&lt;Rectangle&gt;(); \n    }\n}\n</code></pre>\n","answer_id":38073499,"question_id":38073420,"last_edit_date":1467110540},{"owner":{"profile_image":"https://www.gravatar.com/avatar/f62b23a8c68c759abd2337894de7068b?s=256&d=identicon&r=PG","account_id":363966,"user_type":"registered","user_id":708036,"link":"https://stackoverflow.com/users/708036/qben","reputation":823,"display_name":"qben","accept_rate":67},"content_license":"CC BY-SA 3.0","score":6,"is_accepted":false,"last_activity_date":1459633377,"creation_date":1459633377,"body":"<p>Personally, while both of the currently top rated answers are right in a way, I do not think any of them solves the problem in an elegant, reusable way, especially if you have to do this very often.</p>\n\n<p>Suppose you have some old legacy code / dependency that you cannot change in any way (so that it would at least accept <code>List&lt;? extends Object&gt;</code> as @ReverendGonzo suggested <a href=\"https://stackoverflow.com/questions/4288084/how-to-convert-liststring-to-listobject#comment4652138_4288084\">in his comment</a>. Suppose also, that you need to talk to this legacy module a lot.</p>\n\n<p>I do not think either casting / copying all the time would be bearable on the long run. It makes your code either vulnerable to insidious bugs and hard to follow or slightly (or drastically) inefficient and hard-to-read.</p>\n\n<p>To have readable and efficient production code, it is better to encapsulate the dirty part in a separate module which deals with the otherwise harmless but ugly cast.</p>\n\n<pre><code>class ProductionCode {\n    public void doJob() {\n        List&lt;String&gt; strings = Arrays.asList(\"pear\", \"apple\", \"peach\");\n        StringMagicUtils.dealWithStrings(strings);\n    }\n}\n\nclass StringMagicUtils {\n    @SuppressWarnings(\"unchecked\")\n    public static void dealWithStrings(List&lt;String&gt; strings) {\n        ExternalStringMagic.dealWithStringsAsObjects((List) strings);\n    }\n}\n\n// Legacy - cannot edit this wonderful code below ˇˇ\nclass ExternalStringMagic {\n    public static void dealWithStringsAsObjects(List&lt;Object&gt; stringsAsObjects) {\n        // deal with them as they please\n    }\n}\n</code></pre>\n","answer_id":36379062,"question_id":4288084,"last_edit_date":1495540036},{"owner":{"profile_image":"https://www.gravatar.com/avatar/a417e43e9904379c41738adecb183289?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":4934454,"user_type":"registered","user_id":3973077,"link":"https://stackoverflow.com/users/3973077/paul-boddington","reputation":37277,"display_name":"Paul Boddington","accept_rate":77},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":false,"last_activity_date":1425779411,"creation_date":1425777317,"body":"<p>It's an unchecked cast because the compiler cannot be sure that <code>next</code> is a <code>T</code>. All it knows is that it's a <code>Component</code>.</p>\n\n<p>As for your question about why casting to a <code>T</code> generates the warning, but not casting to a <code>TestComponent</code>, that's a lot more subtle. Casting to a <code>TestComponent</code> is inherently less dodgy than casting to a <code>T</code>. If <code>test</code> is not a <code>TestComponent</code>, the cast to a <code>TestComponent</code> would cause a <code>ClassCastException</code> at runtime. But this isn't the case for casting to a <code>T</code> because the type <code>T</code> is not known at runtime, due to type erasure. If you cast a <code>Component</code> that is not a <code>T</code> to a <code>T</code> and then add the result into a <code>List&lt;T&gt;</code>, you would have a <code>List&lt;T&gt;</code> where not all of the items are <code>T</code>s. This would break the guarantee that generics are supposed to provide. There would be no chance of a <code>ClassCastException</code> preventing this.</p>\n\n<p>In your case, you don't need to worry. You have checked the cast to a <code>T</code> is safe by passing the <code>Class&lt;T&gt;</code> object and doing the check. You have two choices. You <em>could</em> suppress the warning and add a comment explaining why it's safe to do so. However, a better alternative would be to write <code>return type.cast(next);</code> instead. This doesn't generate a warning because <code>type.cast(object)</code> <em>would</em> throw  a <code>ClassCastException</code> if <code>object</code> were not a <code>T</code>. </p>\n","answer_id":28922019,"question_id":28921833,"last_edit_date":1425779411},{"owner":{"profile_image":"https://www.gravatar.com/avatar/37168aa60ee0c576241bfe2514b973dc?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":5860981,"user_type":"registered","user_id":4616696,"link":"https://stackoverflow.com/users/4616696/dermot-blair","reputation":1600,"display_name":"Dermot Blair"},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1425776191,"creation_date":1425776191,"body":"<p>As T is a subclass of Component, every T is a Component but not every Component is a T.</p>\n\n<p>If a subclass inherits from a superclass, casting the superclass to the subclass cannot be performed successfully.</p>\n\n<p>Therefore a new Component cannot be cast to a T instance.</p>\n","answer_id":28921913,"question_id":28921833},{"owner":{"profile_image":"https://i.stack.imgur.com/CCZZy.jpg?s=256&g=1","account_id":1257032,"user_type":"registered","user_id":1216288,"link":"https://stackoverflow.com/users/1216288/andrey","reputation":2515,"display_name":"Andrey","accept_rate":71},"content_license":"CC BY-SA 3.0","score":21,"is_accepted":false,"last_activity_date":1405606985,"creation_date":1405592385,"body":"<p>Using method reference, i found other way to pass the argument:</p>\n\n<pre><code>List&lt;String&gt; list = Arrays.asList(\"a\", \"b\", \"c\");        \nsort(list, Comparable::&lt;String&gt;compareTo);\n</code></pre>\n","answer_id":24800909,"question_id":22588518,"last_edit_date":1405606985},{"owner":{"profile_image":"https://i.stack.imgur.com/qBLgl.jpg?s=256&g=1","account_id":1370027,"user_type":"registered","user_id":1305501,"link":"https://stackoverflow.com/users/1305501/nosid","reputation":49130,"display_name":"nosid","accept_rate":77},"content_license":"CC BY-SA 3.0","score":134,"is_accepted":true,"last_activity_date":1395564600,"creation_date":1395564396,"body":"<p>You can't use a <em>lambda expression</em> for a <em>functional interface</em>, if the method in the <em>functional interface</em> has <em>type parameters</em>. See <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.3\">section §15.27.3 in JLS8</a>:</p>\n\n<blockquote>\n  <p>A lambda expression is compatible [..] with a target type <em>T</em> if <em>T</em> is a functional interface type (§9.8) and the expression is <strong>congruent</strong> with the function type of [..] T. [..] A lambda expression is <strong>congruent</strong> with a function type if all of the following are\n  true:</p>\n  \n  <ul>\n  <li>The function type has <em>no type parameters</em>.</li>\n  <li>[..]</li>\n  </ul>\n</blockquote>\n","answer_id":22588738,"question_id":22588518,"last_edit_date":1395564600},{"owner":{"profile_image":"https://www.gravatar.com/avatar/f54e86d83eea6143ecc70a485f4e6044?s=256&d=identicon&r=PG","account_id":1853886,"user_type":"registered","user_id":1679863,"link":"https://stackoverflow.com/users/1679863/rohit-jain","reputation":210617,"display_name":"Rohit Jain","accept_rate":77},"content_license":"CC BY-SA 3.0","score":6,"is_accepted":true,"last_activity_date":1391529387,"creation_date":1391529387,"body":"<p>Both the <code>ArrayList&lt;String&gt;</code> and <code>ArrayList&lt;MyCustomObject&gt;</code> have same erasure <code>ArrayList</code>. Thus, both the constructors will have same signature at runtime, and hence that exception, as you have a duplicate constructor there.</p>\n\n<p>If you want the constructor to take different types of <code>ArrayList</code>, then you can either use <em>unbounded wildcard</em> as in:</p>\n\n<pre><code>public OpponentListAdapter(Context c, ArrayList&lt;?&gt; l) {}\n</code></pre>\n\n<p>that will work for both the array lists, or make your constructor generic, giving a type parameter.</p>\n","answer_id":21557178,"question_id":21556925},{"owner":{"profile_image":"https://www.gravatar.com/avatar/34791a4919530f068710a35c7a558600?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":3218357,"user_type":"registered","user_id":2716383,"link":"https://stackoverflow.com/users/2716383/pedromss","reputation":2453,"display_name":"pedromss","accept_rate":57},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1391529363,"creation_date":1391529363,"body":"<p>You have two constructors with the same signature, constructor1(Context, ArrayList), constructor2(Context, ArrayList), meaning the constructors are the same.</p>\n","answer_id":21557169,"question_id":21556925},{"owner":{"profile_image":"https://www.gravatar.com/avatar/f4e5e5b29cd5c7b59e176d8e3bee3bd4?s=256&d=identicon&r=PG&f=y&so-version=2","account_id":3452279,"user_type":"registered","user_id":2891664,"link":"https://stackoverflow.com/users/2891664/radiodef","reputation":37360,"display_name":"Radiodef","accept_rate":100},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1388272096,"creation_date":1388272096,"body":"<p>In general, Java generics are not appropriate for math.</p>\n\n<p>In Java:</p>\n\n<ul>\n<li>Generics are object only.</li>\n<li>There are no mathematical operators for objects.</li>\n</ul>\n\n<p>It looks like you can perform math on objects because you can do something like this:</p>\n\n<pre><code>Integer a = 1;\nInteger b = 2;\nInteger c = a + b;\n</code></pre>\n\n<p>But that is only due to autoboxing. What actually happens is the compiler replaces that code with this:</p>\n\n<pre><code>Integer a = new Integer(1);\nInteger b = new Integer(3);\nInteger c = Integer.valueOf(a.intValue() + b.intValue());\n</code></pre>\n\n<p>With generics you can specify a bound so that your type must be Number or a subtype of it:</p>\n\n<pre><code>static &lt;N extends Number&gt; N multiply(N n1, N n2) {\n    return n1 * n2; // but you cannot do this because the type is not known\n                    // so the compiler cannot do autoboxing\n}\n</code></pre>\n\n<p>If a supertype is known, you <em>can</em> call methods on them so you can do this as has been pointed out:</p>\n\n<pre><code>static &lt;N extends Number&gt; double multiply(N n1, N n2) {\n    return n1.doubleValue() * n2.doubleValue();\n}\n</code></pre>\n\n<p>But that is no different than the following:</p>\n\n<pre><code>static double multiply(double n1, double n2) {\n    return n1 * n2;\n}\n</code></pre>\n\n<p>Except that the generic version can, for example, take BigDecimal as an argument which will of course not provide a reliable result (see <a href=\"http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#doubleValue%28%29\" rel=\"nofollow\">BigDecimal#doubleValue</a>). (Neither will Long for that matter.)</p>\n\n<p>If you were really determined you could program your own number classes and use polymorphism. Otherwise use overloads or (best of all) stick to one type.</p>\n","answer_id":20820362,"question_id":20819824},{"owner":{"profile_image":"https://www.gravatar.com/avatar/46129117115e53dc8229f938120209c8?s=256&d=identicon&r=PG","account_id":2906108,"user_type":"registered","user_id":2491410,"link":"https://stackoverflow.com/users/2491410/meno-hochschild","reputation":42988,"display_name":"Meno Hochschild","accept_rate":100},"content_license":"CC BY-SA 3.0","score":4,"is_accepted":true,"last_activity_date":1388269525,"creation_date":1388268230,"body":"<p>Maybe this is your intention:</p>\n\n<pre><code>public static &lt;N extends Number&gt; double multiply(N x, N y){\n    return x.doubleValue() * y.doubleValue();\n}\n</code></pre>\n\n<p>Although I must also say that the generic use of Number instead of concrete immutable value types like java primitive <code>double</code> is probably not so healthy because in the example above the arguments could even be of different types, for example Integer and Double.</p>\n\n<p><strong>Attention:</strong></p>\n\n<p>I confirm, the arguments can be of different types as given signature above. So the answer of Bohemian is wrong. I have tested it just now (but knew it already before). The compiler only guarantees that both arguments are of type Number, nothing else.</p>\n\n<p>In order to assert the same argument types the compiler needs self-referencing generics. This feature is not fulfilled by Number-class (that is &lt;N extends Number&lt;N&gt;&gt; is unfortunately not possible). That is why I consider the whole Number approach as not really healthy. Here a test code which everyone can execute:</p>\n\n<pre><code>Integer x = Integer.valueOf(10);\nDouble y = new Double(2.5);\nSystem.out.println(multiply(x, y));\n// Output: 25.0\n</code></pre>\n","answer_id":20819856,"question_id":20819824,"last_edit_date":1388269525},{"owner":{"profile_image":"https://www.gravatar.com/avatar/d84b558fd67be10d5a718fb94231909d?s=256&d=identicon&r=PG","account_id":93689,"user_type":"moderator","user_id":256196,"link":"https://stackoverflow.com/users/256196/bohemian","reputation":415951,"display_name":"Bohemian","accept_rate":77},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1388268458,"creation_date":1388268458,"body":"<p>You can specify a <em>bound</em> to your type by coding <code>&lt;T extends Number&gt;</code>:</p>\n\n<pre><code>public static double &lt;T extends Number&gt; multiply(T x, T y){\n    return x.doubleValue() * y.doubleValue();\n}\n</code></pre>\n\n<p>Which restricts the Number types to being the <em>same</em> type, eg an Integer and an Integer, but not an Integer and a Long.</p>\n\n<p>but you don't need generics at all:</p>\n\n<pre><code>public static double multiply(Number x, Number y){\n    return x.doubleValue() * y.doubleValue();\n}\n</code></pre>\n\n<p>Which allows any two Numbers, eg an Integer and a Long.</p>\n","answer_id":20819888,"question_id":20819824},{"owner":{"profile_image":"https://i.stack.imgur.com/kOdrM.jpg?s=256&g=1","account_id":3050905,"user_type":"registered","user_id":2585483,"link":"https://stackoverflow.com/users/2585483/juniar","reputation":1309,"display_name":"Juniar","accept_rate":50},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1381441209,"creation_date":1381441209,"body":"<p>List &lt; Object > is meant to pass input type parameter of an Object. While List &lt; ? > represents Wildcard type. The wildcard &lt; ? > is of Unknown parameter type. The wildcard cannot be used as a type argument for a generic method and cannot be used to create a generic instance of a class. Wildcard can be used to extend a subtype class, List &lt; ? extends Number >. To relax the restriction of an Object type and in this case to relax \"Number\" Object type.</p>\n","answer_id":19306727,"question_id":490091},{"owner":{"profile_image":"https://i.stack.imgur.com/cEOYD.jpg?s=256&g=1","account_id":1649504,"user_type":"registered","user_id":1520364,"link":"https://stackoverflow.com/users/1520364/karthik-t","reputation":31606,"display_name":"Karthik T","accept_rate":70},"content_license":"CC BY-SA 3.0","score":2,"is_accepted":false,"last_activity_date":1376637777,"creation_date":1376637380,"body":"<p>Take a look at this <a href=\"http://rickyclarkson.blogspot.sg/2008/06/cross-language-generics-trick-java.html\" rel=\"nofollow\">post</a> The person tries to simulate this by chaining <code>pair</code></p>\n\n<p>He does this</p>\n\n<pre><code>Pair&lt;String, Integer&gt; pair = Pairs.pair(\"hello\", 5);\nPair&lt;Double, Pair&lt;String, Integer&gt;&gt; withDouble = Pairs.pair(3.0, pair);\n</code></pre>\n\n<p>And proposes the below to make it cleaner</p>\n\n<pre><code>public class Pair&lt;T, U&gt; { ...\n  public &lt;V&gt; Pair&lt;V, Pair&lt;T, U&gt;&gt; prepend(V v) {\n   return pair(v, this); } }\n</code></pre>\n\n<p>So that it becomes  </p>\n\n<pre><code>Pair&lt;Double, Pair&lt;String, Integer&gt;&gt; pair = Pairs.pair(\"hello\", 5).prepend(3.0);\n</code></pre>\n\n<p>Note: you might need to write <code>Pair</code>.</p>\n\n<p>Note: Seems he actually endorses javatuples at the end..</p>\n\n<p><strong>More relevant:</strong></p>\n\n<p>After reading your comment, this more obvious solution presents itself.\nMultidimensional maps, much like multimensional arrays</p>\n\n<pre><code>Map&lt;XKey, Map&lt;YKey, Value&gt; &gt;\n</code></pre>\n","answer_id":18267838,"question_id":18267714,"last_edit_date":1376637777},{"owner":{"profile_image":"https://www.gravatar.com/avatar/fcbd636611fa901a055a84a16c463219?s=256&d=identicon&r=PG","account_id":165405,"user_type":"registered","user_id":388827,"link":"https://stackoverflow.com/users/388827/qqilihq","reputation":10947,"display_name":"qqilihq","accept_rate":89},"content_license":"CC BY-SA 3.0","score":1,"is_accepted":false,"last_activity_date":1376637323,"creation_date":1376637323,"body":"<p>If you need variable-length keys, you can use <a href=\"http://www.javatuples.org\" rel=\"nofollow\">javatuples</a> or something similar, which wrap an arbitrary number and arbitrary types of arguments (they provide tuples until a length of 10):</p>\n\n<p><code>Map&lt;Triplet&lt;Double,Float,Integer&gt;, Object&gt; mapWithCombinedKeys = ...</code></p>\n","answer_id":18267824,"question_id":18267714},{"owner":{"profile_image":"https://www.gravatar.com/avatar/4143c51b65350247de84a33eb8a9b46c?s=256&d=identicon&r=PG","account_id":880980,"user_type":"registered","user_id":244365,"link":"https://stackoverflow.com/users/244365/paulmurraycbr","reputation":1190,"display_name":"PaulMurrayCbr","accept_rate":25},"content_license":"CC BY-SA 3.0","score":0,"is_accepted":false,"last_activity_date":1342582822,"creation_date":1342582822,"body":"<p><code>List, List&lt;?&gt;, and List&lt;? extends Object&gt;</code> are the same thing. The second is more explicit. For a list of this type, you cannot know what types are legal to put into it, and you don't know anything about the types you can get out of it, except that they will be objects.</p>\n\n<p><code>List&lt;Object&gt;</code> specifically means that the list contains any sort of object.</p>\n\n<p>Let's say we make a list of <code>Foo</code>:</p>\n\n<pre><code>List&lt;Foo&gt; foos= new ArrayList&lt;Foo&gt;();\n</code></pre>\n\n<p>It is not legal to put a <code>Bar</code> into foos.</p>\n\n<pre><code>foos.add(new Bar()); // NOT OK!\n</code></pre>\n\n<p>It is always legal to put anything into a <code>List&lt;Object&gt;</code>. </p>\n\n<pre><code>List&lt;Object&gt; objs = new ArrayList&lt;Object&gt;();\nobjs.add(new Foo());\nobjs.add(new Bar());\n</code></pre>\n\n<p>But you mustn't be allowed to put a <code>Bar</code> into a <code>List&lt;Foo&gt;</code> - that's the whole point. So that means that this:</p>\n\n<pre><code>List&lt;Object&gt; objs = foos; // NOT OK!\n</code></pre>\n\n<p>is not legal.</p>\n\n<p>But it's ok to say that foos is a list of something but we don't know specifically what it is:</p>\n\n<pre><code>List&lt;?&gt; dontKnows = foos;\n</code></pre>\n\n<p>But that then means that it must be prohibited to go</p>\n\n<pre><code>dontKnows.add(new Foo()); // NOT OK\ndontKnows.add(new Bar()); // NOT OK\n</code></pre>\n\n<p>because the variable dontKnows does't know what types are legal.</p>\n","answer_id":11533966,"question_id":490091},{"owner":{"profile_image":"https://www.gravatar.com/avatar/ded1c591320cc2be6aa8109d02a74640?s=256&d=identicon&r=PG","account_id":195025,"user_type":"registered","user_id":437679,"link":"https://stackoverflow.com/users/437679/martin-algesten","reputation":13170,"display_name":"Martin Algesten","accept_rate":63},"content_license":"CC BY-SA 2.5","score":29,"is_accepted":false,"last_activity_date":1290802115,"creation_date":1290800460,"body":"<p>Any java collection is just a collection of objects be it string or other. The type argument is just sugar. Depending on situation, such as dealing with very large lists, you may just want to convert it - obviously risking mixing two different types of objects in the same list.</p>\n\n<pre><code>List&lt;Object&gt; objectList = (List)stringList;\n</code></pre>\n\n<p>And put a @SuppressWarning to get rid of nasties...</p>\n","answer_id":4288129,"question_id":4288084,"last_edit_date":1290802115},{"owner":{"profile_image":"https://www.gravatar.com/avatar/94066dfa49c2feb14706cb081848fda7?s=256&d=identicon&r=PG","account_id":10836,"user_type":"registered","user_id":20654,"link":"https://stackoverflow.com/users/20654/oscarryz","reputation":196641,"display_name":"OscarRyz","accept_rate":80},"content_license":"CC BY-SA 2.5","score":1,"is_accepted":false,"last_activity_date":1290800513,"creation_date":1290800513,"body":"<pre><code>List&lt;Object&gt; ofObjects = new ArrayList&lt;Object&gt;(ofStrings);\n</code></pre>\n\n<p>as in:</p>\n\n<pre><code>import java.util.*;\nclass C { \n  public static void main( String[] args ) { \n     List&lt;String&gt; s = new ArrayList&lt;String&gt;();\n     s.add(\"S\");\n     List&lt;Object&gt; o = new ArrayList&lt;Object&gt;(s);\n     o.add( new Object() );\n     System.out.println(  o );\n\n  }\n}\n</code></pre>\n\n<p>As an alternative you can try the <code>addAll</code> method, if the list of objects is an existing list.</p>\n","answer_id":4288138,"question_id":4288084},{"owner":{"profile_image":"https://www.gravatar.com/avatar/c8d80416510ccfb160d59c96d062707d?s=256&d=identicon&r=PG","account_id":114151,"user_type":"registered","user_id":300311,"link":"https://stackoverflow.com/users/300311/erick-robertson","reputation":32353,"display_name":"Erick Robertson","accept_rate":88},"content_license":"CC BY-SA 2.5","score":103,"is_accepted":true,"last_activity_date":1290800387,"creation_date":1290800387,"body":"<p>Pass the <code>List&lt;String&gt;</code> as a parameter to the constructor of a new <code>ArrayList&lt;Object&gt;</code>.</p>\n\n<pre><code>List&lt;Object&gt; objectList = new ArrayList&lt;Object&gt;(stringList);\n</code></pre>\n\n<p>Any <code>Collection</code> can be passed as an argument to the constructor as long as its type extends the type of the <code>ArrayList</code>, as <code>String</code> extends <code>Object</code>.  The constructor takes a <code>Collection</code>, but <code>List</code> is a subinterface of <code>Collection</code>, so you can just use the <code>List&lt;String&gt;</code>.</p>\n","answer_id":4288124,"question_id":4288084},{"owner":{"profile_image":"https://www.gravatar.com/avatar/32373e3d6ddf18b71b26edac43b03c56?s=256&d=identicon&r=PG","account_id":196062,"user_type":"registered","user_id":439317,"link":"https://stackoverflow.com/users/439317/riley-lark","reputation":20700,"display_name":"Riley Lark","accept_rate":84},"content_license":"CC BY-SA 2.5","score":4,"is_accepted":false,"last_activity_date":1290800325,"creation_date":1290800325,"body":"<p>This is pretty inefficient, but at least you don't have to write a lot of code~</p>\n\n<pre><code>List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();\nList&lt;Object&gt; objectList = Arrays.asList(stringList.toArray());\n</code></pre>\n","answer_id":4288119,"question_id":4288084},{"owner":{"profile_image":"https://www.gravatar.com/avatar/f1463ac968a26c990eccf12ac6cc8eb4?s=256&d=identicon&r=PG","account_id":2539,"user_type":"registered","user_id":3542,"link":"https://stackoverflow.com/users/3542/rob","reputation":48119,"display_name":"Rob"},"content_license":"CC BY-SA 2.5","score":15,"is_accepted":false,"last_activity_date":1257785485,"creation_date":1233190929,"body":"<p>I refer you to the excellent <a href=\"http://java.sun.com/docs/books/tutorial/java/generics/index.html\" rel=\"noreferrer\">Java Generics tutorial</a>, and the <a href=\"http://java.sun.com/docs/books/tutorial/extra/generics/index.html\" rel=\"noreferrer\">\"advanced\" Generics tutorial</a>, both available from Sun Microsystems. Another great resource is the <a href=\"http://oreilly.com/catalog/9780596527754\" rel=\"noreferrer\">Java Generics and Collections</a> book.</p>\n","answer_id":490103,"question_id":490091,"last_edit_date":1257785485},{"owner":{"profile_image":"https://www.gravatar.com/avatar/94066dfa49c2feb14706cb081848fda7?s=256&d=identicon&r=PG","account_id":10836,"user_type":"registered","user_id":20654,"link":"https://stackoverflow.com/users/20654/oscarryz","reputation":196641,"display_name":"OscarRyz","accept_rate":80},"content_license":"CC BY-SA 2.5","score":0,"is_accepted":false,"last_activity_date":1233193551,"creation_date":1233193551,"body":"<blockquote>\n  <p><em>When would I want to use</em></p>\n</blockquote>\n\n<pre><code>public void CanYouGiveMeAnAnswer( List l ){}\n</code></pre>\n\n<p>When you cant to do all the casting your self.</p>\n\n<blockquote>\n  <p><em>When would I want to use</em></p>\n</blockquote>\n\n<pre><code>public void CanYouGiveMeAnAnswer( List l&lt;Object&gt; ){}\n</code></pre>\n\n<p>When you want to restrict the type of the List. For instance, this would be an invalid argument.</p>\n\n<pre><code> new ArrayList&lt;String&gt;();\n</code></pre>\n\n<blockquote>\n  <p><em>When would I want to use</em></p>\n</blockquote>\n\n<pre><code>public void CanYouGiveMeAnAnswer( List l&lt;?&gt; ){}\n</code></pre>\n\n<p>Mostly never.</p>\n","answer_id":490211,"question_id":490091},{"owner":{"profile_image":"https://www.gravatar.com/avatar/94066dfa49c2feb14706cb081848fda7?s=256&d=identicon&r=PG","account_id":10836,"user_type":"registered","user_id":20654,"link":"https://stackoverflow.com/users/20654/oscarryz","reputation":196641,"display_name":"OscarRyz","accept_rate":80},"content_license":"CC BY-SA 2.5","score":42,"is_accepted":false,"last_activity_date":1233193144,"creation_date":1233192659,"body":"<p>In my own simple terms:</p>\n\n<blockquote>\n  <p>List</p>\n</blockquote>\n\n<p>Would declare an ordinary collection, can hold any type, and will always return Object.</p>\n\n<blockquote>\n  <p>List&lt;Object&gt;</p>\n</blockquote>\n\n<p>Will create a list that can hold any type of object, but can only get assigned a another <em>List&lt;Object&gt;</em> </p>\n\n<p>For instance this doesn't work;</p>\n\n<pre><code>List&lt;Object&gt; l = new ArrayList&lt;String&gt;();\n</code></pre>\n\n<p>Of course you can add anything but only can pull Object.</p>\n\n<pre><code>List&lt;Object&gt; l = new ArrayList&lt;Object&gt;();\n\nl.add( new Employee() );\nl.add( new String() );\n\nObject o = l.get( 0 );\nObject o2 = l.get( 1 );\n</code></pre>\n\n<p>Finally </p>\n\n<blockquote>\n  <p>List&lt;?></p>\n</blockquote>\n\n<p>Will let you assign any type, including </p>\n\n<pre><code>List &lt;?&gt; l = new ArrayList(); \nList &lt;?&gt; l2 = new ArrayList&lt;String&gt;();\n</code></pre>\n\n<p>This would be called collection of <em>unknown</em> and since the common denominator of <em>unknown</em> is Object you will be able to fetch Objects ( a coincidence ) </p>\n\n<p>The importance of <em>unknown</em> comes when its used with subclassing:</p>\n\n<pre><code>List&lt;? extends Collection&gt; l = new ArrayList&lt;TreeSet&gt;(); // compiles\n\nList&lt;? extends Collection&gt; l = new ArrayList&lt;String&gt;(); // doesn't,\n// because String is not part of *Collection* inheritance tree. \n</code></pre>\n\n<p>I hope using Collection as the type doesn't create confusion, that was the only tree that came to my mind.</p>\n\n<p>The difference here, is that l is a collection of <em>unknow</em> that belongs to the <em>Collection</em> hierarchy.</p>\n","answer_id":490181,"question_id":490091,"last_edit_date":1233193144},{"owner":{"profile_image":"https://www.gravatar.com/avatar/528394f867632bcca8497088cd71a6d4?s=256&d=identicon&r=PG","account_id":9757,"user_type":"registered","user_id":18154,"link":"https://stackoverflow.com/users/18154/fabian-steeg","reputation":45128,"display_name":"Fabian Steeg","accept_rate":100},"content_license":"CC BY-SA 2.5","score":1,"is_accepted":false,"last_activity_date":1233192579,"creation_date":1233192579,"body":"<p>I'd put it this way: While <code>List</code> and <code>List&lt;Object&gt;</code> can contain any type of objects, <code>List&lt;?&gt;</code> contains elements of an unknown type, but once that type is captured, it can only contain elements of that type. Which is why it is the only type safe variant of those three, and therefore generally preferable.</p>\n","answer_id":490178,"question_id":490091},{"owner":{"profile_image":"https://www.gravatar.com/avatar/7e4008352df551afc7748ba3f71b3e9d?s=256&d=identicon&r=PG","account_id":21852,"user_type":"registered","user_id":53444,"link":"https://stackoverflow.com/users/53444/tim","reputation":19896,"display_name":"Tim","accept_rate":70},"content_license":"CC BY-SA 2.5","score":0,"is_accepted":false,"last_activity_date":1233191858,"creation_date":1233191112,"body":"<p>To complement the tutorials mentioned by Rob, here's a wikibook explaining the topic:<br>\n<a href=\"http://en.wikibooks.org/wiki/Java_Programming/Generics\" rel=\"nofollow noreferrer\">http://en.wikibooks.org/wiki/Java_Programming/Generics</a></p>\n\n<hr>\n\n<p>Edit:</p>\n\n<ol>\n<li><p>No restrictions on type of items in list</p></li>\n<li><p>Items in list must extend Object</p></li>\n<li><p>Wildcard used by itself, so it matches anything</p></li>\n</ol>\n\n<p>Would it be naive of me to conclude at this point that there's hardly any/no difference at all?</p>\n","answer_id":490114,"question_id":490091,"last_edit_date":1233191858},{"owner":{"profile_image":"https://www.gravatar.com/avatar/3d184a8ef609eaabcaabd0dd19196a74?s=256&d=identicon&r=PG","account_id":23143,"user_type":"registered","user_id":57752,"link":"https://stackoverflow.com/users/57752/eddie","reputation":53986,"display_name":"Eddie","accept_rate":73},"content_license":"CC BY-SA 2.5","score":3,"is_accepted":false,"last_activity_date":1233191697,"creation_date":1233191697,"body":"<p>The shortest possible explanation is:  The second item is a list that can hold any type, and you can add objects to it:</p>\n\n<pre><code>List&lt;Object&gt;\n</code></pre>\n\n<p>The first item you list is treated as essentially equivalent to this, except you will get compiler warnings because it is a \"raw type\".</p>\n\n<pre><code>List\n</code></pre>\n\n<p>The third is a list that can hold any type, but you cannot add anything to it:</p>\n\n<pre><code>List&lt;?&gt; \n</code></pre>\n\n<p>Basically, you use the second form (<code>List&lt;Object&gt;</code>) when you truly have a list that can contain any object and you want to be able to add elements to the list.  You use the third form (<code>List&lt;?&gt;</code>)when you receive the list as a method return value and you will iterate over the list but never add anything to it   Never use the first form (<code>List</code>) in new code compiling under Java 5 or later.</p>\n","answer_id":490140,"question_id":490091},{"owner":{"profile_image":"https://www.gravatar.com/avatar/83fd7d4059fec16d3f138f4f351b6423?s=256&d=identicon&r=PG","account_id":7808,"user_type":"registered","user_id":13687,"link":"https://stackoverflow.com/users/13687/john-gardner","reputation":24390,"display_name":"John Gardner"},"content_license":"CC BY-SA 2.5","score":4,"is_accepted":false,"last_activity_date":1233191609,"creation_date":1233191609,"body":"<p>Simplest explanation which is not \"RTFM\":</p>\n\n<pre><code>List\n</code></pre>\n\n<p>Will generate lots of compiler warnings, but is mostly equivalent to:</p>\n\n<pre><code>List&lt;Object&gt;\n</code></pre>\n\n<p>While:</p>\n\n<pre><code>List&lt;?&gt;\n</code></pre>\n\n<p>basically means its something generic, but you don't know what the generic type is.  Its great for getting rid of compiler warnings when you cant modify the return types of other things that just returned List.  Its much more useful in the form:</p>\n\n<pre><code>List&lt;? extends SomeOtherThing&gt;\n</code></pre>\n","answer_id":490137,"question_id":490091}]